"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[9940],{66262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},82958:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>h,data:()=>v});var e=a(20641);const o=a.p+"assets/img/image-20240326221608906.6cf4d2e4.png",p=a.p+"assets/img/image-20240326221907548.4000d04e.png",t=a.p+"assets/img/image-20240326223411829.885c68c7.png",c=a.p+"assets/img/image-20240326225709207.93e0a6f6.png",l=a.p+"assets/img/image-20240326231544244.9231d82b.png",d=a.p+"assets/img/image-20240326233627730.d9ea3180.png",i=a.p+"assets/img/image-20240327222401309.e5806c27.png",r=a.p+"assets/img/image-20240327224623534.d71b35bf.png",k=a.p+"assets/img/image-20240327225404331.a73bed78.png",g=a.p+"assets/img/image-20240331135828610.390e40ca.png",u=[(0,e.Fv)('<h1 id="十六、锁" tabindex="-1"><a class="header-anchor" href="#十六、锁"><span>十六、锁</span></a></h1><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时 <strong>锁机制也为实现MySQL 的各个隔离级别提供了保证</strong>。 锁冲突也是影响数据库 并发访问性能的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。</p><h2 id="_16-1-并发事务访问相同的记录" tabindex="-1"><a class="header-anchor" href="#_16-1-并发事务访问相同的记录"><span>16.1 并发事务访问相同的记录</span></a></h2><h3 id="_16-1-1-读读的情况" tabindex="-1"><a class="header-anchor" href="#_16-1-1-读读的情况"><span>16.1.1 读读的情况</span></a></h3><p>读-读 情况，即并发事务相继 读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。</p><h3 id="_16-1-2-写写的情况" tabindex="-1"><a class="header-anchor" href="#_16-1-2-写写的情况"><span>16.1.2 写写的情况</span></a></h3><p>写-写 情况，即并发事务相继对相同的记录做出改动</p><p>在这种情况下会发生<code> 脏写</code>的问题，<code>任何一种隔离级别都不允许这种问题的发生</code>。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 <code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p><p>这个所谓 的锁其实是一个 <code>内存中的结构</code>，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的，当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构</code>,当没有的时候就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，<code>事务 T1</code> 要对这条记录做改动，就需要生成一个 锁结构与之关联：</p><figure><img src="'+o+'" alt="image-20240326221608906" tabindex="0" loading="lazy"><figcaption>image-20240326221608906</figcaption></figure><p>在 锁结构 里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来</p><ul><li><code>trx信息</code>:代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>:代表当前事务是否在等待。</li></ul><p>当 <code>事务T1</code> 获取锁之后，会将<code> is_waiting</code> 改为 false , 表示获取锁成功。此时若是 <code>事务T2</code> 也想对这条记录进行改动，但是此时 T1 在占着锁，因此会将<code> is_waiting</code> 改为 true，表示获取锁失败</p><figure><img src="'+p+'" alt="image-20240326221907548" tabindex="0" loading="lazy"><figcaption>image-20240326221907548</figcaption></figure><ul><li><p>不加锁</p><ul><li>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</li></ul></li><li><p>获取锁成功，或者加锁成功</p><ul><li>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 <strong>is_waiting 属性为 false</strong> ，也就是事务可以继续执行操作。</li></ul></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><ul><li>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 <strong>is_waiting 属性为 true</strong> ，也就是事务需要等待，不可以继续执行操作。</li></ul></li></ul><h3 id="_16-1-3-读写或写读的情况" tabindex="-1"><a class="header-anchor" href="#_16-1-3-读写或写读的情况"><span>16.1.3 读写或写读的情况</span></a></h3><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。</p><p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题。</p><h3 id="_16-1-4-并发问题的解决方案" tabindex="-1"><a class="header-anchor" href="#_16-1-4-并发问题的解决方案"><span>16.1.4 并发问题的解决方案</span></a></h3><p>怎么解决 <code>脏读 、 不可重复读 、 幻读</code> 这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用<code>多版本并发控制（ MVCC ，下章讲解）</code>，写操作进行 <code>加锁 </code>。</li><li>方案二：读、写操作都采用 加锁 的方式。</li></ul><p>所谓的 MVCC，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本(历史版本由undo日志 构建)。查询语句<code>只能读 到在生成Readview之前已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 <code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li><li>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 <code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><p>像读写都加锁的方式，显然效率比较低，除非一些特殊场景，比如<code>银行存钱</code>， 首先要从数据库读取金额，此时加锁，在更改完之前不允许别的事务进行操作。而大部分采用第一种方案效率会更高！</p><h2 id="_16-2-锁的不同角度的分类" tabindex="-1"><a class="header-anchor" href="#_16-2-锁的不同角度的分类"><span>16.2 锁的不同角度的分类</span></a></h2><figure><img src="'+t+'" alt="image-20240326223411829" tabindex="0" loading="lazy"><figcaption>image-20240326223411829</figcaption></figure><h3 id="_16-2-1-读锁、写锁" tabindex="-1"><a class="header-anchor" href="#_16-2-1-读锁、写锁"><span>16.2.1 读锁、写锁</span></a></h3><ul><li><strong>读锁</strong> ：也称为 <code>共享锁</code> 、英文用 <code>S</code> 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><strong>写锁</strong> ：也称为 <code>排他锁</code> 、英文用 <code>X </code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p><strong>读操作可以加读锁，也可以加写锁，但是写操作只能加写锁</strong></p><ul><li>为读操作增加读锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span> <span class="token punctuation">;</span>\n<span class="token comment">#或</span>\n<span class="token keyword">SELECT</span> <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span><span class="token punctuation">;</span><span class="token comment">#(8.0新增语法)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>为读操作增加写锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>演示为读操作增加写锁被阻塞</strong>：</p><p>1、首先启动俩个客户端C1，C2</p><p>2、在C1中开始事务并为读操作增加 写锁</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>\nQuery OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>\n\nmysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> regions <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token operator">|</span> region_id <span class="token operator">|</span> region_name            <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span> Europe                 <span class="token operator">|</span>\n<span class="token operator">|</span>         <span class="token number">2</span> <span class="token operator">|</span> Americas               <span class="token operator">|</span>\n<span class="token operator">|</span>         <span class="token number">3</span> <span class="token operator">|</span> Asia                   <span class="token operator">|</span>\n<span class="token operator">|</span>         <span class="token number">4</span> <span class="token operator">|</span> Middle East <span class="token operator">and</span> Africa <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、可以看到C1读取成功，此时由于没有提交事务。C2也执行读操作访问相同记录，并且增加写锁，此时就可以看到C2被阻塞</p><figure><img src="'+c+'" alt="image-20240326225709207" tabindex="0" loading="lazy"><figcaption>image-20240326225709207</figcaption></figure><h3 id="_16-2-2-表级锁、页锁、行级锁" tabindex="-1"><a class="header-anchor" href="#_16-2-2-表级锁、页锁、行级锁"><span>16.2.2 表级锁、页锁、行级锁</span></a></h3><p>为了尽可能提高数据库的并发度，<code>每次锁定的数据范围越小越好</code>，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是<code>管理锁是很 耗资源 </code>的事情(涉及获取、检査、释放锁等动作)。因此数据库系统需要在 <code>高并发响应</code>和 <code>系统性能</code> 两方面进行平衡，这样就产生了“<code>锁粒度(Lock granularity)</code>”的概念。</p><h4 id="_1-表级锁" tabindex="-1"><a class="header-anchor" href="#_1-表级锁"><span>（1）表级锁</span></a></h4><h5 id="_1-表级别的s锁、x锁" tabindex="-1"><a class="header-anchor" href="#_1-表级别的s锁、x锁"><span>① 表级别的S锁、X锁</span></a></h5><p>由于 InnoDB 引擎中提供了<code> 锁粒度</code> 更细的<code>行级锁</code> ，因此在 InnoDB中执行SELECT、INSERT、DELETE</p><p>UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 <code>S锁</code> 或者 <code>X锁</code>的.</p><p>但是在对某个表执行一些诸如 <code>ALTER TABLE 、 DROP TABLE</code> 这类的 DDL 语句时，其他事务对这个表并发执行诸如<code>SELECT、INSERT、DELETE、UPDATE</code>的语句会发生阻塞。这个过程其实是通过在 <code>server层 </code>使用一种称之为 <code>元数据锁 </code>（英文名： Metadata Locks ，简称 MDL ）结构来实现的。</p><p><strong>设置S、X锁</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">READ</span> ：<span class="token keyword">InnoDB</span>存储引擎会对表 t 加表级别的 S锁 。\n<span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> t <span class="token keyword">WRITE</span> ：<span class="token keyword">InnoDB</span>存储引擎会对表 t 加表级别的 X锁 。\n<span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span> 释放锁\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>针对表级锁的操作情况</strong></p><figure><img src="'+l+'" alt="image-20240326231544244" tabindex="0" loading="lazy"><figcaption>image-20240326231544244</figcaption></figure><h5 id="_1-意向锁" tabindex="-1"><a class="header-anchor" href="#_1-意向锁"><span>① 意向锁</span></a></h5><p>InnoDB 支持 <code>多粒度锁（multiple granularity locking</code>） ，它允许 <code>行级锁</code>与 <code>表级锁</code> 共存，而<strong>意向锁</strong>就是其中的一种 <code>表锁</code> 。</p><p><strong>作用</strong></p><p>假设有俩个事务 T1、T2，其中T2试图增加表级锁，如果没有意向锁的存在，那么T2就需要去检查每行或者每页是否存在锁，如果数据比较多，这无疑是浪费时间的。如果存在意向锁，那么此时T2就会被阻塞，避免了不要的检查！</p><p><strong>特点</strong></p><p>1、意向锁的存在是为了<code>协调行锁和表锁的关系</code>，支持多粒度(表锁与行锁)的锁并存。</p><p>2、意向锁是一种 <code>不与行级锁冲突表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong></p><p>意向锁分为俩种：</p><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span>\n<span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span>\n<span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>即：意向锁是由存储引擎 自己维护的 ，<strong>用户无法手动操作意向锁</strong>，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p><p><strong>意向锁是兼容的，但是他会与普通的 共享锁/排它锁互斥</strong>：</p><figure><img src="'+d+'" alt="image-20240326233627730" tabindex="0" loading="lazy"><figcaption>image-20240326233627730</figcaption></figure><p><strong>演示意向锁质检互相兼容的情况：</strong></p><p>1、启动俩个客户端C1、C2</p><p>2、C1中开启事务，对其中一条数据设置X锁，此时InnoDB自动生成了一个IX</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>\nQuery OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>\n\nmysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> regions <span class="token keyword">where</span> region_id <span class="token operator">=</span> <span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token operator">|</span> region_id <span class="token operator">|</span> region_name            <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token operator">|</span>         <span class="token number">4</span> <span class="token operator">|</span> Middle East <span class="token operator">and</span> Africa <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+------------------------+</span>\n<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">6.34</span> sec<span class="token punctuation">)</span>\n\nmysql<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、在C2中开启事务，对另外一条数据设置X锁，此时InnoDB自动生成了一个IX，并且成功访问到了数据</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">begin</span><span class="token punctuation">;</span>\nQuery OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>\n\nmysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> regions <span class="token keyword">where</span> region_id <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>\n<span class="token operator">+</span><span class="token comment">-----------+-------------+</span>\n<span class="token operator">|</span> region_id <span class="token operator">|</span> region_name <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+-------------+</span>\n<span class="token operator">|</span>         <span class="token number">3</span> <span class="token operator">|</span> Asia        <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token comment">-----------+-------------+</span>\n<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>\n\nmysql<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-自增锁" tabindex="-1"><a class="header-anchor" href="#_3-自增锁"><span>③ 自增锁</span></a></h5><p>自增锁是一种比较特殊的<strong>表级锁</strong>。并且在事务向包含了 <code>AUTO_INCREMENT</code> 列的表中新增数据时就会去持有自增锁，假设事务 A 正在做这个操作，如果另一个事务 B 尝试执行 <code>INSERT</code>语句，事务 B 会被阻塞住，直到事务 A 释放自增锁。（其实这么说是有些不准确的，因为自增锁有三种模式，每一种模式的处理方式不同）</p><ul><li><strong>传统模式（Traditional）</strong><ul><li>当我们向包含了 <code>AUTO_INCREMENT</code> 列的表中插入数据时，都会持有这么一个特殊的表锁——自增锁（AUTO-INC），并且当语句执行完之后就会释放。这样一来可以保证单个语句内生成的自增值是连续的。但是弊端就是 <code>并发性能差</code> ,因为要一条一条执行</li></ul></li><li><strong>连续模式（Consecutive）</strong><ul><li>在锁模式处于连续模式下时，如果 <code>INSERT</code> 语句能够提前确定插入的数据量，则可以不用获取自增锁，举个例子，像 <code>INSERT INTO</code> 这种简单的、能提前确认数量的新增语句，就不会使用自增锁</li></ul></li><li><strong>交叉模式（Interleaved）</strong><ul><li>交叉模式（Interleaved）下，所有的 <code>INSERT</code> 语句，包含 <code>INSERT</code> 和 <code>INSERT INTO ... SELECT</code> ，都不会使用 <code>AUTO-INC</code> 自增锁，而是使用较为轻量的 <code>mutex</code> 锁。这样一来，多条 <code>INSERT</code> 语句可以并发的执行，这也是三种锁模式中扩展性最好的一种。</li></ul></li></ul><h5 id="_4-元数据锁-mdl" tabindex="-1"><a class="header-anchor" href="#_4-元数据锁-mdl"><span>④ 元数据锁（MDL）</span></a></h5><p>MySQL5.5引入了 <code>meta data lock</code>，简称MDL锁，属于表锁范畴。MDL 的作用是，<code>保证读写的正确性</code></p><p>比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一</p><p>列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，MYSQL会自动加上 MDL 读锁，对表结构进行修改时，会自动加上 MDL 写锁</strong></p><h4 id="_2-innodb中的行锁" tabindex="-1"><a class="header-anchor" href="#_2-innodb中的行锁"><span>（2）InnoDB中的行锁</span></a></h4><p>行锁(Row Lock)也称为<code>记录锁</code>，顾名思义，就是锁住某一行(某条记录 row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现</p><p><strong>优点</strong>: 锁定力度小，发生 <code>锁冲突概率低</code>，可以实现的 <code>并发度高</code>，</p><p><strong>缺点</strong>: 对于 <code>锁的开销比较大</code>，加锁会比较慢，容易出现 <code>死锁</code> 情况。</p><p>InnoDB与MyISAM的最大不同有两点: 一是支持事务(TRANSACTION);二是采用了行级锁。</p><h5 id="_1-记录锁-record-locks" tabindex="-1"><a class="header-anchor" href="#_1-记录锁-record-locks"><span>① 记录锁(Record Locks)</span></a></h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： <code>LOCK_REC_NOT_GAP</code> 。比如我们把id值为8的</p><p>那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p><figure><img src="'+i+'" alt="image-20240327222401309" tabindex="0" loading="lazy"><figcaption>image-20240327222401309</figcaption></figure><p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><h5 id="_2-间隙锁-gap-locks" tabindex="-1"><a class="header-anchor" href="#_2-间隙锁-gap-locks"><span>② 间隙锁(Gap Locks)</span></a></h5><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有 <code>共享gap锁</code> 和 <code>独占gap锁</code> 这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁(不论是共享gap锁还是独占gap锁)，并<strong>不会限制其他事务对这条记录加记录锁或者继续加gap锁</strong>。</p><p>比如，把id值为8的那条记录加一个gap锁的示意图如下。</p><figure><img src="'+r+'" alt="image-20240327224623534" tabindex="0" loading="lazy"><figcaption>image-20240327224623534</figcaption></figure><p>图中id值为8的记录加了gap锁，意味着 <strong>不允许别的事务在id值为8的记录前边的间隙插入新记录</strong> ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。</p><p>若在id值为25的记录增加间隙锁，则 id在 (20,+∞) 这个区间的记录都不允许增加！</p><p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生 死锁</strong></p><figure><img src="'+k+'" alt="image-20240327225404331" tabindex="0" loading="lazy"><figcaption>image-20240327225404331</figcaption></figure><p>由于都为5增加了间隙锁，双方都会等待对方先释放锁而导致死锁！</p><h5 id="_3-临键锁-next-key-locks" tabindex="-1"><a class="header-anchor" href="#_3-临键锁-next-key-locks"><span>③ 临键锁(Next-Key Locks)</span></a></h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 <code>阻止其他事务在该记录前边的间隙插入新记录</code> ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： <code>LOCK_ORDINARY</code> ，我们也可以简称为next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&lt;=</span><span class="token number">8</span> <span class="token operator">and</span> id <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_4-插入意向锁-insert-intention-locks" tabindex="-1"><a class="header-anchor" href="#_4-插入意向锁-insert-intention-locks"><span>④ 插入意向锁(Insert Intention Locks)</span></a></h5><p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁（next-key锁也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个 <code>间隙</code> 中 <code>插入</code> 新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code> ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 <code>插入意向锁</code> 。插入意向锁是一种 <code>Gap锁</code> ，不是<code>意向锁</code>，在insert操作时产生</p><h3 id="_16-2-3-页锁" tabindex="-1"><a class="header-anchor" href="#_16-2-3-页锁"><span>16.2.3 页锁</span></a></h3><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p><code>每个层级的锁数量是有限制的</code>，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h4 id="_1、悲观锁、乐观锁" tabindex="-1"><a class="header-anchor" href="#_1、悲观锁、乐观锁"><span>1、悲观锁、乐观锁</span></a></h4><p>从对待锁的态度来看锁的话，可以将锁分成<code>乐观锁</code>和<code>悲观锁</code>，从名字中也可以看出这两种锁是两种看待数据并发的思维方式 。需要注意的是，<strong>乐观锁和悲观锁并不是锁，而是锁的 设计思想</strong> 。</p><h5 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁"><span>悲观锁</span></a></h5><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中的<code>synchronized</code> 和<code> ReentrantLock</code> 等独占锁就是悲观锁思想的实现</p><h5 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 <code>版本号机制</code> 或者<code> CAS机制</code> 实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中 <code>java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><h4 id="俩种锁的使用场景" tabindex="-1"><a class="header-anchor" href="#俩种锁的使用场景"><span>俩种锁的使用场景</span></a></h4><ol><li><p><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。</p></li></ol><h3 id="_16-2-4-其他锁" tabindex="-1"><a class="header-anchor" href="#_16-2-4-其他锁"><span>16.2.4 其他锁</span></a></h3><h4 id="_1、全局锁" tabindex="-1"><a class="header-anchor" href="#_1、全局锁"><span>1、全局锁</span></a></h4><p>全局锁就是对 <code>整个数据库实例加锁</code>。当你需要让整个库处于 <code>只读状态</code> 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：<code>做 全库逻辑备份</code> 。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>Flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2、死锁" tabindex="-1"><a class="header-anchor" href="#_2、死锁"><span>2、死锁</span></a></h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死锁示例：</p><figure><img src="'+g+'" alt="image-20240331135828610" tabindex="0" loading="lazy"><figcaption>image-20240331135828610</figcaption></figure><p><strong>死锁产生的条件</strong>：</p><p>1、两个或者两个以上事务</p><p>2、每个事务都已经持有锁并且申请新的锁</p><p>3、锁资源同时只能被同一个事务持有或者不兼容</p><p>4、事务之间因为持有锁和申请锁导致彼此循环等待</p><p><strong>解决策略</strong>：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout </code>来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，<code>主动回滚</code>死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code> 设置为on ，表示开启这个逻辑。</li></ul><p><strong>如何避免死锁</strong></p><ul><li><p>合理设计索引，使业务 SQL尽可能通过索引定位更少的行，减少锁竞争。</p></li><li><p>调整业务逻辑 SQL 执行顺序，避免 update/delete 长时间持有锁的 SQL 在事务前面。</p></li><li><p>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更</p></li></ul>',134)],m={},h=(0,a(66262).A)(m,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,u)}]]),v=JSON.parse('{"path":"/MySQL/16%E9%94%81.html","title":"十六、锁","lang":"zh-CN","frontmatter":{"date":"2024-03-28T00:00:00.000Z","category":["数据库"],"tag":["数据库","MySQL"],"editLink":false,"pageview":false,"sticky":true,"star":true,"order":16,"description":"十六、锁 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 并发操作进行控制，因此产生了锁。同时 锁机制也为实现MySQL 的各个隔离级别提供了保证。 锁冲突也是影响数据库 并发访问性能的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。 16.1 并发事务访...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/MySQL/16%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"十六、锁"}],["meta",{"property":"og:description","content":"十六、锁 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 并发操作进行控制，因此产生了锁。同时 锁机制也为实现MySQL 的各个隔离级别提供了保证。 锁冲突也是影响数据库 并发访问性能的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。 16.1 并发事务访..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-05T05:35:13.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-05T05:35:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"十六、锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-05T05:35:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":2,"title":"16.1 并发事务访问相同的记录","slug":"_16-1-并发事务访问相同的记录","link":"#_16-1-并发事务访问相同的记录","children":[{"level":3,"title":"16.1.1 读读的情况","slug":"_16-1-1-读读的情况","link":"#_16-1-1-读读的情况","children":[]},{"level":3,"title":"16.1.2 写写的情况","slug":"_16-1-2-写写的情况","link":"#_16-1-2-写写的情况","children":[]},{"level":3,"title":"16.1.3 读写或写读的情况","slug":"_16-1-3-读写或写读的情况","link":"#_16-1-3-读写或写读的情况","children":[]},{"level":3,"title":"16.1.4 并发问题的解决方案","slug":"_16-1-4-并发问题的解决方案","link":"#_16-1-4-并发问题的解决方案","children":[]}]},{"level":2,"title":"16.2 锁的不同角度的分类","slug":"_16-2-锁的不同角度的分类","link":"#_16-2-锁的不同角度的分类","children":[{"level":3,"title":"16.2.1 读锁、写锁","slug":"_16-2-1-读锁、写锁","link":"#_16-2-1-读锁、写锁","children":[]},{"level":3,"title":"16.2.2 表级锁、页锁、行级锁","slug":"_16-2-2-表级锁、页锁、行级锁","link":"#_16-2-2-表级锁、页锁、行级锁","children":[]},{"level":3,"title":"16.2.3 页锁","slug":"_16-2-3-页锁","link":"#_16-2-3-页锁","children":[]},{"level":3,"title":"16.2.4 其他锁","slug":"_16-2-4-其他锁","link":"#_16-2-4-其他锁","children":[]}]}],"git":{"createdTime":1712295313000,"updatedTime":1712295313000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":18.13,"words":5439},"filePathRelative":"MySQL/16锁.md","localizedDate":"2024年3月28日","excerpt":"\\n<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时 <strong>锁机制也为实现MySQL 的各个隔离级别提供了保证</strong>。 锁冲突也是影响数据库  并发访问性能的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。</p>\\n<h2>16.1 并发事务访问相同的记录</h2>\\n<h3>16.1.1 读读的情况</h3>\\n<p>读-读 情况，即并发事务相继 读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。</p>","autoDesc":true}')}}]);