"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[8521],{66262:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,s]of a)n[e]=s;return n}},48426:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>m,data:()=>k});var s=n(20641);const t=n.p+"assets/img/image-20240331143413546.ddb5854c.png",o=n.p+"assets/img/image-20240331143804882.fea2a505.png",i=n.p+"assets/img/image-20240331144303492.90df58aa.png",p=n.p+"assets/img/image-20240331144352550.9c9ab14f.png",d=n.p+"assets/img/image-20240331152555348.80b748a2.png",c=n.p+"assets/img/image-20240331152746169.d474c350.png",l=n.p+"assets/img/image-20240331154809923.c9e316fb.png",r=n.p+"assets/img/image-20240331155312038.350cc120.png",u=[(0,s.Fv)('<h1 id="十七、mvcc" tabindex="-1"><a class="header-anchor" href="#十七、mvcc"><span>十七、MVCC</span></a></h1><h2 id="_17-1-什么是mvcc" tabindex="-1"><a class="header-anchor" href="#_17-1-什么是mvcc"><span>17.1 什么是MVCC</span></a></h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过<code>数据行的多个版本管理</code>来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。</p><p>多个版本： 指undo日志中保存的被事务修改的行信息</p><h2 id="_17-2-快照读和当前读" tabindex="-1"><a class="header-anchor" href="#_17-2-快照读和当前读"><span>17.2 快照读和当前读</span></a></h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到 <code>不加锁</code> ， 非阻塞并发读 ，而这个读指的就是 <code>快照读</code> , 而非 当前读 。<code>当前读实际上是一种加锁</code>的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><p><strong>快照读</strong></p><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的SELECT都属于快照读</strong>，即不加锁的非阻塞读；比如这样：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> player <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>当前读</strong></p><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<strong>加锁的 SELECT，或者对数据进行增删改</strong>都会进行当前读。比如</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span> <span class="token comment"># 共享锁</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span> <span class="token comment"># 排他锁</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token keyword">values</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>\n<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>\n<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment"># 排他锁</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_17-3-复习" tabindex="-1"><a class="header-anchor" href="#_17-3-复习"><span>17.3 复习</span></a></h2><h3 id="_17-3-1-再谈隔离级别" tabindex="-1"><a class="header-anchor" href="#_17-3-1-再谈隔离级别"><span>17.3.1 再谈隔离级别</span></a></h3><p>四个隔离级别可以解决的并发问题如下：</p><p>读未提交不能解决 <code>脏读、不可重复读、幻读</code></p><p>读已提交解决了<code>脏读</code></p><p>可重复读解决了<code>脏读、不可重复读</code></p><p>串行化解决以上三种并发问题！</p><figure><img src="'+t+'" alt="image-20240331143413546" tabindex="0" loading="lazy"><figcaption>image-20240331143413546</figcaption></figure><p>这仅仅是MySQL中定义的标准，但实际上在MySQL中 <code>可重复读</code>，已经解决了<code>幻读</code>, 靠的就是 MVCC。</p><figure><img src="'+o+'" alt="image-20240331143804882" tabindex="0" loading="lazy"><figcaption>image-20240331143804882</figcaption></figure><h3 id="_17-3-2-隐藏字段、undo日志版本链" tabindex="-1"><a class="header-anchor" href="#_17-3-2-隐藏字段、undo日志版本链"><span>17.3.2 隐藏字段、UNDO日志版本链</span></a></h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p><ul><li><code>trx_id</code> ：每次一个事务<code>对某条聚簇索引记录进行改动</code>时，都会把该事务的 事务id 赋值给<code>trx_id</code> 隐藏列。</li><li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的UndoLog Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行 UPDATE 操作，操作流程如下：</p><figure><img src="'+i+'" alt="image-20240331144303492" tabindex="0" loading="lazy"><figcaption>image-20240331144303492</figcaption></figure><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性（ <strong>INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本</strong>），可以将这些 undo日志都连起来，串成一个链表：</p><figure><img src="'+p+'" alt="image-20240331144352550" tabindex="0" loading="lazy"><figcaption>image-20240331144352550</figcaption></figure><h2 id="_17-4-mvcc实现原理之readview" tabindex="-1"><a class="header-anchor" href="#_17-4-mvcc实现原理之readview"><span>17.4 MVCC实现原理之ReadView</span></a></h2><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p><h3 id="_17-4-1-什么是readview" tabindex="-1"><a class="header-anchor" href="#_17-4-1-什么是readview"><span>17.4.1 什么是ReadView</span></a></h3><p>在 MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在<code> Undo Log</code>里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢? 这时就需要用到 ReadView 了，它帮我们解决了行的可见性问题，</p><p>Readview 就是事务A在<strong>使用MVCC机制进行快照读操作时产生的读视图</strong>。当事务启动时，会<strong>生成数据库系统当前的一个快照</strong>，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code> 的ID(“活跃”指的就是，启动了但还没提交)。</p><blockquote><p>ReadView是和事务一一对应的！并且只有活跃的事务才会有 ReadView ，谨记！！！</p></blockquote><h3 id="_17-4-2-设计思路" tabindex="-1"><a class="header-anchor" href="#_17-4-2-设计思路"><span>17.4.2 设计思路</span></a></h3><p>使用 <code>READ UNCOMMITTED </code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了(没有使用到MVCC)。</p><p>使用 <code>SERIALIZABLE </code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。(没有使用到MVCC)</p><p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 已经提交了的 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。</p><p>核心问题就是<strong>需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</strong></p><p><strong>这个ReadView中主要包含4个比较重要的内容，分别如下</strong>：</p><p>1、<code>creator_trx_id </code>，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个<strong>只读事务中的事务id值都默认为0</strong>。</p></blockquote><p>2、<code>trx_ids</code> ，表示在生成ReadView时当前系统中<code>活跃</code>的读写事务的 事务id列表</p><p>3、<code>up_limit_id </code>，活跃的事务中最小的事务 ID。</p><p>4、<code>low_limit_id </code>，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是<strong>系统最大的事务id值</strong>，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p><blockquote><p>trx_ids 为活跃的事务Id列表，low_limit_id 包括系统中已经提交的事务ID，比如：活跃的事务Id有 1,2 , 提交的事务ID有 3,4。 那么low_limit_id的值就是5。</p></blockquote><h3 id="_17-4-3-readview规则" tabindex="-1"><a class="header-anchor" href="#_17-4-3-readview规则"><span>17.4.3 ReadView规则</span></a></h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果<code>被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同</code>，意味着当前事务在访问它自己修改过的记录，所以该版本<code>可以被当前事务访问</code>。</li><li>如果<code>被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值</code>，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本<code>可以被当前事务访问</code>。</li><li>如果<code>被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值</code>，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本<code>不可以被当前事务访问</code>。</li><li>如果<code>被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间</code>，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。 <ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><blockquote><p>总结起来就是访问最新提交的快照！</p></blockquote><h3 id="_17-4-4-mvcc整体操作流程" tabindex="-1"><a class="header-anchor" href="#_17-4-4-mvcc整体操作流程"><span>17.4.4 MVCC整体操作流程</span></a></h3><p>1、首先获取事务自己的版本号，也就是事务 ID；</p><p>2、 获取 ReadView；</p><p>3、查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p><p>4、如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p><p>5、最后返回符合规则的数据。</p><blockquote><p>Innodb中，MVCC是通过 Undo Log+ ReadView 进行数据获取，Undo Log保存了历史快照，而ReadView帮我们判断是否可以读取！</p></blockquote><p>在隔离级别为**读已提交（Read Committed）**时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</p><figure><img src="'+d+'" alt="image-20240331152555348" tabindex="0" loading="lazy"><figcaption>image-20240331152555348</figcaption></figure><blockquote><p>读已提交: 只能读取其他事物提交过后的数据</p><p>相同SQL查询也会重新获取一次 ReadView，如果俩次 ReadView 的不一样，就有可能导致幻读、不可重复读的问题！</p></blockquote><p>当隔离级别为<code>可重复读</code>的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><figure><img src="'+c+'" alt="image-20240331152746169" tabindex="0" loading="lazy"><figcaption>image-20240331152746169</figcaption></figure><h2 id="_17-5-如何解决幻读" tabindex="-1"><a class="header-anchor" href="#_17-5-如何解决幻读"><span>17.5 如何解决幻读</span></a></h2><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p><figure><img src="'+l+'" alt="image-20240331154809923" tabindex="0" loading="lazy"><figcaption>image-20240331154809923</figcaption></figure><p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为<code> 20</code> ， 事务 B 的事务 id 为<code> 30</code> 。</p><p><strong>事务A开始第一次查询</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids=[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 </code>。</p><p>此时SQL语句查询出来id=1的一条数据，然后根据ReadView判断是否可以被访问：</p><ul><li>trx = 1，小于up_limit_id ，说明在生成ReadView之前已经被提交，因此可以被访问</li></ul><p><strong>结果</strong>：第一次查询出 id = 1 的数据</p><p><strong>事务B执行插入操作</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;李四&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;王五&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时<code>student</code> 表中有三条数据：</p><figure><img src="'+r+'" alt="image-20240331155312038" tabindex="0" loading="lazy"><figcaption>image-20240331155312038</figcaption></figure><p><strong>事务A开始第二次查询</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于隔离级别为 <code>可重复读</code>，此时并不会重新生成 ReadView，三条数据都符合<code>Where</code> 条件，都会被查询出来，然后根据ReadView判断哪个版本可以被访问：</p><ul><li>首先 id = 3，trx_id = 30 ， 在 trx_ids=[20,30] 之间，说明此时的 trx_id = 30 为活跃状态，因此不可以被访问</li><li>id = 2，trx_id = 30 和上面同理，不可以被访问</li><li>id = 1，可以被访问</li></ul><p><strong>结果</strong>：第二次查询出 id = 1 的数据，解决了幻读问题！</p><h2 id="_17-6-总结" tabindex="-1"><a class="header-anchor" href="#_17-6-总结"><span>17.6 总结</span></a></h2><p><strong>MVCC可以解决</strong></p><ul><li><strong>读写之间阻塞的问题</strong>：通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li><strong>降低了死锁的概率</strong> ：这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li><strong>解决快照读的问题</strong>：当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ul><h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1>',87)],g={},m=(0,n(66262).A)(g,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,u)}]]),k=JSON.parse('{"path":"/MySQL/17MVCC.html","title":"十七、MVCC","lang":"zh-CN","frontmatter":{"date":"2024-03-28T00:00:00.000Z","category":["数据库"],"tag":["数据库","MySQL"],"editLink":false,"pageview":false,"sticky":true,"star":true,"order":17,"description":"十七、MVCC 17.1 什么是MVCC MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。 多个版本： 指undo日志中保存的被事务修改的行信息 17.2 快照...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/MySQL/17MVCC.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"十七、MVCC"}],["meta",{"property":"og:description","content":"十七、MVCC 17.1 什么是MVCC MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。 多个版本： 指undo日志中保存的被事务修改的行信息 17.2 快照..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-05T05:35:13.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-05T05:35:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"十七、MVCC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-05T05:35:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":2,"title":"17.1 什么是MVCC","slug":"_17-1-什么是mvcc","link":"#_17-1-什么是mvcc","children":[]},{"level":2,"title":"17.2 快照读和当前读","slug":"_17-2-快照读和当前读","link":"#_17-2-快照读和当前读","children":[]},{"level":2,"title":"17.3 复习","slug":"_17-3-复习","link":"#_17-3-复习","children":[{"level":3,"title":"17.3.1 再谈隔离级别","slug":"_17-3-1-再谈隔离级别","link":"#_17-3-1-再谈隔离级别","children":[]},{"level":3,"title":"17.3.2 隐藏字段、UNDO日志版本链","slug":"_17-3-2-隐藏字段、undo日志版本链","link":"#_17-3-2-隐藏字段、undo日志版本链","children":[]}]},{"level":2,"title":"17.4 MVCC实现原理之ReadView","slug":"_17-4-mvcc实现原理之readview","link":"#_17-4-mvcc实现原理之readview","children":[{"level":3,"title":"17.4.1 什么是ReadView","slug":"_17-4-1-什么是readview","link":"#_17-4-1-什么是readview","children":[]},{"level":3,"title":"17.4.2 设计思路","slug":"_17-4-2-设计思路","link":"#_17-4-2-设计思路","children":[]},{"level":3,"title":"17.4.3 ReadView规则","slug":"_17-4-3-readview规则","link":"#_17-4-3-readview规则","children":[]},{"level":3,"title":"17.4.4 MVCC整体操作流程","slug":"_17-4-4-mvcc整体操作流程","link":"#_17-4-4-mvcc整体操作流程","children":[]}]},{"level":2,"title":"17.5 如何解决幻读","slug":"_17-5-如何解决幻读","link":"#_17-5-如何解决幻读","children":[]},{"level":2,"title":"17.6 总结","slug":"_17-6-总结","link":"#_17-6-总结","children":[]}],"git":{"createdTime":1712295313000,"updatedTime":1712295313000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":9.21,"words":2763},"filePathRelative":"MySQL/17MVCC.md","localizedDate":"2024年3月28日","excerpt":"\\n<h2>17.1 什么是MVCC</h2>\\n<p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过<code>数据行的多个版本管理</code>来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。</p>\\n<p>多个版本： 指undo日志中保存的被事务修改的行信息</p>\\n<h2>17.2 快照读和当前读</h2>\\n<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到 <code>不加锁</code> ， 非阻塞并发读 ，而这个读指的就是 <code>快照读</code> , 而非 当前读 。<code>当前读实际上是一种加锁</code>的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>","autoDesc":true}')}}]);