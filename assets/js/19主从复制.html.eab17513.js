"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[188],{66262:(e,s)=>{s.A=(e,s)=>{const a=e.__vccOpts||e;for(const[e,n]of s)a[e]=n;return a}},7585:(e,s,a)=>{a.r(s),a.d(s,{comp:()=>b,data:()=>h});var n=a(20641);const l=a.p+"assets/img/image-20240401091741919.b5012769.png",i=a.p+"assets/img/image-20240401092406011.914d39f9.png",t=a.p+"assets/img/image-20240401093239495.573c2ff5.png",o=a.p+"assets/img/image-20240401093401888.de2148da.png",p=a.p+"assets/img/image-20240401093954967.14e180df.png",c=a.p+"assets/img/image-20240401095229716.71086e10.png",d=a.p+"assets/img/image-20240401095449801.61e60eba.png",r=a.p+"assets/img/image-20240401095618744.60a24f72.png",g=a.p+"assets/img/image-20240401095701933.90cb9f0f.png",u=a.p+"assets/img/image-20240401095908989.6f0c9a0c.png",m=a.p+"assets/img/image-20240401100217220.82640dc0.png",v=[(0,n.Fv)('<h1 id="十九、主从复制" tabindex="-1"><a class="header-anchor" href="#十九、主从复制"><span>十九、主从复制</span></a></h1><h2 id="_19-1-主从复制的概述" tabindex="-1"><a class="header-anchor" href="#_19-1-主从复制的概述"><span>19.1 主从复制的概述</span></a></h2><h3 id="_19-1-1-如何提升数据库的并发能力" tabindex="-1"><a class="header-anchor" href="#_19-1-1-如何提升数据库的并发能力"><span>19.1.1 如何提升数据库的并发能力</span></a></h3><p>在实际工作中，我们常常将<code> Redis</code> 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就 <code>提升了读取的效率</code>，也减少了对后端数据库的 访问压力。 Redis 的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><figure><img src="'+l+'" alt="image-20240401091741919" tabindex="0" loading="lazy"><figcaption>image-20240401091741919</figcaption></figure><p>此外，一般应用对数据库而言都是“ <code>读多写少 </code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 <code>主从架构 </code>、进行 <code>读写分离</code> ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 <code>优化SQL和索引 </code>，这种方式简单有效；其次才是采用 <code>缓存的策略</code> ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用 <code>主从架构</code> ，进行读写分离</p><h3 id="_19-1-2-主从复制的作用" tabindex="-1"><a class="header-anchor" href="#_19-1-2-主从复制的作用"><span>19.1.2 主从复制的作用</span></a></h3><p>主从同步设计不仅可以<code>提高数据库的吞吐量</code>，还有以下 3 个方面的作用</p><p><strong>第1个作用</strong> : <code>读写分离</code>。我们可以通过主从复制的方式来 <code>同步数据</code>，然后通过读写分离提高数据库并发处理能</p><figure><img src="'+i+'" alt="image-20240401092406011" tabindex="0" loading="lazy"><figcaption>image-20240401092406011</figcaption></figure><p>其中一个是Master主库，负责写入数据，我们称之为: <code>写库</code>。</p><p>其它都是slave从库，负责读取数据，我们称之为: <code>读库</code>。</p><p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。面对“读多写少”的需求，采用读写分离的方式，可以实现, <code>更高的并发访问</code>。同时，</p><p>我们还能对从服务器进行 <code>负载均衡</code>，让不同的读请求按照策略均匀地分发到不同的从服务器上，让 <code>读取更加顺畅</code> 。读取顺畅的另一个原因，就是 <code>减少了锁表</code> 的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行 SELECT 的读取。</p><p><strong>第2个作用</strong> 就是<code>数据备份</code>。我们通过主从复制将主库上的数据复制到了从库上，相当于是一 种 <code>热备份机制</code>，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p><p><strong>第3个作用</strong> 是<code>具有高可用性</code>。数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现 <code>故障</code> 或 <code>宕机 </code>的情况下，可以 <code>切换 </code>到从服务器上，保证服务的正常运行。</p><h2 id="_19-2-主从复制的原理" tabindex="-1"><a class="header-anchor" href="#_19-2-主从复制的原理"><span>19.2 主从复制的原理</span></a></h2><p><code>Slave</code> 会从<code> Master</code> 读取 <code>binlog</code> 来进行数据同步。</p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 <code>3 个线程 </code>来操作，一个主库线程，两个从库线程</p><figure><img src="'+t+'" alt="image-20240401093239495" tabindex="0" loading="lazy"><figcaption>image-20240401093239495</figcaption></figure><p><code>二进制日志转储线程 （Binlog dump thread）</code>是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步</p><figure><img src="'+o+'" alt="image-20240401093401888" tabindex="0" loading="lazy"><figcaption>image-20240401093401888</figcaption></figure><p><strong>三步骤：</strong></p><p>步骤1： <code>Master</code> 将写操作记录到二进制日志（ binlog ）。</p><p>步骤2： Slave 将 Master 的 <code>binary log events</code> 拷贝到它的中继日志（ relay log ）；</p><p>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 <code>接入点</code> 开始复制。</p><p><strong>基本准则</strong>：</p><ul><li>每个 Slave 只有一个 Master</li><li>每个 Slave 只能有一个唯一的服务器ID</li><li>每个 Master 可以有多个 Slave</li></ul><h2 id="_19-3-一主一从搭建" tabindex="-1"><a class="header-anchor" href="#_19-3-一主一从搭建"><span>19.3 一主一从搭建</span></a></h2><p>一台 <code>主机</code> 用于处理所有 <code>写请求</code> ，一台 <code>从机</code> 负责所有 <code>读请求</code> ，架构图如下</p><figure><img src="'+p+'" alt="image-20240401093954967" tabindex="0" loading="lazy"><figcaption>image-20240401093954967</figcaption></figure><h3 id="_19-3-1-准备工作" tabindex="-1"><a class="header-anchor" href="#_19-3-1-准备工作"><span>19.3.1 准备工作</span></a></h3><p>1、准备<code> 2台</code> CentOS 虚拟机</p><p>2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</p><blockquote><p>注意：克隆的方式需要修改新克隆出来主机的：① MAC地址 ② hostname ③ IP 地址 ④ UUID 。</p></blockquote><p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如： <code>show slave status\\G</code> ，报如下的错误：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>Last_IO_Error: Fatal error: The slave I<span class="token operator">/</span>O thread stops because master <span class="token operator">and</span> slave have equal MySQL server UUIDs<span class="token punctuation">;</span> these UUIDs must be different <span class="token keyword">for</span> <span class="token keyword">replication</span> <span class="token keyword">to</span> <span class="token keyword">work</span><span class="token punctuation">.</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改方式：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>vim <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>auto<span class="token punctuation">.</span>cnf\nsystemctl restart mysqld\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19-3-2-主机配置文件" tabindex="-1"><a class="header-anchor" href="#_19-3-2-主机配置文件"><span>19.3.2 主机配置文件</span></a></h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 <code>[mysqld] </code>节点下，且都是小写字母。</p><ul><li><strong>必选</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#[必须]主服务器唯一ID</span>\nserver<span class="token operator">-</span>id<span class="token operator">=</span>\n\n<span class="token comment">#[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span>\nlog<span class="token operator">-</span>bin<span class="token operator">=</span>atguigu<span class="token operator">-</span>bin\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>可选</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#[可选] 0（默认）表示读写（主机），1表示只读（从机）</span>\n<span class="token keyword">read</span><span class="token operator">-</span>only<span class="token operator">=</span><span class="token number">0</span>\n<span class="token comment">#设置日志文件保留的时长，单位是秒</span>\nbinlog_expire_logs_seconds<span class="token operator">=</span><span class="token number">6000</span>\n<span class="token comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span>\nmax_binlog_size<span class="token operator">=</span><span class="token number">200</span>M\n<span class="token comment">#[可选]设置不要复制的数据库</span>\nbinlog<span class="token operator">-</span><span class="token keyword">ignore</span><span class="token operator">-</span>db<span class="token operator">=</span>test\n<span class="token comment">#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span>\nbinlog<span class="token operator">-</span><span class="token keyword">do</span><span class="token operator">-</span>db<span class="token operator">=</span>需要复制的主数据库名字\n<span class="token comment">#[可选]设置binlog格式</span>\nbinlog_format<span class="token operator">=</span>STATEMENT\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>binlog格式设置：</strong></p><p>格式1：<code>STATEMENT模式</code>（基于SQL语句的复制(statement-based replication, SBR)）</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>binlog_format<span class="token operator">=</span>STATEMENT\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每一条会修改数据的 <code>sql语句</code> 会记录到binlog中。这是默认的binlog格式。</p><p><strong>SBR优点</strong></p><ul><li>不需要记录每一行的变化，减少了binlog日志量，文件较小</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li><li>binlog可以用于实时的还原，而不仅仅用于复制</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li></ul><p><strong>SBR缺点</strong></p><ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li></ul><p>格式二：<strong>ROW模式（基于行的复制(row-based replication, RBR)）</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>binlog_format<span class="token operator">=</span><span class="token keyword">ROW</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>RBR 的优点：</strong></p><ul><li><p>任何情况都可以被复制，这对复制来说是最 安全可靠 的。（比如：不会出现某些特定情况下</p><p>的存储过程、function、trigger的调用和触发无法被正确复制的问题）</p></li><li><p>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</p></li><li><p>复制以下几种语句时的行锁更少：INSERT ... SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</p></li><li><p>执行 INSERT，UPDATE，DELETE 语句时锁更少</p></li><li><p>从服务器上采用 多线程 来执行复制成为可能</p></li></ul><p><strong>RBR 的缺点：</strong></p><ul><li>binlog 大了很多</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li><li>无法从 binlog 中看到都复制了些什么语句</li></ul><p>格式三： <strong>MIXED模式（混合模式复制(mixed-based replication, MBR)）</strong></p><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="_19-3-3-从机配置文件" tabindex="-1"><a class="header-anchor" href="#_19-3-3-从机配置文件"><span>19.3.3 从机配置文件</span></a></h3><ul><li><strong>必选</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#[必须]从服务器唯一ID</span>\nserver<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">2</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>可选</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># [可选]启用中继日志</span>\nrelay<span class="token operator">-</span>log<span class="token operator">=</span>mysql<span class="token operator">-</span>relay\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：主从机都关闭防火墙</p><p>service iptables stop #CentOS 6</p><p>systemctl stop firewalld.service #CentOS 7</p></blockquote><h3 id="_19-3-4-主机-建立账户并授权" tabindex="-1"><a class="header-anchor" href="#_19-3-4-主机-建立账户并授权"><span>19.3.4 主机：建立账户并授权</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 在主机MySQL里执行授权主从复制的命令</span>\n<span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">&#39;slave1&#39;</span><span class="token variable">@&#39;从机器数据库IP&#39;</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">&#39;abc123&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">#5.5,5.7</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">&#39;slave1&#39;</span><span class="token variable">@&#39;%&#39;</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">&#39;123456&#39;</span><span class="token punctuation">;</span>\n<span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">&#39;slave1&#39;</span><span class="token variable">@&#39;%&#39;</span><span class="token punctuation">;</span>\n\n<span class="token comment">#此语句必须执行。否则见下面。</span>\n<span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">&#39;slave1&#39;</span><span class="token variable">@&#39;%&#39;</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">&#39;123456&#39;</span><span class="token punctuation">;</span>\nflush <span class="token keyword">privileges</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询Master的状态，并记录下<code>File和Position</code>的值</p><figure><img src="'+c+'" alt="image-20240401095229716" tabindex="0" loading="lazy"><figcaption>image-20240401095229716</figcaption></figure><blockquote><p>注意：执行完此步骤后<strong>不要再操作主服务器MySQL</strong>，防止主服务器状态值变化。</p></blockquote><h3 id="_19-3-5-从机-配置需要复制的主机" tabindex="-1"><a class="header-anchor" href="#_19-3-5-从机-配置需要复制的主机"><span>19.3.5 从机：配置需要复制的主机</span></a></h3><p>1、从机上复制主机的命令</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>CHANGE MASTER <span class="token keyword">TO</span>\nMASTER_HOST<span class="token operator">=</span><span class="token string">&#39;主机的IP地址&#39;</span><span class="token punctuation">,</span>\nMASTER_USER<span class="token operator">=</span><span class="token string">&#39;主机用户名&#39;</span><span class="token punctuation">,</span>\nMASTER_PASSWORD<span class="token operator">=</span><span class="token string">&#39;主机用户名的密码&#39;</span><span class="token punctuation">,</span>\nMASTER_LOG_FILE<span class="token operator">=</span><span class="token string">&#39;mysql-bin.具体数字&#39;</span><span class="token punctuation">,</span>\nMASTER_LOG_POS<span class="token operator">=</span>具体值<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+d+'" alt="image-20240401095449801" tabindex="0" loading="lazy"><figcaption>image-20240401095449801</figcaption></figure><p>若是之前做过主从复制，并且还仍在开着，请先停止！</p><figure><img src="'+r+'" alt="image-20240401095618744" tabindex="0" loading="lazy"><figcaption>image-20240401095618744</figcaption></figure><p>2、启动slave同步</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#启动slave同步</span>\n<span class="token keyword">START</span> SLAVE<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果报错</p><figure><img src="'+g+'" alt="image-20240401095701933" tabindex="0" loading="lazy"><figcaption>image-20240401095701933</figcaption></figure><p>可以执行如下操作，删除之前的 relay_log信息。然后重新执行 <code>CHANGE MASTER TO ...</code> 语句即可。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> reset slave<span class="token punctuation">;</span> <span class="token comment">#删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看同步状态</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> SLAVE <span class="token keyword">STATUS</span>\\G<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="'+u+'" alt="image-20240401095908989" tabindex="0" loading="lazy"><figcaption>image-20240401095908989</figcaption></figure><blockquote><p>上面两个参数都是Yes，则说明主从配置成功！</p></blockquote><h3 id="_19-3-5-停止复制" tabindex="-1"><a class="header-anchor" href="#_19-3-5-停止复制"><span>19.3.5 停止复制</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>stop slave<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错如下：</p><figure><img src="'+m+'" alt="image-20240401100217220" tabindex="0" loading="lazy"><figcaption>image-20240401100217220</figcaption></figure>',98)],k={},b=(0,a(66262).A)(k,[["render",function(e,s){return(0,n.uX)(),(0,n.CE)("div",null,v)}]]),h=JSON.parse('{"path":"/MySQL/19%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html","title":"十九、主从复制","lang":"zh-CN","frontmatter":{"date":"2024-03-28T00:00:00.000Z","category":["数据库"],"tag":["数据库","MySQL"],"editLink":false,"pageview":false,"sticky":true,"star":true,"order":19,"description":"十九、主从复制 19.1 主从复制的概述 19.1.1 如何提升数据库的并发能力 在实际工作中，我们常常将 Redis 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就 提升了读取的效率，也减少了对后端数据库的 访问压力。 Redis 的缓存架构是高并发架构中非常重要的一环。...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/MySQL/19%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"十九、主从复制"}],["meta",{"property":"og:description","content":"十九、主从复制 19.1 主从复制的概述 19.1.1 如何提升数据库的并发能力 在实际工作中，我们常常将 Redis 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就 提升了读取的效率，也减少了对后端数据库的 访问压力。 Redis 的缓存架构是高并发架构中非常重要的一环。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-05T05:35:13.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-05T05:35:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"十九、主从复制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-05T05:35:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":2,"title":"19.1 主从复制的概述","slug":"_19-1-主从复制的概述","link":"#_19-1-主从复制的概述","children":[{"level":3,"title":"19.1.1 如何提升数据库的并发能力","slug":"_19-1-1-如何提升数据库的并发能力","link":"#_19-1-1-如何提升数据库的并发能力","children":[]},{"level":3,"title":"19.1.2 主从复制的作用","slug":"_19-1-2-主从复制的作用","link":"#_19-1-2-主从复制的作用","children":[]}]},{"level":2,"title":"19.2 主从复制的原理","slug":"_19-2-主从复制的原理","link":"#_19-2-主从复制的原理","children":[]},{"level":2,"title":"19.3 一主一从搭建","slug":"_19-3-一主一从搭建","link":"#_19-3-一主一从搭建","children":[{"level":3,"title":"19.3.1 准备工作","slug":"_19-3-1-准备工作","link":"#_19-3-1-准备工作","children":[]},{"level":3,"title":"19.3.2 主机配置文件","slug":"_19-3-2-主机配置文件","link":"#_19-3-2-主机配置文件","children":[]},{"level":3,"title":"19.3.3 从机配置文件","slug":"_19-3-3-从机配置文件","link":"#_19-3-3-从机配置文件","children":[]},{"level":3,"title":"19.3.4 主机：建立账户并授权","slug":"_19-3-4-主机-建立账户并授权","link":"#_19-3-4-主机-建立账户并授权","children":[]},{"level":3,"title":"19.3.5 从机：配置需要复制的主机","slug":"_19-3-5-从机-配置需要复制的主机","link":"#_19-3-5-从机-配置需要复制的主机","children":[]},{"level":3,"title":"19.3.5 停止复制","slug":"_19-3-5-停止复制","link":"#_19-3-5-停止复制","children":[]}]}],"git":{"createdTime":1712295313000,"updatedTime":1712295313000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":8.95,"words":2686},"filePathRelative":"MySQL/19主从复制.md","localizedDate":"2024年3月28日","excerpt":"\\n<h2>19.1 主从复制的概述</h2>\\n<h3>19.1.1 如何提升数据库的并发能力</h3>\\n<p>在实际工作中，我们常常将<code> Redis</code> 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就 <code>提升了读取的效率</code>，也减少了对后端数据库的 访问压力。 Redis 的缓存架构是<code>高并发架构</code>中非常重要的一环。</p>\\n<figure><figcaption>image-20240401091741919</figcaption></figure>","autoDesc":true}')}}]);