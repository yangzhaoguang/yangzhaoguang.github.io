"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[684],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}},71174:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>Ga,data:()=>_a});var t=a(20641);const e=a.p+"assets/img/20210219190809451.eb0d47bb.png",p=a.p+"assets/img/image-20231030212729924.adc079cc.png",o=a.p+"assets/img/cc4b8a8ce7b5b7849b5ca725e22519c4.4a1e8078.png",c=a.p+"assets/img/20200806190511967.0f5aa5d9.png",l=a.p+"assets/img/二叉树前序遍历（迭代法）.7f471867.gif",i=a.p+"assets/img/二叉树中序遍历（迭代法）.2ab8f14c.gif",u=a.p+"assets/img/image-20231030231551687.d40be02e.png",r=a.p+"assets/img/tree1-16987635878798.1bfdd2f0.jpg",d=a.p+"assets/img/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.0ae9243e.gif",k=a.p+"assets/img/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.9fc2840f.jpg",v=a.p+"assets/img/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.35e2bfbc.jpg",m=a.p+"assets/img/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.21bd0502.gif",g=a.p+"assets/img/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.06afff46.jpg",b=a.p+"assets/img/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.38085104.gif",f=a.p+"assets/img/tree1.1bfdd2f0.jpg",A=a.p+"assets/img/tree.63a83a8c.jpg",y=a.p+"assets/img/fig1.f58542ed.png",h=a.p+"assets/img/avg1-tree.69c21fd4.jpg",w=a.p+"assets/img/avg2-tree.76bc045a.jpg",x=a.p+"assets/img/narytreeexample.21ddc823.png",I=a.p+"assets/img/sample_4_964.a355fa13.png",E=a.p+"assets/img/largest_e1.d32049c5.jpg",B=a.p+"assets/img/tmp-tree.a74506dc.jpg",S=a.p+"assets/img/ex_depth.59a282e8.jpg",N=a.p+"assets/img/invert1-tree.acfa2eba.jpg",j=a.p+"assets/img/invert2-tree.dfcb2af3.jpg",Q=a.p+"assets/img/1698026966-JDYPDU-image.e654d969.png",T=a.p+"assets/img/1698027008-nPFLbM-image.1e3377e1.png",L=a.p+"assets/img/image-20231106221428126.b0c3fe36.png",q=a.p+"assets/img/complete.ae367ec1.jpg",H=a.p+"assets/img/balance_1.fc731ea0.jpg",P=a.p+"assets/img/balance_2.851119e1.jpg",D=a.p+"assets/img/paths-tree.e8dc9c8c.jpg",C=a.p+"assets/img/leftsum-tree.69c21fd4.jpg",R=a.p+"assets/img/tree2.e243ce88.jpg",W=a.p+"assets/img/pathsum1.3c13594a.jpg",z=a.p+"assets/img/tree-16999704059491.69c21fd4.jpg",U=a.p+"assets/img/image-20231114221040622.1ae710d1.png",J=a.p+"assets/img/tree1-16999756190813.5c707d10.jpg",F=a.p+"assets/img/merge.41ed8143.jpg",K=a.p+"assets/img/tree1-17000569337032.8e8593d3.jpg",O=a.p+"assets/img/tree2-17000569337034.177c335c.jpg",V=a.p+"assets/img/tree2-17001406088943.c29aaf1d.jpg",Z=a.p+"assets/img/bst1.4fd466d5.jpg",M=a.p+"assets/img/bst2.20e6d00a.jpg",X="data:image/png;base64,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",Y=a.p+"assets/img/insertbst.4e16ecff.jpg",G=a.p+"assets/img/image-20231121231225377.6ee2b34a.png",_=a.p+"assets/img/image-20231121231408805.1b11a9f9.png",$=a.p+"assets/img/trim1.b5e60be7.jpg",nn=a.p+"assets/img/trim2.05dec085.jpg",sn=a.p+"assets/img/btree1.81b4cdc0.jpg",an=a.p+"assets/img/image-20231122222756717.6602e3f3.png",tn=a.p+"assets/img/tree.164945e9.png",en=(0,t.Fv)('<h1 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h1><figure><img src="'+e+'" alt="二叉树大纲" tabindex="0" loading="lazy"><figcaption>二叉树大纲</figcaption></figure><p><strong>满二叉树</strong>：</p><ol><li>对于k层的二叉树来说，拥有 2<sup>k</sup> -1 个结点的二叉树称为满二叉树</li><li>度为0的结点(叶子结点)都在同一层上</li></ol><figure><img src="'+p+'" alt="image-20231030212729924" tabindex="0" loading="lazy"><figcaption>image-20231030212729924</figcaption></figure><p><strong>完全二叉树：</strong></p><ol><li>二叉树的结点位置按照对应的完全二叉树的位置相吻合</li><li>最后一层的结点，一定是从左往右依次排满的</li></ol><figure><img src="'+o+'" alt="image-20230813175651994" tabindex="0" loading="lazy"><figcaption>image-20230813175651994</figcaption></figure><p><strong>线索二叉树</strong></p><p>若根结点的左、右子树均不为空，那么有：</p><ul><li>左子树的所有结点的值均<strong>小于</strong>根结点的值</li><li>右子树的所有结点的值均<strong>大于</strong>根节点的值</li></ul><p><strong>平衡二叉树</strong></p><p>平衡二叉树，又称AVL，一个树的左右子树的高度的差值不能大于1</p><figure><img src="'+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>二叉树的遍历</strong></p><p>二叉树遍历方式分为三种：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>每一种遍历都可以用递归和迭代俩种方法来实现，对应LeetCode题目：</p>',18),pn={href:"https://leetcode.cn/problems/binary-tree-preorder-traversal/",target:"_blank",rel:"noopener noreferrer"},on={href:"https://leetcode.cn/problems/binary-tree-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},cn={href:"https://leetcode.cn/problems/binary-tree-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},ln=(0,t.Fv)('<h2 id="_1、二叉树递归遍历" tabindex="-1"><a class="header-anchor" href="#_1、二叉树递归遍历"><span>1、二叉树递归遍历</span></a></h2><p>递归方法比较简单，只要弄清楚结束条件即可，所谓前、中、后序遍历只不过调整加入集合的顺序即可。</p><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历"><span>前序遍历</span></a></h3><p>前序遍历顺序：</p><ul><li>先遍历根节点</li><li>在遍历左子树</li><li>最后遍历右子树</li></ul><p><strong>代码实现</strong></p><p>定义结点</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> val<span class="token punctuation">;</span>\n    <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>\n    <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>\n\n    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**\n     * 方法一：递归\n     *  根节点、左子树、右子树\n     * */</span>\n    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token comment">// 先遍历根节点</span>\n        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 递归遍历左子树</span>\n        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 递归遍历左子树</span>\n        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历"><span><strong>中序遍历</strong></span></a></h3><p>遍历顺序：</p><ul><li>先遍历左子树</li><li>在遍历根节点</li><li>最后遍历右子树</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n        <span class="token comment">// 先遍历左子树</span>\n        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历根节点</span>\n        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历右子树</span>\n        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历"><span><strong>后序遍历</strong></span></a></h3><ul><li>先遍历左子树</li><li>在遍历右子树</li><li>最后遍历根节点</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n\n        <span class="token comment">// 先遍历左子树</span>\n        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 在遍历右子树</span>\n        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 最后遍历根节点</span>\n        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2、二叉树迭代遍历" tabindex="-1"><a class="header-anchor" href="#_2、二叉树迭代遍历"><span>2、二叉树迭代遍历</span></a></h2><p>二叉树的迭代遍历相较于递归比较困难一些，我们知道所谓的<strong>递归，其实就是将局部变量，返回值，返回地址存放在栈中</strong>，二叉树的迭代遍历也可以用栈来实现。</p><h3 id="前序遍历-1" tabindex="-1"><a class="header-anchor" href="#前序遍历-1"><span><strong>前序遍历</strong></span></a></h3><p>先将根节点入栈，然后弹栈，再将右孩子结点、左孩子结点依次入栈</p><blockquote><p>由于栈先进后出，所以先将右孩子放入栈中，后放左孩子</p></blockquote><figure><img src="'+l+'" alt="二叉树前序遍历（迭代法）" tabindex="0" loading="lazy"><figcaption>二叉树前序遍历（迭代法）</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**\n     * 方法二：迭代遍历\n     * */</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//   先将根节点入栈</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 将根节点弹栈</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 将根节点加入到集合中</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 将右孩子结点入栈，切记: 空结点不放入栈中</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 同理将左孩子放入栈中</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="中序遍历-1" tabindex="-1"><a class="header-anchor" href="#中序遍历-1"><span>中序遍历</span></a></h3><p>在递归中我们只修改了处理结点的顺序（将节点增加到集合中），代码都一样，只是顺序改变了。</p><p>但是在迭代中，我们就无法这样做了，为什么呢？</p><blockquote><p>在前序遍历中，我们访问结点和处理结点的顺序是一致的，从根结点开始访问，也是从根结点开始处理！</p><p>但是在中序遍历中，我们从根节点开始访问，但是处理的结点却是左边最底部的结点。</p><p>因此我们<strong>需要一个指针，帮助我们访问结点</strong></p></blockquote><figure><img src="'+i+'" alt="二叉树中序遍历（迭代法）" tabindex="0" loading="lazy"><figcaption>二叉树中序遍历（迭代法）</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 使用一个指针，帮助访问处理的结点</span>\n        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 说明还未到达左边最底部的结点，继续向下访问</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 左</span>\n                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 说明到达了左边最底部的结点，进行处理</span>\n                <span class="token comment">// 中</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 右</span>\n                cur <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历-1" tabindex="-1"><a class="header-anchor" href="#后序遍历-1"><span>后序遍历</span></a></h3><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转 res 集合，输出的结果顺序就是左右中了，如下图：</p><figure><img src="'+u+'" alt="image-20231030231551687" tabindex="0" loading="lazy"><figcaption>image-20231030231551687</figcaption></figure><p><strong>切记</strong>： 栈的原则为先进后出，先放左，后放右，右先出，左后出！</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**\n     * 方法二：迭代遍历\n     * */</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 先将根节点入栈</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 根</span>\n            <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 左</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 右</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 反转</span>\n        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>其中前序遍历和后序遍历会有一些联系，和中序遍历代码不相关。</p><p>原因就是中序遍历访问和处理的结点不是同一个，需要用额外的一个指针来访问！</p><h2 id="_3、二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_3、二叉树的层序遍历"><span>3、二叉树的层序遍历</span></a></h2>',38),un={id:"_102-二叉树的层序遍历-opens-new-window",tabindex:"-1"},rn={class:"header-anchor",href:"#_102-二叉树的层序遍历-opens-new-window"},dn={href:"https://leetcode.cn/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},kn=(0,t.Fv)('<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1]\n输出：[[1]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：[]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路分析" tabindex="-1"><a class="header-anchor" href="#思路分析"><span>思路分析</span></a></h4><blockquote><p>作者：nettee 链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/</p></blockquote><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。</p><p><strong>DFS 与 BFS</strong></p><p>让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用 <strong>递归</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BFS 遍历使用<strong>队列</strong>数据结构：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Java 的 pop 写作 poll()</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 <strong>栈</strong>，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><p>虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。</p><figure><img src="'+d+'" alt="DFS 与 BFS 对比" tabindex="0" loading="lazy"><figcaption>DFS 与 BFS 对比</figcaption></figure><p><strong>BFS应用场景: 层序遍历</strong></p><blockquote><p><strong>什么是层序遍历？</strong></p></blockquote><p>从上至下，从左到右依次访问二叉树的每一个结点。</p><figure><img src="'+k+'" alt="二叉树的层序遍历" tabindex="0" loading="lazy"><figcaption>二叉树的层序遍历</figcaption></figure><p>其实乍一看这个遍历顺序和 BFS(广度优先遍历)是一样的，但是与BFS不同的是，二叉树的层次遍历却是一个二维数组。而BFS 遍历后得到是一维数组，无法区分每一层</p><figure><img src="'+v+'" alt="BFS 遍历与层序遍历的输出结果不同" tabindex="0" loading="lazy"><figcaption>BFS 遍历与层序遍历的输出结果不同</figcaption></figure><p>那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><figure><img src="'+m+'" alt="BFS 遍历的过程（动图）" tabindex="0" loading="lazy"><figcaption>BFS 遍历的过程（动图）</figcaption></figure><p>截取 BFS 遍历过程中的某一时刻：</p><figure><img src="'+g+'" alt="BFS 遍历中某个时刻队列的状态" tabindex="0" loading="lazy"><figcaption>BFS 遍历中某个时刻队列的状态</figcaption></figure><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们 <strong>无法区分队列中的结点来自哪一层</strong>。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 二叉树的层序遍历</span>\n<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> n <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n            <span class="token comment">// 变量 i 无实际意义，只是为了循环 n 次</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将BFS遍历改成了层序遍历，在遍历过程中，结点的出队入队过程为：</p><figure><img src="'+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><p>最终我们得到的题解代码为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// n记录每一层的结点个数</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> n <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// n 无实际意义，只是为了能够一次性将一层的结点出队</span>\n                <span class="token class-name">TreeNode</span> treeNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                item<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token comment">// 将左孩子结点入队</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 将右孩子结点入队</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>递归版本</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// deep表示遍历的层次</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 终止条件</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token comment">// 没执行一次，层次加一</span>\n        deep<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 每一层的元素加集合，当deep增加时，增加一层元素</span>\n            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 增加当前结点,list索引下标从0开始，所以-1</span>\n        res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deep <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历左子树</span>\n        <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> deep<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历右子树</span>\n        <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> deep<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',43),vn={id:"_107-二叉树的层序遍历-ii",tabindex:"-1"},mn={class:"header-anchor",href:"#_107-二叉树的层序遍历-ii"},gn={href:"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/",target:"_blank",rel:"noopener noreferrer"},bn=(0,t.Fv)('<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><figure><img src="'+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1]\n输出：[[1]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：[]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路分析-1" tabindex="-1"><a class="header-anchor" href="#思路分析-1"><span>思路分析</span></a></h4><p>简单一批，直接将集合反转即可</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> n <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                item<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n       <span class="token operator">/</span>\n        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',13),fn={id:"_199-二叉树的右视图",tabindex:"-1"},An={class:"header-anchor",href:"#_199-二叉树的右视图"},yn={href:"https://leetcode.cn/problems/binary-tree-right-side-view/",target:"_blank",rel:"noopener noreferrer"},hn=(0,t.Fv)('<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><figure><img src="'+A+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: [1,null,3]\n输出: [1,3]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: []\n输出: []\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="思路分析-2" tabindex="-1"><a class="header-anchor" href="#思路分析-2"><span>思路分析</span></a></h4><p>如图所示，我们只需要将层序遍历结果中，每一层的最后一个元素放入结果集中即可</p><figure><img src="'+y+'" alt="fig1" tabindex="0" loading="lazy"><figcaption>fig1</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 将左孩子入队</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 将右孩子结点入队</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 只需要将每层的最后一个放到res即可</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> levelSize<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span>  res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',14),wn={id:"_637-二叉树的层平均值",tabindex:"-1"},xn={class:"header-anchor",href:"#_637-二叉树的层平均值"},In={href:"https://leetcode.cn/problems/average-of-levels-in-binary-tree/",target:"_blank",rel:"noopener noreferrer"},En=(0,t.Fv)('<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：[3.00000,14.50000,11.00000]\n解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><figure><img src="'+w+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,15,7]\n输出：[3.00000,14.50000,11.00000]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数量在 <code>[1, 104]</code> 范围内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h4 id="思路分析-3" tabindex="-1"><a class="header-anchor" href="#思路分析-3"><span>思路分析</span></a></h4><p>遍历每层结点时，累加结点的值，每一层累加完求平均值即可</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n\n        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n                \n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sum<span class="token operator">/</span>levelSize<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12),Bn={id:"_429-n-叉树的层序遍历",tabindex:"-1"},Sn={class:"header-anchor",href:"#_429-n-叉树的层序遍历"},Nn={href:"https://leetcode.cn/problems/n-ary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},jn=(0,t.Fv)('<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p><strong>示例 1：</strong></p><figure><img src="'+x+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,null,3,2,4,null,5,6]\n输出：[[1],[3,2,4],[5,6]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+I+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><h4 id="思路分析-4" tabindex="-1"><a class="header-anchor" href="#思路分析-4"><span>思路分析</span></a></h4><p>在进行二叉树遍历时，我们是将左孩子、右孩子结点入队，N叉树我们只需要改变入队规则，将 结点的 <code>children</code> 入队即可</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List&lt;Node&gt; children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List&lt;Node&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                item<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                \n                <span class="token comment">// 改变入队方式</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n                    queue<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',13),Qn={id:"_515-在每个树行中找最大值",tabindex:"-1"},Tn={class:"header-anchor",href:"#_515-在每个树行中找最大值"},Ln={href:"https://leetcode.cn/problems/find-largest-value-in-each-tree-row/",target:"_blank",rel:"noopener noreferrer"},qn=(0,t.Fv)('<p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><figure><img src="'+E+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [1,3,2,5,3,null,9]\n输出: [1,3,9]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [1,2,3]\n输出: [1,3]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h4 id="思路分析-5" tabindex="-1"><a class="header-anchor" href="#思路分析-5"><span>思路分析</span></a></h4><p>没啥好分析的，和求平均值一样</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">largestValues</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               maxValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',11),Hn={id:"_116-填充每个节点的下一个右侧节点指针",tabindex:"-1"},Pn={class:"header-anchor",href:"#_116-填充每个节点的下一个右侧节点指针"},Dn={href:"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/",target:"_blank",rel:"noopener noreferrer"},Cn=(0,t.Fv)('<p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>struct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：[]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h4 id="思路分析-6" tabindex="-1"><a class="header-anchor" href="#思路分析-6"><span>思路分析</span></a></h4><p>只需要将每一层 poll 出来的结点：</p><ul><li>如果下一个结点不为空，则指向下一个结点</li><li>如果下一个结点为空，则置为null</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n          <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 当前层的第一个节点</span>\n                <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 当前节点的下一个节点,当前结点为这一层的最后一个节点,则为null</span>\n                  node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> levelSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',17),Rn={id:"_104-二叉树的最大深度",tabindex:"-1"},Wn={class:"header-anchor",href:"#_104-二叉树的最大深度"},zn={href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Un=(0,t.Fv)('<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><figure><img src="'+B+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：3\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,null,2]\n输出：2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="思路分析-7" tabindex="-1"><a class="header-anchor" href="#思路分析-7"><span>思路分析</span></a></h4><p>在遍历完每一层时，用一个变量进行累加</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 记录最大深度</span>\n        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            max<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> max<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12),Jn={id:"_111-二叉树的最小深度",tabindex:"-1"},Fn={class:"header-anchor",href:"#_111-二叉树的最小深度"},Kn={href:"https://leetcode.cn/problems/minimum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},On=(0,t.Fv)('<p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>**说明：**叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure><img src="'+S+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [2,null,3,null,4,null,5,null,6]\n输出：5\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路分析-8" tabindex="-1"><a class="header-anchor" href="#思路分析-8"><span>思路分析</span></a></h4><p>相较于最大深度，最小深度是 当某个结点的<code>左右子树都为空</code>时，此时就达到了最近的叶子结点，直接返回深度即可。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 当左右子树都为空时，说明到达叶子节点，返回当前层数</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">return</span> level<span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n            level<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> level<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p>二叉树的层序遍历有俩种思想： 一种是 bfs(广度优先遍历)、一种是 dfs(深度优先遍历)，其中层序遍历使用 bfs 更简单，其模板：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Java 的 pop 写作 poll()</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',16),Vn={id:"_226-翻转二叉树",tabindex:"-1"},Zn={class:"header-anchor",href:"#_226-翻转二叉树"},Mn={href:"https://leetcode.cn/problems/invert-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Xn=(0,t.Fv)('<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><figure><img src="'+N+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+j+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [2,1,3]\n输出：[2,3,1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：[]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="思路分析-9" tabindex="-1"><a class="header-anchor" href="#思路分析-9"><span>思路分析</span></a></h3><p>通过题目描述中也可以得知，所谓的翻转，其实就是将每一层的左右孩子结点进行交换即可。</p><p>先序、后序、层序遍历均可以实现，为什么没有中序呢？中序其实也可以，但是需要考虑的是，在遍历结点的过程中，可能会交换俩次。</p><p><strong>递归：先序遍历</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token comment">// 交换</span>\n        <span class="token function">swap</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历左子树</span>\n        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 遍历右子树</span>\n        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token keyword">return</span>  root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n        <span class="token comment">// 交换左右孩子结点</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n        node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n        node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>bfs - 层序遍历</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 左右交换</span>\n             <span class="token function">swap</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',18),Yn={id:"_101-对称二叉树",tabindex:"-1"},Gn={class:"header-anchor",href:"#_101-对称二叉树"},_n={href:"https://leetcode.cn/problems/symmetric-tree/",target:"_blank",rel:"noopener noreferrer"},$n=(0,t.Fv)('<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><figure><img src="'+Q+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,2,3,4,4,3]\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+T+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,2,null,3,null,3]\n输出：false\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？</p><h4 id="思路分析-10" tabindex="-1"><a class="header-anchor" href="#思路分析-10"><span>思路分析</span></a></h4><p>首先要思考一颗对称的二叉树他有什么特点，根据下图来说：</p><ol><li>俩颗对称的子树它的根的值是相等的</li><li>俩颗子树互为镜像。（这句话怎么理解呢？） <ol><li>左子树的左节点和右子树的右结点是相等的</li><li>左子树的右结点和右子树的左节点是相等的</li><li>即：$left.left = right.right , left.right = right.left$</li></ol></li></ol><p>只要满足以上几种情况，就可以说明该二叉树是对称的，否则则不是。我们也可以利用这些条件做题。</p><figure><img src="'+L+'" alt="image-20231106221428126" tabindex="0" loading="lazy"><figcaption>image-20231106221428126</figcaption></figure><p><strong>第一种方法</strong>：递归</p><ol><li>终止条件就是上面说的那几种情况，只要不满足就返回false <ol><li>根结点值不相等，返回false</li><li>左子树或者右子树有一个为空，返回 false</li><li>左子树和右子树都为空，返回true(说明已经没有结点了，也没有返回false)</li></ol></li><li>每次递归的元素为：左子树的左节点和右子树的右结点，左子树的右结点和右子树的左节点</li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">recursive</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果两个结点都为空，那么就对称的</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token comment">// 如果有一个结点为空，那么就是不对称的</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token comment">// 根结点的值不相等，那么就不是对称的</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token comment">// 递归比较左右子树</span>\n        <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recursive</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二种方法</strong>：迭代</p><p>将递归的比较换成队列，先将左右子树入队，然后继续根据上面的三个条件进行比较。</p><p>将 <code>left.left、right.right 入队，left.right、right.left 入队</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果只有一个结点，那么一定是对称的</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 取出俩个结点，比较它们的值</span>\n            <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>\n            <span class="token comment">// 如果其中一个结点为空，另一个不为空，那么就不是对称的</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n            <span class="token comment">// 如果两个结点的值不相等，那么就不是对称的</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 比较左子树的左孩子结点和右子树的右孩子结点</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 比较左子树的右孩子结点和右子树的左孩子结点</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 如果循环结束，那么说明所有的结点都比较完了，那么就是对称的</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',22),ns={id:"_222-完全二叉树的节点个数",tabindex:"-1"},ss={class:"header-anchor",href:"#_222-完全二叉树的节点个数"},as={href:"https://leetcode.cn/problems/count-complete-tree-nodes/",target:"_blank",rel:"noopener noreferrer"},ts=(0,t.Lk)("p",null,[(0,t.eW)("给你一棵 "),(0,t.Lk)("strong",null,"完全二叉树"),(0,t.eW)(" 的根节点 "),(0,t.Lk)("code",null,"root"),(0,t.eW)(" ，求出该树的节点个数。")],-1),es={href:"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},ps=(0,t.Lk)("code",null,"h",-1),os=(0,t.Lk)("code",null,"1~ 2h",-1),cs=(0,t.Fv)('<p><strong>示例 1：</strong></p><figure><img src="'+q+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5,6]\n输出：6\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1]\n输出：1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><h4 id="思路分析-11" tabindex="-1"><a class="header-anchor" href="#思路分析-11"><span>思路分析</span></a></h4><p>使用 dfs 和 bfs 都可以</p><p>dfs：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token comment">// 左子树结点+右子树结点+根节点</span>\n       <span class="token keyword">return</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bfs：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                sum<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',15),ls={id:"_110-平衡二叉树",tabindex:"-1"},is={class:"header-anchor",href:"#_110-平衡二叉树"},us={href:"https://leetcode.cn/problems/balanced-binary-tree/",target:"_blank",rel:"noopener noreferrer"},rs=(0,t.Fv)('<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><figure><img src="'+H+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+P+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,2,3,3,null,null,4,4]\n输出：false\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = []\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="思路分析-12" tabindex="-1"><a class="header-anchor" href="#思路分析-12"><span>思路分析</span></a></h3><p>平衡二叉树的定义：$一个二叉树 每个节点 的左右两个子树的高度差的绝对值不超过 1 $。</p><p>对于一颗平衡二叉树来说，他所有的子树均为二叉树，因此我们可以使用递归判断所有的子树是否为二叉树</p><p>有俩种递归方式，一种是自上而下，另一种是自下而上</p><p><strong>方法一</strong>：自上而下</p><p>自上而下类似与前序遍历，对每一颗子树都进行判断是否是平衡二叉树</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 求出二叉树的最大深度（先序遍历）</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法二：</strong> 自下而上</p><p>类似于后序遍历，以该结点为根节点的二叉树是平衡二叉树则返回最大 高度，若不是返回-1.</p><p>相较于自上而下来说，这种方法对于每个结点只会处理一次，而自上而下需要处理该结点下的每颗子树。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * Definition for a binary tree node.\n * public class TreeNode <span class="token punctuation">{</span>\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() <span class="token punctuation">{</span><span class="token punctuation">}</span>\n *     TreeNode(int val) <span class="token punctuation">{</span> this.val = val; <span class="token punctuation">}</span>\n *     TreeNode(int val, TreeNode left, TreeNode right) <span class="token punctuation">{</span>\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     <span class="token punctuation">}</span>\n * <span class="token punctuation">}</span>\n */</span>\n<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token keyword">return</span> <span class="token function">height1</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">height1</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">height1</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 如果左右子树的高度差大于1，则返回-1</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 否则返回高度</span>\n            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left <span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',24),ds={id:"☆-257-二叉树的所有路径",tabindex:"-1"},ks={class:"header-anchor",href:"#☆-257-二叉树的所有路径"},vs={href:"https://leetcode.cn/problems/binary-tree-paths/",target:"_blank",rel:"noopener noreferrer"},ms=(0,t.Fv)('<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure><img src="'+D+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,3,null,5]\n输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1]\n输出：[&quot;1&quot;]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="思路分析-13" tabindex="-1"><a class="header-anchor" href="#思路分析-13"><span>思路分析</span></a></h3><p>通过题意我们很清楚的知道使用<strong>先序遍历 + 回溯</strong>方法。当我们将一条路径存到集合中，我们需要回溯到初始结点，继续找下一条路径！</p><p>先序遍历的方法有： 递归、迭代，也可以使用bfs层序遍历实现！</p><p><strong>1、递归</strong></p><p>递归版本的先序遍历代码如下</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以依据上面为模板进行改良，此时不再是输出结点，而是将叶子结点的路径保存起来，代码如下：</p><p>可能会有疑问？这也没进行回溯啊？其实是有的，回溯隐藏在在每次递归的时候。即：$path + node.val + &quot;-&gt;&quot;$</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 该结点为叶子结点</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path <span class="token operator">+</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 在每次遍历的过程中，都要将当前结点的值添加到路径中，这也是隐藏的回溯</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token punctuation">,</span> path <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、非递归</strong></p><p>先看一下非递归的先序遍历代码，如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            \n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样我们也可以对以上代码进行改良，但此时我们需要注意使用迭代的方式，注意进行回溯，递归与回溯一一对应，每一次递归(入栈) 都要进行一次回溯！</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token comment">// 在这里，路径和结点是成双成对的，，保存路径的栈和保存结点的栈使用一个栈来实现</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 注意push、pop的时机，都是先push路径，在push结点。先弹出来的是结点，后是路径</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 如果是叶子结点，保存路径</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 每进行一次入栈，都要进行一次回溯</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3、bfs层序遍历</strong></p><p>同样，先看层序遍历代码模板：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sequence</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改进思路和<strong>第二种方法</strong> 一样，也是要注意回溯的时机</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequence</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',28),gs={id:"_404-左叶子之和",tabindex:"-1"},bs={class:"header-anchor",href:"#_404-左叶子之和"},fs={href:"https://leetcode.cn/problems/sum-of-left-leaves/",target:"_blank",rel:"noopener noreferrer"},As=(0,t.Fv)('<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><figure><img src="'+C+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [3,9,20,null,null,15,7] \n输出: 24 \n解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [1]\n输出: 0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="思路分析-14" tabindex="-1"><a class="header-anchor" href="#思路分析-14"><span>思路分析</span></a></h3><blockquote><p>当某个结点没有左右孩子结点，该结点就是叶子结点。</p></blockquote><p>我们可以使用 dfs 和 bfs 俩种方法，即递归或者迭代。</p><p>在遍历过程中，我们只需要判断它的左子节点是否有左右孩子结点，如果没有就是叶子结点，累加左子节点的值即可。</p><p><strong>dfs：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 先序遍历-递归</span>\n    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token comment">// 左叶子节点</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>bfs：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 说明是叶子节点</span>\n                    sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>\n                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',16),ys={id:"_513-找树左下角的值",tabindex:"-1"},hs={class:"header-anchor",href:"#_513-找树左下角的值"},ws={href:"https://leetcode.cn/problems/find-bottom-left-tree-value/",target:"_blank",rel:"noopener noreferrer"},xs=(0,t.Fv)('<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><figure><img src="data:image/jpeg;base64,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" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [2,1,3]\n输出: 1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><figure><img src="'+R+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="思路分析-15" tabindex="-1"><a class="header-anchor" href="#思路分析-15"><span>思路分析</span></a></h3><p>题目要求找到<strong>最后一层最左边的结点</strong>，我的第一想法是：</p><p>1、求出二叉树的高度</p><p>2、进行层序遍历，找出最后一层的第一个结点，该结点为最左侧的结点</p><p><strong>代码如下</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            height<span class="token operator">--</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 判断该结点是否为最后一层最左边的</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>height <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 获取二叉树的高度</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>随后又仔细想了一下，我直接从右向左层序遍历，最后一个结点不就是最左侧的结点吗？ 好一个脱裤子放屁！！</p><p>改良后的代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>   <span class="token comment">// 层序遍历————从右往左，最后一个访问的就是最左侧的结点</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findBottomLeftValue1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            res <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',19),Is={id:"_112-路径总和",tabindex:"-1"},Es={class:"header-anchor",href:"#_112-路径总和"},Bs={href:"https://leetcode.cn/problems/path-sum/",target:"_blank",rel:"noopener noreferrer"},Ss=(0,t.Fv)('<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure><img src="'+W+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n输出：true\n解释：等于目标和的根节点到叶节点路径如上图所示。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="data:image/jpeg;base64,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" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,3], targetSum = 5\n输出：false\n解释：树中存在两条根节点到叶子节点的路径：\n(1 --&gt; 2): 和为 3\n(1 --&gt; 3): 和为 4\n不存在 sum = 5 的根节点到叶子节点的路径。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [], targetSum = 0\n输出：false\n解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="思路分析-16" tabindex="-1"><a class="header-anchor" href="#思路分析-16"><span>思路分析</span></a></h3>',13),Ns={href:"https://leetcode.cn/problems/binary-tree-paths/",target:"_blank",rel:"noopener noreferrer"},js=(0,t.Fv)('<p><strong>1、递归</strong></p><p>回溯隐藏在递归中，<code>targetSum - root.val</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 递归+回溯</span>\n        <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、非递归</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token comment">// 即保存结点也保存结点和</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">Integer</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 如果sum和等于targetSum并且该结点为叶子结点 直接返回true</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> targetSum <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 每次入栈都要伴随着一次回溯</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',5),Qs={id:"_106-从中序与后序遍历序列构造二叉树",tabindex:"-1"},Ts={class:"header-anchor",href:"#_106-从中序与后序遍历序列构造二叉树"},Ls={href:"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},qs=(0,t.Fv)('<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：inorder = [-1], postorder = [-1]\n输出：[-1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h3 id="思路分析-17" tabindex="-1"><a class="header-anchor" href="#思路分析-17"><span>思路分析</span></a></h3><p>中序遍历+后续遍历确定一颗二叉树步骤：</p><p>1、找出根节点： 由于后续遍历根节点总是在最后遍历，因此<code>postorder</code> 数组最后一个元素为根结点</p><p>2、确定根节点在<code>inorder</code> 中的位置： 中序遍历中根结点在中间，左边为左子树，右边为右子树</p><p>3、确定根节点的左子树的起始范围</p><p>4、确定根节点的右子树的起始范围</p><p>不断重复上面的四步，直到构成一个二叉树！</p><p>其实构建二叉树的步骤大家都明白，只是在递归的过程中，左右子树的起始范围不太好确定, 看一下下面这张图：</p><figure><img src="http://images-1313160403.cos.ap-beijing.myqcloud.com/MarkDown/image-20231113230335449.png" alt="image-20231113230335449" tabindex="0" loading="lazy"><figcaption>image-20231113230335449</figcaption></figure><p><strong>疑问点</strong>：</p><p>$rootIndex - inStart $是什么？</p><p>通过图片其实可以看出，$rootIndex - inStart $ 得到的是<strong>根结点左子树的个数</strong> ，无论是中序、后续，它的左右子树结点个数肯定是不会变的。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 保存中序遍历的值与下标对应关系</span>\n    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 递归</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> postStart<span class="token punctuation">,</span> <span class="token keyword">int</span> postEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>inStart <span class="token operator">&gt;</span> inEnd <span class="token operator">||</span> postStart <span class="token operator">&gt;</span> postEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 找到根结点</span>\n        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postEnd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 从map中找到根结点在中序遍历中的下表</span>\n        <span class="token class-name">Integer</span> rootIndex <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 计算出中序遍历中根结点的左子树结点的个数</span>\n        <span class="token keyword">int</span> nums_in_left <span class="token operator">=</span> rootIndex <span class="token operator">-</span> inStart<span class="token punctuation">;</span>\n        <span class="token comment">// 递归左子树</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> rootIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> postStart<span class="token punctuation">,</span> postStart <span class="token operator">+</span> nums_in_left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> postStart <span class="token operator">+</span> nums_in_left<span class="token punctuation">,</span> postEnd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',21),Hs={id:"_105-从前序与中序遍历序列构造二叉树",tabindex:"-1"},Ps={class:"header-anchor",href:"#_105-从前序与中序遍历序列构造二叉树"},Ds={href:"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},Cs=(0,t.Fv)('<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><figure><img src="'+z+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: preorder = [-1], inorder = [-1]\n输出: [-1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h3 id="思路分析-18" tabindex="-1"><a class="header-anchor" href="#思路分析-18"><span>思路分析</span></a></h3>',9),Rs={href:"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},Ws=(0,t.Fv)('<p>1、从前序遍历中找到根结点： 与后序遍历不同的是，根节点为前序遍历中的第一个结点</p><p>2、从中序遍历中找到根结点的位置</p><p>3、确定根结点左子树的起始范围</p><p>4、确定根结点右子树的起始范围</p><p>不断循环上面的步骤，直到构建出二叉树！</p><p>与后序遍历+中序遍历不同的是，每次循环左子树、右子树的起始范围不同，看下面这张图：</p><figure><img src="'+U+'" alt="image-20231114221040622" tabindex="0" loading="lazy"><figcaption>image-20231114221040622</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 使用map保存inOrder节点值与下标的对应关系</span>\n    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preStart<span class="token punctuation">,</span> <span class="token keyword">int</span> preEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 终止条件</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>preStart <span class="token operator">&gt;</span> preEnd <span class="token operator">||</span> inStart <span class="token operator">&gt;</span> inEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token comment">// 获取根节点</span>\n        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 根据结点值从map中获取根节点的下标</span>\n        <span class="token class-name">Integer</span> rootIndex <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 计算根节点左子树的结点数量</span>\n        <span class="token class-name">Integer</span> nums_left_nodes <span class="token operator">=</span> rootIndex <span class="token operator">-</span> inStart<span class="token punctuation">;</span>\n        <span class="token comment">// 递归处理左右子树</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> nums_left_nodes<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> rootIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> nums_left_nodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',8),zs={id:"_654-最大二叉树",tabindex:"-1"},Us={class:"header-anchor",href:"#_654-最大二叉树"},Js={href:"https://leetcode.cn/problems/maximum-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Fs=(0,t.Fv)('<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="'+J+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [3,2,1,6,0,5]\n输出：[6,3,5,null,2,0,null,null,1]\n解释：递归调用如下所示：\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n        - 空数组，无子节点。\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n            - 空数组，无子节点。\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\n        - 空数组，无子节点。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="data:image/jpeg;base64,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" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [3,2,1]\n输出：[3,null,2,null,1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="思路分析-19" tabindex="-1"><a class="header-anchor" href="#思路分析-19"><span>思路分析</span></a></h3><p>该题和 105、106一样，只不过不再是从前序或者后序找根结点，而是找最大值。</p><p>还是要强调一点：注意搜索最大值的起始范围。我才用的左闭右开区间。</p><p>假设最大值下标为rootIndex，则左子树搜索范围：[begin,rootIndex), 右子树搜索范围: [rootIndex,end)</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 终止条件，如果是左闭右闭区间，则是 begin&gt;end</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token comment">// 找到数组最大值的下标</span>\n        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token function">findMax</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 以最大值为根结点</span>\n        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 递归找左右字数：[begin,rootIdnex)  [rootIndex,end)</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 假设第一个元素为最大值</span>\n        <span class="token keyword">int</span> max_index <span class="token operator">=</span> begin<span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>max_index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                max_index <span class="token operator">=</span> i<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> max_index<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',16),Ks={id:"_617-合并二叉树",tabindex:"-1"},Os={class:"header-anchor",href:"#_617-合并二叉树"},Vs={href:"https://leetcode.cn/problems/merge-two-binary-trees/",target:"_blank",rel:"noopener noreferrer"},Zs=(0,t.Fv)('<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><figure><img src="'+F+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root1 = [1], root2 = [1,2]\n输出：[2,2]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root2<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root1<span class="token punctuation">;</span>\n        <span class="token comment">// 采用先序遍历，先处理结点</span>\n        root1<span class="token punctuation">.</span>val <span class="token operator">+=</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 根</span>\n       root1<span class="token punctuation">.</span>left <span class="token operator">=</span>  <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左</span>\n        root1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span>\n\n        <span class="token keyword">return</span> root1<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12),Ms={id:"_700-二叉搜索树中的搜索",tabindex:"-1"},Xs={class:"header-anchor",href:"#_700-二叉搜索树中的搜索"},Ys={href:"https://leetcode.cn/problems/search-in-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Gs=(0,t.Fv)('<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><figure><img src="'+K+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,7,1,3], val = 2\n输出：[2,1,3]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><figure><img src="'+O+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,7,1,3], val = 5\n输出：[]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h3 id="思路分析-20" tabindex="-1"><a class="header-anchor" href="#思路分析-20"><span>思路分析</span></a></h3><p>最直观的方法其实就是按照普通二叉树去挨个结点遍历，找到等于val的结点返回即可。什么先序、中序、后序、层序自己选一个喜欢的就行。如下：</p><p><strong>层序遍历</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>先序遍历：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 终止条件</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        \n        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">searchBST1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> <span class="token function">searchBST1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样写就违背这道题的初衷了，也没有用到 二叉搜索树的性质，什么性质呢？</p><ul><li>对于一个结点，如果它的左右子树不为空，那么就有： <ul><li>左子树上的所有结点的值都<strong>小于</strong>该结点的值</li><li>右子树上的所有结点的值都<strong>大于</strong>该结点的值</li></ul></li></ul><p>那么它相较于普通二叉树的搜索来说多了一层判断：</p><p><strong>递归</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 二叉树搜索树--递归</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 终止条件</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n\n        <span class="token class-name">TreeNode</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token comment">// 去右子树查找</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token function">searchBST2</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 去左子树查找</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token function">searchBST2</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>迭代：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 二叉搜索树 -迭代</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">searchBST3</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        <span class="token comment">// 大于val，去左子树查找</span>\n        <span class="token comment">// 小于val，去右子树查找</span>\n        <span class="token comment">// 等于val，直接返回</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',23),_s={id:"_98-验证二叉搜索树",tabindex:"-1"},$s={class:"header-anchor",href:"#_98-验证二叉搜索树"},na={href:"https://leetcode.cn/problems/validate-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},sa=(0,t.Fv)('<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><figure><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAC2AS4DASIAAhEBAxEB/8QAHQABAQACAwEBAQAAAAAAAAAAAAgEBgEFBwkDAv/EAD8QAAEEAgIBAgMDCgMIAgMAAAEAAgMEBQYHEQgSIRMiMQlBYRQmMjNFUVJicYEVGCMWJThCQ2NydTSzdoKy/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/APqmiIgIiICIiAiIgIiICIiAiIgIi8t8kuesD468XXd8ylSTJZKeWPGYDDwdmfLZSbsV6sYAJJcQSSASGtcQCQAQc9eSXF3jrga+U3zJzzZLJP8AgYfAYyL8pymWnJAEVauD249kD1HpoJAJBIB8XqVvPfyI/wB4WszhvHXT7HvBTiqMzGzTxdnozOf1DWLh6fZvUjCSCD0tn8ZfGXL6zl7HkH5B3YNo5p2iISW7cjQ+vr1dw7bjqDT2ImMDi1z2+7j6vcgkupNBKbfs9dPyw/KOQPITnTb7r/eSW/usscYP8kcTWhjf3Ds9Lh/gDQwA/KuK/J3nLTrrPeMM2t12mT/3K8zSJB+HqCq1EEg3d284PGYG/wAj4PG8/aFVHdnMa1RbjtlpwtB9UslEH4NgAAfLEfV9S5wCobh7mvjTnnTa+9cXbRWzOMlPolDPknqTdduhniPzRSD72uH7iOwQTvCkfyK4N2niDbLfl74vUG1tpx8fx911Ou0sp7fjWH1S9xt9m3GN9T2SAepx7+rj08K4RajxNylp/NXHWC5Q0PIC5hc/VFmu4+z43dlr4pB/yyMeHMcPuc0rbkBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAREQFItap/mI898jayB/KNP8dcZBFTgPZin2bIM9bpiO+nGGBvpA6JZI0EEdqulKf2erRltP5Y5AsfPd2/lfY78sh+ojZKyKOP/AMWhh6H3dlBViIiDX9y5D0DjmgzK8hbzr+sUpX+hlnM5OClE537g+VzQT+Ha7LCZ7B7Ni4M3rmZo5XHWm+uC5RsMnglb+9r2EtcP6FR5yH4F47mryV2rmryhzuO2Lj2DFtra7hIsrcp/4bGwNLnzuZ8MNb7SPJZIB275geloX2W+NrYzkjninxXkL1rhmrnIq+sunldJC6drpPW6Jzuy4fD+H83fuPQT2T2g+hyIiCReAan+Xzy75I8b4D8HUd6pDknUK/v8OpM+T4ORqx+/QHxQJGsHQaxv09+1XSlPyfaNf8tvFveKnyTy5rPa5YI/6sFugPS137w1zS4fiVViAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIClLwBeMBQ5p4rtfJd07lbOsEZ+pp2XMmry/0eC8j+iq1SDu10eM3nBjeR77hV0Ln6lW1rMWT02GnstNpFGSR3fQE0PqiHt+l63E9BBXyIiD5Oefvm5rG2c4zeN2yZfasXxRrlj4O3v1eKGTJZyy0BzqjTLLGxkDT01x9R7IcfSegFWHgp5VeNnMePucQ+OnHWy6ljNMx8Vk18nRqwROY9/o7DorErpJC4duc/3P1JJVZogIi/OxYgqQSWrU0cMMLDJJJI4NaxoHZcSfYAD3JKCVvI542vzN8ZtAp/O/FWdg23IAf9CCCmI4HH8HSlzf6hVapF8UJZ+fueuSvMSxE865MxuhaA+Rv63E1JS61bZ7/oTWQS0+xHpeCq6QEREBERAREQEREBERAREQEREBERAREQEREBERAREQEREBERAXlHlNrPD+28DbdiedclWxmn/kLpreRlcGvoSMPcU8J6J+M2T0+gAEud03p3q6O8b3veo8ZajlN73vO1cNgsNA6zcuWXdMjYPoAPq5xJAa0AlxIABJAUpaNo24ecO4Yzm3m3B28Lw9hbAuaLotxvpfmHj9DK5Nn0c0j3ihPY6P3tJModP4beaWXGE1nifyhgymuZnLVQ/Strz1Q0q+248OLIXvLiWxWy0NJa5x9Ycx3ZLx67kWococScccz6ba0Hk3UqOewdoDutYYQYnAdNkie3p8Tx37PYQ4e/up0qcA+Xfj5/oeN/NmN3rUYf/j6hyS2SWapH2f8ATrZGH/UIAIDGSAMaGj6+6CukUpt8n/LbXx+Sbx4E7HLOz2NjXNsoZCCX+Zreg5gP7ndlcP8AI7zN2sfkegeDNzFPf7f4htu4U6sEH4ugjBlePwae0FU2LEFSCS1amjhhhYZJJJHBrWNA7LiT7AAe5JXzu8vfL2py/Um4x4xtZ6HheHLVcPydydh6D7NWtVmf0+pVePZzHD5ZZm+oAPaAHBwD/W5fFDnrn6dljzE5vim1wuEj9A0JsuOxMv1+S1acRZss9x8h66LQQ5UxhuOtD17SY+NsJp+Ip6rHUdQGHiqMFQ13Ah8bo+vS4OBPq779XZJ7JKBx1htJ17Q9fwnG0NCPVaeOgiw4oPD65qBg+G5jgSHgt6Pq7Pq77JJPa2JRT+c32d+zftHO+NWdu/z2LWg2pn/3dJj3vd+JYT/F+usvFZXGZ3GVM1hchXv4+/CyzVtVpRJFPE8BzXsc3sOaQQQR7EFBloiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIC6De971HjLUcpve952rhsFhoHWblyy7pkbB9AB9XOJIDWgEuJAAJICb3veo8ZajlN73vO1cNgsNA6zcuWXdMjYPoAPq5xJAa0AlxIABJAUpaNo24ecO4Yzm3m3B28Lw9hbAuaLotxvpfmHj9DK5Nn0c0j3ihPY6P3tJMoNG0bcPOHcMZzbzbg7eF4ewtgXNF0W430vzDx+hlcmz6OaR7xQnsdH72kmWy2taxoYxoa1o6AA6ACNa1jQxjQ1rR0AB0AFygIiICIiAiIgxMrisZncZbwuax9e/j78L61qrZiEkU8TwWuY9ruw5pBIIPsQVGn5zfZ37N+0c741Z27/PYtaDamf8A3dJj3vd+JYT/ABfrrWWJlcVjM7jLeFzWPr38ffhfWtVbMQkinieC1zHtd2HNIJBB9iCgYrK4zO4ypmsLkK9/H34WWatqtKJIp4ngOa9jm9hzSCCCPYgrLUU/nN9nfs37RzvjVnbv89i1oNqZ/wDd0mPe934lhP8AF+usvFZXGZ3GVM1hchXv4+/CyzVtVpRJFPE8BzXsc3sOaQQQR7EFBloiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAug3ve9R4y1HKb3vedq4bBYaB1m5csu6ZGwfQAfVziSA1oBLiQACSAm973qPGWo5Te97ztXDYLDQOs3Lll3TI2D6AD6ucSQGtAJcSAASQFKWjaNuHnDuGM5t5twdvC8PYWwLmi6Lcb6X5h4/QyuTZ9HNI94oT2Oj97STKDRtG3Dzh3DGc2824O3heHsLYFzRdFuN9L8w8foZXJs+jmke8UJ7HR+9pJlstrWsaGMaGtaOgAOgAjWtY0MY0Na0dAAdABcoCIiAiIgIiICIiAiIgxMrisZncZbwuax9e/j78L61qrZiEkU8TwWuY9ruw5pBIIPsQVGn5zfZ37N+0c741Z27/PYtaDamf/AHdJj3vd+JYT/F+utZYmVxWMzuMt4XNY+vfx9+F9a1VsxCSKeJ4LXMe13Yc0gkEH2IKBisrjM7jKmawuQr38ffhZZq2q0okinieA5r2Ob2HNIIII9iCstRT+c32d+zftHO+NWdu/z2LWg2pn/wB3SY973fiWE/xfrrLxWVxmdxlTNYXIV7+Pvwss1bVaUSRTxPAc17HN7DmkEEEexBQZaIiAiIgIiICIiAiIgIiICIiAiIgIiIC6De971HjLUcpve952rhsFhoHWblyy7pkbB9AB9XOJIDWgEuJAAJICb3veo8ZajlN73vO1cNgsNA6zcuWXdMjYPoAPq5xJAa0AlxIABJAUpaNo24ecO4Yzm3m3B28Lw9hbAuaLotxvpfmHj9DK5Nn0c0j3ihPY6P3tJMoNG0bcPOHcMZzbzbg7eF4ewtgXNF0W430vzDx+hlcmz6OaR7xQnsdH72kmWy2taxoYxoa1o6AA6ACNa1jQxjQ1rR0AB0AFygIiICIiAiIgIiICIiAiIgIiIMTK4rGZ3GW8LmsfXv4+/C+taq2YhJFPE8FrmPa7sOaQSCD7EFRp+c32d+zftHO+NWdu/wA9i1oNqZ/93SY973fiWE/xfrrWWJlcVjM7jLeFzWPr38ffhfWtVbMQkinieC1zHtd2HNIJBB9iCgYrK4zO4ypmsLkK9/H34WWatqtKJIp4ngOa9jm9hzSCCCPYgrLUU/nN9nfs37RzvjVnbv8APYtaDamf/d0mPe934lhP8X66y8VlcZncZUzWFyFe/j78LLNW1WlEkU8TwHNexzew5pBBBHsQUGWiIgIiICIiAiIgIi8t568kuLvHXA18pvmTnmyWSf8AAw+AxkX5TlMtOSAIq1cHtx7IHqPTQSASCQCHqSKRalbz38iP94WszhvHXT7HvBTiqMzGzTxdnozOf1DWLh6fZvUjCSCD0s5v2eun5YflHIHkJzpt91/vJLf3WWOMH+SOJrQxv7h2ekFWIpSf4A0MAPyrivyd5y066z3jDNrddpk/9yvM0iQfh6guuu7t5weMwN/kfB43n7Qqo7s5jWqLcdstOFoPqlkog/BsAAD5Yj6vqXOAQV8ug3ve9R4y1HKb3vedq4bBYaB1m5csu6ZGwfQAfVziSA1oBLiQACSAtH1nym4G23iC5zrieRcZ/sfjIDLkbczzHJQeAO4J4j87JuyGiPr1OJb6fV6h34Vo2jbh5w7hjObebcHbwvD2FsC5oui3G+l+YeP0Mrk2fRzSPeKE9jo/e0kyg0bRtw84dwxnNvNuDt4Xh7C2Bc0XRbjfS/MPH6GVybPo5pHvFCex0fvaSZbLa1rGhjGhrWjoADoAI1rWNDGNDWtHQAHQAXKAiIgIiICIiAiIgIiICIiAiIgIiICIiDEyuKxmdxlvC5rH17+PvwvrWqtmISRTxPBa5j2u7DmkEgg+xBUafnN9nfs37RzvjVnbv89i1oNqZ/8Ad0mPe934lhP8X661liZXFYzO4y3hc1j69/H34X1rVWzEJIp4ngtcx7XdhzSCQQfYgoGKyuMzuMqZrC5Cvfx9+FlmrarSiSKeJ4DmvY5vYc0gggj2IKy1FP5zfZ37N+0c741Z27/PYtaDamf/AHdJj3vd+JYT/F+u955l8p+G+EdOxu3bFsYyr9hYx2u4rCAXb+dc8D4YpxMP+oHepvz9hg9Q7d7jsPXUUi1K3nv5Ef7wtZnDeOun2PeCnFUZmNmni7PRmc/qGsXD0+zepGEkEHpZzfs9dPyw/KOQPITnTb7r/eSW/usscYP8kcTWhjf3Ds9IKsRSk/wBoYAflXFfk7zlp11nvGGbW67TJ/7leZpEg/D1Bddd3bzg8Zgb/I+DxvP2hVR3ZzGtUW47ZacLQfVLJRB+DYAAHyxH1fUucAgr5Fo/D3NfGnPOm1964u2itmcZKfRKGfJPUm67dDPEfmikH3tcP3EdggneEHlvklz1gfHXi67vmUqSZLJTyx4zAYeDsz5bKTdivVjABJLiCSQCQ1riASAD594y+MuX1nL2PIPyDuwbRzTtEQkt25Gh9fXq7h23HUGnsRMYHFrnt93H1e5BJdrFap/mI898jayB/KNP8dcZBFTgPZin2bIM9bpiO+nGGBvpA6JZI0EEdqukBEWNksnjcLj7OXzGQrUaNKJ09m1ZlbFFDG0due97iA1oAJJJ6AQZKLrdd2TXdvwtXZNTz+OzWJvM+JVv461HZrTs769TJIyWuHYI7BP0XZIIb80vDbCDLxeUPE+jUcrmdcv189telPa5uP22vWLnOe6FhDTbY10jmkgh/ZBa4np9a8ScoabzPxxgeTdBvi1g89UbYrHoB0RBLXwvaP0Xxva5jh9zmkLb1IvANT/L55d8keN8B+DqO9UhyTqFf3+HUmfJ8HI1Y/foD4oEjWDoNY36e/aCukREBERAREQEREBERAREQEREBERAREQEREBERB5F5T8y6dwlw3l9i27BxbC/KgYTFa66ISuzt+yCyKkI+j6g/wB/V7HpjXno/Q+S+EPhDhOAcJV5C5CoVMjyVka56HqdNV1mrI50n+HUPiOcY2sMjg54JLiXAEtJLv4rVP8AMR575G1kD+Uaf464yCKnAezFPs2QZ63TEd9OMMDfSB0SyRoII7VdICItd3LkXj7jmnDkeQt717WKth/w4p8zlIKUcj/4Wulc0E+49h+9BsSLFxeVxmbx8GWwuRq36Npgkgs1ZmyxSsP0c17SQ4fiCspBI/kVwbtPEG2W/L3xeoNrbTj4/j7rqddpZT2/GsPql7jb7NuMb6nskA9Tj39XHp9FcTcpafzVx1guUNDyAuYXP1RZruPs+N3Za+KQf8sjHhzHD7nNK25Rvw1kMT4teVPJ3BGVyEWL0TcqTOSdVEzi2CjNLMK+QqsPuADMWvawdBrR9PftB3n2erRltP5Y5AsfPd2/lfY78sh+ojZKyKOP/wAWhh6H3dlVYpS8AXjAUOaeK7XyXdO5WzrBGfqadlzJq8v9HgvI/oqtQFB/2jegeSe+aNyFfi5Ax2scO6trf+JnH0o/Vkc/cYz1OimcD8lcO6+8d9e7HezheC8L85v+EDlz/wDFrn/8oOo+zx/4MuLf/Tn/AO6RUWp0+zx/4MuLf/Tn/wC6RUWgKU/J9o1/y28W94qfJPLms9rlgj/qwW6A9LXfvDXNLh+JVWKUvI542vzN8ZtAp/O/FWdg23IAf9CCCmI4HH8HSlzf6hBVqIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIglP7PVoy2n8scgWPnu7fyvsd+WQ/URslZFHH/wCLQw9D7uyqsUpeALxgKHNPFdr5LuncrZ1gjP1NOy5k1eX+jwXkf0VWoChbzT8b+BsZsOy+XXlLktl3jVMVja2Mo6jRc6qKUj5GRsdFKyzEXdvcSWkt7Lifm6AV0qE+b/MbmXxJ8kM27nLUc3sfCmZpMOt28Bia5fUsn09xySPLA9/fraWvkafSWuDXIOPsjMPkaXCe15etn6smrZjZZ7WvYOPKsvT4esR+rn9Dj8KR3bSWHp3t6iAXK7VB/wBm7pu7ZTkHmTyLv6Je0bUOSMnHNr+CuRGB7mNfI91gRewAPrA9QHTiXekkDs3ggL5kfbXVbeGw/FW9YW5LSvxWcriZZoXel0kMja8oaT94DoSR/wCRX03XzN+2QqZ7f7fF3FWm49+RysUeV2G3Xj93R12mtBG8j9xc+Qf/AKoPdN2ujxm84MbyPfcKuhc/Uq2tZiyemw09lptIoySO76Amh9UQ9v0vW4noKvlo3NfD2m888aZvi7eqZlxmZg9AlYB8apO33isROP6MkbwHA/h0ewSD4Bwb5FbZxBtNXxe8vchFj9prNEGp7rP3HjdvptIbGfiu+WO4B6WvY49ud17lzh6wrhERARF+dixBUgktWpo4YYWGSSSRwa1jQOy4k+wAHuSUCxYgqQSWrU0cMMLDJJJI4NaxoHZcSfYAD3JKknxQln5+565K8xLETzrkzG6FoD5G/rcTUlLrVtnv+hNZBLT7Eel4K6Tk/k/ZfN7Zbvjr465SavxnXlFfkPkOuP8AQng/58XjX/SaSQfK+RvbQ0/e0/PXun6jrmg6titK1DEwYzC4SpHSo1IW9MihY3po/E+3ZJ9ySSeySg7hERAREQEREBERAREQEREBERAREQEREBERAREQSDu10eM3nBjeR77hV0Ln6lW1rMWT02GnstNpFGSR3fQE0PqiHt+l63E9BV8tG5r4e03nnjTN8Xb1TMuMzMHoErAPjVJ2+8ViJx/RkjeA4H8Oj2CQfAODfIrbOINpq+L3l7kIsftNZog1PdZ+48bt9NpDYz8V3yx3APS17HHtzuvcucPWFcIiICIvzsWIKkElq1NHDDCwySSSODWsaB2XEn2AA9ySgWLEFSCS1amjhhhYZJJJHBrWNA7LiT7AAe5JUi+K7B5Ec6cmeXuSpifWLLG6FoPx4w5s+JpzF9q20HsFk1oepp6BHpeD9F1HJ/J+y+b2y3fHXx1yk1fjOvKK/IfIdcf6E8H/AD4vGv8ApNJIPlfI3toafvafnr3T9R1zQdWxWlahiYMZhcJUjpUakLemRQsb00fifbsk+5JJPZJQdwtR5S4m465q0+3ofKGp0c/hbnu6vZafVG8fSSJ7SHxSDs9PYQ4dn390RBMuQ4a8qfFrE28rwRzrjdy0TFxmYaryTFNPNRgBPbK2Qrj4xABAYx4DWho+vuvEKv212Hw1uxhd64AuRX6UhhmlxOfbPDI4fUtEsDHNH4En+qIg/Wp9shb3/PVNN4q4GhiyuRf8Ovb2HYCyvG77i+OCBznD+jgvdGeK/OnkQK+S8vecYrOsThk/+wOhMmxuJnaR2G2rTyLNhnRHyHrotBDkRBU2o6fq2g65R1DStfo4TC4yIQ1KNKFsUMTB9waPvJ9yfqSSSST2u4REBERAREQEREBERAREQEREBERAREQEREBERAREQFqPKXE3HXNWn29D5Q1Ojn8Lc93V7LT6o3j6SRPaQ+KQdnp7CHDs+/uiIJlyHDXlT4tYm3leCOdcbuWiYuMzDVeSYpp5qMAJ7ZWyFcfGIAIDGPAa0NH1914hV+2uw+Gt2MLvXAFyK/SkMM0uJz7Z4ZHD6lolgY5o/Ak/1REH61PtkLe/56ppvFXA0MWVyL/h17ew7AWV43fcXxwQOc4f0cF7ozxX508iBXyXl7zjFZ1icMn/ANgdCZNjcTO0jsNtWnkWbDOiPkPXRaCHIiCptR0/VtB1yjqGla/RwmFxkQhqUaULYoYmD7g0feT7k/UkkkkntdwiIP/Z" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [2,1,3]\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+V+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [5,1,4,null,null,3,6]\n输出：false\n解释：根节点的值是 5 ，但是右子节点的值是 4 。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="思路分析-21" tabindex="-1"><a class="header-anchor" href="#思路分析-21"><span>思路分析</span></a></h3><p><strong>第一种方法</strong>：</p><p>将二叉树中序遍历，遍历的元素放放到集合中，判断集合是否有序 （如果是搜索树那么中序遍历一定是从小到大排列）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果是搜索树，res一定是从小到大排</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 中序遍历</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 左</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 根</span>\n        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 右</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二种方法</strong>：</p><p>二叉搜索树的中序遍历一定是升序的，因此我们可以判断当前结点是否比上一个节点大，如果小于或者等于，说明不满足二叉搜索树。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 中序遍历</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 左</span>\n        <span class="token keyword">boolean</span> left <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 根, 中序遍历二叉搜索树是升序的，判断当前结点是否比上一个节点大，如果小于或者等于，就不是一颗二叉搜索树</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> minValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        minValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n\n        <span class="token comment">// 右</span>\n        <span class="token keyword">boolean</span> right <span class="token operator">=</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',18),aa={id:"_530-二叉搜索树的最小绝对差",tabindex:"-1"},ta={class:"header-anchor",href:"#_530-二叉搜索树的最小绝对差"},ea={href:"https://leetcode.cn/problems/minimum-absolute-difference-in-bst/",target:"_blank",rel:"noopener noreferrer"},pa=(0,t.Fv)('<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><figure><img src="'+Z+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,6,1,3]\n输出：1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+M+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,0,48,null,null,12,49]\n输出：1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="思路分析-22" tabindex="-1"><a class="header-anchor" href="#思路分析-22"><span>思路分析</span></a></h3><p>依然利用二叉搜索树的行： 左子树 &lt; 根节点 &lt; 右子树， 那么中序遍历： 左 -- 根 -- 右，遍历出来的一定是一个升序数组。</p><p>可以先利用中序遍历保存到一个集合中，然后遍历集合求相邻俩个结点的差，找出最小的即可。</p><p>也可以在遍历过程中，<strong>维护一个变量，保存上一个结点的值</strong>，不断更新这个变量，并且求出当前结点与这个变量的差。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 用来保存结果值</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2000000</span><span class="token punctuation">;</span>\n    <span class="token comment">// 保存遍历的上一个结点的值</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> pre <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token doc-comment comment">/**\n     * 二叉搜索树的最小绝对差，只可能出现在相邻的结点中\n     * 1、左孩子结点  和 父节点\n     * 2、父节点 和 右孩子结点\n     * 因此我们需要保存上一个结点的值\n     * */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>技巧</strong>：</p><p>在递归遍历的过程中，一定要学会记录前后俩个指针。</p>',17),oa={id:"_501-二叉搜索树中的众数",tabindex:"-1"},ca={class:"header-anchor",href:"#_501-二叉搜索树中的众数"},la={href:"https://leetcode.cn/problems/find-mode-in-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},ia=(0,t.Lk)("code",null,"root",-1),ua={href:"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796",target:"_blank",rel:"noopener noreferrer"},ra=(0,t.Fv)('<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><figure><img src="data:image/jpeg;base64,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" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,null,2,2]\n输出：[2]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [0]\n输出：[0]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p>**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h3 id="思路分析-23" tabindex="-1"><a class="header-anchor" href="#思路分析-23"><span>思路分析</span></a></h3><p>如果是普通二叉树，我们这道题该如何做呢？</p><blockquote><p>遍历二叉树，然后使用map统计二叉树出现的次数，然后将map按照出现的次数升序，最后取出频率最高的结点即可。</p></blockquote><p>这道题也可以这样做，但是这就失去了这道题的意义，如何利用二叉搜索树的性质解决这道题呢？</p><p><strong>二叉搜索树的中序遍历一定是升序的(这句话背下来)</strong> ，因此它相同的结点一定是相邻的。</p><p>那么好了，我们又要用到上面的<strong>技巧</strong>了，在遍历的过程需要记录上一个结点的值，我们需要判断 <strong>当前结点</strong> 是否和<strong>上一个结点相同</strong>，如果相等我们就记录次数 <code>count++</code>。如果不相等，就将次数<code>count</code> 恢复成 1 。</p><p>并且我们还需要一个变量<code>maxCount</code> 记录出现的最大频率，如果 <code>count == maxCount </code> 我们就记录这个结点，代码如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是问题来了，我们怎么知道当前结点出现的频率是不是最高的呢？ 因此我们还需要再多一层比较，如果<code>count &gt; maxCount</code> 就说明当前结点比上一个结点出现的频率要高，因此清空res集合，将当前结点重新加入进去。</p><p>完整代码如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 上一个结点的值</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> pre <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span> <span class="token punctuation">;</span>\n\t<span class="token comment">// 记录结点出现的频率</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> count<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\t<span class="token comment">// 记录遍历时出现的最大频率</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findMode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            ints<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> ints<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 统计出现的频率</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            count<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n            count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 说明遍历到当前结点为止，该结点的值已经是出现的频率最高了，因此需要将当前节点的值放入集合中</span>\n            <span class="token comment">// 但是并不代表 遍历完所有结点后，当前结点的值出现的频率还是最高</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> maxCount<span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token comment">// 此时 count &gt; maxCount,说明已经出现比上一个元素出现频率更高的元素了。</span>\n            <span class="token comment">// 因此需要将上一个元素清空，并重新记录当前这个频率更高的元素</span>\n            res<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',22),da={id:"_236-二叉树的最近公共祖先",tabindex:"-1"},ka={class:"header-anchor",href:"#_236-二叉树的最近公共祖先"},va={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"},ma=(0,t.Lk)("p",null,"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。",-1),ga={href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},ba=(0,t.Lk)("strong",null,"一个节点也可以是它自己的祖先",-1),fa=(0,t.Fv)('<p><strong>示例 1：</strong></p><figure><img src="'+X+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+X+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2], p = 1, q = 2\n输出：1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h3 id="思路分析-24" tabindex="-1"><a class="header-anchor" href="#思路分析-24"><span>思路分析</span></a></h3><p><strong>公共祖先</strong>：简单来说就是一个或多个结点的共同父节点(若只有一个结点，本身也是公共祖先)</p><p>先来讨论一下几种情况，假设 root 为 p、q的公共祖先，那么一共有以下几种情况：</p><ol><li>q和p在二叉树的异侧，即一个在左子树一个在右子树</li><li>p = root，即q在p的左子树或者右子树</li><li>q=root，即p在q的右子树或者左子树</li></ol><p>根据以上条件，我们可以定义一个递归，用来寻找公共祖先：</p><p><strong>终止条件：</strong></p><ol><li>$root == null$ 则返回 root</li><li>$root == q || root == p$ , 则直接返回 root</li></ol><p><strong>返回值：</strong></p><p>由于我们使用的是递归，默认左右子树已经有结果，即用 **left ** 和 <strong>right</strong> 表示：</p><ol><li>若<code>left == null</code>，则公共祖先在右子树，返回 <strong>right</strong></li><li>若 <code>right == null </code>，则公共祖先在左子树，返回 <strong>left</strong></li><li>如果<code> root != null &amp;&amp; right != null</code> ， 说明 p 和 q在root的左右子树中，即 root 就是公共祖先，返回 <strong>root</strong></li><li>若 <code> root == null &amp;&amp; right == null</code> ，则不存在公共祖先，返回NULL （此步判断其实已经包在 1 和 2里）</li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span> root <span class="token operator">==</span> q <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历左子树</span>\n        <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历右子树</span>\n        <span class="token comment">// 如果左子树为空，说明 最近的公共祖先在右子树上，返回right</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>\n        <span class="token comment">// 同理，右子树为空，说明左子树上存在公共祖先</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>\n        <span class="token comment">// 如果 left和right都不为空，说明当前结点就是公共祖先</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',21),Aa={id:"_235-二叉搜索树的最近公共祖先",tabindex:"-1"},ya={class:"header-anchor",href:"#_235-二叉搜索树的最近公共祖先"},ha={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},wa=(0,t.Lk)("p",null,"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。",-1),xa={href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},Ia=(0,t.Lk)("strong",null,"一个节点也可以是它自己的祖先",-1),Ea=(0,t.Fv)('<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><figure><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>示例 1:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="思路分析-25" tabindex="-1"><a class="header-anchor" href="#思路分析-25"><span>思路分析</span></a></h3><p>利用二叉搜索树的性质：</p><ul><li>如果 root.val 比 q、p都大，说明公共祖先在 root 的左子树上</li><li>如果 root.val 比 q、p都小，说明公共祖先在 root 的右子树上</li><li>如果 root.val 在 [p,q]或者[q,p] 区间之内，说明root就是公共祖先</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果 root 比 q、p都大说明在root的左边</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 如果 root 比 q、p都小说明在root的左右边</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 如果 root在 [p,q]的区间之内，说明root就是公共祖先</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12),Ba={id:"_701-二叉搜索树中的插入操作",tabindex:"-1"},Sa={class:"header-anchor",href:"#_701-二叉搜索树中的插入操作"},Na={href:"https://leetcode.cn/problems/insert-into-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},ja=(0,t.Fv)('<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="'+Y+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,7,1,3], val = 5\n输出：[4,2,7,1,3,5]\n解释：另一个满足题目要求可以通过的树是：\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [40,20,60,10,30,50,70], val = 25\n输出：[40,20,60,10,30,50,70,null,null,25]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n输出：[4,2,7,1,3,5]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h3 id="思路分析-26" tabindex="-1"><a class="header-anchor" href="#思路分析-26"><span>思路分析</span></a></h3><p>题目中说，二叉搜索树中的任意一个结点都不相同，并且val在二叉树中不存在。</p><p>那么我们就可以直接遍历二叉搜索树，找到一个空的位置插入即可。</p><ul><li>当前结点值 &lt; val 就去右子树搜索</li><li>当前结点值 &gt; val 就去左子树搜索</li><li>如果当前节点值为空，则该位置就是要插入的位置</li></ul><p><strong>递归</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token comment">// 递归</span>\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 递归左右子树，如果小于val，就去右子树搜索。相反则去左子树上去搜索</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span> root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>迭代</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insertIntoBST1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>\n\n        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 去右子树上搜素</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 右子树为空，直接插入</span>\n                    cur<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">break</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 如果不为空，继续往下遍历</span>\n                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 左子树上去搜索</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    cur<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">break</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',19),Qa={id:"_450-删除二叉搜索树中的节点",tabindex:"-1"},Ta={class:"header-anchor",href:"#_450-删除二叉搜索树中的节点"},La={href:"https://leetcode.cn/problems/delete-node-in-a-bst/",target:"_blank",rel:"noopener noreferrer"},qa=(0,t.Fv)('<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [5,3,6,2,4,null,7], key = 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [5,3,6,2,4,null,7], key = 0\n输出: [5,3,6,2,4,null,7]\n解释: 二叉树不包含值为 0 的节点\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: root = [], key = 0\n输出: []\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h3 id="思路分析-27" tabindex="-1"><a class="header-anchor" href="#思路分析-27"><span>思路分析</span></a></h3><p>二叉搜索树的题目往往都可以使用递归来解决</p><p><strong>结束条件</strong></p><p>当 root 为空的时候，则返回 root</p><p><strong>返回值</strong></p><p>在二叉搜索树的插入中，用返回值确定插入的结点，此处也可以用返回值来确定要删除的结点</p><p><strong>单层递归逻辑</strong></p><p>此处就是删除结点的逻辑，我们需要分情况讨论：</p><ul><li>没有找到删除的结点，遍历到空结点直接返回</li><li>找到删除的结点，假设为root <ul><li>第一种情况：root为叶子结点，即没有左右子树，直接删除即可，返回 NULL</li><li>第二种情况：左子树不为空，右子树为空，返回左子树代替删除结点root</li><li>第三种情况：右子树不为空，左子树为空，返回右子树代替删除节点root</li><li>第四种情况：也是最复杂的情况，左右子树均不为空时，将 root 的左子树移动到 root 的右子树的最左侧结点的左子树上(即root的右子树最小结点上)，如图所示：</li></ul></li></ul><figure><img src="'+G+'" alt="image-20231121231225377" tabindex="0" loading="lazy"><figcaption>image-20231121231225377</figcaption></figure><figure><img src="'+_+'" alt="image-20231121231408805" tabindex="0" loading="lazy"><figcaption>image-20231121231408805</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 此时root为要删除的结点</span>\n\n            <span class="token comment">// 第一种情况：左右子树都为空，直接删除结点</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token comment">// 第二种情况：左子树不为空，右子树为空，返回左子树为新的子树</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token comment">// 第三种情况：左子树为空，右子树不为空，返回右子树为新的子树</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token comment">// 第四种情况：左右子树都不为空</span>\n            <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token comment">// 移动到要删除结点的右子树的最左边的结点(删除结点右子树的最小值)</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token comment">// 删除操作</span>\n            <span class="token comment">// 将删除结点的左子树移动到 删除结点的右子树中最小结点的左子树上</span>\n            cur<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token comment">// 覆盖删除结点</span>\n            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> key<span class="token punctuation">)</span> root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',25),Ha={id:"_669-修剪二叉搜索树",tabindex:"-1"},Pa={class:"header-anchor",href:"#_669-修剪二叉搜索树"},Da={href:"https://leetcode.cn/problems/trim-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Ca=(0,t.Fv)('<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><figure><img src="'+$+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,0,2], low = 1, high = 2\n输出：[1,null,2]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="'+nn+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n输出：[3,2,null,1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 104</code></li></ul><h3 id="思路分析-28" tabindex="-1"><a class="header-anchor" href="#思路分析-28"><span>思路分析</span></a></h3><p>这道题其实和 450 道题差不多，无非就是一个删除单个结点，该题可能删除多个结点。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">trimBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> high <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> low<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 找到修剪的结点</span>\n            <span class="token comment">// 第一种情况：左右子树都为null，直接返回null</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token comment">// 第二种情况：左子树为空，右子树不为空，返回右子树为新的子树</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token comment">// 第三种情况：左子树不为空，右子树为空，返回左子树为新的子树</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n\n            <span class="token comment">// 第四种情况：当左右子树都不为空时，将 删除结点的左子树 移动到删除节点右子树中最小的结点</span>\n            <span class="token class-name">TreeNode</span> curr <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token comment">// 将删除结点的左子树移动到cur的左子树上</span>\n            curr<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>\n            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>\n            <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是我们大可不必这么麻烦，题目中给了 [low,high] 区间，那么:</p><ul><li>当 <code>root.val &gt; high </code>时，说明root的整颗右子树都要修剪掉，我们直接跳过root结点及右子树，从<code>root.left</code>开始递归</li><li>当 <code>root.val &lt; left</code>时，说明root的整颗左子树都要修剪掉，我们直接跳过root结点及左子树，从<code>root.right</code>开始递归</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">trimBST1</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n\n        <span class="token comment">// root.val &lt; low 不在范围内，说明root的整颗左子树都符合修剪条件，跳过root及左子树，从右子树开始递归</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 同理，root.val比最大值还大，说明root的整颗右子树都符合修剪条件，跳过root结点及右子树，递归左子树</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 此时接入上面返回的左子树或者右子树</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',16),Ra={id:"_108-将有序数组转换为二叉搜索树",tabindex:"-1"},Wa={class:"header-anchor",href:"#_108-将有序数组转换为二叉搜索树"},za={href:"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Ua=(0,t.Fv)('<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><figure><img src="'+sn+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="data:image/jpeg;base64,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" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [1,3]\n输出：[3,1]\n解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h3 id="思路分析-29" tabindex="-1"><a class="header-anchor" href="#思路分析-29"><span>思路分析</span></a></h3><p>在写这道题之前，建议看看</p>',12),Ja={href:"https://leetcode.cn/problems/maximum-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Fa={href:"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},Ka={href:"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},Oa=(0,t.Fv)('<p>该题和上面三题思路一样，只不过是找根结点和递归的边界有所不同。</p><p>那么在 此题中，根节点为数组中间的一个，而根节点左边为左子树，根节点右边为右子树</p><figure><img src="'+an+'" alt="image-20231122222756717" tabindex="0" loading="lazy"><figcaption>image-20231122222756717</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token comment">// 确定根结点</span>\n        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> <span class="token function">left</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>\n        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 递归创建左右子树</span>\n        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> rootIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',4),Va={id:"_538-把二叉搜索树转换为累加树",tabindex:"-1"},Za={class:"header-anchor",href:"#_538-把二叉搜索树转换为累加树"},Ma={href:"https://leetcode.cn/problems/convert-bst-to-greater-tree/",target:"_blank",rel:"noopener noreferrer"},Xa=(0,t.Fv)('<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p>**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="'+tn+'" alt="img" loading="lazy"></strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [0,null,1]\n输出：[1,null,1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,0,2]\n输出：[3,3,2]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 4：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [3,2,4,1]\n输出：[7,9,4,10]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><h3 id="思路分析-30" tabindex="-1"><a class="header-anchor" href="#思路分析-30"><span>思路分析</span></a></h3><p>题目要求<code>将结点的值改为比当前结点值 大于或等于 节点值的总和</code></p><p>这样可能不好理解，我举个栗子：</p><p>将二叉搜索树变成一个有序数组（中序遍历），[0,1,2,3,4,5,6,7,8] ，那么求节点4的新值，就是 4+5+6+7+8=30， 求节点5的新值为：5+6+7+8 = 26</p><p>其实就是<code>从后到前累加节点的和</code>！！！！</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">convertBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token comment">// 从最大值开始遍历</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 累加从后到当前节点的和</span>\n        total <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>\n        root<span class="token punctuation">.</span>val <span class="token operator">=</span> total<span class="token punctuation">;</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1>',22),Ya={},Ga=(0,a(66262).A)(Ya,[["render",function(n,s){const a=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[en,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.Lk)("a",pn,[(0,t.eW)("144.二叉树的前序遍历(opens new window)"),(0,t.bF)(a)])]),(0,t.Lk)("li",null,[(0,t.Lk)("a",on,[(0,t.eW)("94.二叉树的中序遍历(opens new window)"),(0,t.bF)(a)])]),(0,t.Lk)("li",null,[(0,t.Lk)("a",cn,[(0,t.eW)("145.二叉树的后序遍历"),(0,t.bF)(a)])])]),ln,(0,t.Lk)("h3",un,[(0,t.Lk)("a",rn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",dn,[(0,t.eW)("102.二叉树的层序遍历(opens new window)"),(0,t.bF)(a)])])])]),kn,(0,t.Lk)("h3",vn,[(0,t.Lk)("a",mn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",gn,[(0,t.eW)("107. 二叉树的层序遍历 II"),(0,t.bF)(a)])])])]),bn,(0,t.Lk)("h3",fn,[(0,t.Lk)("a",An,[(0,t.Lk)("span",null,[(0,t.Lk)("a",yn,[(0,t.eW)("199. 二叉树的右视图"),(0,t.bF)(a)])])])]),hn,(0,t.Lk)("h3",wn,[(0,t.Lk)("a",xn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",In,[(0,t.eW)("637. 二叉树的层平均值"),(0,t.bF)(a)])])])]),En,(0,t.Lk)("h3",Bn,[(0,t.Lk)("a",Sn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Nn,[(0,t.eW)("429. N 叉树的层序遍历"),(0,t.bF)(a)])])])]),jn,(0,t.Lk)("h3",Qn,[(0,t.Lk)("a",Tn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Ln,[(0,t.eW)("515. 在每个树行中找最大值"),(0,t.bF)(a)])])])]),qn,(0,t.Lk)("h3",Hn,[(0,t.Lk)("a",Pn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Dn,[(0,t.eW)("116. 填充每个节点的下一个右侧节点指针"),(0,t.bF)(a)])])])]),Cn,(0,t.Lk)("h3",Rn,[(0,t.Lk)("a",Wn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",zn,[(0,t.eW)("104. 二叉树的最大深度"),(0,t.bF)(a)])])])]),Un,(0,t.Lk)("h3",Jn,[(0,t.Lk)("a",Fn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Kn,[(0,t.eW)("111. 二叉树的最小深度"),(0,t.bF)(a)])])])]),On,(0,t.Lk)("h2",Vn,[(0,t.Lk)("a",Zn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Mn,[(0,t.eW)("226. 翻转二叉树"),(0,t.bF)(a)])])])]),Xn,(0,t.Lk)("h2",Yn,[(0,t.Lk)("a",Gn,[(0,t.Lk)("span",null,[(0,t.Lk)("a",_n,[(0,t.eW)("101. 对称二叉树"),(0,t.bF)(a)])])])]),$n,(0,t.Lk)("h2",ns,[(0,t.Lk)("a",ss,[(0,t.Lk)("span",null,[(0,t.Lk)("a",as,[(0,t.eW)("222. 完全二叉树的节点个数"),(0,t.bF)(a)])])])]),ts,(0,t.Lk)("p",null,[(0,t.Lk)("a",es,[(0,t.eW)("完全二叉树"),(0,t.bF)(a)]),(0,t.eW)(" 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 "),ps,(0,t.eW)(" 层，则该层包含 "),os,(0,t.eW)(" 个节点。")]),cs,(0,t.Lk)("h2",ls,[(0,t.Lk)("a",is,[(0,t.Lk)("span",null,[(0,t.Lk)("a",us,[(0,t.eW)("110. 平衡二叉树"),(0,t.bF)(a)])])])]),rs,(0,t.Lk)("h2",ds,[(0,t.Lk)("a",ks,[(0,t.Lk)("span",null,[(0,t.eW)("☆ "),(0,t.Lk)("a",vs,[(0,t.eW)("257. 二叉树的所有路径"),(0,t.bF)(a)])])])]),ms,(0,t.Lk)("h2",gs,[(0,t.Lk)("a",bs,[(0,t.Lk)("span",null,[(0,t.Lk)("a",fs,[(0,t.eW)("404. 左叶子之和"),(0,t.bF)(a)])])])]),As,(0,t.Lk)("h2",ys,[(0,t.Lk)("a",hs,[(0,t.Lk)("span",null,[(0,t.Lk)("a",ws,[(0,t.eW)("513. 找树左下角的值"),(0,t.bF)(a)])])])]),xs,(0,t.Lk)("h2",Is,[(0,t.Lk)("a",Es,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Bs,[(0,t.eW)("112. 路径总和"),(0,t.bF)(a)])])])]),Ss,(0,t.Lk)("p",null,[(0,t.eW)("这道题和 "),(0,t.Lk)("a",Ns,[(0,t.eW)("257. 二叉树的所有路径"),(0,t.bF)(a)]),(0,t.eW)(" 思路一样，都需要进行回溯，只不过该题回溯的是 结点的和！")]),js,(0,t.Lk)("h2",Qs,[(0,t.Lk)("a",Ts,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Ls,[(0,t.eW)("106. 从中序与后序遍历序列构造二叉树"),(0,t.bF)(a)])])])]),qs,(0,t.Lk)("h2",Hs,[(0,t.Lk)("a",Ps,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Ds,[(0,t.eW)("105. 从前序与中序遍历序列构造二叉树"),(0,t.bF)(a)])])])]),Cs,(0,t.Lk)("p",null,[(0,t.eW)("思路其实和 "),(0,t.Lk)("a",Rs,[(0,t.eW)("106. 从中序与后序遍历序列构造二叉树"),(0,t.bF)(a)]),(0,t.eW)(" 一样：")]),Ws,(0,t.Lk)("h2",zs,[(0,t.Lk)("a",Us,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Js,[(0,t.eW)("654. 最大二叉树"),(0,t.bF)(a)])])])]),Fs,(0,t.Lk)("h2",Ks,[(0,t.Lk)("a",Os,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Vs,[(0,t.eW)("617. 合并二叉树"),(0,t.bF)(a)])])])]),Zs,(0,t.Lk)("h2",Ms,[(0,t.Lk)("a",Xs,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Ys,[(0,t.eW)("700. 二叉搜索树中的搜索"),(0,t.bF)(a)])])])]),Gs,(0,t.Lk)("h2",_s,[(0,t.Lk)("a",$s,[(0,t.Lk)("span",null,[(0,t.Lk)("a",na,[(0,t.eW)("98. 验证二叉搜索树"),(0,t.bF)(a)])])])]),sa,(0,t.Lk)("h2",aa,[(0,t.Lk)("a",ta,[(0,t.Lk)("span",null,[(0,t.Lk)("a",ea,[(0,t.eW)("530. 二叉搜索树的最小绝对差"),(0,t.bF)(a)])])])]),pa,(0,t.Lk)("h2",oa,[(0,t.Lk)("a",ca,[(0,t.Lk)("span",null,[(0,t.Lk)("a",la,[(0,t.eW)("501. 二叉搜索树中的众数"),(0,t.bF)(a)])])])]),(0,t.Lk)("p",null,[(0,t.eW)("给你一个含重复值的二叉搜索树（BST）的根节点 "),ia,(0,t.eW)(" ，找出并返回 BST 中的所有 "),(0,t.Lk)("a",ua,[(0,t.eW)("众数"),(0,t.bF)(a)]),(0,t.eW)("（即，出现频率最高的元素）。")]),ra,(0,t.Lk)("h2",da,[(0,t.Lk)("a",ka,[(0,t.Lk)("span",null,[(0,t.Lk)("a",va,[(0,t.eW)("236. 二叉树的最近公共祖先"),(0,t.bF)(a)])])])]),ma,(0,t.Lk)("p",null,[(0,t.Lk)("a",ga,[(0,t.eW)("百度百科"),(0,t.bF)(a)]),(0,t.eW)("中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),ba,(0,t.eW)("）。”")]),fa,(0,t.Lk)("h2",Aa,[(0,t.Lk)("a",ya,[(0,t.Lk)("span",null,[(0,t.Lk)("a",ha,[(0,t.eW)("235. 二叉搜索树的最近公共祖先"),(0,t.bF)(a)])])])]),wa,(0,t.Lk)("p",null,[(0,t.Lk)("a",xa,[(0,t.eW)("百度百科"),(0,t.bF)(a)]),(0,t.eW)("中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),Ia,(0,t.eW)("）。”")]),Ea,(0,t.Lk)("h2",Ba,[(0,t.Lk)("a",Sa,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Na,[(0,t.eW)("701. 二叉搜索树中的插入操作"),(0,t.bF)(a)])])])]),ja,(0,t.Lk)("h2",Qa,[(0,t.Lk)("a",Ta,[(0,t.Lk)("span",null,[(0,t.Lk)("a",La,[(0,t.eW)("450. 删除二叉搜索树中的节点"),(0,t.bF)(a)])])])]),qa,(0,t.Lk)("h2",Ha,[(0,t.Lk)("a",Pa,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Da,[(0,t.eW)("669. 修剪二叉搜索树"),(0,t.bF)(a)])])])]),Ca,(0,t.Lk)("h2",Ra,[(0,t.Lk)("a",Wa,[(0,t.Lk)("span",null,[(0,t.Lk)("a",za,[(0,t.eW)("108. 将有序数组转换为二叉搜索树"),(0,t.bF)(a)])])])]),Ua,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.Lk)("a",Ja,[(0,t.eW)("654. 最大二叉树"),(0,t.bF)(a)])]),(0,t.Lk)("li",null,[(0,t.Lk)("a",Fa,[(0,t.eW)("106. 从中序与后序遍历序列构造二叉树"),(0,t.bF)(a)])]),(0,t.Lk)("li",null,[(0,t.Lk)("a",Ka,[(0,t.eW)("105. 从前序与中序遍历序列构造二叉树"),(0,t.bF)(a)])])]),Oa,(0,t.Lk)("h2",Va,[(0,t.Lk)("a",Za,[(0,t.Lk)("span",null,[(0,t.Lk)("a",Ma,[(0,t.eW)("538. 把二叉搜索树转换为累加树"),(0,t.bF)(a)])])])]),Xa])}]]),_a=JSON.parse('{"path":"/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"二叉树","lang":"zh-CN","frontmatter":{"date":"2024-03-28T00:00:00.000Z","category":["算法"],"tag":["二叉树","二叉树遍历","平衡二叉树","搜索二叉树"],"editLink":false,"pageview":false,"star":true,"order":5,"description":"二叉树 二叉树大纲二叉树大纲 满二叉树： 对于k层的二叉树来说，拥有 2k -1 个结点的二叉树称为满二叉树 度为0的结点(叶子结点)都在同一层上 image-20231030212729924image-20231030212729924 完全二叉树： 二叉树的结点位置按照对应的完全二叉树的位置相吻合 最后一层的结点，一定是从左往右依次排满的 ima...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"二叉树"}],["meta",{"property":"og:description","content":"二叉树 二叉树大纲二叉树大纲 满二叉树： 对于k层的二叉树来说，拥有 2k -1 个结点的二叉树称为满二叉树 度为0的结点(叶子结点)都在同一层上 image-20231030212729924image-20231030212729924 完全二叉树： 二叉树的结点位置按照对应的完全二叉树的位置相吻合 最后一层的结点，一定是从左往右依次排满的 ima..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-10T10:55:43.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"二叉树"}],["meta",{"property":"article:tag","content":"二叉树遍历"}],["meta",{"property":"article:tag","content":"平衡二叉树"}],["meta",{"property":"article:tag","content":"搜索二叉树"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-10T10:55:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树\\",\\"image\\":[\\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\\",\\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\\",\\"http://images-1313160403.cos.ap-beijing.myqcloud.com/MarkDown/image-20231113230335449.png\\",\\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\\",\\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-10T10:55:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":2,"title":"1、二叉树递归遍历","slug":"_1、二叉树递归遍历","link":"#_1、二叉树递归遍历","children":[{"level":3,"title":"前序遍历","slug":"前序遍历","link":"#前序遍历","children":[]},{"level":3,"title":"中序遍历","slug":"中序遍历","link":"#中序遍历","children":[]},{"level":3,"title":"后序遍历","slug":"后序遍历","link":"#后序遍历","children":[]}]},{"level":2,"title":"2、二叉树迭代遍历","slug":"_2、二叉树迭代遍历","link":"#_2、二叉树迭代遍历","children":[{"level":3,"title":"前序遍历","slug":"前序遍历-1","link":"#前序遍历-1","children":[]},{"level":3,"title":"中序遍历","slug":"中序遍历-1","link":"#中序遍历-1","children":[]},{"level":3,"title":"后序遍历","slug":"后序遍历-1","link":"#后序遍历-1","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"3、二叉树的层序遍历","slug":"_3、二叉树的层序遍历","link":"#_3、二叉树的层序遍历","children":[{"level":3,"title":"102.二叉树的层序遍历(opens new window)","slug":"_102-二叉树的层序遍历-opens-new-window","link":"#_102-二叉树的层序遍历-opens-new-window","children":[]},{"level":3,"title":"107. 二叉树的层序遍历 II","slug":"_107-二叉树的层序遍历-ii","link":"#_107-二叉树的层序遍历-ii","children":[]},{"level":3,"title":"199. 二叉树的右视图","slug":"_199-二叉树的右视图","link":"#_199-二叉树的右视图","children":[]},{"level":3,"title":"637. 二叉树的层平均值","slug":"_637-二叉树的层平均值","link":"#_637-二叉树的层平均值","children":[]},{"level":3,"title":"429. N 叉树的层序遍历","slug":"_429-n-叉树的层序遍历","link":"#_429-n-叉树的层序遍历","children":[]},{"level":3,"title":"515. 在每个树行中找最大值","slug":"_515-在每个树行中找最大值","link":"#_515-在每个树行中找最大值","children":[]},{"level":3,"title":"116. 填充每个节点的下一个右侧节点指针","slug":"_116-填充每个节点的下一个右侧节点指针","link":"#_116-填充每个节点的下一个右侧节点指针","children":[]},{"level":3,"title":"104. 二叉树的最大深度","slug":"_104-二叉树的最大深度","link":"#_104-二叉树的最大深度","children":[]},{"level":3,"title":"111. 二叉树的最小深度","slug":"_111-二叉树的最小深度","link":"#_111-二叉树的最小深度","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"226. 翻转二叉树","slug":"_226-翻转二叉树","link":"#_226-翻转二叉树","children":[{"level":3,"title":"思路分析","slug":"思路分析-9","link":"#思路分析-9","children":[]}]},{"level":2,"title":"101. 对称二叉树","slug":"_101-对称二叉树","link":"#_101-对称二叉树","children":[]},{"level":2,"title":"222. 完全二叉树的节点个数","slug":"_222-完全二叉树的节点个数","link":"#_222-完全二叉树的节点个数","children":[]},{"level":2,"title":"110. 平衡二叉树","slug":"_110-平衡二叉树","link":"#_110-平衡二叉树","children":[{"level":3,"title":"思路分析","slug":"思路分析-12","link":"#思路分析-12","children":[]}]},{"level":2,"title":"☆ 257. 二叉树的所有路径","slug":"☆-257-二叉树的所有路径","link":"#☆-257-二叉树的所有路径","children":[{"level":3,"title":"思路分析","slug":"思路分析-13","link":"#思路分析-13","children":[]}]},{"level":2,"title":"404. 左叶子之和","slug":"_404-左叶子之和","link":"#_404-左叶子之和","children":[{"level":3,"title":"思路分析","slug":"思路分析-14","link":"#思路分析-14","children":[]}]},{"level":2,"title":"513. 找树左下角的值","slug":"_513-找树左下角的值","link":"#_513-找树左下角的值","children":[{"level":3,"title":"思路分析","slug":"思路分析-15","link":"#思路分析-15","children":[]}]},{"level":2,"title":"112. 路径总和","slug":"_112-路径总和","link":"#_112-路径总和","children":[{"level":3,"title":"思路分析","slug":"思路分析-16","link":"#思路分析-16","children":[]}]},{"level":2,"title":"106. 从中序与后序遍历序列构造二叉树","slug":"_106-从中序与后序遍历序列构造二叉树","link":"#_106-从中序与后序遍历序列构造二叉树","children":[{"level":3,"title":"思路分析","slug":"思路分析-17","link":"#思路分析-17","children":[]}]},{"level":2,"title":"105. 从前序与中序遍历序列构造二叉树","slug":"_105-从前序与中序遍历序列构造二叉树","link":"#_105-从前序与中序遍历序列构造二叉树","children":[{"level":3,"title":"思路分析","slug":"思路分析-18","link":"#思路分析-18","children":[]}]},{"level":2,"title":"654. 最大二叉树","slug":"_654-最大二叉树","link":"#_654-最大二叉树","children":[{"level":3,"title":"思路分析","slug":"思路分析-19","link":"#思路分析-19","children":[]}]},{"level":2,"title":"617. 合并二叉树","slug":"_617-合并二叉树","link":"#_617-合并二叉树","children":[]},{"level":2,"title":"700. 二叉搜索树中的搜索","slug":"_700-二叉搜索树中的搜索","link":"#_700-二叉搜索树中的搜索","children":[{"level":3,"title":"思路分析","slug":"思路分析-20","link":"#思路分析-20","children":[]}]},{"level":2,"title":"98. 验证二叉搜索树","slug":"_98-验证二叉搜索树","link":"#_98-验证二叉搜索树","children":[{"level":3,"title":"思路分析","slug":"思路分析-21","link":"#思路分析-21","children":[]}]},{"level":2,"title":"530. 二叉搜索树的最小绝对差","slug":"_530-二叉搜索树的最小绝对差","link":"#_530-二叉搜索树的最小绝对差","children":[{"level":3,"title":"思路分析","slug":"思路分析-22","link":"#思路分析-22","children":[]}]},{"level":2,"title":"501. 二叉搜索树中的众数","slug":"_501-二叉搜索树中的众数","link":"#_501-二叉搜索树中的众数","children":[{"level":3,"title":"思路分析","slug":"思路分析-23","link":"#思路分析-23","children":[]}]},{"level":2,"title":"236. 二叉树的最近公共祖先","slug":"_236-二叉树的最近公共祖先","link":"#_236-二叉树的最近公共祖先","children":[{"level":3,"title":"思路分析","slug":"思路分析-24","link":"#思路分析-24","children":[]}]},{"level":2,"title":"235. 二叉搜索树的最近公共祖先","slug":"_235-二叉搜索树的最近公共祖先","link":"#_235-二叉搜索树的最近公共祖先","children":[{"level":3,"title":"思路分析","slug":"思路分析-25","link":"#思路分析-25","children":[]}]},{"level":2,"title":"701. 二叉搜索树中的插入操作","slug":"_701-二叉搜索树中的插入操作","link":"#_701-二叉搜索树中的插入操作","children":[{"level":3,"title":"思路分析","slug":"思路分析-26","link":"#思路分析-26","children":[]}]},{"level":2,"title":"450. 删除二叉搜索树中的节点","slug":"_450-删除二叉搜索树中的节点","link":"#_450-删除二叉搜索树中的节点","children":[{"level":3,"title":"思路分析","slug":"思路分析-27","link":"#思路分析-27","children":[]}]},{"level":2,"title":"669. 修剪二叉搜索树","slug":"_669-修剪二叉搜索树","link":"#_669-修剪二叉搜索树","children":[{"level":3,"title":"思路分析","slug":"思路分析-28","link":"#思路分析-28","children":[]}]},{"level":2,"title":"108. 将有序数组转换为二叉搜索树","slug":"_108-将有序数组转换为二叉搜索树","link":"#_108-将有序数组转换为二叉搜索树","children":[{"level":3,"title":"思路分析","slug":"思路分析-29","link":"#思路分析-29","children":[]}]},{"level":2,"title":"538. 把二叉搜索树转换为累加树","slug":"_538-把二叉搜索树转换为累加树","link":"#_538-把二叉搜索树转换为累加树","children":[{"level":3,"title":"思路分析","slug":"思路分析-30","link":"#思路分析-30","children":[]}]}],"git":{"createdTime":1712746543000,"updatedTime":1712746543000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":58.11,"words":17434},"filePathRelative":"LeetCode/二叉树.md","localizedDate":"2024年3月28日","excerpt":"\\n<figure><figcaption>二叉树大纲</figcaption></figure>\\n<p><strong>满二叉树</strong>：</p>\\n<ol>\\n<li>对于k层的二叉树来说，拥有 2<sup>k</sup> -1 个结点的二叉树称为满二叉树</li>\\n<li>度为0的结点(叶子结点)都在同一层上</li>\\n</ol>\\n<figure><figcaption>image-20231030212729924</figcaption></figure>\\n<p><strong>完全二叉树：</strong></p>\\n<ol>\\n<li>二叉树的结点位置按照对应的完全二叉树的位置相吻合</li>\\n<li>最后一层的结点，一定是从左往右依次排满的</li>\\n</ol>","autoDesc":true}')}}]);