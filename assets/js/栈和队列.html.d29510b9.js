"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[866],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}},99459:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>j,data:()=>K});var t=a(20641);const e=(0,t.Lk)("h1",{id:"栈和队列",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#栈和队列"},[(0,t.Lk)("span",null,"栈和队列")])],-1),p={id:"_232-用栈实现队列",tabindex:"-1"},o={class:"header-anchor",href:"#_232-用栈实现队列"},c={href:"https://leetcode.cn/problems/implement-queue-using-stacks/",target:"_blank",rel:"noopener noreferrer"},l=(0,t.Fv)('<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><h3 id="思路分析" tabindex="-1"><a class="header-anchor" href="#思路分析"><span>思路分析</span></a></h3><p>使用俩个栈实现队列，一个作为输入栈，一个作为输出栈。</p><p>栈为先进后出，队列为先进先出，push 时往输入栈里面push，但是 pop 的时候，需要将输入栈导入到输出栈。此时输出栈的顺序才和队列一致。</p><figure><img src="data:image/png;base64,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" alt="image-20231019212329144" tabindex="0" loading="lazy"><figcaption>image-20231019212329144</figcaption></figure><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{</span>\n\n    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inputStack<span class="token punctuation">;</span>\n    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> outputStack<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 输入栈</span>\n       inputStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 输出栈</span>\n       outputStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 直接压入输入栈</span>\n        inputStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 需要先将输入栈导入输出栈</span>\n        <span class="token function">exportInputStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> outputStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 需要先将输入栈导入输出栈</span>\n        <span class="token function">exportInputStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> outputStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 俩个栈都为空</span>\n          <span class="token keyword">return</span> inputStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> outputStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 将输入栈导出到输出栈中</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exportInputStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outputStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>inputStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            outputStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>inputStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',15),i={id:"_20-有效的括号",tabindex:"-1"},u={class:"header-anchor",href:"#_20-有效的括号"},k={href:"https://leetcode.cn/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Fv)('<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;()&quot;\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;()[]{}&quot;\n输出：true\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;(]&quot;\n输出：false\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]{}&#39;</code> 组成</li></ul><h3 id="思路分析-1" tabindex="-1"><a class="header-anchor" href="#思路分析-1"><span>思路分析</span></a></h3><p>根据题意可知，有效的字符串一定是成双成对的，一定<strong>是2的倍数</strong>，并且<strong>左括号后面一定是对应的右括号</strong>！</p><p>可以利用栈先进先出的特性，对其进行校验：</p><ul><li>如果遇到左括号，直接入栈</li><li>如果遇到右括号，弹栈，判断是否符合()、[]、{} ，若不符合直接返回false</li></ul><p>如果是有效的字符串的话，一定是先入栈-弹栈-入栈-弹栈.....这种顺序，那么到最后一个操作时一定是<strong>弹栈</strong>，并且栈一定是<strong>空</strong>的！！！</p><h3 id="代码实现-1" tabindex="-1"><a class="header-anchor" href="#代码实现-1"><span>代码实现</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果不是2的倍数，一定不是有效的括号</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 遇到左括号直接入栈</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">&#39;(&#39;</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">&#39;[&#39;</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">&#39;{&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 遇到右括号弹栈，弹出一个左括号</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n                <span class="token class-name">Character</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 校验</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">&#39;)&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token char">&#39;(&#39;</span> <span class="token operator">!=</span> pop<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">&#39;]&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token char">&#39;[&#39;</span> <span class="token operator">!=</span> pop<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">&#39;}&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token char">&#39;{&#39;</span><span class="token operator">!=</span> pop<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',18),d={id:"_1047-删除字符串中的所有相邻重复项",tabindex:"-1"},v={class:"header-anchor",href:"#_1047-删除字符串中的所有相邻重复项"},A={href:"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/",target:"_blank",rel:"noopener noreferrer"},m=(0,t.Fv)('<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：&quot;abbaca&quot;\n输出：&quot;ca&quot;\n解释：\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><h3 id="思路分析-2" tabindex="-1"><a class="header-anchor" href="#思路分析-2"><span>思路分析</span></a></h3><p>这个题目其实和 20题：有效的括号 思路一样</p><ul><li>当stack为空或者遇到不相等的元素，直接入栈</li><li>遇到相等的元素弹栈，判断下一个元素</li><li>最后stack中剩下的就是不重复的元素</li></ul><h3 id="代码实现-2" tabindex="-1"><a class="header-anchor" href="#代码实现-2"><span>代码实现</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 将不相等的字符入栈，相等的字符弹栈</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                 stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 剩下的就是不重复的元素</span>\n        <span class="token class-name">StringBuilder</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12),h={id:"_150-逆波兰表达式求值",tabindex:"-1"},g={class:"header-anchor",href:"#_150-逆波兰表达式求值"},b={href:"https://leetcode.cn/problems/evaluate-reverse-polish-notation/",target:"_blank",rel:"noopener noreferrer"},E=(0,t.Lk)("code",null,"tokens",-1),C={href:"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437",target:"_blank",rel:"noopener noreferrer"},Q=(0,t.Fv)('<p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h3 id="思路分析-3" tabindex="-1"><a class="header-anchor" href="#思路分析-3"><span>思路分析</span></a></h3><p>题目比较简单，只要弄清楚什么是逆波兰表达式即可。需要注意的是除法和减法，不要搞混运算顺序。</p><h3 id="代码实现-3" tabindex="-1"><a class="header-anchor" href="#代码实现-3"><span>代码实现</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> token <span class="token operator">:</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 如果是字符，取出俩个数计算，并讲解结果放入栈中</span>\n                <span class="token keyword">switch</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">{</span>\n                    <span class="token keyword">case</span> <span class="token string">&quot;*&quot;</span> <span class="token operator">:</span>\n                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">break</span><span class="token punctuation">;</span>\n                    <span class="token keyword">case</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">:</span>\n                        <span class="token comment">// 除法要特殊处理，先弹出来的是除数，后弹出来的是被除数</span>\n                        <span class="token class-name">Integer</span> op1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token class-name">Integer</span> op2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> op2 <span class="token operator">/</span> op1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">break</span><span class="token punctuation">;</span>\n                    <span class="token keyword">case</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">:</span>\n                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">break</span><span class="token punctuation">;</span>\n                    <span class="token keyword">case</span> <span class="token string">&quot;-&quot;</span> <span class="token operator">:</span>\n                        <span class="token comment">// 减法也要特殊处理，先弹出来的是减数，后弹出来的是被减数</span>\n                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">break</span><span class="token punctuation">;</span>\n                    <span class="token keyword">default</span><span class="token operator">:</span>  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span>  stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',20),f={id:"☆239-滑动窗口最大值",tabindex:"-1"},I={class:"header-anchor",href:"#☆239-滑动窗口最大值"},y={href:"https://leetcode.cn/problems/sliding-window-maximum/",target:"_blank",rel:"noopener noreferrer"},w=(0,t.Fv)('<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：nums = [1], k = 1\n输出：[1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h3 id="思路分析-4" tabindex="-1"><a class="header-anchor" href="#思路分析-4"><span>思路分析</span></a></h3><p>该题目使用单调递减队列比较容易理解一些。我们只需要<strong>维护队首最大的元素</strong>即可，同时要保证队列中的元素<strong>保持递减</strong>。</p><p>那么该如何维护呢？通过题意我们可以发现，每次移动窗口，都是在pop、push，那么在push 和 pop 要遵循以下原则：</p><ol><li>pop(): <ol><li>保证队列的单调递减，将 <strong>比当前值小的元素都弹出</strong></li><li>判断队首元素是否在该滑动区间内 , 如果不是直接弹出队首元素</li></ol></li><li>push： <ol><li>保证push的元素一定是当前队列中的最小值 或者 队列为空</li></ol></li></ol><p><strong>例</strong></p>',13),x=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,"nums = [1,3,-1,-3,5,3,6,7], k = 3"),(0,t.Lk)("p",null,"初始状态设[L,R] = [0,0],队列 Q ={}，res = []"),(0,t.Lk)("p",{1:""},"i = 0, nums[0] = 1, 队列为空，直接入队 Q ="),(0,t.Lk)("p",{3:""},"i = 1, nums[1] = 3, 3 > 1 遇见比当前值小的，则依次弹出后加入，Q ="),(0,t.Lk)("p",null,"i = 2, nums[2] = -1， -1 < 3, 直接入队，Q = {3,-1},此时L=0，R=2，i在区间之内，则res = [3]"),(0,t.Lk)("p",null,"i=3,nums[3]=-3。队尾值为-1，-3<-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]"),(0,t.Lk)("p",null,"i=4,nums[4]=5。队尾值为-3，5>-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]"),(0,t.Lk)("p",null,"i=5,nums[5]=3。队尾值为5，3<5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]"),(0,t.Lk)("p",null,"i=6,nums[6]=6。队尾值为3，6>3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]"),(0,t.Lk)("p",null,"i=7,nums[7]=7。队尾值为6，7>6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]")],-1),q=(0,t.Fv)('<p>通过模拟可以发现：</p><ul><li>$R = i， L = R-k+1 = i- k + 1$， 判断队首元素是否在[L,R] 之内，只需要判断队首元素的下标是否大于 $ i-k+1$</li><li>在队里中存储元素下标更为访问，因为要判断队首元素是否在滑动窗口之内！</li></ul><h3 id="代码实现-4" tabindex="-1"><a class="header-anchor" href="#代码实现-4"><span><strong>代码实现</strong></span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n            <span class="token comment">// 将队列中比当前元素小的都弹出，保证当前值为最小值或者队列为空</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 增加元素到队尾</span>\n            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 判断队首元素是否在滑动区间内[i-k+1,i]，若不在则弹出队首的元素</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 获取队列最大值，由于是单调递减，第一个元素就是最大值</span>\n                res<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',4),S={id:"_347-前-k-个高频元素",tabindex:"-1"},B={class:"header-anchor",href:"#_347-前-k-个高频元素"},F={href:"https://leetcode.cn/problems/top-k-frequent-elements/",target:"_blank",rel:"noopener noreferrer"},R=(0,t.Fv)('<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: nums = [1], k = 1\n输出: [1]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p>**进阶：**你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h3 id="思路分析-5" tabindex="-1"><a class="header-anchor" href="#思路分析-5"><span>思路分析</span></a></h3><ol><li><p>统计<code>nums</code> 数组中每个数字出现的频率</p><p>类似这种统计，我们都可以使用<code>map</code>来存储 , 这道题key存储元素，value存储每个元素出现的次数</p></li><li><p>需要对<code>map</code>中的元素按照 <code>value</code> 大小进行排序</p><p>最重要的就是该步，时间复杂度也都取决于该步，可以使用冒泡, 选择, 插入等等等，但是他们的复杂度 &gt;= $O(nlogn)$</p><p>因此再次步，我们可以使用 <strong>优先级队列</strong> 当做存储容器，其实现方式通常由 <strong>小顶堆、大顶堆</strong></p><ul><li>小顶堆：非叶子节点比左右孩子结点小</li><li>大顶堆：非叶子节点比左右孩子结点大</li></ul><p>在 Java中可以使用<code>PriorityQueue</code> 表示优先级队列</p></li><li><p>获取优先级队列前k个元素</p></li></ol><h3 id="代码实现-5" tabindex="-1"><a class="header-anchor" href="#代码实现-5"><span>代码实现</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 统计nums中每个数字出现的次数</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// getOrDefault 获取value，如果不存在就存入默认值</span>\n            table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>table<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 使用优先级队列进行排序</span>\n        <span class="token comment">/*\n        * PriorityQueue默认创建的就是小顶堆，即从小到大排序\n        * (o1,o2) -&gt; o2[0] - o1[0] : 创建的是大顶堆，即从大到小排序\n        * */</span>\n        <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> table<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 由于创建的大顶堆，比较数组中第一个元素。因此按照value值进行排序</span>\n            pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 获取前k个元素</span>\n        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            ints<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span>  ints<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>此篇中，最重要的是学到了 <code>单调队列 </code>和 <code>优先级队列</code></p><p>单调队列通常用<code>双端队列</code> 实现，需要<strong>手动</strong>保持队列中的元素单调性，单调递增或者递减，通常用于解决 滑动窗口 类的问题。</p><p>优先级队列通常用 <code>小顶堆、大顶堆</code>来实现, 在插入删除时<strong>自动</strong>保持顺序</p><h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1>',17),U={},j=(0,a(66262).A)(U,[["render",function(n,s){const a=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[e,(0,t.Lk)("h2",p,[(0,t.Lk)("a",o,[(0,t.Lk)("span",null,[(0,t.Lk)("a",c,[(0,t.eW)("232. 用栈实现队列"),(0,t.bF)(a)])])])]),l,(0,t.Lk)("h2",i,[(0,t.Lk)("a",u,[(0,t.Lk)("span",null,[(0,t.Lk)("a",k,[(0,t.eW)("20. 有效的括号"),(0,t.bF)(a)])])])]),r,(0,t.Lk)("h2",d,[(0,t.Lk)("a",v,[(0,t.Lk)("span",null,[(0,t.Lk)("a",A,[(0,t.eW)("1047. 删除字符串中的所有相邻重复项"),(0,t.bF)(a)])])])]),m,(0,t.Lk)("h2",h,[(0,t.Lk)("a",g,[(0,t.Lk)("span",null,[(0,t.Lk)("a",b,[(0,t.eW)("150. 逆波兰表达式求值"),(0,t.bF)(a)])])])]),(0,t.Lk)("p",null,[(0,t.eW)("给你一个字符串数组 "),E,(0,t.eW)(" ，表示一个根据 "),(0,t.Lk)("a",C,[(0,t.eW)("逆波兰表示法"),(0,t.bF)(a)]),(0,t.eW)(" 表示的算术表达式。")]),Q,(0,t.Lk)("h2",f,[(0,t.Lk)("a",I,[(0,t.Lk)("span",null,[(0,t.eW)("☆"),(0,t.Lk)("a",y,[(0,t.eW)("239. 滑动窗口最大值"),(0,t.bF)(a)])])])]),w,x,q,(0,t.Lk)("h2",S,[(0,t.Lk)("a",B,[(0,t.Lk)("span",null,[(0,t.Lk)("a",F,[(0,t.eW)("347. 前 K 个高频元素"),(0,t.bF)(a)])])])]),R])}]]),K=JSON.parse('{"path":"/LeetCode/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html","title":"栈和队列","lang":"zh-CN","frontmatter":{"date":"2024-03-28T00:00:00.000Z","category":["算法"],"tag":["栈","队列"],"editLink":false,"pageview":false,"star":true,"order":5,"description":"栈和队列 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/LeetCode/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"栈和队列"}],["meta",{"property":"og:description","content":"栈和队列 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-10T10:55:43.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"栈"}],["meta",{"property":"article:tag","content":"队列"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-10T10:55:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈和队列\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-10T10:55:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":2,"title":"232. 用栈实现队列","slug":"_232-用栈实现队列","link":"#_232-用栈实现队列","children":[{"level":3,"title":"思路分析","slug":"思路分析","link":"#思路分析","children":[]},{"level":3,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}]},{"level":2,"title":"20. 有效的括号","slug":"_20-有效的括号","link":"#_20-有效的括号","children":[{"level":3,"title":"思路分析","slug":"思路分析-1","link":"#思路分析-1","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-1","link":"#代码实现-1","children":[]}]},{"level":2,"title":"1047. 删除字符串中的所有相邻重复项","slug":"_1047-删除字符串中的所有相邻重复项","link":"#_1047-删除字符串中的所有相邻重复项","children":[{"level":3,"title":"思路分析","slug":"思路分析-2","link":"#思路分析-2","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-2","link":"#代码实现-2","children":[]}]},{"level":2,"title":"150. 逆波兰表达式求值","slug":"_150-逆波兰表达式求值","link":"#_150-逆波兰表达式求值","children":[{"level":3,"title":"思路分析","slug":"思路分析-3","link":"#思路分析-3","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-3","link":"#代码实现-3","children":[]}]},{"level":2,"title":"☆239. 滑动窗口最大值","slug":"☆239-滑动窗口最大值","link":"#☆239-滑动窗口最大值","children":[{"level":3,"title":"思路分析","slug":"思路分析-4","link":"#思路分析-4","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-4","link":"#代码实现-4","children":[]}]},{"level":2,"title":"347. 前 K 个高频元素","slug":"_347-前-k-个高频元素","link":"#_347-前-k-个高频元素","children":[{"level":3,"title":"思路分析","slug":"思路分析-5","link":"#思路分析-5","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-5","link":"#代码实现-5","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1712746543000,"updatedTime":1712746543000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":11.74,"words":3523},"filePathRelative":"LeetCode/栈和队列.md","localizedDate":"2024年3月28日","excerpt":"\\n<h2><a class=\\"header-anchor\\" href=\\"#_232-用栈实现队列\\"><span></span></a><a href=\\"https://leetcode.cn/problems/implement-queue-using-stacks/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">232. 用栈实现队列</a></h2>\\n<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>","autoDesc":true}')}}]);