"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[9601],{66262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,t]of a)i[e]=t;return i}},63378:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>w,data:()=>z});var t=i(20641);const n=i.p+"assets/img/image-20240416203555111.8cff0c65.png",o=i.p+"assets/img/image-20240416222902670.a41096b6.png",p=i.p+"assets/img/image-20240417162206531.7dcc51aa.png",c=i.p+"assets/img/image-20240417162515274.0a1dc6ef.png",l=i.p+"assets/img/image-20240417164418066.22ea05e1.png",g=i.p+"assets/img/image-20240417165601046.27f79ca3.png",r=i.p+"assets/img/v2-a0c5b881af3e29d14060306e39af2819_1440w.d313eec4.webp",d=i.p+"assets/img/v2-6ecb287bdfcb2ecf3a0ac7be1dadf6d3_1440w.83216982.webp",s=i.p+"assets/img/v2-1f86ba3b8134da8f5a6c445ac89e3897_1440w.997d7448.webp",m=i.p+"assets/img/v2-f750b841ed5aa97ecf5ed378442e3f4d_1440w.aa8fa511.webp",h=i.p+"assets/img/v2-49c096143aa1f17a783c226b201dbe8a_1440w.8d7c43d1.webp",f=(0,t.Fv)('<h1 id="缓存双写一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存双写一致性问题"><span>缓存双写一致性问题</span></a></h1><p>只要使用缓存，就可能涉及到 Redis 缓存与数据库 双存储双写，只要是双写，就一定会有<strong>数据一致性</strong>的问题！</p><figure><img src="'+n+'" alt="image-20240416203555111" tabindex="0" loading="lazy"><figcaption>image-20240416203555111</figcaption></figure><h3 id="你是如何解决数据一致性问题的" tabindex="-1"><a class="header-anchor" href="#你是如何解决数据一致性问题的"><span>你是如何解决数据一致性问题的？</span></a></h3><ul><li>采用 <strong>双检加锁</strong> 策略</li></ul><p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 <code>互斥锁</code>来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做<code>缓存</code>。后面的线程进来发现已经有缓存了，就直接走缓存。</p><figure><img src="'+o+'" alt="image-20240416222902670" tabindex="0" loading="lazy"><figcaption>image-20240416222902670</figcaption></figure><h3 id="你的更新策略是什么" tabindex="-1"><a class="header-anchor" href="#你的更新策略是什么"><span>你的更新策略是什么？</span></a></h3>',8),u={class:"hint-container tip"},b=(0,t.Lk)("p",{class:"hint-container-title"},"原文",-1),y={href:"https://zhuanlan.zhihu.com/p/490902522",target:"_blank",rel:"noopener noreferrer"},x=(0,t.Fv)('<p><strong>目前常见的更新策略有四种</strong>：</p><ol><li>先写缓存，再写数据库</li><li>先写数据库，再写缓存</li><li>先删缓存，再写数据库</li><li>先写数据库，再删缓存</li></ol><h4 id="先写缓存-再写数据库" tabindex="-1"><a class="header-anchor" href="#先写缓存-再写数据库"><span>先写缓存，再写数据库</span></a></h4><p>这种方案是最不可取的，写完缓存后，更新数据库时出现网络异常，导致数据库更新不成功！</p><p>那么 Redis 中的数据不就成了 <code>脏数据</code>了 吗？</p><figure><img src="'+p+'" alt="image-20240417162206531" tabindex="0" loading="lazy"><figcaption>image-20240417162206531</figcaption></figure><h4 id="先写数据库-再写缓存" tabindex="-1"><a class="header-anchor" href="#先写数据库-再写缓存"><span>先写数据库，再写缓存</span></a></h4><p>这种方案貌似解决了上面<code>脏数据</code> 的问题，但是又带来了一个新问题，<code>新值被覆盖</code>的问题</p><figure><img src="'+c+'" alt="image-20240417162515274" tabindex="0" loading="lazy"><figcaption>image-20240417162515274</figcaption></figure><ul><li>假设请求a先执行数据库写操作，在写入缓存是出现卡顿</li><li>这时，请求b在请求a卡顿的过程中，先更新缓存的值为5</li><li>在请求b更新完之后，请求a卡顿结束，更新缓存值为6</li></ul><p>这时请求a的旧值就覆盖了请求b的新值</p><h4 id="先删缓存-再写数据库" tabindex="-1"><a class="header-anchor" href="#先删缓存-再写数据库"><span>先删缓存，再写数据库</span></a></h4><p>这种方案仍然会出现<code>新值被覆盖</code>的问题</p><p>假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求c，还有另一个写数据请求d（一个更新操作），同时请求到业务系统。如下图所示：</p><figure><img src="'+l+'" alt="image-20240417164418066" tabindex="0" loading="lazy"><figcaption>image-20240417164418066</figcaption></figure><ul><li>请求d先删除数据库，在写数据库时出现卡顿</li><li>此时请求c过来查询缓存没有，查询数据库并更新缓存，但此时更新的是旧值，请求d由于卡顿还未更新数据库。</li><li>在请求c更新缓存之后，请求d卡顿结束，写入数据库</li></ul><p>这就造成了数据库时请求d更新的新值，而缓存中是请求c更新的旧值，造成了<code>数据不一致</code>的问题！</p><p>但是这个方案有一个解决方法，就是在请求d写数据库完之后，<code>间隔一段时间</code>再去删除缓存，也就是所谓的 <code>延时双删</code> 的策略！</p><p>值得注意的是，一定要间隔一段时间，在请求c更新缓存之后再去删除，否则没有意义！</p><blockquote><p>这个间隔多长时间根据你具体的业务去考虑</p></blockquote><h4 id="先写数据库-再删缓存" tabindex="-1"><a class="header-anchor" href="#先写数据库-再删缓存"><span>先写数据库，再删缓存</span></a></h4><p>这种方案其实是比较推荐的！</p><figure><img src="'+g+'" alt="image-20240417165601046" tabindex="0" loading="lazy"><figcaption>image-20240417165601046</figcaption></figure><ul><li>请求d先写数据库，由于卡顿未来得及删除缓存</li><li>请求c查询缓存，由于请求d未删除，返回的是旧值</li><li>请求d删除缓存</li></ul><p>这个方案，仅仅是请求c读到了一次旧值，但随之请求d就删除了，相对前面三个比较能接受一些！</p><h4 id="删除失败怎么办" tabindex="-1"><a class="header-anchor" href="#删除失败怎么办"><span>删除失败怎么办</span></a></h4><p>其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：<strong>如果缓存删除失败了，也会导致缓存和数据库的数据不一致</strong></p><p>这种情况就需要使用 <code>重试机制</code> ，当删除失败后，可以立即进行重试，若多次重试之后仍然失败，这是就需要记录给相关人员手工处理了！</p><p>而实现重试机制有很多种方式，常见的有：<code>定时任务、RabbitMQ、binlog日志</code></p><h5 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务"><span>定时任务</span></a></h5><p>1、当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>2、在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为0。然后重试5次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq"><span>RabbitMQ</span></a></h5><ol><li>当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。</li><li>mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入<code>死信队列</code>中。</li><li>由指定的消费者监听<code>死信队列</code> , 若失败5次仍然未成功可以保存到表中通知相关人员做下一步处理！</li></ol><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="binlog" tabindex="-1"><a class="header-anchor" href="#binlog"><span>binlog</span></a></h5><p>无论是定时任务，还是mq（消息队列），做重试机制，对业务都有一定的侵入性。</p><p>其实，还有一种更优雅的实现，即<code>监听binlog</code>，比如使用：<code>canal</code>等中间件。</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>在业务接口中写数据库之后，就不管了，直接返回成功。</li><li>mysql服务器会自动把变更的数据写入binlog中。</li><li>binlog订阅者获取变更的数据，然后删除缓存。</li></ol><p>这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在binlog订阅者中做缓存删除工作。</p><p>但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</p><p>如何解决这个问题呢？</p><p>答：这就需要加上前面聊过的<code>重试机制</code>了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入mq，让mq自动重试。</p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',47),E={},w=(0,i(66262).A)(E,[["render",function(e,a){const i=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[f,(0,t.Lk)("div",u,[b,(0,t.Lk)("p",null,[(0,t.Lk)("a",y,[(0,t.eW)("如何保证数据库和缓存双写一致性？ - 知乎 (zhihu.com)"),(0,t.bF)(i)])])]),x])}]]),z=JSON.parse('{"path":"/Redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html","title":"缓存双写一致性问题","lang":"zh-CN","frontmatter":{"date":"2024-04-17T00:00:00.000Z","category":["Redis"],"tag":["缓存","MySQL","数据一致性"],"editLink":false,"pageview":false,"sticky":true,"order":1,"description":"缓存双写一致性问题 只要使用缓存，就可能涉及到 Redis 缓存与数据库 双存储双写，只要是双写，就一定会有数据一致性的问题！ image-20240416203555111image-20240416203555111 你是如何解决数据一致性问题的？ 采用 双检加锁 策略 多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一...","head":[["meta",{"property":"og:url","content":"https://www.yzgc.top/Redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"鲨瓜"}],["meta",{"property":"og:title","content":"缓存双写一致性问题"}],["meta",{"property":"og:description","content":"缓存双写一致性问题 只要使用缓存，就可能涉及到 Redis 缓存与数据库 双存储双写，只要是双写，就一定会有数据一致性的问题！ image-20240416203555111image-20240416203555111 你是如何解决数据一致性问题的？ 采用 双检加锁 策略 多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-17T10:01:27.000Z"}],["meta",{"property":"article:author","content":"鲨瓜"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"数据一致性"}],["meta",{"property":"article:published_time","content":"2024-04-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-17T10:01:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存双写一致性问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-17T10:01:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鲨瓜\\",\\"url\\":\\"https://www.yzgc.top\\"}]}"]]},"headers":[{"level":3,"title":"你是如何解决数据一致性问题的？","slug":"你是如何解决数据一致性问题的","link":"#你是如何解决数据一致性问题的","children":[]},{"level":3,"title":"你的更新策略是什么？","slug":"你的更新策略是什么","link":"#你的更新策略是什么","children":[]}],"git":{"createdTime":1713348087000,"updatedTime":1713348087000,"contributors":[{"name":"“杨照光”","email":"“yangzhaoguang@ciictec.com”","commits":1}]},"readingTime":{"minutes":5.53,"words":1659},"filePathRelative":"Redis/缓存双写一致性问题.md","localizedDate":"2024年4月17日","excerpt":"\\n<p>只要使用缓存，就可能涉及到 Redis 缓存与数据库 双存储双写，只要是双写，就一定会有<strong>数据一致性</strong>的问题！</p>\\n<figure><figcaption>image-20240416203555111</figcaption></figure>\\n<h3>你是如何解决数据一致性问题的？</h3>\\n<ul>\\n<li>采用 <strong>双检加锁</strong> 策略</li>\\n</ul>\\n<p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 <code>互斥锁</code>来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做<code>缓存</code>。后面的线程进来发现已经有缓存了，就直接走缓存。</p>","autoDesc":true}')}}]);