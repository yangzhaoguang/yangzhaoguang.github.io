const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:n})=>n),bt=et(V(JSON.parse("{\"/\":{\"documentCount\":893,\"nextId\":893,\"documentIds\":{\"0\":\"1\",\"1\":\"1#_1、二叉树递归遍历\",\"2\":\"1#前序遍历\",\"3\":\"1#中序遍历\",\"4\":\"1#后序遍历\",\"5\":\"1#_2、二叉树迭代遍历\",\"6\":\"1#前序遍历-1\",\"7\":\"1#中序遍历-1\",\"8\":\"1#后序遍历-1\",\"9\":\"1#总结\",\"10\":\"1#_3、二叉树的层序遍历\",\"11\":\"1#_102-二叉树的层序遍历-opens-new-window\",\"12\":\"1#思路分析\",\"13\":\"1#_107-二叉树的层序遍历-ii\",\"14\":\"1#思路分析-1\",\"15\":\"1#_199-二叉树的右视图\",\"16\":\"1#思路分析-2\",\"17\":\"1#_637-二叉树的层平均值\",\"18\":\"1#思路分析-3\",\"19\":\"1#_429-n-叉树的层序遍历\",\"20\":\"1#思路分析-4\",\"21\":\"1#_515-在每个树行中找最大值\",\"22\":\"1#思路分析-5\",\"23\":\"1#_116-填充每个节点的下一个右侧节点指针\",\"24\":\"1#思路分析-6\",\"25\":\"1#_104-二叉树的最大深度\",\"26\":\"1#思路分析-7\",\"27\":\"1#_111-二叉树的最小深度\",\"28\":\"1#思路分析-8\",\"29\":\"1#总结-1\",\"30\":\"1#_226-翻转二叉树\",\"31\":\"1#思路分析-9\",\"32\":\"1#_101-对称二叉树\",\"33\":\"1#思路分析-10\",\"34\":\"1#_222-完全二叉树的节点个数\",\"35\":\"1#思路分析-11\",\"36\":\"1#_110-平衡二叉树\",\"37\":\"1#思路分析-12\",\"38\":\"1#☆-257-二叉树的所有路径\",\"39\":\"1#思路分析-13\",\"40\":\"1#_404-左叶子之和\",\"41\":\"1#思路分析-14\",\"42\":\"1#_513-找树左下角的值\",\"43\":\"1#思路分析-15\",\"44\":\"1#_112-路径总和\",\"45\":\"1#思路分析-16\",\"46\":\"1#_106-从中序与后序遍历序列构造二叉树\",\"47\":\"1#思路分析-17\",\"48\":\"1#_105-从前序与中序遍历序列构造二叉树\",\"49\":\"1#思路分析-18\",\"50\":\"1#_654-最大二叉树\",\"51\":\"1#思路分析-19\",\"52\":\"1#_617-合并二叉树\",\"53\":\"1#_700-二叉搜索树中的搜索\",\"54\":\"1#思路分析-20\",\"55\":\"1#_98-验证二叉搜索树\",\"56\":\"1#思路分析-21\",\"57\":\"1#_530-二叉搜索树的最小绝对差\",\"58\":\"1#思路分析-22\",\"59\":\"1#_501-二叉搜索树中的众数\",\"60\":\"1#思路分析-23\",\"61\":\"1#_236-二叉树的最近公共祖先\",\"62\":\"1#思路分析-24\",\"63\":\"1#_235-二叉搜索树的最近公共祖先\",\"64\":\"1#思路分析-25\",\"65\":\"1#_701-二叉搜索树中的插入操作\",\"66\":\"1#思路分析-26\",\"67\":\"1#_450-删除二叉搜索树中的节点\",\"68\":\"1#思路分析-27\",\"69\":\"1#_669-修剪二叉搜索树\",\"70\":\"1#思路分析-28\",\"71\":\"1#_108-将有序数组转换为二叉搜索树\",\"72\":\"1#思路分析-29\",\"73\":\"1#_538-把二叉搜索树转换为累加树\",\"74\":\"1#思路分析-30\",\"75\":\"1@0\",\"76\":\"1@1\",\"77\":\"2\",\"78\":\"2#_509-斐波那契数\",\"79\":\"2#思路分析\",\"80\":\"2#_70-爬楼梯\",\"81\":\"2#思路分析-1\",\"82\":\"2#_746-使用最小花费爬楼梯\",\"83\":\"2#思路分析-2\",\"84\":\"2#_62-不同路径\",\"85\":\"2#思路分析-3\",\"86\":\"2#_343-整数拆分\",\"87\":\"2#思路分析-4\",\"88\":\"2#_96-不同的二叉搜索树\",\"89\":\"2#思路分析-5\",\"90\":\"2#背包问题\",\"91\":\"2#_01背包-二维数组\",\"92\":\"2#_01背包-一维数组\",\"93\":\"2#完全背包\",\"94\":\"2#_416-分割等和子集\",\"95\":\"2#思路分析-6\",\"96\":\"2#_1049-最后一块石头的重量-ii\",\"97\":\"2#思路分析-7\",\"98\":\"2#_494-目标和\",\"99\":\"2#思路分析-8\",\"100\":\"2#_474-一和零\",\"101\":\"2#思路分析-9\",\"102\":\"2#_518-零钱兑换-ii\",\"103\":\"2#思路分析-10\",\"104\":\"2#_377-组合总和-iv\",\"105\":\"2#思路分析-11\",\"106\":\"2#_322-零钱兑换\",\"107\":\"2#思路分析-12\",\"108\":\"2#_279-完全平方数\",\"109\":\"2#思路分析-13\",\"110\":\"2#_139-单词拆分\",\"111\":\"2#思路分析-14\",\"112\":\"2#_198-打家劫舍\",\"113\":\"2#思路分析-15\",\"114\":\"2#_213-打家劫舍-ii\",\"115\":\"2#思路分析-16\",\"116\":\"2#_337-打家劫舍-iii\",\"117\":\"2#思路分析-17\",\"118\":\"2#买卖股票全系列\",\"119\":\"2#_121-买卖股票的最佳时机\",\"120\":\"2#思路分析-18\",\"121\":\"2#_122-买卖股票的最佳时机-ii\",\"122\":\"2#思路分析-19\",\"123\":\"2#_123-买卖股票的最佳时机-iii\",\"124\":\"2#思路分析-20\",\"125\":\"2#_188-买卖股票的最佳时机-iv\",\"126\":\"2#思路分析-21\",\"127\":\"2#_309-买卖股票的最佳时机含冷冻期\",\"128\":\"2#思路分析-22\",\"129\":\"2#_714-买卖股票的最佳时机含手续费\",\"130\":\"2#思路分析-23\",\"131\":\"2#子序列问题\",\"132\":\"2#_300-最长递增子序列\",\"133\":\"2#思路分析-24\",\"134\":\"2#_674-最长连续递增序列\",\"135\":\"2#思路分析-25\",\"136\":\"2#_718-最长重复子数组\",\"137\":\"2#思路分析-26\",\"138\":\"2#_1143-最长公共子序列\",\"139\":\"2#思路分析-27\",\"140\":\"2#_1035-不相交的线\",\"141\":\"2#思路分析-28\",\"142\":\"2#_53-最大子数组和\",\"143\":\"2#思路分析-29\",\"144\":\"2#编辑距离问题\",\"145\":\"2#_392-判断子序列\",\"146\":\"2#思路分析-30\",\"147\":\"2#_115-不同的子序列\",\"148\":\"2#思路分析-31\",\"149\":\"2#_583-两个字符串的删除操作\",\"150\":\"2#思路分析-32\",\"151\":\"2#_72-编辑距离\",\"152\":\"2#思路分析-33\",\"153\":\"2#总结\",\"154\":\"2#_647-回文子串\",\"155\":\"2#思路分析-34\",\"156\":\"2#_516-最长回文子序列\",\"157\":\"2#思路分析-35\",\"158\":\"2@0\",\"159\":\"2@1\",\"160\":\"3\",\"161\":\"3#_242-有效的字母异位词\",\"162\":\"3#思路分析\",\"163\":\"3#代码实现\",\"164\":\"3#_49-字母异位词分组\",\"165\":\"3#思路分析-1\",\"166\":\"3#_349-两个数组的交集\",\"167\":\"3#思路分析-2\",\"168\":\"3#代码实现-1\",\"169\":\"3#_202-快乐数\",\"170\":\"3#思路分析-3\",\"171\":\"3#代码实现-2\",\"172\":\"3#_263-丑数\",\"173\":\"3#思路分析-4\",\"174\":\"3#_1-两数之和\",\"175\":\"3#思路分析-5\",\"176\":\"3#_15-三数之和\",\"177\":\"3#思路分析-6\",\"178\":\"3#_18-四数之和\",\"179\":\"3#思路分析-7\",\"180\":\"3@0\",\"181\":\"3@1\",\"182\":\"4\",\"183\":\"4#简单介绍\",\"184\":\"4#如何理解回溯\",\"185\":\"4#回溯模板\",\"186\":\"4#_77-组合\",\"187\":\"4#思路分析\",\"188\":\"4#剪枝优化\",\"189\":\"4#_216-组合总和-iii\",\"190\":\"4#思路分析-1\",\"191\":\"4#剪枝优化-1\",\"192\":\"4#_17-电话号码的字母组合\",\"193\":\"4#思路分析-2\",\"194\":\"4#_39-组合总和\",\"195\":\"4#思路分析-3\",\"196\":\"4#_40-组合总和-ii\",\"197\":\"4#思路分析-4\",\"198\":\"4#_131-分割回文串\",\"199\":\"4#思路分析-5\",\"200\":\"4#_93-复原-ip-地址\",\"201\":\"4#思路分析-6\",\"202\":\"4#_78-子集\",\"203\":\"4#思路分析-7\",\"204\":\"4#_90-子集-ii\",\"205\":\"4#思路分析-8\",\"206\":\"4#_491-递增子序列\",\"207\":\"4#思路分析-9\",\"208\":\"4#_46-全排列\",\"209\":\"4#思路分析-10\",\"210\":\"4#_47-全排列-ii\",\"211\":\"4#思路分析-11\",\"212\":\"4#_332-重新安排行程\",\"213\":\"4#思路分析-12\",\"214\":\"4#_51-n-皇后\",\"215\":\"4#思路分析-13\",\"216\":\"4#_37-解数独\",\"217\":\"4#思路分析-14\",\"218\":\"4#总结\",\"219\":\"4@0\",\"220\":\"4@1\",\"221\":\"5\",\"222\":\"5#dfs-和-bfs-的区别\",\"223\":\"5#_797-所有可能的路径\",\"224\":\"5#思路分析\",\"225\":\"5#_200-岛屿数量\",\"226\":\"5#思路分析-1\",\"227\":\"5#_695-岛屿的最大面积\",\"228\":\"5#思路分析-2\",\"229\":\"5#_1020-飞地的数量\",\"230\":\"5#思路分析-3\",\"231\":\"5#_130-被围绕的区域\",\"232\":\"5#思路分析-4\",\"233\":\"5#_417-太平洋大西洋水流问题\",\"234\":\"5#思路分\",\"235\":\"5@0\",\"236\":\"5@1\",\"237\":\"6\",\"238\":\"6#双指针系列\",\"239\":\"6#_14-最长公共前缀\",\"240\":\"6#_167-两数之和-ii-输入有序数组\",\"241\":\"6#思路分析\",\"242\":\"6#代码实现\",\"243\":\"6#反转字符串系列\",\"244\":\"6#_151-反转字符串中的单词\",\"245\":\"6#思路分析-1\",\"246\":\"6#_557-反转字符串中的单词-iii\",\"247\":\"6#思路分析-2\",\"248\":\"6#代码实现-1\",\"249\":\"6#_344-反转字符串\",\"250\":\"6#思路分析-3\",\"251\":\"6#代码实现-2\",\"252\":\"6#_541-反转字符串-ii\",\"253\":\"6#思路分析-4\",\"254\":\"6#代码实现-3\",\"255\":\"6#lcr-182-动态口令\",\"256\":\"6#思路分析-5\",\"257\":\"6#_561-数组拆分\",\"258\":\"6#思路分析-6\",\"259\":\"6#代码实现-4\",\"260\":\"6#_5-最长回文子串\",\"261\":\"6#思路分析-7\",\"262\":\"6#代码实现-5\",\"263\":\"6@0\",\"264\":\"6@1\",\"265\":\"7\",\"266\":\"7#_217-存在重复元素\",\"267\":\"7#思路分析\",\"268\":\"7#代码实现\",\"269\":\"7#_704-二分查找\",\"270\":\"7#思路分析-1\",\"271\":\"7#代码实现-1\",\"272\":\"7#相关题目\",\"273\":\"7#_35-搜索插入位置\",\"274\":\"7#_278-第一个错误的版本\",\"275\":\"7#_34-在排序数组中查找元素的第一个和最后一个位置\",\"276\":\"7#_153-寻找旋转排序数组中的最小值\",\"277\":\"7#_33-搜索旋转排序数组\",\"278\":\"7#_27-移除元素\",\"279\":\"7#思路分析-2\",\"280\":\"7#代码实现-2\",\"281\":\"7#_977-有序数组的平方\",\"282\":\"7#思路分析-3\",\"283\":\"7#代码实现-3\",\"284\":\"7#_209-长度最小的子数组\",\"285\":\"7#思路分析-4\",\"286\":\"7#代码实现-4\",\"287\":\"7#_59-螺旋矩阵-ii\",\"288\":\"7#思路分析-5\",\"289\":\"7#代码实现-5\",\"290\":\"7#_1991-寻找数组的中心索引\",\"291\":\"7#思路分析-6\",\"292\":\"7#代码实现-6\",\"293\":\"7#优化\",\"294\":\"7#_56-合并区间\",\"295\":\"7#思路分析-7\",\"296\":\"7#代码实现-7\",\"297\":\"7#_48-旋转图像\",\"298\":\"7#第一种方法-使用辅助矩阵\",\"299\":\"7#第二种方法-原地修改\",\"300\":\"7#面试题-01-08-零矩阵\",\"301\":\"7#思路分析-8\",\"302\":\"7#代码实现-8\",\"303\":\"7#_498-对角线遍历\",\"304\":\"7#思路分析-9\",\"305\":\"7#代码实现-9\",\"306\":\"7#_485-最大连续-1-的个数\",\"307\":\"7#思路分析-10\",\"308\":\"7#代码实现-10\",\"309\":\"7#_118-杨辉三角\",\"310\":\"7#思路分析-11\",\"311\":\"7#代码实现-11\",\"312\":\"7#_26-删除有序数组中的重复项\",\"313\":\"7#思路分析-12\",\"314\":\"7#代码实现-12\",\"315\":\"7#_283-移动零\",\"316\":\"7#思路分析-13\",\"317\":\"7#代码实现-13\",\"318\":\"7@0\",\"319\":\"7@1\",\"320\":\"8\",\"321\":\"8#_232-用栈实现队列\",\"322\":\"8#思路分析\",\"323\":\"8#代码实现\",\"324\":\"8#_20-有效的括号\",\"325\":\"8#思路分析-1\",\"326\":\"8#代码实现-1\",\"327\":\"8#_1047-删除字符串中的所有相邻重复项\",\"328\":\"8#思路分析-2\",\"329\":\"8#代码实现-2\",\"330\":\"8#_150-逆波兰表达式求值\",\"331\":\"8#思路分析-3\",\"332\":\"8#代码实现-3\",\"333\":\"8#☆239-滑动窗口最大值\",\"334\":\"8#思路分析-4\",\"335\":\"8#代码实现-4\",\"336\":\"8#_347-前-k-个高频元素\",\"337\":\"8#思路分析-5\",\"338\":\"8#代码实现-5\",\"339\":\"8#总结\",\"340\":\"8@0\",\"341\":\"8@1\",\"342\":\"9\",\"343\":\"9#_455-分发饼干\",\"344\":\"9#思路分析\",\"345\":\"9#_376-摆动序列\",\"346\":\"9#思路分析-1\",\"347\":\"9#_53-最大子数组和\",\"348\":\"9#思路分析-2\",\"349\":\"9#_55-跳跃游戏\",\"350\":\"9#思路分析-3\",\"351\":\"9#_45-跳跃游戏-ii\",\"352\":\"9#思路分析-4\",\"353\":\"9#_1005-k-次取反后最大化的数组和\",\"354\":\"9#思路分析-5\",\"355\":\"9#_134-加油站\",\"356\":\"9#思路分析-6\",\"357\":\"9#_860-柠檬水找零\",\"358\":\"9#思路分析-7\",\"359\":\"9#_135-分发糖果\",\"360\":\"9#思路分析-8\",\"361\":\"9#_406-根据身高重建队列\",\"362\":\"9#思路分析-9\",\"363\":\"9#_452-用最少数量的箭引爆气球\",\"364\":\"9#思路分析-10\",\"365\":\"9#_435-无重叠区间\",\"366\":\"9#思路分析-11\",\"367\":\"9#_763-划分字母区间\",\"368\":\"9#思路分析-12\",\"369\":\"9#_738-单调递增的数字\",\"370\":\"9#思路分析-13\",\"371\":\"9#_968-监控二叉树\",\"372\":\"9#思路分析-14\",\"373\":\"9@0\",\"374\":\"9@1\",\"375\":\"10\",\"376\":\"10#_203-移除链表元素\",\"377\":\"10#思路分析\",\"378\":\"10#代码实现\",\"379\":\"10#_237-删除链表中的节点\",\"380\":\"10#_206-反转链表\",\"381\":\"10#思路分析-1\",\"382\":\"10#代码实现-1\",\"383\":\"10#_92-反转链表-ii\",\"384\":\"10#思路分析-2\",\"385\":\"10#_24-两两交换链表中的节点\",\"386\":\"10#思路分析-3\",\"387\":\"10#代码实现-2\",\"388\":\"10#_19-删除链表的倒数第-n-个结点\",\"389\":\"10#思路分析-4\",\"390\":\"10#面试题-02-07-链表相交\",\"391\":\"10#思路分析-5\",\"392\":\"10#代码实现-3\",\"393\":\"10#_142-环形链表-ii\",\"394\":\"10#思路分析-6\",\"395\":\"10#代码实现-4\",\"396\":\"10@0\",\"397\":\"10@1\",\"398\":\"11\",\"399\":\"11#一、简介\",\"400\":\"11#二、服务注册-配置nacos\",\"401\":\"11#_2-1-下载启动\",\"402\":\"11#_2-2-服务注册\",\"403\":\"11#_2-3-服务配置\",\"404\":\"11#_2-3-1-namespace-groupid-dataid\",\"405\":\"11#三、熔断限流-sentinel\",\"406\":\"11#_3-1-介绍\",\"407\":\"11#_3-2-下载安装\",\"408\":\"11#_3-3-如何使用\",\"409\":\"11#_3-3-1-流控规则\",\"410\":\"11#流控模式\",\"411\":\"11#流控效果\",\"412\":\"11#_3-3-2-熔断规则\",\"413\":\"11#慢调用比例\",\"414\":\"11#异常比例\",\"415\":\"11#异常数\",\"416\":\"11#_3-3-3-sentinelresource\",\"417\":\"11#_3-3-4-热点规则\",\"418\":\"11#_3-3-5-授权规则\",\"419\":\"11#_3-3-6-持久化规则\",\"420\":\"11#_3-4-sentinel-整合openfeign\",\"421\":\"11#_3-5-sentinel整合gateway\",\"422\":\"11#控制台方式\",\"423\":\"11#配置类方式\",\"424\":\"11#持久化规则\",\"425\":\"11#四、seata\",\"426\":\"11#_4-1-介绍\",\"427\":\"11#_4-2-下载\",\"428\":\"11#_4-2-1-数据库准备\",\"429\":\"11#_4-2-2-配置\",\"430\":\"11#_4-3-案例搭建\",\"431\":\"11#数据库创建\",\"432\":\"11#新建订单-order-微服务\",\"433\":\"11#新建库存-storage-微服务\",\"434\":\"11#新建库存-account-微服务\",\"435\":\"11#测试\",\"436\":\"11#_4-4-seata-原理\",\"437\":\"11@0\",\"438\":\"11@1\",\"439\":\"12\",\"440\":\"12#一、搭建示例项目\",\"441\":\"12#_1-1-环境搭建\",\"442\":\"12#_1-2-mapper4一键生成\",\"443\":\"12#_1-3-新建支付模块\",\"444\":\"12#_1-4-解决时间格式、同一返回结果\",\"445\":\"12#_1-5-全局异常处理\",\"446\":\"12#_1-6-新建订单模块\",\"447\":\"12#_1-7-目前项目存在的问题\",\"448\":\"12#二、consul\",\"449\":\"12#_2-1-介绍、安装\",\"450\":\"12#_2-2-服务注册\",\"451\":\"12#_2-3-小问题\",\"452\":\"12#_2-4-分布式配置\",\"453\":\"12#_2-5-动态刷新\",\"454\":\"12#_2-6-配置持久化\",\"455\":\"12#三、服务调用\",\"456\":\"12#_3-1-loadbalance\",\"457\":\"12#_3-1-1-介绍\",\"458\":\"12#_3-1-2-如何使用\",\"459\":\"12#_3-1-3-案例演示\",\"460\":\"12#_3-1-4-负载均衡原理\",\"461\":\"12#_3-2-openfeign\",\"462\":\"12#_3-2-1-介绍\",\"463\":\"12#_3-2-2-如何使用\",\"464\":\"12#_3-2-3-案例演示\",\"465\":\"12#_3-2-4-高级特性\",\"466\":\"12#_1、超时控制\",\"467\":\"12#_2、重试机制\",\"468\":\"12#_3、默认httpclient修改\",\"469\":\"12#_4、请求-响应压缩\",\"470\":\"12#_5、日志打印功能\",\"471\":\"12#四、熔断降级\",\"472\":\"12#_4-1-概念介绍\",\"473\":\"12#_4-2-resilience4j\",\"474\":\"12#_4-2-1-介绍\",\"475\":\"12#_4-2-2-熔断机制\",\"476\":\"12#_1、断路器配置参数\",\"477\":\"12#_2、基于调用数量统计的案例演示\",\"478\":\"12#_3、基于调用时间-统计的案例演示\",\"479\":\"12#_4-2-3-隔离\",\"480\":\"12#_1、semaphorebulkhead\",\"481\":\"12#_2、fixedthreadpoolbulkhead\",\"482\":\"12#_4-2-4-限流\",\"483\":\"12#五、分布式链路追踪\",\"484\":\"12#_5-1-micrometer-zipkin\",\"485\":\"12#_5-1-1-下载-zipkin\",\"486\":\"12#_5-1-2-搭建链路监控\",\"487\":\"12#六、gateway-网关\",\"488\":\"12#_6-1-gateway-三大核心\",\"489\":\"12#_6-2-简单配置\",\"490\":\"12#_6-3-高级特性\",\"491\":\"12#_6-3-1-predicate断言\",\"492\":\"12#_1-after、before、between\",\"493\":\"12#_2-cookie、header、host、path\",\"494\":\"12#_3-query\",\"495\":\"12#_4-remoteaddr\",\"496\":\"12#_5-methods\",\"497\":\"12#_6-自定义predicate断言\",\"498\":\"12#_6-3-2-filter过滤器\",\"499\":\"12#_1-请求头相关\",\"500\":\"12#_2-请求参数相关\",\"501\":\"12#_3-回应头相关\",\"502\":\"12#_4-前缀和路径相关\",\"503\":\"12#_5-自定义全局过滤器\",\"504\":\"12#_6-自定义单一内置过滤器\",\"505\":\"12@0\",\"506\":\"12@1\",\"507\":\"13\",\"508\":\"13#_1-1-rdbms-和-非-rdbms\",\"509\":\"13#_1-1-1-关系型数据库-rdbms\",\"510\":\"13#_1-1-2-非关系型数据库-非rdbms\",\"511\":\"13#_1-2-关系型数据库的设计规则\",\"512\":\"13#_1-2-1-表、记录、字段\",\"513\":\"13#_1-2-2-表的关联关系\",\"514\":\"13@0\",\"515\":\"13@1\",\"516\":\"14\",\"517\":\"14#_2-1-sql的分类\",\"518\":\"14#_2-2-sql规范\",\"519\":\"14#_2-3-dml中的select\",\"520\":\"14#_2-3-1-基本select\",\"521\":\"14#_1-列的别名\",\"522\":\"14#_2-去掉重复行\",\"523\":\"14#_3-空值参与运算\",\"524\":\"14#_4-着重号\",\"525\":\"14#_2-3-2-过滤器where\",\"526\":\"14#_2-3-3-运算符\",\"527\":\"14#算数运算符\",\"528\":\"14#比较运算符\",\"529\":\"14#符号运算符\",\"530\":\"14#逻辑运算符\",\"531\":\"14#位运算符\",\"532\":\"14#_2-3-4-多表查询\",\"533\":\"14#_1-等值连接\",\"534\":\"14#_2-非等值连接\",\"535\":\"14#_3-非自连接\",\"536\":\"14#_4-自连接\",\"537\":\"14#_5-内连接-vs-外连接\",\"538\":\"14#内连接\",\"539\":\"14#外连接\",\"540\":\"14#union-all\",\"541\":\"14#七种join的使用\",\"542\":\"14#_2-4-dml之增删改\",\"543\":\"14@0\",\"544\":\"14@1\",\"545\":\"15\",\"546\":\"15#_3-1-单行函数\",\"547\":\"15#_3-1-1-数值函数\",\"548\":\"15#_1-基本函数\",\"549\":\"15#_2-三角函数\",\"550\":\"15#_4-指数和对数\",\"551\":\"15#_5-进制间的转换\",\"552\":\"15#_3-1-2-字符串函数\",\"553\":\"15#_3-1-3-日期函数\",\"554\":\"15#_1-获取日期、时间\",\"555\":\"15#_2-获取月份、星期、星期数、天数等函数\",\"556\":\"15#_3-时间和秒钟的转换\",\"557\":\"15#_4-计算日期和时间的函数\",\"558\":\"15#_5-日期的格式化与解析\",\"559\":\"15#_3-1-4-流程控制函数\",\"560\":\"15#_3-2-多行函数\",\"561\":\"15#_3-2-1-聚合函数\",\"562\":\"15#_1-常用的聚合函数\",\"563\":\"15#_2-group-by\",\"564\":\"15#_3-havign\",\"565\":\"15#_4-sql的完整结构及执行原理\",\"566\":\"15@0\",\"567\":\"15@1\",\"568\":\"16\",\"569\":\"16#_4-1-提出需求并解决\",\"570\":\"16#_4-2-子查询的分类\",\"571\":\"16#_4-2-1-单行子查询\",\"572\":\"16#_1-单行比较操作符\",\"573\":\"16#_2-案例\",\"574\":\"16#_3-having中的子查询\",\"575\":\"16#_4-case-中的子查询\",\"576\":\"16#_4-2-2-多行子查询\",\"577\":\"16#_1-多行比较操作符\",\"578\":\"16#_2-案例-1\",\"579\":\"16#_4-2-3-相关子查询\",\"580\":\"16@0\",\"581\":\"16@1\",\"582\":\"17\",\"583\":\"17#_5-1-标识符命名规则\",\"584\":\"17#_5-2-创建和管理数据库\",\"585\":\"17#_5-2-1-创建数据库\",\"586\":\"17#_5-2-2-管理数据库\",\"587\":\"17#_5-2-3-创建表\",\"588\":\"17#_5-2-4-修改表\",\"589\":\"17#_5-2-5-truncate-与-delete-对比\",\"590\":\"17@0\",\"591\":\"17@1\",\"592\":\"18\",\"593\":\"18#_6-1-整型\",\"594\":\"18#_6-1-1-可选属性\",\"595\":\"18#_1-m\",\"596\":\"18#_2-unsigend\",\"597\":\"18#_3-zerofill\",\"598\":\"18#_6-1-2-适用场景\",\"599\":\"18#_6-2-浮点类型\",\"600\":\"18#_6-3-定点数类型\",\"601\":\"18#_6-4-位类型\",\"602\":\"18#_6-5-日期和时间类型\",\"603\":\"18#_6-6-文本字符串类型\",\"604\":\"18#_6-6-1-char-与-varchar\",\"605\":\"18#_6-6-2-text-类型\",\"606\":\"18#_6-6-3-enum-类型\",\"607\":\"18#_6-6-4-set-类型\",\"608\":\"18#_6-6-5-json-类型\",\"609\":\"18@0\",\"610\":\"18@1\",\"611\":\"19\",\"612\":\"19#_7-1-约束概念\",\"613\":\"19#_7-2-约束的分类\",\"614\":\"19#_7-2-1-非空约束\",\"615\":\"19#_7-2-2-唯一性约束\",\"616\":\"19#_7-2-3-主键约束\",\"617\":\"19#_7-2-4-自增列\",\"618\":\"19#_7-2-5-外键约束\",\"619\":\"19#_7-2-6-check约束\",\"620\":\"19#_7-2-7-default-约束\",\"621\":\"19@0\",\"622\":\"19@1\",\"623\":\"20\",\"624\":\"20#_8-1-逻辑架构剖析\",\"625\":\"20#_8-1-1-第一层-连接层\",\"626\":\"20#_8-1-2-第二层-服务层\",\"627\":\"20#sql接口\",\"628\":\"20#parser-解析器\",\"629\":\"20#optimizer-查询优化器\",\"630\":\"20#caches-buffers-查询缓存组件\",\"631\":\"20#_8-1-3-第三层-引擎层\",\"632\":\"20#_8-1-4-第四层-存储层\",\"633\":\"20#总结\",\"634\":\"20#_8-2-sql执行流程\",\"635\":\"20#_8-3-存储引擎\",\"636\":\"20#_8-3-1-innodb引擎\",\"637\":\"20#_8-3-2-myisam引擎\",\"638\":\"20@0\",\"639\":\"20@1\",\"640\":\"21\",\"641\":\"21#_9-1-为什么要使用索引\",\"642\":\"21#_9-2-索引的特点及优缺点\",\"643\":\"21#_9-3-一个简单索引的设计方案\",\"644\":\"21#_9-4-innodb中的索引方案\",\"645\":\"21#_9-4-1-目录项记录的页\",\"646\":\"21#_9-4-2-多个目录项记录的页\",\"647\":\"21#_9-4-3-目录项记录页得目录页\",\"648\":\"21#_9-4-4-b-tree\",\"649\":\"21#_9-5-常见索引概念\",\"650\":\"21#_9-5-1-聚簇索引\",\"651\":\"21#_9-5-2-二级索引-辅助索引、非聚簇索引\",\"652\":\"21#_9-5-3-联合索引\",\"653\":\"21#_9-6-myisam索中的索引方案\",\"654\":\"21#_9-6-1-myisam索引原理\",\"655\":\"21#_9-7-innodb引擎与myisam引擎对比\",\"656\":\"21#_9-8-索引的代价\",\"657\":\"21#_9-9-mysql数据结构选择的合理性\",\"658\":\"21#_1-hash结构\",\"659\":\"21#_2-二叉搜索树\",\"660\":\"21#_3-avl\",\"661\":\"21#_4-b-tree\",\"662\":\"21#_5-b-tree\",\"663\":\"21@0\",\"664\":\"21@1\",\"665\":\"22\",\"666\":\"22#_10-1-磁盘与内存交互的基本单位-页\",\"667\":\"22#_10-2-数据页的内部结构\",\"668\":\"22#_10-2-1-文件头\",\"669\":\"22#_10-2-2-文件尾\",\"670\":\"22#_10-2-3-free-space-空闲空间\",\"671\":\"22#_10-2-4-user-records-用户记录\",\"672\":\"22#_10-2-5-infimum-supremum-最小最大记录\",\"673\":\"22#_10-2-6-page-directory-页目录\",\"674\":\"22#_10-2-7-page-header-页面头部\",\"675\":\"22#_10-3-innodb-行格式\",\"676\":\"22#_10-3-1-指定行格式的语法\",\"677\":\"22#_10-3-1-compact行格式\",\"678\":\"22#变长字段长度列表\",\"679\":\"22#null值列表\",\"680\":\"22#记录头像信息\",\"681\":\"22#记录的真实数据\",\"682\":\"22@0\",\"683\":\"22@1\",\"684\":\"23\",\"685\":\"23#_11-1-索引的声明与使用\",\"686\":\"23#_11-1-1-索引的分类\",\"687\":\"23#_11-1-2-增加、删除索引\",\"688\":\"23#_11-1-3-索引的设计原则\",\"689\":\"23#_1-哪些情况适合创建索引\",\"690\":\"23#_2-哪些情况不适合创建索引\",\"691\":\"23@0\",\"692\":\"23@1\",\"693\":\"24\",\"694\":\"24#_12-1-数据库服务器的优化步骤\",\"695\":\"24#_12-2-查看系统性能参数\",\"696\":\"24#_12-3-统计sql的查询成本-last-query-cost\",\"697\":\"24#_12-4-定位执行慢的sql-慢查询日志\",\"698\":\"24#_12-4-1-开启-关闭-删除-慢查询日志\",\"699\":\"24#_12-4-2-慢查询日志分析工具-mysqldumpslow\",\"700\":\"24#_12-5-分析查询语句\",\"701\":\"24#_12-5-1-table\",\"702\":\"24#_12-5-2-id\",\"703\":\"24#_12-5-3-select-type\",\"704\":\"24#_12-5-4-type△\",\"705\":\"24#_12-5-5-possible-keys和key\",\"706\":\"24#_12-5-6-key-len-☆\",\"707\":\"24#_12-5-7-ref\",\"708\":\"24#_12-5-8-rows\",\"709\":\"24#_12-5-9-filtered\",\"710\":\"24#_12-5-10-extra-☆\",\"711\":\"24@0\",\"712\":\"24@1\",\"713\":\"25\",\"714\":\"25#_13-1-索引失效的11种情况\",\"715\":\"25#_1、全值匹配\",\"716\":\"25#_2、最佳左前缀法则\",\"717\":\"25#_3、计算、函数、类型转换导致索引失效\",\"718\":\"25#_4、范围条件右边的列索引失效\",\"719\":\"25#_5、不等于-或者-索引失效\",\"720\":\"25#_6、isnull-可使用索引-is-not-null无法使用\",\"721\":\"25#_7、like以通配符-开头索引失\",\"722\":\"25#_8、or-前后存在非索引的列-索引失效\",\"723\":\"25#_13-2-关联查询的优化\",\"724\":\"25#_13-3-子查询优化\",\"725\":\"25#_13-4-排序优化\",\"726\":\"25#_13-5-group-by-和-分页优化\",\"727\":\"25#_13-6-优先考虑覆盖索引\",\"728\":\"25#_13-7-索引下推\",\"729\":\"25#_13-8-其他优化策略\",\"730\":\"25#_13-9-主键的设计\",\"731\":\"25#_13-9-1-自增id的问题\",\"732\":\"25#_13-9-2-业务字段做主键\",\"733\":\"25#_13-9-3-推荐的主键设计\",\"734\":\"25@0\",\"735\":\"25@1\",\"736\":\"26\",\"737\":\"26#_14-1-数据库范式\",\"738\":\"26@0\",\"739\":\"26@1\",\"740\":\"27\",\"741\":\"27#_15-1-事务概述\",\"742\":\"27#_15-3-事务的状态\",\"743\":\"27#_15-4-如何使用事务\",\"744\":\"27#_15-4-1-显示事务\",\"745\":\"27#_15-4-2-隐式事务\",\"746\":\"27#_15-5-事务的隔离级别\",\"747\":\"27#_15-6-事务日志\",\"748\":\"27#_15-6-1-redo-日志\",\"749\":\"27#_1-为什么需要-redo-日志呢\",\"750\":\"27#_2-好处、特点\",\"751\":\"27#_3-redo组成\",\"752\":\"27#_4-redo整体流程\",\"753\":\"27#_5-redo-刷盘策略\",\"754\":\"27#_15-6-2-undo-日志\",\"755\":\"27#_1-如何理解undo日志\",\"756\":\"27#_2-undo日志的作用\",\"757\":\"27#_3-undo-日志生命周期\",\"758\":\"27@0\",\"759\":\"27@1\",\"760\":\"28\",\"761\":\"28#_16-1-并发事务访问相同的记录\",\"762\":\"28#_16-1-1-读读的情况\",\"763\":\"28#_16-1-2-写写的情况\",\"764\":\"28#_16-1-3-读写或写读的情况\",\"765\":\"28#_16-1-4-并发问题的解决方案\",\"766\":\"28#_16-2-锁的不同角度的分类\",\"767\":\"28#_16-2-1-读锁、写锁\",\"768\":\"28#_16-2-2-表级锁、页锁、行级锁\",\"769\":\"28#_1-表级锁\",\"770\":\"28#_1-表级别的s锁、x锁\",\"771\":\"28#_1-意向锁\",\"772\":\"28#_3-自增锁\",\"773\":\"28#_4-元数据锁-mdl\",\"774\":\"28#_2-innodb中的行锁\",\"775\":\"28#_1-记录锁-record-locks\",\"776\":\"28#_2-间隙锁-gap-locks\",\"777\":\"28#_3-临键锁-next-key-locks\",\"778\":\"28#_4-插入意向锁-insert-intention-locks\",\"779\":\"28#_16-2-3-页锁\",\"780\":\"28#_1、悲观锁、乐观锁\",\"781\":\"28#悲观锁\",\"782\":\"28#乐观锁\",\"783\":\"28#俩种锁的使用场景\",\"784\":\"28#_16-2-4-其他锁\",\"785\":\"28#_1、全局锁\",\"786\":\"28#_2、死锁\",\"787\":\"28@0\",\"788\":\"28@1\",\"789\":\"29\",\"790\":\"29#_17-1-什么是mvcc\",\"791\":\"29#_17-2-快照读和当前读\",\"792\":\"29#_17-3-复习\",\"793\":\"29#_17-3-1-再谈隔离级别\",\"794\":\"29#_17-3-2-隐藏字段、undo日志版本链\",\"795\":\"29#_17-4-mvcc实现原理之readview\",\"796\":\"29#_17-4-1-什么是readview\",\"797\":\"29#_17-4-2-设计思路\",\"798\":\"29#_17-4-3-readview规则\",\"799\":\"29#_17-4-4-mvcc整体操作流程\",\"800\":\"29#_17-5-如何解决幻读\",\"801\":\"29#_17-6-总结\",\"802\":\"29@0\",\"803\":\"29@1\",\"804\":\"30\",\"805\":\"30#_18-1-日志类型\",\"806\":\"30#_18-2-通用查询日志\",\"807\":\"30#_18-3-错误日志\",\"808\":\"30#_18-4-二进制日志-bin-log\",\"809\":\"30#_18-4-1-使用命令\",\"810\":\"30#_18-4-2-写入机制\",\"811\":\"30#_18-4-3-binlog-和-redolog对比\",\"812\":\"30#_18-4-4-俩阶段提交\",\"813\":\"30#_18-5-中继日志-relay-log\",\"814\":\"30@0\",\"815\":\"30@1\",\"816\":\"31\",\"817\":\"31#_19-1-主从复制的概述\",\"818\":\"31#_19-1-1-如何提升数据库的并发能力\",\"819\":\"31#_19-1-2-主从复制的作用\",\"820\":\"31#_19-2-主从复制的原理\",\"821\":\"31#_19-3-一主一从搭建\",\"822\":\"31#_19-3-1-准备工作\",\"823\":\"31#_19-3-2-主机配置文件\",\"824\":\"31#_19-3-3-从机配置文件\",\"825\":\"31#_19-3-4-主机-建立账户并授权\",\"826\":\"31#_19-3-5-从机-配置需要复制的主机\",\"827\":\"31#_19-3-5-停止复制\",\"828\":\"31@0\",\"829\":\"31@1\",\"830\":\"32\",\"831\":\"32#_20-1-逻辑备份\",\"832\":\"32#_20-2-逻辑恢复\",\"833\":\"32@0\",\"834\":\"32@1\",\"835\":\"33\",\"836\":\"33#阿里巴巴字段命名规范\",\"837\":\"33#阿里巴巴外键规范\",\"838\":\"33@0\",\"839\":\"33@1\",\"840\":\"34\",\"841\":\"34@0\",\"842\":\"34@1\",\"843\":\"35\",\"844\":\"35#你是如何解决数据一致性问题的\",\"845\":\"35#你的更新策略是什么\",\"846\":\"35#先写缓存-再写数据库\",\"847\":\"35#先写数据库-再写缓存\",\"848\":\"35#先删缓存-再写数据库\",\"849\":\"35#先写数据库-再删缓存\",\"850\":\"35#删除失败怎么办\",\"851\":\"35#定时任务\",\"852\":\"35#rabbitmq\",\"853\":\"35#binlog\",\"854\":\"35@0\",\"855\":\"35@1\",\"856\":\"36\",\"857\":\"36@0\",\"858\":\"37\",\"859\":\"37@0\",\"860\":\"37@1\",\"861\":\"38\",\"862\":\"38@0\",\"863\":\"38@1\",\"864\":\"39\",\"865\":\"39#markdown-介绍\",\"866\":\"39#markdown-配置\",\"867\":\"39#markdown-扩展\",\"868\":\"39#vuepress-扩展\",\"869\":\"39#主题扩展\",\"870\":\"39#提示容器\",\"871\":\"39#代码块\",\"872\":\"39#上下角标\",\"873\":\"39#自定义对齐\",\"874\":\"39#attrs\",\"875\":\"39#脚注\",\"876\":\"39#标记\",\"877\":\"39#任务列表\",\"878\":\"39#图片增强\",\"879\":\"39#组件\",\"880\":\"39@0\",\"881\":\"39@1\",\"882\":\"40\",\"883\":\"40#页面标题\",\"884\":\"40#页面信息\",\"885\":\"40#页面内容\",\"886\":\"40#组件\",\"887\":\"40@0\",\"888\":\"40@1\",\"889\":\"41\",\"890\":\"42\",\"891\":\"43\",\"892\":\"44\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,43],\"1\":[2,6],\"2\":[1,33],\"3\":[1,25],\"4\":[1,22],\"5\":[2,7],\"6\":[1,43],\"7\":[1,57],\"8\":[1,53],\"9\":[1,5],\"10\":[2],\"11\":[1,28],\"12\":[1,188],\"13\":[1,28],\"14\":[1,39],\"15\":[1,22],\"16\":[1,48],\"17\":[1,37],\"18\":[1,47],\"19\":[1,38],\"20\":[1,48],\"21\":[1,23],\"22\":[1,50],\"23\":[1,60],\"24\":[1,47],\"25\":[1,28],\"26\":[1,41],\"27\":[1,31],\"28\":[1,47],\"29\":[1,31],\"30\":[1,24],\"31\":[1,54],\"32\":[1,26],\"33\":[1,88],\"34\":[1,36],\"35\":[1,46],\"36\":[1,32],\"37\":[1,67],\"38\":[1,27],\"39\":[1,104],\"40\":[1,31],\"41\":[1,46],\"42\":[1,28],\"43\":[1,56],\"44\":[1,50],\"45\":[1,49],\"46\":[1,35],\"47\":[1,78],\"48\":[1,35],\"49\":[1,70],\"50\":[1,47],\"51\":[1,52],\"52\":[1,54],\"53\":[1,32],\"54\":[1,61],\"55\":[1,36],\"56\":[1,55],\"57\":[1,28],\"58\":[1,57],\"59\":[1,42],\"60\":[1,92],\"61\":[1,49],\"62\":[1,69],\"63\":[1,43],\"64\":[1,30],\"65\":[1,54],\"66\":[1,43],\"67\":[1,54],\"68\":[1,72],\"69\":[1,43],\"70\":[1,70],\"71\":[1,36],\"72\":[1,41],\"73\":[1,70],\"74\":[1,42],\"75\":[null,null,1],\"76\":[null,null,4],\"77\":[1,13],\"78\":[1,30],\"79\":[1,36],\"80\":[1,23],\"81\":[1,59],\"82\":[1,42],\"83\":[1,66],\"84\":[1,36],\"85\":[1,57],\"86\":[1,27],\"87\":[1,61],\"88\":[1,21],\"89\":[1,63],\"90\":[1,12],\"91\":[2,117],\"92\":[1,74],\"93\":[1,37],\"94\":[1,29],\"95\":[1,95],\"96\":[1,57],\"97\":[1,89],\"98\":[1,40],\"99\":[1,86],\"100\":[1,53],\"101\":[1,63],\"102\":[1,40],\"103\":[1,74],\"104\":[1,41],\"105\":[1,62],\"106\":[1,30],\"107\":[1,64],\"108\":[1,33],\"109\":[1,49],\"110\":[1,48],\"111\":[1,72],\"112\":[1,38],\"113\":[1,46],\"114\":[1,39],\"115\":[1,84],\"116\":[1,43],\"117\":[1,123],\"118\":[1],\"119\":[1,48],\"120\":[1,70],\"121\":[1,52],\"122\":[1,95],\"123\":[1,46],\"124\":[1,65],\"125\":[1,43],\"126\":[1,70],\"127\":[1,35],\"128\":[1,46],\"129\":[1,43],\"130\":[1,29],\"131\":[1],\"132\":[1,36],\"133\":[1,47],\"134\":[1,42],\"135\":[1,29],\"136\":[1,27],\"137\":[1,67],\"138\":[1,45],\"139\":[1,57],\"140\":[1,48],\"141\":[1,47],\"142\":[1,30],\"143\":[1,49],\"144\":[1],\"145\":[1,56],\"146\":[1,79],\"147\":[1,37],\"148\":[1,74],\"149\":[1,29],\"150\":[1,44],\"151\":[1,50],\"152\":[1,92],\"153\":[1,114],\"154\":[1,34],\"155\":[1,107],\"156\":[1,25],\"157\":[1,60],\"158\":[null,null,1],\"159\":[null,null,1],\"160\":[1],\"161\":[1,30],\"162\":[1,22],\"163\":[1,52],\"164\":[1,29],\"165\":[1,57],\"166\":[1,29],\"167\":[1,7],\"168\":[1,30],\"169\":[1,41],\"170\":[1,37],\"171\":[1,38],\"172\":[1,35],\"173\":[1,41],\"174\":[1,40],\"175\":[1,63],\"176\":[1,36],\"177\":[1,116],\"178\":[1,35],\"179\":[1,70],\"180\":[null,null,1],\"181\":[null,null,1],\"182\":[1],\"183\":[1,28],\"184\":[1,14],\"185\":[1,42],\"186\":[1,21],\"187\":[1,103],\"188\":[1,65],\"189\":[1,39],\"190\":[1,78],\"191\":[1,64],\"192\":[1,42],\"193\":[1,140],\"194\":[1,53],\"195\":[1,65],\"196\":[1,29],\"197\":[1,72],\"198\":[1,24],\"199\":[1,91],\"200\":[1,60],\"201\":[1,106],\"202\":[1,26],\"203\":[1,72],\"204\":[1,24],\"205\":[1,63],\"206\":[1,27],\"207\":[1,96],\"208\":[1,23],\"209\":[1,66],\"210\":[1,17],\"211\":[1,111],\"212\":[1,51],\"213\":[1,92],\"214\":[1,32],\"215\":[1,102],\"216\":[1,41],\"217\":[1,92],\"218\":[1,37],\"219\":[null,null,1],\"220\":[null,null,1],\"221\":[1],\"222\":[4,89],\"223\":[1,41],\"224\":[1,61],\"225\":[1,32],\"226\":[1,80],\"227\":[1,47],\"228\":[1,66],\"229\":[1,48],\"230\":[1,67],\"231\":[1,45],\"232\":[1,68],\"233\":[1,63],\"234\":[1,73],\"235\":[null,null,1],\"236\":[null,null,1],\"237\":[1],\"238\":[1],\"239\":[1,1],\"240\":[1,52],\"241\":[1,31],\"242\":[1,27],\"243\":[1],\"244\":[1,46],\"245\":[1,62],\"246\":[1,36],\"247\":[1,4],\"248\":[1,21],\"249\":[1,32],\"250\":[1,16],\"251\":[1,21],\"252\":[1,28],\"253\":[1,17],\"254\":[1,43],\"255\":[1,27],\"256\":[1,51],\"257\":[1,48],\"258\":[1,7],\"259\":[1,21],\"260\":[1,24],\"261\":[1,71],\"262\":[1,41],\"263\":[null,null,1],\"264\":[null,null,2],\"265\":[1],\"266\":[2,17],\"267\":[1,21],\"268\":[1,23],\"269\":[2,38],\"270\":[1,22],\"271\":[1,63],\"272\":[1],\"273\":[2,106],\"274\":[1,70],\"275\":[1,78],\"276\":[1,131],\"277\":[1,108],\"278\":[1,63],\"279\":[1,50],\"280\":[1,38],\"281\":[2,31],\"282\":[1,33],\"283\":[1,36],\"284\":[2,30],\"285\":[1,15],\"286\":[1,43],\"287\":[3,25],\"288\":[1,37],\"289\":[1,43],\"290\":[2,45],\"291\":[1,13],\"292\":[1,32],\"293\":[1,33],\"294\":[1,37],\"295\":[1,30],\"296\":[1,44],\"297\":[1,44],\"298\":[2,52],\"299\":[2,111],\"300\":[1,15],\"301\":[1,7],\"302\":[1,33],\"303\":[1,30],\"304\":[1,104],\"305\":[1,39],\"306\":[1,24],\"307\":[1,17],\"308\":[1,31],\"309\":[1,23],\"310\":[1,7],\"311\":[1,37],\"312\":[1,69],\"313\":[1,66],\"314\":[1,25],\"315\":[1,25],\"316\":[1,6],\"317\":[1,26],\"318\":[null,null,1],\"319\":[null,null,2],\"320\":[1],\"321\":[1,69],\"322\":[1,14],\"323\":[1,29],\"324\":[1,23],\"325\":[1,19],\"326\":[1,40],\"327\":[1,34],\"328\":[1,9],\"329\":[1,36],\"330\":[1,67],\"331\":[1,5],\"332\":[1,35],\"333\":[1,29],\"334\":[1,95],\"335\":[1,43],\"336\":[1,36],\"337\":[1,32],\"338\":[1,50],\"339\":[1,16],\"340\":[null,null,1],\"341\":[null,null,2],\"342\":[1,28],\"343\":[1,44],\"344\":[1,47],\"345\":[1,62],\"346\":[1,59],\"347\":[1,39],\"348\":[1,51],\"349\":[1,39],\"350\":[1,60],\"351\":[1,45],\"352\":[1,48],\"353\":[1,35],\"354\":[1,63],\"355\":[1,72],\"356\":[1,72],\"357\":[1,65],\"358\":[1,51],\"359\":[1,35],\"360\":[1,96],\"361\":[1,55],\"362\":[1,86],\"363\":[1,69],\"364\":[1,82],\"365\":[1,34],\"366\":[1,75],\"367\":[1,36],\"368\":[1,45],\"369\":[1,30],\"370\":[1,60],\"371\":[1,23],\"372\":[1,126],\"373\":[null,null,1],\"374\":[null,null,1],\"375\":[1],\"376\":[1,29],\"377\":[1,27],\"378\":[1,33],\"379\":[1,66],\"380\":[1,21],\"381\":[1,28],\"382\":[1,47],\"383\":[1,32],\"384\":[1,48],\"385\":[1,24],\"386\":[1,38],\"387\":[1,24],\"388\":[1,25],\"389\":[1,45],\"390\":[1,73],\"391\":[1,55],\"392\":[1,35],\"393\":[1,53],\"394\":[1,6],\"395\":[1,25],\"396\":[null,null,1],\"397\":[null,null,1],\"398\":[2,12],\"399\":[2,158],\"400\":[2,5],\"401\":[3,27],\"402\":[2,137],\"403\":[3,113],\"404\":[6,74],\"405\":[3,24],\"406\":[3,55],\"407\":[3,38],\"408\":[2,45],\"409\":[3,33],\"410\":[1,60],\"411\":[1,63],\"412\":[3,49],\"413\":[1,24],\"414\":[1,15],\"415\":[1,16],\"416\":[2,137],\"417\":[3,47],\"418\":[3,54],\"419\":[3,151],\"420\":[4,130],\"421\":[3,31],\"422\":[1,176],\"423\":[1,143],\"424\":[1,67],\"425\":[2,7],\"426\":[3,78],\"427\":[3,9],\"428\":[4,113],\"429\":[3,190],\"430\":[3,12],\"431\":[1,196],\"432\":[1,300],\"433\":[3,56],\"434\":[3,75],\"435\":[1,45],\"436\":[3,48],\"437\":[null,null,1],\"438\":[null,null,5],\"439\":[1,15],\"440\":[2,90],\"441\":[2,203],\"442\":[3,229],\"443\":[3,228],\"444\":[4,164],\"445\":[3,35],\"446\":[3,127],\"447\":[3,31],\"448\":[2],\"449\":[4,57],\"450\":[2,46],\"451\":[3,41],\"452\":[3,146],\"453\":[3,18],\"454\":[3,76],\"455\":[2],\"456\":[3],\"457\":[3,30],\"458\":[4,25],\"459\":[3,58],\"460\":[4,40],\"461\":[3],\"462\":[4,41],\"463\":[3,68],\"464\":[3,132],\"465\":[4],\"466\":[2,23],\"467\":[2,38],\"468\":[2,49],\"469\":[3,24],\"470\":[2,45],\"471\":[2,18],\"472\":[3,38],\"473\":[3],\"474\":[4,46],\"475\":[3,70],\"476\":[2,67],\"477\":[2,205],\"478\":[3,64],\"479\":[4,21],\"480\":[2,79],\"481\":[2,110],\"482\":[3,75],\"483\":[2,17],\"484\":[5,11],\"485\":[4,20],\"486\":[4,72],\"487\":[3,24],\"488\":[4,50],\"489\":[3,102],\"490\":[3],\"491\":[4,57],\"492\":[5,47],\"493\":[6,48],\"494\":[3,28],\"495\":[3,65],\"496\":[3,21],\"497\":[3,110],\"498\":[4,14],\"499\":[3,46],\"500\":[3,33],\"501\":[3,15],\"502\":[3,59],\"503\":[3,72],\"504\":[3,102],\"505\":[null,null,1],\"506\":[null,null,6],\"507\":[2],\"508\":[4,13],\"509\":[4,22],\"510\":[5,62],\"511\":[3,10],\"512\":[5,21],\"513\":[3,43],\"514\":[null,null,1],\"515\":[null,null,2],\"516\":[2,21],\"517\":[3,55],\"518\":[2,45],\"519\":[3],\"520\":[4,18],\"521\":[3,19],\"522\":[3,26],\"523\":[3,22],\"524\":[3,10],\"525\":[3,12],\"526\":[3],\"527\":[1,15],\"528\":[1,40],\"529\":[1,24],\"530\":[1,2],\"531\":[1,2],\"532\":[4,16],\"533\":[3,57],\"534\":[3,26],\"535\":[3,3],\"536\":[3,19],\"537\":[5,21],\"538\":[1,24],\"539\":[1,57],\"540\":[3,37],\"541\":[1,63],\"542\":[3,50],\"543\":[null,null,1],\"544\":[null,null,2],\"545\":[2,9],\"546\":[3],\"547\":[3],\"548\":[3,66],\"549\":[3,35],\"550\":[3,27],\"551\":[3,13],\"552\":[4,115],\"553\":[3],\"554\":[4,40],\"555\":[6,54],\"556\":[3,15],\"557\":[3,85],\"558\":[3,47],\"559\":[4,61],\"560\":[3],\"561\":[4,9],\"562\":[3,38],\"563\":[4,25],\"564\":[3,46],\"565\":[3,62],\"566\":[null,null,1],\"567\":[null,null,3],\"568\":[2,17],\"569\":[3,33],\"570\":[3,33],\"571\":[4],\"572\":[3,2],\"573\":[3,25],\"574\":[3,18],\"575\":[4,32],\"576\":[3,3],\"577\":[3,2],\"578\":[3,46],\"579\":[4,92],\"580\":[null,null,1],\"581\":[null,null,2],\"582\":[2,9],\"583\":[3,31],\"584\":[3],\"585\":[4,17],\"586\":[3,25],\"587\":[4,44],\"588\":[4,35],\"589\":[6,28],\"590\":[null,null,1],\"591\":[null,null,2],\"592\":[2,4],\"593\":[3,14],\"594\":[3],\"595\":[3,60],\"596\":[3,16],\"597\":[3,33],\"598\":[4,66],\"599\":[3,79],\"600\":[3,45],\"601\":[3,16],\"602\":[3,39],\"603\":[2,13],\"604\":[5,99],\"605\":[4,43],\"606\":[4,44],\"607\":[4,32],\"608\":[4,49],\"609\":[null,null,1],\"610\":[null,null,2],\"611\":[2],\"612\":[3,48],\"613\":[3,49],\"614\":[4,30],\"615\":[3,73],\"616\":[4,56],\"617\":[4,78],\"618\":[4,226],\"619\":[4,30],\"620\":[4,25],\"621\":[null,null,1],\"622\":[null,null,2],\"623\":[2],\"624\":[3,20],\"625\":[4,31],\"626\":[5],\"627\":[1,14],\"628\":[2,23],\"629\":[2,15],\"630\":[3,24],\"631\":[5,14],\"632\":[5,22],\"633\":[1,17],\"634\":[3,74],\"635\":[3,68],\"636\":[4,42],\"637\":[4,35],\"638\":[null,null,1],\"639\":[null,null,2],\"640\":[2],\"641\":[3,16],\"642\":[3,70],\"643\":[3,72],\"644\":[3],\"645\":[4,38],\"646\":[4,14],\"647\":[4,4],\"648\":[3,40],\"649\":[3,12],\"650\":[4,79],\"651\":[7,44],\"652\":[4,11],\"653\":[3,16],\"654\":[4,34],\"655\":[3,29],\"656\":[3,25],\"657\":[2,12],\"658\":[3,87],\"659\":[3,20],\"660\":[3,53],\"661\":[4,15],\"662\":[4,30],\"663\":[null,null,1],\"664\":[null,null,2],\"665\":[2],\"666\":[4,23],\"667\":[3,33],\"668\":[3,66],\"669\":[3,9],\"670\":[7,20],\"671\":[7,6],\"672\":[8,14],\"673\":[7,12],\"674\":[7,10],\"675\":[4,12],\"676\":[4,33],\"677\":[4,7],\"678\":[1,13],\"679\":[1,8],\"680\":[1,88],\"681\":[1,23],\"682\":[null,null,1],\"683\":[null,null,2],\"684\":[2],\"685\":[3],\"686\":[3,94],\"687\":[5,75],\"688\":[4],\"689\":[3,125],\"690\":[3,42],\"691\":[null,null,1],\"692\":[null,null,2],\"693\":[2],\"694\":[3,23],\"695\":[3,13],\"696\":[6,72],\"697\":[4,22],\"698\":[7,47],\"699\":[5,58],\"700\":[1,25],\"701\":[4,52],\"702\":[4,41],\"703\":[5,67],\"704\":[4,126],\"705\":[1,17],\"706\":[6,8],\"707\":[4,15],\"708\":[4,11],\"709\":[4,25],\"710\":[5,135],\"711\":[null,null,1],\"712\":[null,null,2],\"713\":[2],\"714\":[3],\"715\":[2,29],\"716\":[2,24],\"717\":[4,24],\"718\":[2,36],\"719\":[5,25],\"720\":[6,16],\"721\":[3,20],\"722\":[4],\"723\":[3],\"724\":[3,34],\"725\":[3,117],\"726\":[6,58],\"727\":[3,27],\"728\":[3,82],\"729\":[3,72],\"730\":[3],\"731\":[4,41],\"732\":[4,24],\"733\":[4,19],\"734\":[null,null,1],\"735\":[null,null,2],\"736\":[2,72],\"737\":[3,123],\"738\":[null,null,1],\"739\":[null,null,2],\"740\":[2],\"741\":[3,57],\"742\":[3,54],\"743\":[3],\"744\":[4,28],\"745\":[4,37],\"746\":[3,132],\"747\":[3,41],\"748\":[5],\"749\":[5,59],\"750\":[4,8],\"751\":[3,30],\"752\":[3,21],\"753\":[4,70],\"754\":[5,10],\"755\":[3,65],\"756\":[3,11],\"757\":[4,46],\"758\":[null,null,1],\"759\":[null,null,2],\"760\":[2,22],\"761\":[3],\"762\":[3,9],\"763\":[4,70],\"764\":[4,19],\"765\":[4,52],\"766\":[3,2],\"767\":[5,78],\"768\":[5,19],\"769\":[3],\"770\":[3,48],\"771\":[2,127],\"772\":[2,61],\"773\":[4,25],\"774\":[3,29],\"775\":[5,24],\"776\":[5,36],\"777\":[6,33],\"778\":[6,29],\"779\":[4,22],\"780\":[3,8],\"781\":[1,20],\"782\":[1,22],\"783\":[1,22],\"784\":[4],\"785\":[2,24],\"786\":[2,52],\"787\":[null,null,1],\"788\":[null,null,2],\"789\":[2],\"790\":[3,13],\"791\":[3,48],\"792\":[3],\"793\":[4,17],\"794\":[5,48],\"795\":[3,8],\"796\":[4,26],\"797\":[4,60],\"798\":[4,35],\"799\":[3,51],\"800\":[3,87],\"801\":[3,19],\"802\":[null,null,1],\"803\":[null,null,2],\"804\":[2],\"805\":[3,44],\"806\":[3,65],\"807\":[3,54],\"808\":[6,19],\"809\":[4,202],\"810\":[4,45],\"811\":[6,25],\"812\":[3,32],\"813\":[6,27],\"814\":[null,null,1],\"815\":[null,null,2],\"816\":[2],\"817\":[3],\"818\":[3,40],\"819\":[4,65],\"820\":[3,71],\"821\":[3,10],\"822\":[4,71],\"823\":[4,136],\"824\":[3,19],\"825\":[5,36],\"826\":[5,48],\"827\":[4,7],\"828\":[null,null,1],\"829\":[null,null,2],\"830\":[2,22],\"831\":[3,115],\"832\":[3,75],\"833\":[null,null,1],\"834\":[null,null,2],\"835\":[1,79],\"836\":[1,67],\"837\":[1,28],\"838\":[null,null,1],\"839\":[null,null,2],\"840\":[1],\"841\":[null,null,1],\"842\":[null,null,2],\"843\":[1,9],\"844\":[2,13],\"845\":[2,12],\"846\":[2,11],\"847\":[2,15],\"848\":[2,33],\"849\":[2,14],\"850\":[1,18],\"851\":[1,20],\"852\":[1,14],\"853\":[1,31],\"854\":[null,null,1],\"855\":[null,null,3],\"856\":[1],\"857\":[null,null,1],\"858\":[1,18],\"859\":[null,null,1],\"860\":[null,null,1],\"861\":[1,20],\"862\":[null,null,1],\"863\":[null,null,1],\"864\":[2,11],\"865\":[2,8],\"866\":[2,13],\"867\":[2,11],\"868\":[2,10],\"869\":[1,10],\"870\":[1,19],\"871\":[1,1],\"872\":[1,3],\"873\":[1,3],\"874\":[1,5],\"875\":[1,2],\"876\":[1,3],\"877\":[1,6],\"878\":[1,2],\"879\":[1],\"880\":[null,null,1],\"881\":[null,null,1],\"882\":[1,3],\"883\":[1,19],\"884\":[1,20],\"885\":[1,12],\"886\":[1,13],\"887\":[null,null,1],\"888\":[null,null,2],\"889\":[1,3],\"890\":[2],\"891\":[1],\"892\":[1]},\"averageFieldLength\":[2.070977427867024,46.64273523879649,0.2628435279029686],\"storedFields\":{\"0\":{\"h\":\"二叉树\",\"t\":[\"二叉树大纲\",\"满二叉树：\",\"对于k层的二叉树来说，拥有 2k -1 个结点的二叉树称为满二叉树\",\"度为0的结点(叶子结点)都在同一层上\",\"image-20231030212729924\",\"完全二叉树：\",\"二叉树的结点位置按照对应的完全二叉树的位置相吻合\",\"最后一层的结点，一定是从左往右依次排满的\",\"image-20230813175651994\",\"线索二叉树\",\"若根结点的左、右子树均不为空，那么有：\",\"左子树的所有结点的值均小于根结点的值\",\"右子树的所有结点的值均大于根节点的值\",\"平衡二叉树\",\"平衡二叉树，又称AVL，一个树的左右子树的高度的差值不能大于1\",\"img\",\"二叉树的遍历\",\"二叉树遍历方式分为三种：\",\"前序遍历\",\"中序遍历\",\"后序遍历\",\"每一种遍历都可以用递归和迭代俩种方法来实现，对应LeetCode题目：\",\"144.二叉树的前序遍历(opens new window)\",\"94.二叉树的中序遍历(opens new window)\",\"145.二叉树的后序遍历\"]},\"1\":{\"h\":\"1、二叉树递归遍历\",\"t\":[\"递归方法比较简单，只要弄清楚结束条件即可，所谓前、中、后序遍历只不过调整加入集合的顺序即可。\"]},\"2\":{\"h\":\"前序遍历\",\"t\":[\"前序遍历顺序：\",\"先遍历根节点\",\"在遍历左子树\",\"最后遍历右子树\",\"代码实现\",\"定义结点\",\"public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } \",\" /** * 方法一：递归 * 根节点、左子树、右子树 * */ ArrayList<Integer> res = new ArrayList<Integer>(); public List<Integer> preorderTraversal(TreeNode root) { if (root == null) return res; // 先遍历根节点 res.add(root.val); // 递归遍历左子树 preorderTraversal(root.left); // 递归遍历左子树 preorderTraversal(root.right); return res; } \"]},\"3\":{\"h\":\"\",\"t\":[\"遍历顺序：\",\"先遍历左子树\",\"在遍历根节点\",\"最后遍历右子树\",\" ArrayList<Integer> res = new ArrayList<>(); public List<Integer> inorderTraversal(TreeNode root) { if (root == null) return res; // 先遍历左子树 inorderTraversal(root.left); // 遍历根节点 res.add(root.val); // 遍历右子树 inorderTraversal(root.right); return res; } \"]},\"4\":{\"h\":\"\",\"t\":[\"先遍历左子树\",\"在遍历右子树\",\"最后遍历根节点\",\" ArrayList<Integer> res = new ArrayList<>(); public List<Integer> postorderTraversal(TreeNode root) { if (root == null) return res; // 先遍历左子树 postorderTraversal(root.left); // 在遍历右子树 postorderTraversal(root.right); // 最后遍历根节点 res.add(root.val); return res; } \"]},\"5\":{\"h\":\"2、二叉树迭代遍历\",\"t\":[\"二叉树的迭代遍历相较于递归比较困难一些，我们知道所谓的递归，其实就是将局部变量，返回值，返回地址存放在栈中，二叉树的迭代遍历也可以用栈来实现。\"]},\"6\":{\"h\":\"\",\"t\":[\"先将根节点入栈，然后弹栈，再将右孩子结点、左孩子结点依次入栈\",\"由于栈先进后出，所以先将右孩子放入栈中，后放左孩子\",\"二叉树前序遍历（迭代法）\",\" /** * 方法二：迭代遍历 * */ public List<Integer> preorderTraversal2(TreeNode root) { ArrayList<Integer> res = new ArrayList<Integer>(); if (root == null) return res; Stack<TreeNode> stack = new Stack<>(); // 先将根节点入栈 stack.push(root); while (!stack.isEmpty()) { // 将根节点弹栈 TreeNode node = stack.pop(); // 将根节点加入到集合中 res.add(node.val); // 将右孩子结点入栈，切记: 空结点不放入栈中 if (node.right != null) stack.push(node.right); // 同理将左孩子放入栈中 if (node.left != null) stack.push(node.left); } return res; } \"]},\"7\":{\"h\":\"中序遍历\",\"t\":[\"在递归中我们只修改了处理结点的顺序（将节点增加到集合中），代码都一样，只是顺序改变了。\",\"但是在迭代中，我们就无法这样做了，为什么呢？\",\"在前序遍历中，我们访问结点和处理结点的顺序是一致的，从根结点开始访问，也是从根结点开始处理！\",\"但是在中序遍历中，我们从根节点开始访问，但是处理的结点却是左边最底部的结点。\",\"因此我们需要一个指针，帮助我们访问结点\",\"二叉树中序遍历（迭代法）\",\" public List<Integer> inorderTraversal2(TreeNode root) { ArrayList<Integer> res = new ArrayList<>(); if (root == null) return res; Stack<TreeNode> stack = new Stack<>(); // 使用一个指针，帮助访问处理的结点 TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if (cur != null) { // 说明还未到达左边最底部的结点，继续向下访问 stack.push(cur); // 左 cur = cur.left; }else { // 说明到达了左边最底部的结点，进行处理 // 中 TreeNode node = stack.pop(); res.add(node.val); // 右 cur = node.right; } } return res; } \"]},\"8\":{\"h\":\"后序遍历\",\"t\":[\"再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转 res 集合，输出的结果顺序就是左右中了，如下图：\",\"image-20231030231551687\",\"切记： 栈的原则为先进后出，先放左，后放右，右先出，左后出！\",\" /** * 方法二：迭代遍历 * */ public List<Integer> postorderTraversal2(TreeNode root) { ArrayList<Integer> res = new ArrayList<>(); if (root == null) return res; Stack<TreeNode> stack = new Stack<>(); // 先将根节点入栈 stack.push(root); while(!stack.isEmpty()) { // 根 TreeNode cur = stack.pop(); res.add(cur.val); // 左 if (cur.left != null) stack.push(cur.left); // 右 if (cur.right != null) stack.push(cur.right); } // 反转 Collections.reverse(res); return res; } \"]},\"9\":{\"h\":\"总结\",\"t\":[\"其中前序遍历和后序遍历会有一些联系，和中序遍历代码不相关。\",\"原因就是中序遍历访问和处理的结点不是同一个，需要用额外的一个指针来访问！\"]},\"10\":{\"h\":\"3、二叉树的层序遍历\"},\"11\":{\"h\":\"\",\"t\":[\"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] \",\"示例 2：\",\"输入：root = [1] 输出：[[1]] \",\"示例 3：\",\"输入：root = [] 输出：[] \",\"提示：\",\"树中节点数目在范围 [0, 2000] 内\",\"-1000 <= Node.val <= 1000\"]},\"12\":{\"h\":\"思路分析\",\"t\":[\"作者：nettee 链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/\",\"DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？\",\"如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。\",\"DFS 与 BFS\",\"让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。\",\"DFS 遍历使用 递归：\",\"void dfs(TreeNode root) { if (root == null) { return; } dfs(root.left); dfs(root.right); } \",\"BFS 遍历使用队列数据结构：\",\"void bfs(TreeNode root) { Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); // Java 的 pop 写作 poll() if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } \",\"是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。\",\"虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。\",\"DFS 与 BFS 对比\",\"BFS应用场景: 层序遍历\",\"什么是层序遍历？\",\"从上至下，从左到右依次访问二叉树的每一个结点。\",\"二叉树的层序遍历\",\"其实乍一看这个遍历顺序和 BFS(广度优先遍历)是一样的，但是与BFS不同的是，二叉树的层次遍历却是一个二维数组。而BFS 遍历后得到是一维数组，无法区分每一层\",\"BFS 遍历与层序遍历的输出结果不同\",\"那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：\",\"BFS 遍历的过程（动图）\",\"截取 BFS 遍历过程中的某一时刻：\",\"BFS 遍历中某个时刻队列的状态\",\"可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们 无法区分队列中的结点来自哪一层。\",\"因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点\",\"// 二叉树的层序遍历 void bfs(TreeNode root) { Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { int n = queue.size(); for (int i = 0; i < n; i++) { // 变量 i 无实际意义，只是为了循环 n 次 TreeNode node = queue.poll(); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } } \",\"将BFS遍历改成了层序遍历，在遍历过程中，结点的出队入队过程为：\",\"img\",\"可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。\",\"最终我们得到的题解代码为：\",\"class Solution { List<List<Integer>> res = new ArrayList<>(); public List<List<Integer>> levelOrder(TreeNode root) { if (root == null) return res; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); // n记录每一层的结点个数 while(!queue.isEmpty()) { int n = queue.size(); ArrayList<Integer> item = new ArrayList<>(); for (int i = 0; i < n; i++) { // n 无实际意义，只是为了能够一次性将一层的结点出队 TreeNode treeNode = queue.poll(); item.add(treeNode.val); // 将左孩子结点入队 if (treeNode.left != null) queue.add(treeNode.left); // 将右孩子结点入队 if (treeNode.right != null) queue.add(treeNode.right); } res.add(item); } return res; } } \",\"递归版本：\",\"class Solution { List<List<Integer>> res = new ArrayList<>(); public List<List<Integer>> levelOrder(TreeNode root) { recursion(root, 0); return res; } // deep表示遍历的层次 public void recursion(TreeNode node, int deep) { // 终止条件 if (node == null) return; // 没执行一次，层次加一 deep++; if (res.size() < deep) { // 每一层的元素加集合，当deep增加时，增加一层元素 List<Integer> item = new ArrayList<>(); res.add(item); } // 增加当前结点,list索引下标从0开始，所以-1 res.get(deep - 1).add(node.val); // 遍历左子树 recursion(node.left, deep); // 遍历右子树 recursion(node.right, deep); } } \"]},\"13\":{\"h\":\"\",\"t\":[\"给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：[[15,7],[9,20],[3]] \",\"示例 2：\",\"输入：root = [1] 输出：[[1]] \",\"示例 3：\",\"输入：root = [] 输出：[] \",\"提示：\",\"树中节点数目在范围 [0, 2000] 内\",\"-1000 <= Node.val <= 1000\"]},\"14\":{\"h\":\"思路分析\",\"t\":[\"简单一批，直接将集合反转即可\",\" public List<List<Integer>> levelOrderBottom(TreeNode root) { List<List<Integer>> res = new ArrayList<>(); if (root == null) return res; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { int n = queue.size(); List<Integer> item = new ArrayList<>(); for (int i = 0; i < n; i++) { TreeNode node = queue.poll(); item.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } res.add(item); } / Collections.reverse(res); return res; } \"]},\"15\":{\"h\":\"\",\"t\":[\"给定一个二叉树的 根节点root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\",\"示例 1:\",\"img\",\"输入: [1,2,3,null,5,null,4] 输出: [1,3,4] \",\"示例 2:\",\"输入: [1,null,3] 输出: [1,3] \",\"示例 3:\",\"输入: [] 输出: [] \",\"提示:\",\"二叉树的节点个数的范围是 [0,100]\",\"-100 <= Node.val <= 100\"]},\"16\":{\"h\":\"思路分析\",\"t\":[\"如图所示，我们只需要将层序遍历结果中，每一层的最后一个元素放入结果集中即可\",\"fig1\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> rightSideView(TreeNode root) { ArrayList<Integer> res = new ArrayList<>(); if (root == null) return res; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 1; i <= levelSize; i++) { TreeNode node = queue.poll(); // 将左孩子入队 if (node.left != null) queue.add(node.left); // 将右孩子结点入队 if (node.right != null) queue.add(node.right); // 只需要将每层的最后一个放到res即可 if (i == levelSize) res.add(node.val); } } return res; } } \"]},\"17\":{\"h\":\"\",\"t\":[\"给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：[3.00000,14.50000,11.00000] 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。 因此返回 [3, 14.5, 11] 。 \",\"示例 2:\",\"img\",\"输入：root = [3,9,20,15,7] 输出：[3.00000,14.50000,11.00000] \",\"提示：\",\"树中节点数量在 [1, 104] 范围内\",\"-231 <= Node.val <= 231 - 1\"]},\"18\":{\"h\":\"思路分析\",\"t\":[\"遍历每层结点时，累加结点的值，每一层累加完求平均值即可\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Double> averageOfLevels(TreeNode root) { ArrayList<Double> res = new ArrayList<>(); if (root == null) return res; ArrayDeque<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { int levelSize = queue.size(); double sum = 0; for (int i = 0; i < levelSize; i++) { TreeNode node = queue.pop(); sum += node.val; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } res.add(sum/levelSize); } return res; } } \"]},\"19\":{\"h\":\"\",\"t\":[\"给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\",\"树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\",\"示例 1：\",\"img\",\"输入：root = [1,null,3,2,4,null,5,6] 输出：[[1],[3,2,4],[5,6]] \",\"示例 2：\",\"img\",\"输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] \",\"提示：\",\"树的高度不会超过 1000\",\"树的节点总数在 [0, 10^4] 之间\"]},\"20\":{\"h\":\"思路分析\",\"t\":[\"在进行二叉树遍历时，我们是将左孩子、右孩子结点入队，N叉树我们只需要改变入队规则，将 结点的 children 入队即可\",\"/* // Definition for a Node. class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }; */ class Solution { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> res = new ArrayList<>(); if (root == null) return res; Queue<Node> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { int levelSize = queue.size(); ArrayList<Integer> item = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node node = queue.poll(); item.add(node.val); // 改变入队方式 if (node.children != null){ queue.addAll(node.children); } } res.add(item); } return res; } } \"]},\"21\":{\"h\":\"\",\"t\":[\"给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\",\"示例1：\",\"img\",\"输入: root = [1,3,2,5,3,null,9] 输出: [1,3,9] \",\"示例2：\",\"输入: root = [1,2,3] 输出: [1,3] \",\"提示：\",\"二叉树的节点个数的范围是 [0,104]\",\"-231 <= Node.val <= 231 - 1\"]},\"22\":{\"h\":\"思路分析\",\"t\":[\"没啥好分析的，和求平均值一样\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> largestValues(TreeNode root) { ArrayList<Integer> res = new ArrayList<>(); if (root == null) return res; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { int levelSize = queue.size(); int maxValue = Integer.MIN_VALUE; for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); maxValue = Math.max(maxValue,node.val); if (node.left!=null) queue.add(node.left); if (node.right!=null) queue.add(node.right); } res.add(maxValue); } return res; } } \"]},\"23\":{\"h\":\"\",\"t\":[\"给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\",\"struct Node { int val; Node *left; Node *right; Node *next; } \",\"填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\",\"初始状态下，所有 next 指针都被设置为 NULL。\",\"示例 1：\",\"img\",\"输入：root = [1,2,3,4,5,6,7] 输出：[1,#,2,3,#,4,5,6,7,#] 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。 \",\"示例 2:\",\"输入：root = [] 输出：[] \",\"提示：\",\"树中节点的数量在 [0, 212 - 1] 范围内\",\"-1000 <= node.val <= 1000\",\"进阶：\",\"你只能使用常量级额外空间。\",\"使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\"]},\"24\":{\"h\":\"思路分析\",\"t\":[\"只需要将每一层 poll 出来的结点：\",\"如果下一个结点不为空，则指向下一个结点\",\"如果下一个结点为空，则置为null\",\"/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if (root == null) return root; Queue<Node> queue = new ArrayDeque<Node>(); queue.add(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { // 当前层的第一个节点 Node node = queue.poll(); // 当前节点的下一个节点,当前结点为这一层的最后一个节点,则为null node.next = (i == levelSize - 1) ? null : queue.peek(); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } } return root; } } \"]},\"25\":{\"h\":\"\",\"t\":[\"给定一个二叉树 root ，返回其最大深度。\",\"二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：3 \",\"示例 2：\",\"输入：root = [1,null,2] 输出：2 \",\"提示：\",\"树中节点的数量在 [0, 104] 区间内。\",\"-100 <= Node.val <= 100\"]},\"26\":{\"h\":\"思路分析\",\"t\":[\"在遍历完每一层时，用一个变量进行累加\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; ArrayDeque<TreeNode> queue = new ArrayDeque<>(); queue.add(root); // 记录最大深度 int max = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); if (node.left!= null) queue.add(node.left); if (node.right!= null) queue.add(node.right); } max++; } return max; } } \"]},\"27\":{\"h\":\"\",\"t\":[\"给定一个二叉树，找出其最小深度。\",\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\",\"**说明：**叶子节点是指没有子节点的节点。\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：2 \",\"示例 2：\",\"输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 \",\"提示：\",\"树中节点数的范围在 [0, 105] 内\",\"-1000 <= Node.val <= 1000\"]},\"28\":{\"h\":\"思路分析\",\"t\":[\"相较于最大深度，最小深度是 当某个结点的左右子树都为空时，此时就达到了最近的叶子结点，直接返回深度即可。\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; ArrayDeque<TreeNode> queue = new ArrayDeque<>(); queue.add(root); int level = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); // 当左右子树都为空时，说明到达叶子节点，返回当前层数 if (node.left == null && node.right == null) { return level; } if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } level++; } return level; } } \"]},\"29\":{\"h\":\"总结\",\"t\":[\"二叉树的层序遍历有俩种思想： 一种是 bfs(广度优先遍历)、一种是 dfs(深度优先遍历)，其中层序遍历使用 bfs 更简单，其模板：\",\"void bfs(TreeNode root) { Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); // Java 的 pop 写作 poll() if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } \"]},\"30\":{\"h\":\"\",\"t\":[\"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\",\"示例 1：\",\"img\",\"输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] \",\"示例 2：\",\"img\",\"输入：root = [2,1,3] 输出：[2,3,1] \",\"示例 3：\",\"输入：root = [] 输出：[] \",\"提示：\",\"树中节点数目范围在 [0, 100] 内\",\"-100 <= Node.val <= 100\"]},\"31\":{\"h\":\"思路分析\",\"t\":[\"通过题目描述中也可以得知，所谓的翻转，其实就是将每一层的左右孩子结点进行交换即可。\",\"先序、后序、层序遍历均可以实现，为什么没有中序呢？中序其实也可以，但是需要考虑的是，在遍历结点的过程中，可能会交换俩次。\",\"递归：先序遍历\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return root; // 交换 swap(root); // 遍历左子树 invertTree(root.left); // 遍历右子树 invertTree(root.right); return root; } // 交换左右孩子结点 public void swap(TreeNode node) { if (node == null) return; TreeNode temp = node.left; node.left = node.right; node.right = temp; } } \",\"bfs - 层序遍历\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return root; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { TreeNode node = queue.poll(); // 左右交换 swap(node); if (node.left!= null) queue.add(node.left); if (node.right!= null) queue.add(node.right); } return root; } } \"]},\"32\":{\"h\":\"\",\"t\":[\"给你一个二叉树的根节点 root ， 检查它是否轴对称。\",\"示例 1：\",\"img\",\"输入：root = [1,2,2,3,4,4,3] 输出：true \",\"示例 2：\",\"img\",\"输入：root = [1,2,2,null,3,null,3] 输出：false \",\"提示：\",\"树中节点数目在范围 [1, 1000] 内\",\"-100 <= Node.val <= 100\",\"**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？\"]},\"33\":{\"h\":\"思路分析\",\"t\":[\"首先要思考一颗对称的二叉树他有什么特点，根据下图来说：\",\"俩颗对称的子树它的根的值是相等的\",\"俩颗子树互为镜像。（这句话怎么理解呢？） \",\"左子树的左节点和右子树的右结点是相等的\",\"左子树的右结点和右子树的左节点是相等的\",\"即：$left.left = right.right , left.right = right.left$\",\"只要满足以上几种情况，就可以说明该二叉树是对称的，否则则不是。我们也可以利用这些条件做题。\",\"image-20231106221428126\",\"第一种方法：递归\",\"终止条件就是上面说的那几种情况，只要不满足就返回false \",\"根结点值不相等，返回false\",\"左子树或者右子树有一个为空，返回 false\",\"左子树和右子树都为空，返回true(说明已经没有结点了，也没有返回false)\",\"每次递归的元素为：左子树的左节点和右子树的右结点，左子树的右结点和右子树的左节点\",\" public boolean isSymmetric2(TreeNode root) { if (root == null) return true; return recursive(root.left, root.right); } private boolean recursive(TreeNode left, TreeNode right) { // 如果两个结点都为空，那么就对称的 if (left == null && right == null) return true; // 如果有一个结点为空，那么就是不对称的 if (left == null || right == null) return false; // 根结点的值不相等，那么就不是对称的 if (left.val != right.val) return false; // 递归比较左右子树 return recursive(left.left,right.right) && recursive(left.right,right.left); } \",\"第二种方法：迭代\",\"将递归的比较换成队列，先将左右子树入队，然后继续根据上面的三个条件进行比较。\",\"将 left.left、right.right 入队，left.right、right.left 入队\",\" public boolean isSymmetric1(TreeNode root) { // 如果只有一个结点，那么一定是对称的 if (root == null || (root.left == null && root.right == null)) return true; LinkedList<TreeNode> queue = new LinkedList<>(); queue.add(root.left); queue.add(root.right); while (queue.size() > 0) { // 取出俩个结点，比较它们的值 TreeNode left = queue.poll(); TreeNode right = queue.poll(); if (left == null && right == null) continue; // 如果其中一个结点为空，另一个不为空，那么就不是对称的 if (left == null || right == null) return false; // 如果两个结点的值不相等，那么就不是对称的 if (left.val != right.val) return false; // 比较左子树的左孩子结点和右子树的右孩子结点 queue.add(left.left); queue.add(right.right); // 比较左子树的右孩子结点和右子树的左孩子结点 queue.add(left.right); queue.add(right.left); } // 如果循环结束，那么说明所有的结点都比较完了，那么就是对称的 return true; } \"]},\"34\":{\"h\":\"\",\"t\":[\"给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\",\"完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\",\"示例 1：\",\"img\",\"输入：root = [1,2,3,4,5,6] 输出：6 \",\"示例 2：\",\"输入：root = [] 输出：0 \",\"示例 3：\",\"输入：root = [1] 输出：1 \",\"提示：\",\"树中节点的数目范围是[0, 5 * 104]\",\"0 <= Node.val <= 5 * 104\",\"题目数据保证输入的树是 完全二叉树\"]},\"35\":{\"h\":\"思路分析\",\"t\":[\"使用 dfs 和 bfs 都可以\",\"dfs：\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int countNodes(TreeNode root) { if (root == null) return 0; // 左子树结点+右子树结点+根节点 return countNodes(root.left) + countNodes(root.right) + 1; } } \",\"bfs：\",\" public int countNodes(TreeNode root) { if (root == null) return 0; ArrayDeque<TreeNode> queue = new ArrayDeque<>(); int sum = 0; queue.add(root); while(!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.pop(); sum+=1; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } } return sum; } \"]},\"36\":{\"h\":\"\",\"t\":[\"给定一个二叉树，判断它是否是高度平衡的二叉树。\",\"本题中，一棵高度平衡二叉树定义为：\",\"一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\",\"示例 1：\",\"img\",\"输入：root = [3,9,20,null,null,15,7] 输出：true \",\"示例 2：\",\"img\",\"输入：root = [1,2,2,3,3,null,null,4,4] 输出：false \",\"示例 3：\",\"输入：root = [] 输出：true \",\"提示：\",\"树中的节点数在范围 [0, 5000] 内\",\"-104 <= Node.val <= 104\"]},\"37\":{\"h\":\"思路分析\",\"t\":[\"平衡二叉树的定义：$一个二叉树 每个节点 的左右两个子树的高度差的绝对值不超过 1 $。\",\"对于一颗平衡二叉树来说，他所有的子树均为二叉树，因此我们可以使用递归判断所有的子树是否为二叉树\",\"有俩种递归方式，一种是自上而下，另一种是自下而上\",\"方法一：自上而下\",\"自上而下类似与前序遍历，对每一颗子树都进行判断是否是平衡二叉树\",\" public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(height(root.left) - height((root.right))) <= 1 && isBalanced(root.right) && isBalanced(root.left); } // 求出二叉树的最大深度（先序遍历） public int height(TreeNode node){ if (node == null) return 0; return Math.max(height(node.left) , height(node.right)) + 1; } \",\"方法二： 自下而上\",\"类似于后序遍历，以该结点为根节点的二叉树是平衡二叉树则返回最大 高度，若不是返回-1.\",\"相较于自上而下来说，这种方法对于每个结点只会处理一次，而自上而下需要处理该结点下的每颗子树。\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isBalanced(TreeNode root) { return height1(root) >=0; } public int height1(TreeNode node) { if (node == null) return 0; int left = height1(node.left); int right = height1(node.right); // 如果左右子树的高度差大于1，则返回-1 if (left == -1 || right == -1 || Math.abs(left - right) > 1) { return -1; } else { // 否则返回高度 return Math.max(left , right) + 1; } } } \"]},\"38\":{\"h\":\"\",\"t\":[\"给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\",\"叶子节点 是指没有子节点的节点。\",\"示例 1：\",\"img\",\"输入：root = [1,2,3,null,5] 输出：[\\\"1->2->5\\\",\\\"1->3\\\"] \",\"示例 2：\",\"输入：root = [1] 输出：[\\\"1\\\"] \",\"提示：\",\"树中节点的数目在范围 [1, 100] 内\",\"-100 <= Node.val <= 100\"]},\"39\":{\"h\":\"思路分析\",\"t\":[\"通过题意我们很清楚的知道使用先序遍历 + 回溯方法。当我们将一条路径存到集合中，我们需要回溯到初始结点，继续找下一条路径！\",\"先序遍历的方法有： 递归、迭代，也可以使用bfs层序遍历实现！\",\"1、递归\",\"递归版本的先序遍历代码如下\",\" public void dfs(TreeNode node){ if (node == null) return; System.out.println(node.val); dfs(node.left); dfs(node.right); } \",\"我们可以依据上面为模板进行改良，此时不再是输出结点，而是将叶子结点的路径保存起来，代码如下：\",\"可能会有疑问？这也没进行回溯啊？其实是有的，回溯隐藏在在每次递归的时候。即：$path + node.val + \\\"->\\\"$\",\"class Solution { public List<String> binaryTreePaths(TreeNode root) { ArrayList<String> res = new ArrayList<>(); dfs(root, \\\"\\\", res); return res; } public void dfs(TreeNode node, String path, List<String> res) { if (node == null) return; if (node.left == null && node.right == null) { // 该结点为叶子结点 res.add(path + node.val); return; } // 在每次遍历的过程中，都要将当前结点的值添加到路径中，这也是隐藏的回溯 dfs(node.left, path + node.val + \\\"->\\\", res); dfs(node.right , path + node.val + \\\"->\\\", res); } } \",\"2、非递归\",\"先看一下非递归的先序遍历代码，如下：\",\" public void iterator(TreeNode root) { if (root == null) return; Stack<TreeNode> stack = new Stack<>(); stack.push(root); while(!stack.isEmpty()){ TreeNode node = stack.pop(); System.out.println(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } } \",\"同样我们也可以对以上代码进行改良，但此时我们需要注意使用迭代的方式，注意进行回溯，递归与回溯一一对应，每一次递归(入栈) 都要进行一次回溯！\",\" public List<String> iterator(TreeNode root) { ArrayList<String> res = new ArrayList<>(); if (root == null) return res; // 在这里，路径和结点是成双成对的，，保存路径的栈和保存结点的栈使用一个栈来实现 Stack<Object> stack = new Stack<>(); stack.push(root.val + \\\"\\\"); stack.push(root); while (!stack.isEmpty()) { // 注意push、pop的时机，都是先push路径，在push结点。先弹出来的是结点，后是路径 TreeNode node = (TreeNode) stack.pop(); String path = (String) stack.pop(); // 如果是叶子结点，保存路径 if (node.left == null && node.right == null) res.add(path); if (node.right != null) { // 每进行一次入栈，都要进行一次回溯 stack.push(path + \\\"->\\\" + node.right.val); stack.push(node.right); } ; if (node.left != null) { stack.push(path + \\\"->\\\" + node.left.val); stack.push(node.left); } ; } return res; } \",\"3、bfs层序遍历\",\"同样，先看层序遍历代码模板：\",\" public void sequence(TreeNode root) { if (root == null) return; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.println(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } } \",\"改进思路和第二种方法 一样，也是要注意回溯的时机\",\" public List<String> sequence(TreeNode root) { ArrayList<String> res = new ArrayList<>(); if (root == null) return res; Queue<Object> queue = new ArrayDeque<>(); queue.add(root.val + \\\"\\\"); queue.add(root); while (!queue.isEmpty()) { String path = (String)queue.poll(); TreeNode node = (TreeNode) queue.poll(); if (node.left==null && node.right==null) res.add(path); if (node.left != null) { queue.add(path + \\\"->\\\" + node.left.val); queue.add(node.left); }; if (node.right != null) { queue.add(path + \\\"->\\\" + node.right.val); queue.add(node.right); }; } return res; } \"]},\"40\":{\"h\":\"\",\"t\":[\"给定二叉树的根节点 root ，返回所有左叶子之和。\",\"示例 1：\",\"img\",\"输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 \",\"示例 2:\",\"输入: root = [1] 输出: 0 \",\"提示:\",\"节点数在 [1, 1000] 范围内\",\"-1000 <= Node.val <= 1000\"]},\"41\":{\"h\":\"思路分析\",\"t\":[\"当某个结点没有左右孩子结点，该结点就是叶子结点。\",\"我们可以使用 dfs 和 bfs 俩种方法，即递归或者迭代。\",\"在遍历过程中，我们只需要判断它的左子节点是否有左右孩子结点，如果没有就是叶子结点，累加左子节点的值即可。\",\"dfs：\",\"class Solution { // 先序遍历-递归 int sum = 0; public int sumOfLeftLeaves(TreeNode root) { dfs(root); return sum; } public void dfs(TreeNode node) { if (node == null) return; // 左叶子节点 if (node.left != null && node.left.left == null && node.left.right == null){ sum += node.left.val; } dfs(node.left); dfs(node.right); } } \",\"bfs：\",\"class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; int sum = 0; Stack<TreeNode> stack = new Stack<>(); stack.push(root); while(!stack.isEmpty()) { TreeNode node = stack.pop(); if (node.left!= null){ if (node.left.left == null && node.left.right == null) { // 说明是叶子节点 sum += node.left.val; }else{ stack.push(node.left); } } if (node.right != null) stack.push(node.right); } return sum; } } \"]},\"42\":{\"h\":\"\",\"t\":[\"给定一个二叉树的 根节点root，请找出该二叉树的 最底层 最左边 节点的值。\",\"假设二叉树中至少有一个节点。\",\"示例 1:\",\"img\",\"输入: root = [2,1,3] 输出: 1 \",\"示例 2:\",\"img\",\"输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 \",\"提示:\",\"二叉树的节点个数的范围是 [1,104]\",\"-231 <= Node.val <= 231 - 1\"]},\"43\":{\"h\":\"思路分析\",\"t\":[\"题目要求找到最后一层最左边的结点，我的第一想法是：\",\"1、求出二叉树的高度\",\"2、进行层序遍历，找出最后一层的第一个结点，该结点为最左侧的结点\",\"代码如下：\",\" public int findBottomLeftValue(TreeNode root) { if (root == null) return 0; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); int height = getHeight(root); while(!queue.isEmpty()) { int levelSize = queue.size(); height--; for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (node.left!= null) queue.add(node.left); if (node.right!= null) queue.add(node.right); // 判断该结点是否为最后一层最左边的 if (height == 0) return node.val; } } return 0; } // 获取二叉树的高度 public int getHeight(TreeNode node) { if (node == null) return 0; return Math.max(getHeight(node.left), getHeight(node.right)) + 1; } \",\"随后又仔细想了一下，我直接从右向左层序遍历，最后一个结点不就是最左侧的结点吗？ 好一个脱裤子放屁！！\",\"改良后的代码：\",\" // 层序遍历————从右往左，最后一个访问的就是最左侧的结点 public int findBottomLeftValue1(TreeNode root) { if (root == null) return 0; Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); int res = 0; while(!queue.isEmpty()) { TreeNode node = queue.poll(); res = node.val; if (node.right != null) queue.add(node.right); if (node.left != null) queue.add(node.left); } return res; } \"]},\"44\":{\"h\":\"\",\"t\":[\"给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\",\"叶子节点 是指没有子节点的节点。\",\"示例 1：\",\"img\",\"输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 \",\"示例 2：\",\"img\",\"输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --> 2): 和为 3 (1 --> 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 \",\"示例 3：\",\"输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 \",\"提示：\",\"树中节点的数目在范围 [0, 5000] 内\",\"-1000 <= Node.val <= 1000\",\"-1000 <= targetSum <= 1000\"]},\"45\":{\"h\":\"思路分析\",\"t\":[\"这道题和 257. 二叉树的所有路径 思路一样，都需要进行回溯，只不过该题回溯的是 结点的和！\",\"1、递归\",\"回溯隐藏在递归中，targetSum - root.val\",\" public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; if (root.left == null && root.right == null) return targetSum - root.val == 0; // 递归+回溯 return hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val) ; } \",\"2、非递归\",\" public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; // 即保存结点也保存结点和 Stack<Object> stack = new Stack<>(); stack.push(root.val); stack.push(root); while (!stack.isEmpty()) { TreeNode node = (TreeNode) stack.pop(); Integer sum = (Integer) stack.pop(); // 如果sum和等于targetSum并且该结点为叶子结点 直接返回true if (sum == targetSum && node.left == null && node.right == null) return true; // 每次入栈都要伴随着一次回溯 if (node.left != null) { stack.push(sum + node.left.val); stack.push(node.left); } if (node.right != null) { stack.push(sum + node.right.val); stack.push(node.right); } } return false; } \"]},\"46\":{\"h\":\"\",\"t\":[\"给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\",\"示例 1:\",\"img\",\"输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] \",\"示例 2:\",\"输入：inorder = [-1], postorder = [-1] 输出：[-1] \",\"提示:\",\"1 <= inorder.length <= 3000\",\"postorder.length == inorder.length\",\"-3000 <= inorder[i], postorder[i] <= 3000\",\"inorder 和 postorder 都由 不同 的值组成\",\"postorder 中每一个值都在 inorder 中\",\"inorder保证是树的中序遍历\",\"postorder保证是树的后序遍历\"]},\"47\":{\"h\":\"思路分析\",\"t\":[\"中序遍历+后续遍历确定一颗二叉树步骤：\",\"1、找出根节点： 由于后续遍历根节点总是在最后遍历，因此postorder 数组最后一个元素为根结点\",\"2、确定根节点在inorder 中的位置： 中序遍历中根结点在中间，左边为左子树，右边为右子树\",\"3、确定根节点的左子树的起始范围\",\"4、确定根节点的右子树的起始范围\",\"不断重复上面的四步，直到构成一个二叉树！\",\"其实构建二叉树的步骤大家都明白，只是在递归的过程中，左右子树的起始范围不太好确定, 看一下下面这张图：\",\"image-20231113230335449\",\"疑问点：\",\"$rootIndex - inStart $是什么？\",\"通过图片其实可以看出，$rootIndex - inStart $ 得到的是根结点左子树的个数 ，无论是中序、后续，它的左右子树结点个数肯定是不会变的。\",\" // 保存中序遍历的值与下标对应关系 HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); public TreeNode buildTree1(int[] inorder, int[] postorder) { for (int i = 0; i < inorder.length; i++) { map.put(inorder[i], i); } return helper(postorder, 0, inorder.length - 1, 0, postorder.length - 1); } // 递归 public TreeNode helper(int[] postorder, int inStart, int inEnd, int postStart, int postEnd) { if (inStart > inEnd || postStart > postEnd) { return null; } // 找到根结点 TreeNode root = new TreeNode(postorder[postEnd]); // 从map中找到根结点在中序遍历中的下表 Integer rootIndex = map.get(root.val); // 计算出中序遍历中根结点的左子树结点的个数 int nums_in_left = rootIndex - inStart; // 递归左子树 root.left = helper(postorder, inStart, rootIndex - 1, postStart, postStart + nums_in_left - 1); root.right = helper(postorder, rootIndex + 1, inEnd, postStart + nums_in_left, postEnd - 1); return root; } \"]},\"48\":{\"h\":\"\",\"t\":[\"给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\",\"示例 1:\",\"img\",\"输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] \",\"示例 2:\",\"输入: preorder = [-1], inorder = [-1] 输出: [-1] \",\"提示:\",\"1 <= preorder.length <= 3000\",\"inorder.length == preorder.length\",\"-3000 <= preorder[i], inorder[i] <= 3000\",\"preorder 和 inorder 均 无重复 元素\",\"inorder 均出现在 preorder\",\"preorder保证 为二叉树的前序遍历序列\",\"inorder保证 为二叉树的中序遍历序列\"]},\"49\":{\"h\":\"思路分析\",\"t\":[\"思路其实和 106. 从中序与后序遍历序列构造二叉树 一样：\",\"1、从前序遍历中找到根结点： 与后序遍历不同的是，根节点为前序遍历中的第一个结点\",\"2、从中序遍历中找到根结点的位置\",\"3、确定根结点左子树的起始范围\",\"4、确定根结点右子树的起始范围\",\"不断循环上面的步骤，直到构建出二叉树！\",\"与后序遍历+中序遍历不同的是，每次循环左子树、右子树的起始范围不同，看下面这张图：\",\"image-20231114221040622\",\"class Solution { // 使用map保存inOrder节点值与下标的对应关系 HashMap<Integer, Integer> map = new HashMap<>(); public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i < inorder.length; i++) { map.put(inorder[i], i); } return helper(preorder, 0, preorder.length - 1, 0, inorder.length - 1); } public TreeNode helper(int[] preorder, int preStart, int preEnd, int inStart, int inEnd) { // 终止条件 if (preStart > preEnd || inStart > inEnd) return null; // 获取根节点 TreeNode root = new TreeNode(preorder[preStart]); // 根据结点值从map中获取根节点的下标 Integer rootIndex = map.get(root.val); // 计算根节点左子树的结点数量 Integer nums_left_nodes = rootIndex - inStart; // 递归处理左右子树 root.left = helper(preorder, preStart + 1, preStart + nums_left_nodes, inStart, rootIndex - 1); root.right = helper(preorder, preStart + nums_left_nodes + 1, preEnd, rootIndex + 1, inEnd); return root; } } \"]},\"50\":{\"h\":\"\",\"t\":[\"给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\",\"创建一个根节点，其值为 nums 中的最大值。\",\"递归地在最大值 左边 的 子数组前缀上 构建左子树。\",\"递归地在最大值 右边 的 子数组后缀上 构建右子树。\",\"返回 nums 构建的 *最大二叉树* 。\",\"示例 1：\",\"img\",\"输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 \",\"示例 2：\",\"img\",\"输入：nums = [3,2,1] 输出：[3,null,2,null,1] \",\"提示：\",\"1 <= nums.length <= 1000\",\"0 <= nums[i] <= 1000\",\"nums 中的所有整数 互不相同\"]},\"51\":{\"h\":\"思路分析\",\"t\":[\"该题和 105、106一样，只不过不再是从前序或者后序找根结点，而是找最大值。\",\"还是要强调一点：注意搜索最大值的起始范围。我才用的左闭右开区间。\",\"假设最大值下标为rootIndex，则左子树搜索范围：[begin,rootIndex), 右子树搜索范围: [rootIndex,end)\",\" public TreeNode constructMaximumBinaryTree(int[] nums) { return helper(nums, 0, nums.length); } public TreeNode helper(int[] nums, int begin, int end) { // 终止条件，如果是左闭右闭区间，则是 begin>end if (begin >= end) return null; // 找到数组最大值的下标 int rootIndex = findMax(nums, begin, end); // 以最大值为根结点 TreeNode root = new TreeNode(nums[rootIndex]); // 递归找左右字数：[begin,rootIdnex) [rootIndex,end) root.left = helper(nums, begin, rootIndex); root.right = helper(nums, rootIndex + 1, end); return root; } private static int findMax(int[] nums, int begin, int end) { // 假设第一个元素为最大值 int max_index = begin; for (int i = begin; i < end; i++) { if (nums[max_index] < nums[i]) { max_index = i; } } return max_index; } \"]},\"52\":{\"h\":\"\",\"t\":[\"给你两棵二叉树： root1 和 root2 。\",\"想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\",\"返回合并后的二叉树。\",\"注意: 合并过程必须从两个树的根节点开始。\",\"示例 1：\",\"img\",\"输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] \",\"示例 2：\",\"输入：root1 = [1], root2 = [1,2] 输出：[2,2] \",\"提示：\",\"两棵树中的节点数目在范围 [0, 2000] 内\",\"-104 <= Node.val <= 104\",\" public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; // 采用先序遍历，先处理结点 root1.val += root2.val; // 根 root1.left = mergeTrees(root1.left,root2.left); // 左 root1.right = mergeTrees(root1.right,root2.right); // 右 return root1; } \"]},\"53\":{\"h\":\"\",\"t\":[\"给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\",\"你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\",\"示例 1:\",\"img\",\"输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] \",\"示例 2:\",\"img\",\"输入：root = [4,2,7,1,3], val = 5 输出：[] \",\"提示：\",\"数中节点数在 [1, 5000] 范围内\",\"1 <= Node.val <= 107\",\"root 是二叉搜索树\",\"1 <= val <= 107\"]},\"54\":{\"h\":\"思路分析\",\"t\":[\"最直观的方法其实就是按照普通二叉树去挨个结点遍历，找到等于val的结点返回即可。什么先序、中序、后序、层序自己选一个喜欢的就行。如下：\",\"层序遍历：\",\" public TreeNode searchBST(TreeNode root, int val) { Queue<TreeNode> queue = new ArrayDeque<>(); queue.add(root); while(!queue.isEmpty()) { TreeNode node = queue.poll(); if (node.val == val) return node; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } return null; } \",\"先序遍历：\",\" public TreeNode searchBST1(TreeNode root, int val) { // 终止条件 if (root == null || root.val == val) return root; TreeNode left = searchBST1(root.left, val); if (left != null ) return left; return searchBST1(root.right, val); } \",\"但是这样写就违背这道题的初衷了，也没有用到 二叉搜索树的性质，什么性质呢？\",\"对于一个结点，如果它的左右子树不为空，那么就有： \",\"左子树上的所有结点的值都小于该结点的值\",\"右子树上的所有结点的值都大于该结点的值\",\"那么它相较于普通二叉树的搜索来说多了一层判断：\",\"递归：\",\" // 二叉树搜索树--递归 public TreeNode searchBST2(TreeNode root, int val) { // 终止条件 if (root == null || root.val == val) return root; TreeNode result = null; // 去右子树查找 if (root.val < val) result = searchBST2(root.right,val); // 去左子树查找 if (root.val > val) result = searchBST2(root.left,val); return result; } \",\"迭代：\",\" // 二叉搜索树 -迭代 public TreeNode searchBST3(TreeNode root, int val) { // 大于val，去左子树查找 // 小于val，去右子树查找 // 等于val，直接返回 while(root != null) { if (root.val > val) root = root.left; else if (root.val < val) root = root.right; else return root; } return null; } \"]},\"55\":{\"h\":\"\",\"t\":[\"给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\",\"有效 二叉搜索树定义如下：\",\"节点的左子树只包含 小于 当前节点的数。\",\"节点的右子树只包含 大于 当前节点的数。\",\"所有左子树和右子树自身必须也是二叉搜索树。\",\"示例 1：\",\"img\",\"输入：root = [2,1,3] 输出：true \",\"示例 2：\",\"img\",\"输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 \",\"提示：\",\"树中节点数目范围在[1, 104] 内\",\"-231 <= Node.val <= 231 - 1\"]},\"56\":{\"h\":\"思路分析\",\"t\":[\"第一种方法：\",\"将二叉树中序遍历，遍历的元素放放到集合中，判断集合是否有序 （如果是搜索树那么中序遍历一定是从小到大排列）\",\" public boolean isValidBST1(TreeNode root) { ArrayList<Integer> res = new ArrayList<>(); dfs(root,res); for (int i = 1; i < res.size(); i++) { // 如果是搜索树，res一定是从小到大排 if (res.get(i) <= res.get(i-1)) return false; } return true; } // 中序遍历 public void dfs(TreeNode root, List<Integer> res) { if (root == null) return; // 左 dfs(root.left,res); // 根 res.add(root.val); // 右 dfs(root.right,res); } \",\"第二种方法：\",\"二叉搜索树的中序遍历一定是升序的，因此我们可以判断当前结点是否比上一个节点大，如果小于或者等于，说明不满足二叉搜索树。\",\" // 中序遍历 public boolean isValidBST(TreeNode root) { if (root == null) return true; // 左 boolean left = isValidBST(root.left); // 根, 中序遍历二叉搜索树是升序的，判断当前结点是否比上一个节点大，如果小于或者等于，就不是一颗二叉搜索树 if (root.val <= minValue) return false; minValue = (long) root.val; // 右 boolean right = isValidBST(root.right); return left && right; } \"]},\"57\":{\"h\":\"\",\"t\":[\"给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\",\"差值是一个正数，其数值等于两值之差的绝对值。\",\"示例 1：\",\"img\",\"输入：root = [4,2,6,1,3] 输出：1 \",\"示例 2：\",\"img\",\"输入：root = [1,0,48,null,null,12,49] 输出：1 \",\"提示：\",\"树中节点的数目范围是 [2, 104]\",\"0 <= Node.val <= 105\"]},\"58\":{\"h\":\"思路分析\",\"t\":[\"依然利用二叉搜索树的行： 左子树 < 根节点 < 右子树， 那么中序遍历： 左 -- 根 -- 右，遍历出来的一定是一个升序数组。\",\"可以先利用中序遍历保存到一个集合中，然后遍历集合求相邻俩个结点的差，找出最小的即可。\",\"也可以在遍历过程中，维护一个变量，保存上一个结点的值，不断更新这个变量，并且求出当前结点与这个变量的差。\",\" // 用来保存结果值 private Integer res = -2000000; // 保存遍历的上一个结点的值 private Integer pre = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { dfs(root); return res; } /** * 二叉搜索树的最小绝对差，只可能出现在相邻的结点中 * 1、左孩子结点 和 父节点 * 2、父节点 和 右孩子结点 * 因此我们需要保存上一个结点的值 * */ public void dfs(TreeNode root) { if (root == null) return; dfs(root.left); res = Math.min(res,root.val - pre); pre = root.val; dfs(root.right); } \",\"技巧：\",\"在递归遍历的过程中，一定要学会记录前后俩个指针。\"]},\"59\":{\"h\":\"\",\"t\":[\"给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。\",\"如果树中有不止一个众数，可以按 任意顺序 返回。\",\"假定 BST 满足如下定义：\",\"结点左子树中所含节点的值 小于等于 当前节点的值\",\"结点右子树中所含节点的值 大于等于 当前节点的值\",\"左子树和右子树都是二叉搜索树\",\"示例 1：\",\"img\",\"输入：root = [1,null,2,2] 输出：[2] \",\"示例 2：\",\"输入：root = [0] 输出：[0] \",\"提示：\",\"树中节点的数目在范围 [1, 104] 内\",\"-105 <= Node.val <= 105\",\"**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\"]},\"60\":{\"h\":\"思路分析\",\"t\":[\"如果是普通二叉树，我们这道题该如何做呢？\",\"遍历二叉树，然后使用map统计二叉树出现的次数，然后将map按照出现的次数升序，最后取出频率最高的结点即可。\",\"这道题也可以这样做，但是这就失去了这道题的意义，如何利用二叉搜索树的性质解决这道题呢？\",\"二叉搜索树的中序遍历一定是升序的(这句话背下来) ，因此它相同的结点一定是相邻的。\",\"那么好了，我们又要用到上面的技巧了，在遍历的过程需要记录上一个结点的值，我们需要判断 当前结点 是否和上一个结点相同，如果相等我们就记录次数 count++。如果不相等，就将次数count 恢复成 1 。\",\"并且我们还需要一个变量maxCount 记录出现的最大频率，如果 count == maxCount 我们就记录这个结点，代码如下：\",\" if (count == maxCount) { res.add(root.val); } \",\"但是问题来了，我们怎么知道当前结点出现的频率是不是最高的呢？ 因此我们还需要再多一层比较，如果count > maxCount 就说明当前结点比上一个结点出现的频率要高，因此清空res集合，将当前结点重新加入进去。\",\"完整代码如下：\",\" // 上一个结点的值 private Integer pre = Integer.MIN_VALUE ; // 记录结点出现的频率 private Integer count= 0; // 记录遍历时出现的最大频率 private Integer maxCount = 0; private List<Integer> res = new ArrayList<>(); public int[] findMode(TreeNode root) { dfs(root); int[] ints = new int[res.size()]; for (int i = 0; i < res.size(); i++) { ints[i] = res.get(i); } return ints; } public void dfs(TreeNode root){ if (root == null) return; dfs(root.left); // 统计出现的频率 if(root.val == pre) { count++; }else { count=1; } if (count == maxCount) { // 说明遍历到当前结点为止，该结点的值已经是出现的频率最高了，因此需要将当前节点的值放入集合中 // 但是并不代表 遍历完所有结点后，当前结点的值出现的频率还是最高 res.add(root.val); }else if (count > maxCount){ // 此时 count > maxCount,说明已经出现比上一个元素出现频率更高的元素了。 // 因此需要将上一个元素清空，并重新记录当前这个频率更高的元素 res.clear(); res.add(root.val); maxCount = count; } pre = root.val; dfs(root.right); } \"]},\"61\":{\"h\":\"\",\"t\":[\"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\",\"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\",\"示例 1：\",\"img\",\"输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 \",\"示例 2：\",\"img\",\"输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 \",\"示例 3：\",\"输入：root = [1,2], p = 1, q = 2 输出：1 \",\"提示：\",\"树中节点数目在范围 [2, 105] 内。\",\"-109 <= Node.val <= 109\",\"所有 Node.val互不相同 。\",\"p != q\",\"p 和 q 均存在于给定的二叉树中。\"]},\"62\":{\"h\":\"思路分析\",\"t\":[\"公共祖先：简单来说就是一个或多个结点的共同父节点(若只有一个结点，本身也是公共祖先)\",\"先来讨论一下几种情况，假设 root 为 p、q的公共祖先，那么一共有以下几种情况：\",\"q和p在二叉树的异侧，即一个在左子树一个在右子树\",\"p = root，即q在p的左子树或者右子树\",\"q=root，即p在q的右子树或者左子树\",\"根据以上条件，我们可以定义一个递归，用来寻找公共祖先：\",\"终止条件：\",\"$root == null$ 则返回 root\",\"$root == q || root == p$ , 则直接返回 root\",\"返回值：\",\"由于我们使用的是递归，默认左右子树已经有结果，即用 **left ** 和 right 表示：\",\"若left == null，则公共祖先在右子树，返回 right\",\"若 right == null ，则公共祖先在左子树，返回 left\",\"如果 root != null && right != null ， 说明 p 和 q在root的左右子树中，即 root 就是公共祖先，返回 root\",\"若 root == null && right == null ，则不存在公共祖先，返回NULL （此步判断其实已经包在 1 和 2里）\",\" public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if ( root == q || root == p || root == null) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); // 遍历左子树 TreeNode right = lowestCommonAncestor(root.right,p,q); // 遍历右子树 // 如果左子树为空，说明 最近的公共祖先在右子树上，返回right if (left == null) return right; // 同理，右子树为空，说明左子树上存在公共祖先 if (right == null) return left; // 如果 left和right都不为空，说明当前结点就是公共祖先 return root; } \"]},\"63\":{\"h\":\"\",\"t\":[\"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\",\"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\",\"例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\",\"img\",\"示例 1:\",\"输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 \",\"示例 2:\",\"输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 \",\"说明:\",\"所有节点的值都是唯一的。\",\"p、q 为不同节点且均存在于给定的二叉搜索树中。\"]},\"64\":{\"h\":\"思路分析\",\"t\":[\"利用二叉搜索树的性质：\",\"如果 root.val 比 q、p都大，说明公共祖先在 root 的左子树上\",\"如果 root.val 比 q、p都小，说明公共祖先在 root 的右子树上\",\"如果 root.val 在 [p,q]或者[q,p] 区间之内，说明root就是公共祖先\",\" public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 如果 root 比 q、p都大说明在root的左边 if (root.val > q.val && root.val > p.val) return lowestCommonAncestor(root.left,p,q); // 如果 root 比 q、p都小说明在root的左右边 if (root.val < q.val && root.val < p.val) return lowestCommonAncestor(root.right,p,q); // 如果 root在 [p,q]的区间之内，说明root就是公共祖先 return root; } \"]},\"65\":{\"h\":\"\",\"t\":[\"给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\",\"注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\",\"示例 1：\",\"img\",\"输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： \",\"示例 2：\",\"输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] \",\"示例 3：\",\"输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] \",\"提示：\",\"树中的节点数将在 [0, 104]的范围内。\",\"-108 <= Node.val <= 108\",\"所有值 Node.val 是 独一无二 的。\",\"-108 <= val <= 108\",\"保证val 在原始BST中不存在。\"]},\"66\":{\"h\":\"思路分析\",\"t\":[\"题目中说，二叉搜索树中的任意一个结点都不相同，并且val在二叉树中不存在。\",\"那么我们就可以直接遍历二叉搜索树，找到一个空的位置插入即可。\",\"当前结点值 < val 就去右子树搜索\",\"当前结点值 > val 就去左子树搜索\",\"如果当前节点值为空，则该位置就是要插入的位置\",\"递归\",\" // 递归 public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); // 递归左右子树，如果小于val，就去右子树搜索。相反则去左子树上去搜索 if (root.val < val) root.right = insertIntoBST(root.right,val); if (root.val > val) root.left = insertIntoBST(root.left,val); return root; } \",\"迭代\",\" public TreeNode insertIntoBST1(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode cur = root; while(cur != null) { if (cur.val < val) { // 去右子树上搜素 if (cur.right == null) { // 右子树为空，直接插入 cur.right = new TreeNode(val); break; }else { // 如果不为空，继续往下遍历 cur = cur.right; } }else { // 左子树上去搜索 if (cur.left == null) { cur.left = new TreeNode(val); break; }else { cur = cur.left; } } } return root; } \"]},\"67\":{\"h\":\"\",\"t\":[\"给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\",\"一般来说，删除节点可分为两个步骤：\",\"首先找到需要删除的节点；\",\"如果找到了，删除它。\",\"示例 1:\",\"img\",\"输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 \",\"示例 2:\",\"输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 \",\"示例 3:\",\"输入: root = [], key = 0 输出: [] \",\"提示:\",\"节点数的范围 [0, 104].\",\"-105 <= Node.val <= 105\",\"节点值唯一\",\"root 是合法的二叉搜索树\",\"-105 <= key <= 105\",\"进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。\"]},\"68\":{\"h\":\"思路分析\",\"t\":[\"二叉搜索树的题目往往都可以使用递归来解决\",\"结束条件\",\"当 root 为空的时候，则返回 root\",\"返回值\",\"在二叉搜索树的插入中，用返回值确定插入的结点，此处也可以用返回值来确定要删除的结点\",\"单层递归逻辑\",\"此处就是删除结点的逻辑，我们需要分情况讨论：\",\"没有找到删除的结点，遍历到空结点直接返回\",\"找到删除的结点，假设为root \",\"第一种情况：root为叶子结点，即没有左右子树，直接删除即可，返回 NULL\",\"第二种情况：左子树不为空，右子树为空，返回左子树代替删除结点root\",\"第三种情况：右子树不为空，左子树为空，返回右子树代替删除节点root\",\"第四种情况：也是最复杂的情况，左右子树均不为空时，将 root 的左子树移动到 root 的右子树的最左侧结点的左子树上(即root的右子树最小结点上)，如图所示：\",\"image-20231121231225377\",\"image-20231121231408805\",\" public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return root; if (root.val == key) { // 此时root为要删除的结点 // 第一种情况：左右子树都为空，直接删除结点 if (root.right == null && root.left == null) return null; // 第二种情况：左子树不为空，右子树为空，返回左子树为新的子树 if (root.right == null) return root.left; // 第三种情况：左子树为空，右子树不为空，返回右子树为新的子树 if (root.left == null) return root.right; // 第四种情况：左右子树都不为空 TreeNode cur = root.right; // 移动到要删除结点的右子树的最左边的结点(删除结点右子树的最小值) while (cur.left != null) cur = cur.left; // 删除操作 // 将删除结点的左子树移动到 删除结点的右子树中最小结点的左子树上 cur.left = root.left; // 覆盖删除结点 root = root.right; return root; } if (root.val > key) root.left = deleteNode(root.left, key); if (root.val < key) root.right = deleteNode(root.right, key); return root; } \"]},\"69\":{\"h\":\"\",\"t\":[\"给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\",\"所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\",\"示例 1：\",\"img\",\"输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] \",\"示例 2：\",\"img\",\"输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] \",\"提示：\",\"树中节点数在范围 [1, 104] 内\",\"0 <= Node.val <= 104\",\"树中每个节点的值都是 唯一 的\",\"题目数据保证输入是一棵有效的二叉搜索树\",\"0 <= low <= high <= 104\"]},\"70\":{\"h\":\"思路分析\",\"t\":[\"这道题其实和 450 道题差不多，无非就是一个删除单个结点，该题可能删除多个结点。\",\" public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) return root; root.right = trimBST(root.right, low, high); root.left = trimBST(root.left, low, high); if (!(root.val <= high && root.val >= low)) { // 找到修剪的结点 // 第一种情况：左右子树都为null，直接返回null if (root.left == null && root.right == null) return null; // 第二种情况：左子树为空，右子树不为空，返回右子树为新的子树 if (root.left == null) return root.right; // 第三种情况：左子树不为空，右子树为空，返回左子树为新的子树 if (root.right == null) return root.left; // 第四种情况：当左右子树都不为空时，将 删除结点的左子树 移动到删除节点右子树中最小的结点 TreeNode curr = root.right; while (curr.left != null) { curr = curr.left; } // 将删除结点的左子树移动到cur的左子树上 curr.left = root.left; root = root.right; return root; } return root; } \",\"但是我们大可不必这么麻烦，题目中给了 [low,high] 区间，那么:\",\"当 root.val > high 时，说明root的整颗右子树都要修剪掉，我们直接跳过root结点及右子树，从root.left开始递归\",\"当 root.val < left时，说明root的整颗左子树都要修剪掉，我们直接跳过root结点及左子树，从root.right开始递归\",\" public TreeNode trimBST1(TreeNode root, int low, int high) { if (root == null) return root; // root.val < low 不在范围内，说明root的整颗左子树都符合修剪条件，跳过root及左子树，从右子树开始递归 if (root.val < low) return trimBST1(root.right,low,high); // 同理，root.val比最大值还大，说明root的整颗右子树都符合修剪条件，跳过root结点及右子树，递归左子树 if (root.val > high) return trimBST1(root.left,low,high); // 此时接入上面返回的左子树或者右子树 root.left = trimBST(root.left,low,high); root.right = trimBST(root.right,low,high); return root; } \"]},\"71\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\",\"高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\",\"示例 1：\",\"img\",\"输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： \",\"示例 2：\",\"img\",\"输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 \",\"提示：\",\"1 <= nums.length <= 104\",\"-104 <= nums[i] <= 104\",\"nums 按 严格递增 顺序排列\"]},\"72\":{\"h\":\"思路分析\",\"t\":[\"在写这道题之前，建议看看\",\"654. 最大二叉树\",\"106. 从中序与后序遍历序列构造二叉树\",\"105. 从前序与中序遍历序列构造二叉树\",\"该题和上面三题思路一样，只不过是找根结点和递归的边界有所不同。\",\"那么在 此题中，根节点为数组中间的一个，而根节点左边为左子树，根节点右边为右子树\",\"image-20231122222756717\",\" public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length); } public TreeNode helper(int[] nums, int left, int right) { if (left > right) return null; // 确定根结点 int rootIndex = left(right - left) / 2; TreeNode root = new TreeNode(nums[rootIndex]); // 递归创建左右子树 root.left = helper(nums, left, rootIndex - 1); root.right = helper(nums, rootIndex + 1, right); return root; } \"]},\"73\":{\"h\":\"\",\"t\":[\"给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\",\"提醒一下，二叉搜索树满足下列约束条件：\",\"节点的左子树仅包含键 小于 节点键的节点。\",\"节点的右子树仅包含键 大于 节点键的节点。\",\"左右子树也必须是二叉搜索树。\",\"**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\",\"示例 1：\",\"输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] \",\"示例 2：\",\"输入：root = [0,null,1] 输出：[1,null,1] \",\"示例 3：\",\"输入：root = [1,0,2] 输出：[3,3,2] \",\"示例 4：\",\"输入：root = [3,2,4,1] 输出：[7,9,4,10] \",\"提示：\",\"树中的节点数介于 0 和 104 之间。\",\"每个节点的值介于 -104 和 104 之间。\",\"树中的所有值 互不相同 。\",\"给定的树为二叉搜索树。\"]},\"74\":{\"h\":\"思路分析\",\"t\":[\"题目要求将结点的值改为比当前结点值 大于或等于 节点值的总和\",\"这样可能不好理解，我举个栗子：\",\"将二叉搜索树变成一个有序数组（中序遍历），[0,1,2,3,4,5,6,7,8] ，那么求节点4的新值，就是 4+5+6+7+8=30， 求节点5的新值为：5+6+7+8 = 26\",\"其实就是从后到前累加节点的和！！！！\",\" public TreeNode convertBST(TreeNode root) { dfs(root); return root; } public void dfs(TreeNode root) { if (root == null) return; // 从最大值开始遍历 dfs(root.right); // 累加从后到当前节点的和 total += root.val; root.val = total; dfs(root.left); } \"]},\"75\":{\"c\":[\"算法\"]},\"76\":{\"c\":[\"二叉树\",\"二叉树遍历\",\"平衡二叉树\",\"搜索二叉树\"]},\"77\":{\"h\":\"动态规划\",\"t\":[\"动态规划与贪心的区别：\",\"动态规划的每一步都是由上一步推导出来来的\",\"贪心则是每一步尽量选择最优解，与上一步没有关系\",\"动态规划五部曲：\",\"确定dp数组（dp table）以及下标的含义\",\"确定递推公式\",\"dp数组如何初始化\",\"确定遍历顺序\",\"举例推导dp数组\"]},\"78\":{\"h\":\"\",\"t\":[\"斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\",\"F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 \",\"给定 n ，请计算 F(n) 。\",\"示例 1：\",\"输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 \",\"示例 2：\",\"输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 \",\"示例 3：\",\"输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 \",\"提示：\",\"0 <= n <= 30\"]},\"79\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组（dp table）以及下标的含义\",\"保存前 i 项的和\",\"确定递推公式\",\"递推公式其实题目中已经给出。dp[i] = dp[i-1] + dp[i-2]\",\"dp数组如何初始化\",\"dp[0]=0 、dp[1]=1\",\"确定遍历顺序\",\"举例推导dp数组\",\" public int fib(int n) { if (n <= 1) return n; // 定义dp数组,dp数组的含义：保存前N项的和 int[] dp = new int[n+1]; // 初始化F0=0，F1=1 dp[0] = 0; dp[1] = 1; for (int i = 2; i <= n; i++) { // 确定递推公式 dp[i-1] + dp[i-2] dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } \"]},\"80\":{\"h\":\"\",\"t\":[\"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\",\"每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\",\"示例 1：\",\"输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 \",\"示例 2：\",\"输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 \",\"提示：\",\"1 <= n <= 45\"]},\"81\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组（dp table）以及下标的含义\",\"dp[i]： 爬到第i层楼梯，有dp[i]种方法\",\"确定递推公式\",\"第 i 层，只能通过 i-1 层 或者 i-2 层上来(只能跨1步或者2步)，因此第i层的方法其实就是 i-1 层的方法 + i -2 层的方法。即：dp[i] = dp[i-1] + dp[i-2]\",\"dp数组如何初始化\",\"dp[1] = 1, dp[2] = 2 第一层只有一种方法，第二层有俩种方法 即 1+1， 2\",\"确定遍历顺序\",\"举例推导dp数组\",\" public int climbStairs(int n) { if (n < 3) return n; // 定义dp数组,含义：保存爬到第i层有dp[i]中方案 int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } \",\"优化\",\"像这种dp问题，由于 dp[i] dp[i-1] 之和 dp[i-2] 有关系，我们可以利用滚动数组的思想：\",\"fig1\",\" // 优化：利用滚动数组的思想 public int climbStairs1(int n) { int p = 0, q = 0, r = 1; for (int i = 1; i <= n; i++) { p = q; q = r; r = p + q; } return r; } \"]},\"82\":{\"h\":\"\",\"t\":[\"给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\",\"你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\",\"请你计算并返回达到楼梯顶部的最低花费。\",\"示例 1：\",\"输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。 - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 \",\"示例 2：\",\"输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。 - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。 \",\"提示：\",\"2 <= cost.length <= 1000\",\"0 <= cost[i] <= 999\"]},\"83\":{\"h\":\"思路分析\",\"t\":[\"假设 cost = [10,15,20] ,其实要走四节楼梯才能到达楼顶，如图所示：\",\"image-20231227222904092\",\"从第0层走到 1 、2 层是不需要花费体力的\",\"假设我们从第0层一次性爬俩步到第二层，花费体力为0.\",\"从第二层我们仍然可以选择一次性爬俩步到达楼顶，总共花费：15\",\"确定dp数组（dp table）以及下标的含义 \",\"dp[i] : 表示爬到第 i 节楼梯最低的花费\",\"由于楼梯数要比层数大1，因此：dp[cost.length+1]\",\"确定递推公式 \",\"到达第 i 节楼梯时，一共有俩种方式： \",\"可以从第 i-1 节使用 cost[i-1] 到达\",\"可以从 i-2 节使用 cost[i-2] 到达\",\"因此为了使花费最少，应在以上俩种方式中选择一个花费最少的： \",\"dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])\",\" public int minCostClimbingStairs(int[] cost) { // 定义dp数组，含义：爬到第i层的最低花费 int[] dp = new int[cost.length+1]; // 第一步不需要花费 dp[0] = 0; dp[1] = 0; for (int i = 2; i <= cost.length; i++) { // 选择最少的花费开始爬 dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } System.out.println(Arrays.toString(dp)); return dp[cost.length]; } \"]},\"84\":{\"h\":\"\",\"t\":[\"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\",\"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\",\"问总共有多少条不同的路径？\",\"示例 1：\",\"img\",\"输入：m = 3, n = 7 输出：28 \",\"示例 2：\",\"输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 3. 向下 -> 向右 -> 向下 \",\"示例 3：\",\"输入：m = 7, n = 3 输出：28 \",\"示例 4：\",\"输入：m = 3, n = 3 输出：6 \",\"提示：\",\"1 <= m, n <= 100\",\"题目数据保证答案小于等于 2 * 109\"]},\"85\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组（dp table）以及下标的含义 \",\"当前位置共有dp[i][j] 种路径\",\"确定递推公式\",\"这道题其实我们仔细找一下规律和杨辉三角非常的像\",\"每种结果都等于 上面的结果 + 左边的结果 , 用转化为 递推公式为：dp[i][j] = dp[i][j-1] +dp[i-1][j] \",\"image-20231228222645533\",\"dp数组如何初始化\",\"通过上图可以得知，第一行和第一列初始化为1\",\"确定遍历顺序\",\"从递推公式可以看出，当前结果是由上一层和前一列得出，因此一层一层的从左往右遍历即可。\",\"举例推导dp数组\",\"完整代码\",\" /** * 1. 确定dp数组下标含义 dp[i][j] 到每一个坐标可能的路径种类 * 2. 递推公式 dp[i][j] = dp[i-1][j] dp[i][j-1] * 3. 初始化 dp[i][0]=1 dp[0][i]=1 初始化横竖就可 * 4. 遍历顺序 一行一行遍历 * 5. 推导结果 。。。。。。。。 * * @param m * @param n * @return */ public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; //初始化 for (int i = 0; i < m; i++) { dp[i][0] = 1; } for (int i = 0; i < n; i++) { dp[0][i] = 1; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } \"]},\"86\":{\"h\":\"\",\"t\":[\"给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。\",\"返回 你可以获得的最大乘积 。\",\"示例 1:\",\"输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 \",\"示例 2:\",\"输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 \",\"提示:\",\"2 <= n <= 58\"]},\"87\":{\"h\":\"思路分析\",\"t\":[\"对于整数 n 来说，他的每个正整数的最大乘积取决于上一个整合的最大乘积，因此我们可以用 动态规划\",\"1、dp数组下标的含义\",\"dp[i] : 表示将 整数 i 拆分成整数的最大乘积为 dp[i]\",\"2、dp数组的初始化\",\"dp[0] = dp[1] = 0 , dp[2] = 2\",\"3、确定递推公式\",\"n >= 2, 假设拆分出第一个整数为 j，那么他有俩种可能得到最大乘积：\",\"拆分俩个正整数：j 和 i-j ，则乘积为：(i-j) * j\",\"拆分俩个以上的正整数：j 和 i-j 拆分更多的正整数，则乘积为： dp[i-j] * j\",\"dp[i-j] 相当于拆分 i-j，得到的是 i-j 的最大乘积 \",\"完整代码\",\"class Solution { public int integerBreak(int n) { if (n == 2) return 1; // 定义dp数组 int[] dp = new int[n + 1]; // 初始化，整数为2，最大乘积就是 1*1 = 2 dp[2] = 1; for (int i = 3; i <= n; i++) { // j表示拆分的正整数，从1开始，0没有意义，任何数*0=0 for (int j = 1; j < i - 1; j++) { /* * (i - j) * j 表示拆分成2个正整数: j 和 i-j * dp[i - j] * j : 表示将 i-j拆分成多个正整数 * */ dp[i] = Math.max(dp[i], Math.max((i - j) * j, dp[i - j] * j)); } } return dp[n]; } } \"]},\"88\":{\"h\":\"\",\"t\":[\"给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\",\"示例 1：\",\"img\",\"输入：n = 3 输出：5 \",\"示例 2：\",\"输入：n = 1 输出：1 \",\"提示：\",\"1 <= n <= 19\"]},\"89\":{\"h\":\"思路分析\",\"t\":[\"1、定义dp数组以及下标的含义\",\"dp[i] 表示：整数为i时，一共可以构建 dp[i] 种二叉搜索树\",\"2、初始化\",\"dp[0] = dp[1] = 1, 空树也算二叉搜索树\",\"3、确定递推关系式\",\"image-20240103221010457\",\"image-20240103221447619\",\"当头结点为 1 或者 3 时，我们看左右子节点其实和 n=2 时一样\",\"当头结点为 2 时，左右子节点其实和 n=1 一样\",\"// 因此求 n 个结点的二叉搜索树的数量时就是： 左子树的二叉搜素树数量 * 右子树的二叉搜索树数量 // 假设头结点为 j，则有： dp[i] += dp[j-1] * dp[i-j] // j-1 为左子树，i-j为右子树，这是利用了二叉搜索树的性质。 // 使用 += 的原因是因为我们要逐渐累加左右子树的二叉搜索树的数量 \",\"完整代码\",\"class Solution { public int numTrees(int n) { // 定义dp数组 int[] dp = new int[n+1]; // 初始化 dp[0] = dp[1] = 1; // 外层循环计算由 2~n的二叉搜索树数量 for (int i = 2; i <= n; i++) { // 内层循环计算: 由j为头结点时，左右子树的二叉搜索树数量 for (int j = 1; j <= i; j++) { // 使用 += 是因为我们要逐渐累加头结点为 1~i时的左右子树的二叉搜索树的数量 dp[i] += dp[j-1] * dp[i-j]; } } return dp[n]; } } \"]},\"90\":{\"h\":\"背包问题\",\"t\":[\"对于背包问题，分为：01背包、完全背包、多重背包、分组背包等等，掌握01、完全背包对付面试完全足够了！\",\"01背包：有n种物品，每种物品只有一个\",\"完全背包：有n种物品，每种物品有无限个\",\"多重背包：有n种物品，每种物品的个数不确定\"]},\"91\":{\"h\":\"01背包-二维数组\",\"t\":[\"有一个背包，容量为4磅 ， 现有如下物品， 要求达到的目标为装入的背包的总价值最大，并且重量不超出背包的容量， 要求装入的物品不能重复\",\"重量w\",\"价值v\",\"物品0\",\"1\",\"15\",\"物品1\",\"3\",\"20\",\"物品2\",\"4\",\"30\",\"确定dp数组及下标的含义\",\"对于01背包问题，可以使用基础的二维数组，也可以用优化的一维数组。先来说二维数组\",\"dp[i][j] : 表示装入 0~i 个物品，重量为 j 的最大价值\",\"确定递推关系式\",\"确定关系式，就要知道 dp[i][j] 由哪种情况可以得来，对于背包问题来说，无非有俩种情况，一种是不放第 i 个物品，一种是放第 i 个物品：\",\"不放第 i 个物品 的价值，当前背包容量小于第 i 个物品的重量： dp[i-1][j]\",\"放第i 个物品的价值，当前背包容量大于等于第 i 个物品的重量： dp[i-1][j-w[i]] + v[i]\",\"dp[i-1][j-w[i]] + v[i] : 背包容量 - 物品i的重量 所能装入物品的最大价值 + 物品i的价值 \",\"俩种方案选择最大价值的为结果：\",\"Math.max（dp[i-1][j]，dp[i-1][j-w[i]] + v[i]）\",\"初始化dp数组\",\"当 j = 0 时，放不下任何物品，其总价值也一定为0.\",\"image-20240104212748795\",\"当 j != 0 时，我们说了有俩种方案可以得到当前的总价值，一个是由正上方推导而来，一个是由左上方推导而来，因此我们还需要初始化第一行。 需要注意的是，如果物品0的重量为3，那么对于重量为 1、2时，他的总价值也为0\",\"image-20240104213223574\",\"完整代码\",\"public class Knapsack01 { public static void main(String[] args) { int[] weight = {1, 2, 4}; int[] value = {15, 20, 30}; testWeightBagProblem(weight, value, 4); } public static void testWeightBagProblem(int[] weight, int[] value, int bagSize) { // 定义dp数组:，dp[i][j]含义：放入0~i个物品重量为 j 时的最大价值 int[][] dp = new int[weight.length][bagSize + 1]; // 初始化dp数组，第一行为物品0的价值 for (int j = 1; j <= bagSize; j++) { dp[0][j] = value[0]; } // 填充dp数组 for (int i = 1; i < weight.length; i++) { // 遍历物品 for (int j = 1; j <= bagSize; j++) { // 遍历背包容量 if (weight[i] > j) { // 当前物品的容量大于背包容量 dp[i][j] = dp[i - 1][j]; } else { // 当前物品容量小于或等于背包容量 dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } } // 打印dp数组 for (int i = 0; i < weight.length; i++) { for (int j = 0; j <= bagSize; j++) { System.out.print(dp[i][j] + \\\"\\\\t\\\"); } System.out.println(\\\"\\\\n\\\"); } } } \"]},\"92\":{\"h\":\"\",\"t\":[\"相较于二维数组的实现，一维数组其实就是将每一行的数据都进行拷贝。利用上一层的数据拷贝到当前层(滚动数组)\",\"dp数组的含义\",\"dp[j] : 表示重量为 j 的容量的最大价值\",\"递推关系式\",\"同样是有俩种情况：\",\"不放入第 i 个物品: dp[j]\",\"放入第 i 个物品 ： dp[j-weight[i]] + value[i]\",\"初始化\",\"初始化尽量初始化成一个最小的非负整数，避免由于值太大而覆盖原本计算出来的值，这里直接都初始化成0是可以的\",\"遍历顺序\",\"一维数组的遍历顺序是非常讲究的，在二维数组中我们正序、倒序遍历都可以，但是在一维数组中，我们只能倒序，即：\",\" for (int i = 0; i < weight.length; i++) { // 遍历物品 for (int j = bagSize; j >= weight[i]; j--) { // 遍历背包容量，一定要倒序，保证每个物品仅增加一遍 } } \",\"这是因为我们使用的是一维数组，每个值都是需要重复使用的，如果正序遍历，就会导致一个物品被重复装入的可能。\",\"比如：\",\"dp[j-weight[i]] + value[i] 带入：\",\"dp[1] = dp[1-1] + 15 = 15\",\"dp[2] = dp[2-1] + 15 = 30\",\"可以发现，容量为2时，重复增加了物品0\",\"倒序就不会出现这种情况：\",\"dp[2] = dp[2-1] + 15 = 15\",\"dp[1] = dp[1-1] + 15 = 15\",\"完整代码\",\" // 一维数组实现 public static void testWeightBagProblemByOne(int[] weight, int[] value, int bagSize) { // dp[j] 表示容量为j时 所能装入的最大价值 int[] dp = new int[bagSize + 1]; // 填充数组 for (int i = 0; i < weight.length; i++) { // 遍历物品 for (int j = bagSize; j >= weight[i]; j--) { // 遍历背包容量，一定要倒序，保证每个物品仅增加一遍 dp[j] = Math.max(dp[j - weight[i]] + value[i],dp[j]); } } System.out.println(Arrays.toString(dp)); } \"]},\"93\":{\"h\":\"完全背包\",\"t\":[\"完全背包与01背包的区别: 01背包中的物品只能使用一次，完全背包中的物品可以无限使用\",\"在 01背包问题中起始就有过说明,在我们遍历容量的时候要使用倒序，目的就是为了防止物品重复增加，而对于完全背包来说，只需要将容量正序遍历即可。\",\" for (int i = 0; i < weight.length; i++) { // 遍历物品 for (int j = weight[i]; j <= bagSize; j--) { // 遍历背包容量 dp[j] = Math.max(dp[j - weight[i]] + value[i],dp[j]); } } for (int j = 0; j <= bagSize; j--) { // 遍历背包容量 for (int i = 0; i < weight.length; i++) { // 遍历物品 if(j - weight[i] >= 0) dp[j] = Math.max(dp[j - weight[i]] + value[i],dp[j]); } } \",\"对于完全背包问题，其实先遍历物品还是先遍历背包容量是无所谓的, 因为当前背包的价值由前一个背包的价值得来，只要保障前一个价值计算值正确即可。\",\"但是对于LeetCode某些题，遍历顺序就很重要了！！\"]},\"94\":{\"h\":\"\",\"t\":[\"给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\",\"示例 1：\",\"输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 \",\"示例 2：\",\"输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 \",\"提示：\",\"1 <= nums.length <= 200\",\"1 <= nums[i] <= 100\"]},\"95\":{\"h\":\"思路分析\",\"t\":[\"这道题大概一看，可能会发现使用回溯进行求解，但是毫无疑问，超时！！！！\",\"因此，这道题我们也可以转换为 01背包问题，那么我们需要知道以下问题：\",\"物品的价值、重量对应本地中的数组元素值\",\"背包的容量为 数组元素总和 / 2\",\"背包不能放入重复的元素\",\"了解以上问题，我们就可以将这道题转换为01背包问题了\",\"确定dp数组及下标含义\",\"01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。\",\"在这道题中我们可以认为，在容量为 j 时，元素值的最大和为 dp[j] , 由于重量和价值是等价的，因此我们可以认为，当 dp 装满之后，如果等于 数组元素总和 / 2 就说明可以分割成俩个元素相等的子集。\",\"递推关系式\",\"01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\",\"weight[i] 和 value[i] 都是 nums[i], 因此该题的关系式为：\",\"dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\",\"初始化\",\"和01背包一样，都为0\",\"遍历顺序\",\"01背包问题最重要的一个条件就是物品不能重复使用，因此在使用一维数组时，仍然要采取倒序遍历\",\"推导dp数组\",\"输入[1,5,11,5] 为例，如图：\",\"image-20240104232139131\",\"完整代码\",\"class Solution { public boolean canPartition(int[] nums) { if (nums.length == 0) return false; int sum = Arrays.stream(nums).sum(); // 如果可以分割等和子集，则该子集的和为target // 和为奇数，不能分割成等长的子集 if (sum % 2 != 0) return false; int target = sum / 2; int[] dp = new int[target + 1]; for (int i = 0; i < nums.length; i++) { // 保证每个元素只使用一次，一定要倒序！ // nums[i] 即表示重量也表示价值 for (int j = target; j >= nums[i]; j--) { dp[j] = Math.max(dp[j],dp[j-nums[i]] + nums[i]); } // 当dp数组被填满之后，并且最大值为子集的和 if (dp[target] == target) return true; } return dp[target] == target; } } \"]},\"96\":{\"h\":\"\",\"t\":[\"有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\",\"每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：\",\"如果 x == y，那么两块石头都会被完全粉碎；\",\"如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\",\"最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\",\"示例 1：\",\"输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 \",\"示例 2：\",\"输入：stones = [31,26,33,21,40] 输出：5 \",\"提示：\",\"1 <= stones.length <= 30\",\"1 <= stones[i] <= 100\"]},\"97\":{\"h\":\"思路分析\",\"t\":[\"其实这道题难得是 如何转换成01 背包\",\"首先我们看题目描述，目的是随机取走俩个数，计算其差值，将差值放入原数组中，继续与其他元素求差值，使求得的差值最小。\",\"假设有 a,b,c,d 四个元素，并且满足 a >= b >= c >=d\",\"第一次取a,b，求出差值 a - b, 此时 stones = [a-b,c,d]\",\"第二次取c,d，求出差值 c -d , 此时 stones =[a-b,c-d]\",\"第三次取a-b,c-d，求出差值(a-b) - (c-d)\",\"通过上面的例子我们可以看出来，所谓的【取出】【放回】无非是改变元素的符号，最后形成一个扁平化的 【计算表达式】\",\"而想要 (a-b) - (c-d) <==> a-b-c+d <==> (a+d) - (b+c) 这个【计算表达式】差值最小，那么就应该保证a+d 和 b+c 尽可能的接近。接近总和 sum/2。\",\"说到这，其实就和 416. 分割等和子集 题一样了，在 416 题中，是 \\\"==\\\" sum/2 , 而在这道题中是尽可能接近 sum/2.\",\"将 stones 所有的石头尽可能分成俩堆，这俩堆的总和尽可能的接近 sum/2\",\" public int lastStoneWeightII(int[] stones) { // 计算石头的总重量 int sum = Arrays.stream(stones).sum(); // 尽量将俩堆的重量分成相等的情况 int target = sum / 2; int[] dp = new int[target + 1]; for (int i = 0; i < stones.length; i++) { // 遍历物品 for (int j = target; j >= stones[i]; j--) { // 遍历背包，倒序遍历，防止多次放入同一个石头 // 俩种情况，放或者不放 dp[j] = Math.max(dp[j], dp[j - stones[j]] + stones[j]); } } // 俩个target值都不会超过 sum/2 ，因此求出来一定是正整数且最少 return sum - dp[target] * 2; } \"]},\"98\":{\"h\":\"\",\"t\":[\"给你一个非负整数数组 nums 和一个整数 target 。\",\"向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\",\"例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \\\"+2-1\\\" 。\",\"返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\",\"示例 1：\",\"输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 \",\"示例 2：\",\"输入：nums = [1], target = 1 输出：1 \",\"提示：\",\"1 <= nums.length <= 20\",\"0 <= nums[i] <= 1000\",\"0 <= sum(nums[i]) <= 1000\",\"-1000 <= target <= 1000\"]},\"99\":{\"h\":\"思路分析\",\"t\":[\"这道题与上面的动态规划题有些不一样，在我们做过的动态背包问题中，都是背包最大容量下能够装多少\",\"而这道题则是有多少种方式能够将背包装满，这么一听貌似是组合问题，可以用回溯算法。\",\"但是回溯算法的时间复杂度为：2n 对于这道题超时！！\",\"那么如何转化为动态规划呢？\",\"假如表达式中的加法总和为 x ，那么对应的减法总和为: sum - x\",\"进一步推导 x - (sum - x )= target, x = (target - sum)/2 ， 此时target、sum已知，而问题的关键就是在nums中求出 x 的集合。\",\"x 就是我们背包的容量，还需要注意一点，假设 (target - sum)/2 不是整除的话，其实是没有结果的。\",\"定义dp数组\",\"dp[j]:表示容量为j时，有dp[j]种方法\",\"确定递推关系式\",\"有哪些来源可以推出dp[j]呢？\",\"只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。\",\"例如：dp[j]，j 为5，\",\"已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。\",\"已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。\",\"已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包\",\"已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包\",\"已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包\",\"那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\",\"dp[j] += do[j-nums[i]] \",\"初始化\",\"在初始化时，我们要将 dp[0] = 1, 如果=0的话，无论有多少种方法最后都是0\",\" public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; //如果target过大 sum将无法满足 if ( target < 0 && sum < -target) return 0; if ((target + sum) % 2 != 0) return 0; int size = (target + sum) / 2; if(size < 0) size = -size; int[] dp = new int[size + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = size; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[size]; } \"]},\"100\":{\"h\":\"\",\"t\":[\"给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\",\"请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\",\"如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\",\"示例 1：\",\"输入：strs = [\\\"10\\\", \\\"0001\\\", \\\"111001\\\", \\\"1\\\", \\\"0\\\"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\\\"10\\\",\\\"0001\\\",\\\"1\\\",\\\"0\\\"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\\\"0001\\\",\\\"1\\\"} 和 {\\\"10\\\",\\\"1\\\",\\\"0\\\"} 。{\\\"111001\\\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 \",\"示例 2：\",\"输入：strs = [\\\"10\\\", \\\"0\\\", \\\"1\\\"], m = 1, n = 1 输出：2 解释：最大的子集是 {\\\"0\\\", \\\"1\\\"} ，所以答案是 2 。 \",\"提示：\",\"1 <= strs.length <= 600\",\"1 <= strs[i].length <= 100\",\"strs[i] 仅由 '0' 和 '1' 组成\",\"1 <= m, n <= 100\"]},\"101\":{\"h\":\"思路分析\",\"t\":[\"这道题我们可以把 0 和 1的个数看做背包的容量，再次之前背包容量只有一个维度来决定，这道题由俩个纬度，m 和 n，把每一个字符串看做放入背包的物品，因此可以使用01背包求解。\",\"动态规划的思路是：物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：选与不选。\",\"确定dp数组含义\",\"dp[i][j] : 表示i个0 j 个1的情况下，有dp[i][j] 个子集\",\"确定递推关系式\",\"原01背包递推关系式：dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i])\",\"对于这道题来说，有一个weight纬度变成了俩个纬度：因此 dp[i][j] = Math.max(dp[i][j],dp[i - 当前字符串使用0的个数][j - 当前字符串使用1的个数] + 1)\",\"class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; int zero, one; for (String str : strs) { // 遍历物品 zero = 0; one = 0; for (char c : str.toCharArray()) { if (c == '0') { zero++; } else { one++; } } for (int i = m; i >= zero; i--) { // 遍历背包容量，有俩个纬度 for (int j = n; j >= one; j--) { dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1); } } } return dp[m][n]; } } \"]},\"102\":{\"h\":\"\",\"t\":[\"给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\",\"请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\",\"假设每一种面额的硬币有无限个。\",\"题目数据保证结果符合 32 位带符号整数。\",\"示例 1：\",\"输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 \",\"示例 2：\",\"输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 \",\"示例 3：\",\"输入：amount = 10, coins = [10] 输出：1 \",\"提示：\",\"1 <= coins.length <= 300\",\"1 <= coins[i] <= 5000\",\"coins 中的所有值 互不相同\",\"0 <= amount <= 5000\"]},\"103\":{\"h\":\"思路分析\",\"t\":[\"题目说明硬币的数量无限，因此我们可以看出来使用完全背包进行求解。\",\"定义dp数组的含义\",\"dp[j]：金额为j时，一共有 dp[j]中组合方式。\",\"注意组合和排列的区别：组合不强调元素的顺序，排列强调元素的顺序\",\"{2,2,1},{2,1,2} 是一种组合，但是是俩种排列！！！！\",\"递推关系式\",\"在求组合问题时，公式通用：\",\"dp[j] += dp[j - coins[i]]\",\"遍历顺序\",\"对于这道题的遍历顺序是非常讲究的，在讲完全背包时，我们说先遍历物品还是先遍历背包都无所谓，但对于这种求组合的问题，就不能无所谓了！！\",\"当我们先遍历物品时,假设：coins[0] = 1，coins[1] = 5。\",\"那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。\",\" for (int i = 0; i < coins.length; i++) { //遍历物品 for (int j = coins[i]; j <= amount; j++) { // 遍历容量 dp[j] += dp[j - coins[i]]; } } \",\"因此这种遍历顺序正是求组合的遍历顺序！！！\",\"当先遍历背包时：\",\"for (int j = 0; j <= amount; j++) { // 遍历背包容量 for (int i = 0; i < coins.size(); i++) { // 遍历物品 if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]]; } } \",\"背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。\",\"因此这种遍历顺序是求全排列的遍历顺序！！！！\",\"public int change(int amount, int[] coins) { // dp[j]: 表示金额为j时，一共有dp[j]中组合方式 int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i < coins.length; i++) { //遍历物品 for (int j = coins[i]; j <= amount; j++) { // 遍历容量 dp[j] += dp[j - coins[i]]; } System.out.println(Arrays.toString(dp)); } return dp[amount]; } \"]},\"104\":{\"h\":\"\",\"t\":[\"给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\",\"题目数据保证答案符合 32 位整数范围。\",\"示例 1：\",\"输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 \",\"示例 2：\",\"输入：nums = [9], target = 3 输出：0 \",\"提示：\",\"1 <= nums.length <= 200\",\"1 <= nums[i] <= 1000\",\"nums 中的所有元素 互不相同\",\"1 <= target <= 1000\",\"**进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？\"]},\"105\":{\"h\":\"思路分析\",\"t\":[\"这道题和 518 不同的是，这题要求的是 全排列 问题\",\"定义dp数组及下标含义\",\"dp[j]: 表示和为 j 时，一共有 dp[j] 种组合方式\",\"递推公式\",\"dp[j] += dp[j - nums[i]]\",\"遍历顺序\",\"对于动态规划，求组合问题 或者 全排列问题 遍历的顺序是不一样的。\",\"组合问题： 先遍历物品，在遍历容量。\",\"全排列问题： 先遍历容量，在遍历物品。\",\"class Solution { public int combinationSum4(int[] nums, int target) { // dp[j]: 表示和为j时，一共有dp[j]种方式 int[] dp = new int[target + 1]; dp[0] = 1; // 动态规划求全排列问题，先遍历容量在遍历物品。求组合问题则相反 for (int j = 0; j <= target; j++) { // 遍历容量 for (int i = 0; i < nums.length; i++) { // 遍历物品 if (j - nums[i] >= 0) dp[j] += dp[j - nums[i]]; } } // System.out.println(Arrays.toString(dp)); return dp[target]; } } \"]},\"106\":{\"h\":\"\",\"t\":[\"给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\",\"计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\",\"你可以认为每种硬币的数量是无限的。\",\"示例 1：\",\"输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 \",\"示例 2：\",\"输入：coins = [2], amount = 3 输出：-1 \",\"示例 3：\",\"输入：coins = [1], amount = 0 输出：0 \",\"提示：\",\"1 <= coins.length <= 12\",\"1 <= coins[i] <= 231 - 1\",\"0 <= amount <= 104\"]},\"107\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组及其下标含义\",\"dp[j] : 表示凑成金额j时，最少需要dp[j]个硬币\",\"确定递推公式\",\"凑足总额为 j - coins[i] 的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）\",\"所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。\",\"递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);\",\"初始化\",\"在对dp数组初始化时，应尽量初始化为一个较大值，否则就会在dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 比较时被覆盖！\",\"遍历顺序\",\"由于这道题并不是求组合、全排列问题，因此先遍历背包或者是物品都可以\",\"class Solution { public int coinChange(int[] coins, int amount) { // dp[j]: 当金额为j时，最少需要dp[j]个硬币 int[] dp = new int[amount + 1]; // 将dp数组填充尽可能大的值，否则不会被覆盖 Arrays.fill(dp,Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i < coins.length; i++) { for (int j = coins[i]; j <= amount; j++) { // 只有当dp[j - coins[i]]不是最大值的时候，才有必要进行替换 // // 否则在进行比较时dp[j - coins[i]] + 1 可能会溢出或者导致不正确的值！！ if (dp[j - coins[i]] != Integer.MAX_VALUE) { dp[j] = Math.min(dp[j],dp[j - coins[i]] + 1); } } } return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; } } \"]},\"108\":{\"h\":\"\",\"t\":[\"给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\",\"完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\",\"示例 1：\",\"输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 \",\"示例 2：\",\"输入：n = 13 输出：2 解释：13 = 4 + 9 \",\"提示：\",\"1 <= n <= 104\"]},\"109\":{\"h\":\"思路分析\",\"t\":[\"每一个完全平方数可以看做是物品，可以使用无限次，因此是完全背包。\",\"背包容量就是完全平方数的和 n\",\"确定dp含义\",\"dp[j] : 表示和为j时，最少需要dp[j]个完全平方数\",\"递推关系式\",\"dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。\",\"所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);\",\"初始化\",\"由于要求最少值，数组尽可能初始化为较大的值\",\"dp[0] 初始化成0\",\"class Solution { public int numSquares(int n) { // dp[j]: 表示和为j时,所需要最少得完全平方数个数为dp[j]个 int[] dp = new int[n + 1]; Arrays.fill(dp,Integer.MAX_VALUE); dp[0] = 0; for (int j = 0; j <= n; j++) { // 先遍历背包容量 for (int i = 1; i * i <= j; i++) { // 遍历物品，物品为每一个完全平方数 dp[j] = Math.min(dp[j],dp[j - i * i] + 1); } } return dp[n]; } } \"]},\"110\":{\"h\":\"\",\"t\":[\"给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。\",\"**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\",\"示例 1：\",\"输入: s = \\\"leetcode\\\", wordDict = [\\\"leet\\\", \\\"code\\\"] 输出: true 解释: 返回 true 因为 \\\"leetcode\\\" 可以由 \\\"leet\\\" 和 \\\"code\\\" 拼接成。 \",\"示例 2：\",\"输入: s = \\\"applepenapple\\\", wordDict = [\\\"apple\\\", \\\"pen\\\"] 输出: true 解释: 返回 true 因为 \\\"applepenapple\\\" 可以由 \\\"apple\\\" \\\"pen\\\" \\\"apple\\\" 拼接成。 注意，你可以重复使用字典中的单词。 \",\"示例 3：\",\"输入: s = \\\"catsandog\\\", wordDict = [\\\"cats\\\", \\\"dog\\\", \\\"sand\\\", \\\"and\\\", \\\"cat\\\"] 输出: false \",\"提示：\",\"1 <= s.length <= 300\",\"1 <= wordDict.length <= 1000\",\"1 <= wordDict[i].length <= 20\",\"s 和 wordDict[i] 仅由小写英文字母组成\",\"wordDict 中的所有字符串 互不相同\"]},\"111\":{\"h\":\"思路分析\",\"t\":[\"确定dp含义\",\"dp[i]: 表示前 i个字符串，是否能够为空格拆分。\",\"确定递推关系式\",\"在遍历s串的时候，我们可以尝试使用j来定位 s串的分割点。那么s串就会被分成俩个子串s1为\",\"s.substring(0, j),s2为 s.substring(j, i)，如果这俩个子串都合法，那么我们就可以证明 s 串合法。\",\"s.substring(0, j), 我们可以用 dp[j] 表示，如果 dp[j] = true ，表示s1是合法，那么我们只需要在判断 s2 是否出现在 wordDict 即可，如果有，就说明s串是合法的。\",\"因此我们可以推出关系式为: d[j] && wordDict.contains(s.substring(j, i))\",\"初始化\",\"dp[0] = true, 表示空串是合法的。\",\"class Solution { public boolean wordBreak(String s, List<String> wordDict) { // 将list转换成set，提高效率 HashSet<String> set = new HashSet<>(wordDict); // dp[i]: 表示S(0~i)是否是合法的 boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 1; i <= s.length(); i++) { // 遍历字符串(背包)，从1开始，因为0是合法的 for (int j = 0; j < i; j++) { if (dp[j] && set.contains(s.substring(j,i))){ // dp[j]表示S(0~j)是否合法 dp[i] = true; break; } } } return dp[s.length()]; } } \"]},\"112\":{\"h\":\"\",\"t\":[\"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\",\"给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\",\"示例 1：\",\"输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 \",\"示例 2：\",\"输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 \",\"提示：\",\"1 <= nums.length <= 100\",\"0 <= nums[i] <= 400\"]},\"113\":{\"h\":\"思路分析\",\"t\":[\"确定dp含义及下标\",\"dp[j]: 表示前i个房屋，能够偷到的最高金额为dp[j]\",\"确定递推关系式\",\"在题目中我们可以得知，对于第i个房屋，只有俩种可能：\",\"偷: dp[i] = dp[i-2] + nums[i], dp[i-2]表示在隔2个房屋偷到的最大金额，i-1是不行的，因为 i-1 和 i 表示连着偷相邻的房屋。\",\"不偷: dp[i] = dp[i-1]\",\"因此递推关系式为: dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1])\",\"初始化\",\"从递推关系式上看来，推导的结果依赖于dp[0],dp[1]\",\"dp[0] = nums[0], 而dp[1] = Math.max(dp[0],nums[1])\",\"class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(dp[0], nums[1]); for (int i = 2; i < nums.length; i++) { dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.length - 1]; } } \"]},\"114\":{\"h\":\"\",\"t\":[\"你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\",\"给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\",\"示例 1：\",\"输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 \",\"示例 2：\",\"输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 \",\"示例 3：\",\"输入：nums = [1,2,3] 输出：3 \",\"提示：\",\"1 <= nums.length <= 100\",\"0 <= nums[i] <= 1000\"]},\"115\":{\"h\":\"思路分析\",\"t\":[\"这道题与198. 打家劫舍 唯一的区别就是房屋是首尾相连的。\",\"如果有一间房屋，我们就偷一间，如果有俩间房屋就偷较大金额的房屋。如果有超过2间的房屋，我们就需要考虑首尾相连了。\",\"首先第一间房屋和最后一间房屋不能同时被偷，否则就会触发警报。\",\"那么对于可以偷的房屋我们可以分成俩个线性队列：\",\"偷第一间房屋,不偷最后一间: nums[0,length-2]\",\"不偷第一间房屋，偷最后一间房屋: nums[1,length-1]\",\"对这俩个队列分别求出能够偷的最大金额，方法和198. 打家劫舍 一样，然后取最大值即可！\",\"class Solution { public int rob(int[] nums) { /*分析：依然使用动态规划,只不过最后一个元素需要特殊处理 * 核心：第一个元素与最后一个元素,只能去一个--->分解成两问题*/ if(nums.length == 0) return 0; if(nums.length ==1) return nums[0]; // 初始化 int length = nums.length; int[] dp = new int[length + 2]; // 偷第一间房屋,不偷最后一间 for (int i = 2; i < length + 1; i++) { dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]); } int pre = dp[length]; // 不偷第一间房屋，偷最后一间房屋 dp[2] = 0; for (int i = 3; i < length + 2; i++) { dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]); } return Math.max(pre, dp[length + 1]); } } \",\"优化：\",\"我们发现 dp[n] 只与 dp[n−1] 和 dp[n−2]有关系，因此我们可以设两个变量 cur和 pre 交替记录，将空间复杂度降到 O(1)\",\"递推关系式 :\",\"​ 偷当前屋: 直接用cur表示\",\"​ 不偷当前屋：上一个\",\" class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; return Math.max(robMax(Arrays.copyOfRange(nums, 0, nums.length - 1)), robMax(Arrays.copyOfRange(nums, 1, nums.length))); } public int robMax(int[] nums) { int pre = 0, cur = 0, temp; for (int num : nums) { temp = cur; // 俩种情况: // 上一个未偷最大金额 + 偷当前房屋最大金额。 // 偷当前房屋最大金额 cur = Math.max(pre + num, cur); pre = temp; } return cur; } } \"]},\"116\":{\"h\":\"\",\"t\":[\"小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\",\"除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\",\"给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\",\"示例 1:\",\"img\",\"输入: root = [3,2,3,null,3,null,1] 输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 \",\"示例 2:\",\"img\",\"输入: root = [3,4,5,1,3,null,1] 输出: 9 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 \",\"提示：\",\"树的节点数在 [1, 104] 范围内\",\"0 <= Node.val <= 104\"]},\"117\":{\"h\":\"思路分析\",\"t\":[\"这道题与 打家劫舍 和 打家劫舍二 有所不同，之前都是数组的动态规划，而这道题则是基于二叉树的动态规划。\",\"对于每个节点依然有俩种情况，选或者不选，设当前节点为node：\",\"选择node节点: 不能选儿子节点, 而是要考虑儿子的儿子结点\",\"不选node节点: 可以选择儿子结点\",\"在之前数组版本的打家劫舍，选/不选 的状态由 i-1/i-2 转移过来 ，如果应用的树形DP上，如果选择node节点，node节点的儿子节点不能选，就需要从儿子的儿子转移过来，这样需要最多考虑四个节点，这写起来就比较复杂。\",\"既然每个节点有俩种情况，就将 选/不选 作为俩种状态:\",\"当选择node节点时，这颗子树最大和是多少\",\"当不选择node节点时，这颗子树最大和是多少\",\"这样就只需要考虑儿子节点了！！\",\"这里可能有一个疑问，为什么将选/不选作为状态，就只需要考虑儿子了呢？\",\"这里画图将每一个节点选或者不选的最大值标出来就清晰了！\",\"由于当前节点的状态由儿子节点转移而来，因此我们要采用后序遍历！\",\"1、选择节点3最大和为3，不选则为0\",\"image-20240124225306215\",\"2、选择节点2，不能选择儿子节点最大值为2\",\"不选择节点2，可以选择儿子节点，最大值为3\",\"image-20240124225359093\",\"3、右子树同理\",\"image-20240124225525551\",\"4、对于根节点3,：\",\"选择: 儿子节点都不能选，从儿子节点返回的状态就可以看出，儿子节点选或不选的最大值，因此 3+1+3 = 7\",\"不选： 儿子节点选不选都可以，我们取最大值 3+3 = 6\",\"最后取最大值 Max(6,7) = 7\",\"image-20240124225905894\",\"总结\",\"图片来自：@灵茶山艾府\",\"image-20240124224148152\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int rob(TreeNode root) { int[] status = dfs(root); return Math.max(status[0],status[1]); } // int[0]: 不选当前节点子树最大和 // int[1]: 选当前节点子树最大和 public int[] dfs(TreeNode node){ // 节点为null，最大和为0 if (node == null) return new int[]{0,0}; int[] left = dfs(node.left); // 递归左子树所得到的最大和(选/不选) int[] right = dfs(node.right);// 递归右子树所得到的最大和(选/不选) // 选则当前节点：左右孩子不选的最大和 + 当前节点的值 int select = left[0] + right[0] + node.val; // 不选则当前节点： // 找出选择左孩子、不选择左孩子的最大值 // 选择右孩子、不选择右孩子的最大值 // 最后加在一起 int not_select = Math.max(left[1],left[0]) + Math.max(right[1],right[0]); return new int[]{not_select,select}; } } \"]},\"118\":{\"h\":\"买卖股票全系列\"},\"119\":{\"h\":\"\",\"t\":[\"给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\",\"你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\",\"返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\",\"示例 1：\",\"输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 \",\"示例 2：\",\"输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 \",\"提示：\",\"1 <= prices.length <= 105\",\"0 <= prices[i] <= 104\"]},\"120\":{\"h\":\"思路分析\",\"t\":[\"一次遍历\",\"这道题和 买卖股票的最佳时机二 的区别就是 只能买入一次股票，只能在买入之后一次卖入股票。\",\"因此我们在遍历过程维护一个最低价格 和 每天与最低价格的利润 ，不断维护这俩个变量。\",\" public int maxProfit(int[] prices) { // 记录历史最低价格 int minPrice = Integer.MAX_VALUE; // 记录每一天的与历史最低价格的利润 int maxProfit = 0; for (int price : prices) { if (price < minPrice) { minPrice = price; } else if (price - minPrice > maxProfit) { maxProfit = price - minPrice; } } return maxProfit; } \",\"动态规划\",\"对于某一天的股票只有俩种状态： 持有股票/不持有股票\",\"定义dp数组含义\",\"dp[i][0] : 第i天交易完手里没有股票的最大利润\",\"dp[i][1] : 第i天交易完手里有股票的最大利润\",\"递推公式\",\"对于今天是否持有股票由前一天状态转移而来：\",\"今天没有股票dp[i][0]\",\"可能前一天也没有股票: dp[i-1][0]\",\"可能前一天有股票，这时候卖出股票，增加利润： dp[i-1][1] + prices[i]\",\"今天有股票dp[i][1]\",\"前一天可能也有股票：dp[i][1]\",\"前一天没有股票，这时候买入股票，由于只能买一次，因此利润一定是股票的负数: - prices[i]\",\"因此递推公式为：\",\"dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])\",\"dp[i][1] = max(dp[i-1][1], - prices[i])\",\"到最后一天一定是没有股票的状态，即返回结果：dp[prices.length-1][0]\",\"初始化\",\"dp[0][0] = 0 第一天没有股票，利润为0\",\"dp[0][1] = -prices[0] 第一天买入股票，利润为第一天的负数\",\"class Solution { public int maxProfit(int[] prices) { int length = prices.length; int[][] dp = new int[length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i < length; i++) { dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], - prices[i]); } return dp[length-1][0]; } } \"]},\"121\":{\"h\":\"\",\"t\":[\"给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\",\"在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\",\"返回 你能获得的 最大 利润 。\",\"示例 1：\",\"输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 \",\"示例 2：\",\"输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 \",\"示例 3：\",\"输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 \",\"提示：\",\"1 <= prices.length <= 3 * 104\",\"0 <= prices[i] <= 104\"]},\"122\":{\"h\":\"思路分析\",\"t\":[\"贪心算法\",\"这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入.....循环反复。\",\"如果想到其实最终利润是可以分解的，那么本题就很容易了！\",\"如何分解呢？\",\"假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。\",\"相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。\",\"此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！\",\"那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。\",\"如图：\",\"122.买卖股票的最佳时机II\",\"局部最优：收集每天的正利润，全局最优：求得最大利润。\",\" public int maxProfit(int[] prices) { int res = 0; // 从第二天开始,第一天无法产生利润 for (int i = 1; i < prices.length; i++) { // 只收集每天的正利润 res += Math.max(prices[i] - prices[i-1],0); } return res; } \",\"动态规划\",\"题目中规定每一天不能【重复交易】，那么每一天就只有俩种状态:\",\"持有股票\",\"不持有股票\",\"定义dp数组含义\",\"dp[i][0] : 第i天交易完手里没有股票的最大利润\",\"dp[i][1] : 第i天交易完手里有股票的最大利润\",\"递推公式\",\"对于今天是否持有股票由前一天状态转移而来：\",\"今天没有股票dp[i][0]\",\"可能前一天也没有股票: dp[i-1][0]\",\"可能前一天中持有股票，这时候要卖出股票，因此利润增加： dp[i-1][1] + prices[i]\",\"今天有股票dp[i][1]\",\"前一天可能也有股票：dp[i][1]\",\"前一天没有股票，这时候要卖入股票，利润减少: dp[i-1][0] - prices[i]\",\"这里也是和121. 买卖股票的最佳时机 的唯一区别：\",\"由于 121 只能买一次，因此买入的时候一定是负利润\",\"而 122 可以多次买入，因此买入的时候还要算上之前买卖的利润！\",\"因此递推公式为：\",\"dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])\",\"dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])\",\"到最后一天一定是没有股票的状态，即返回结果：dp[prices.length-1][0]\",\"初始化\",\"dp[0][0] = 0 第一天没有股票，利润为0\",\"dp[0][1] = -prices[0] 第一天买入股票，利润为第一天的负数\",\"class Solution { public int maxProfit(int[] prices) { int length = prices.length; int[][] dp = new int[length][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i < length; i++) { dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]); } return dp[length-1][0]; } } \"]},\"123\":{\"h\":\"\",\"t\":[\"给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\",\"设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\",\"**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\",\"示例 1:\",\"输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 \",\"示例 2：\",\"输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 \",\"示例 3：\",\"输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 \",\"示例 4：\",\"输入：prices = [1] 输出：0 \",\"提示：\",\"1 <= prices.length <= 105\",\"0 <= prices[i] <= 105\"]},\"124\":{\"h\":\"思路分析\",\"t\":[\"这题相较于前面俩道题难了不少，主要在于如何知道买卖的次数，有可能买卖一次，有可能买卖俩次，有可能不买卖，这时股票就应该有五种状态：\",\"0:不进行买卖股票【可以忽略】\",\"1:第一次持有股票\",\"2:第一次不持有股票\",\"3:第二次持有股票\",\"4:第二次不持有股票\",\"定义dp数组含义\",\"dp[i][5] : 表示第i天在 [0~4] 状态下所获得的最大利润\",\"递推公式\",\"达到dp[i][1]状态由俩种操作转移而来：\",\"沿用前一天持有股票的状态: dp[i-1][1]\",\"前一天没有股票，交易完买入股票： dp[i-1][0] - prices[i]\",\"这俩种状态取最大值: max(dp\\\\[i-1][1],dp\\\\[i-1][0] - prices[i])\",\"达到dp[i][2]状态由俩种操作转移而来：\",\"沿用前一天不持有股票的状态: dp[i-1][2]\",\"前一天持有股票，交易完卖出股票： dp[i-1][1] + prices[i]\",\"这俩种状态取最大值: max(dp\\\\[i-1][2],dp\\\\[i-1][1] + prices[i])\",\"同理求出状态3、4的公式为：\",\" max(dp\\\\[i-1][3],dp\\\\[i-1][2] - prices[i])\",\" max(dp\\\\[i-1][4],dp\\\\[i-1][3] + prices[i])\",\"初始化\",\"dp[0][1] = -prices[0] // 第一次买入\",\"dp[0][2] =0 // 第一次卖出\",\"dp[0][3] = -prices[0] // 第二次买入\",\"dp[0][4] =0 // 第二次卖出\",\"class Solution { public int maxProfit(int[] prices) { int length = prices.length; // 定义dp数组 /* * dp[i][0]：第i天不操作所获得的最大利润 * dp[i][1]：第i天第一次持有股票所获得的最大利润 * dp[i][2]：第i天第一次不持有股票所获得的最大利润 * dp[i][3]：第i天第二次持有股票所获得的最大利润 * dp[i][4]：第i天第二次不持有股票所获得的最大利润 * */ int[][] dp = new int[length][5]; dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i < length; i++) { dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return dp[length-1][4]; } } \"]},\"125\":{\"h\":\"\",\"t\":[\"给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。\",\"设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\",\"**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\",\"示例 1：\",\"输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 \",\"示例 2：\",\"输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 \",\"提示：\",\"1 <= k <= 100\",\"1 <= prices.length <= 1000\",\"0 <= prices[i] <= 1000\"]},\"126\":{\"h\":\"思路分析\",\"t\":[\"这道题说要完成k次交易,这回我们不知道要设几种状态。我们可以找一下规律：\",\"1:第一次持有股票\",\"2:第一次不持有股票\",\"3:第二次持有股票\",\"4:第二次不持有股票\",\"5：第三次持有股票\",\"6：第三次持有股票\",\"....\",\"我们可以发现当 k 为奇数时表示 持有/买入 股票，当 k 为偶数时表示 不持有/卖出 股票。\",\"定义dp数组含义\",\"dp[i][j]: 第 i 天，状态为 j 时所获得的最大利润\",\" // 奇数为买入，偶数为卖出 int[][] dp = new int[length][ 2 * k + 1]; \",\"递推公式\",\"达到dp[i][1]状态由俩种操作转移而来：\",\"沿用前一天持有股票的状态: dp[i-1][1]\",\"前一天没有股票，交易完买入股票： dp[i-1][0] - prices[i]\",\"这俩种状态取最大值: max(dp\\\\[i-1][1],dp\\\\[i-1][0] - prices[i])\",\"达到dp[i][2]状态由俩种操作转移而来：\",\"沿用前一天不持有股票的状态: dp[i-1][2]\",\"前一天持有股票，交易完卖出股票： dp[i-1][1] + prices[i]\",\"这俩种状态取最大值: max(dp\\\\[i-1][2],dp\\\\[i-1][1] + prices[i])\",\"....\",\"由此我们可以推算出规律：\",\"买入：max(dp\\\\[i-1][j+1],dp\\\\[i-1][j] - prices[i])\",\"卖出: max(dp\\\\[i-1][j+2],dp\\\\[i-1][j+1] + prices[i])\",\"for (int j = 0; j < 2 * k - 1; j += 2) { dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]); } \",\"初始化\",\"k 为奇数为买入，将买入时的利润设为 -prices[0]\",\" for (int i = 1; i < 2 * k; i += 2) { dp[0][i] = -prices[0]; } \",\"完整代码\",\"class Solution { public int maxProfit(int k, int[] prices) { int length = prices.length; // 奇数为买入，偶数为卖出 int[][] dp = new int[length][2 * k + 1]; // 初始化 for (int i = 1; i < 2 * k; i += 2) { dp[0][i] = -prices[0]; } for (int i = 1; i < length; i++) { for (int j = 0; j < 2 * k - 1; j += 2) { dp[i][j + 1] = Math.max(dp[i-1][j + 1], dp[i-1][j] - prices[i]); dp[i][j + 2] = Math.max(dp[i-1][j + 2], dp[i-1][j + 1] + prices[i]); } } return dp[length - 1][2 * k]; } } \"]},\"127\":{\"h\":\"\",\"t\":[\"给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。\",\"设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\",\"卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\",\"**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\",\"示例 1:\",\"输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] \",\"示例 2:\",\"输入: prices = [1] 输出: 0 \",\"提示：\",\"1 <= prices.length <= 5000\",\"0 <= prices[i] <= 1000\"]},\"128\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组及含义\",\"dp[i][0] : 第i天交易完手里没有股票的最大利润\",\"dp[i][1] : 第i天交易完手里有股票的最大利润\",\"递推公式\",\"如果没有冷冻期，不难写出这样的递推公式：\",\"dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])\",\"dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])\",\"而有了冷冻期之后，则表示在第i天持有股票的条件下，有可能 i-1 天为冷冻期，i-2 天为卖出操作。\",\"因此递推关系式为：\",\"dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])\",\"dp[i][1] = max(dp[i-1][1],dp[i-2][0] - prices[i])\",\"初始化\",\"由于递推关系式中依赖于 i-2 ，因此我们要初始化俩天的买入/卖出操作\",\" dp[0][0] = 0; dp[0][1] = -prices[0]; dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]); dp[1][1] = Math.max(dp[0][1], -prices[1]); \",\"完整代码\",\"class Solution { public int maxProfit(int[] prices) { if (prices == null || prices.length < 2) { return 0; } int[][] dp = new int[prices.length][2]; // bad case dp[0][0] = 0; dp[0][1] = -prices[0]; dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]); dp[1][1] = Math.max(dp[0][1], -prices[1]); for (int i = 2; i < prices.length; i++) { // dp公式 dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]); } return dp[prices.length - 1][0]; } } \"]},\"129\":{\"h\":\"\",\"t\":[\"给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。\",\"你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\",\"返回获得利润的最大值。\",\"**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\",\"示例 1：\",\"输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 \",\"示例 2：\",\"输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 \",\"提示：\",\"1 <= prices.length <= 5 * 104\",\"1 <= prices[i] < 5 * 104\",\"0 <= fee < 5 * 104\"]},\"130\":{\"h\":\"思路分析\",\"t\":[\"定义dp数组及含义\",\"dp[i][0] : 第i天交易完手里没有股票的最大利润\",\"dp[i][1] : 第i天交易完手里有股票的最大利润\",\"递推公式\",\"在股票 买入/卖出 之后要扣减手续费\",\"dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i] - fee)\",\"dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])\",\" public int maxProfit(int[] prices, int fee) { int length = prices.length; int[][] dp = new int[length][2]; dp[0][1] = -prices[0]; for (int i = 1; i < length; i++) { dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i] - fee); dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]); } return Math.max(dp[length-1][0],dp[length-1][1]); } \"]},\"131\":{\"h\":\"子序列问题\"},\"132\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\",\"子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\",\"示例 1：\",\"输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 \",\"示例 2：\",\"输入：nums = [0,1,0,3,2,3] 输出：4 \",\"示例 3：\",\"输入：nums = [7,7,7,7,7,7,7] 输出：1 \",\"提示：\",\"1 <= nums.length <= 2500\",\"-104 <= nums[i] <= 104\"]},\"133\":{\"h\":\"思路分析\",\"t\":[\"子序列问题通常要求出下标为 i的元素与 0~i-1之前的元素之间的关系。\",\"dp数组含义\",\"dp[i] 表示前i个元素的最长递增子序列为dp[i]\",\"递推公式\",\"位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。\",\"所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);\",\"初始化\",\"每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.\",\" public int lengthOfLIS(int[] nums) { // dp[i] 表示前i个元素的最长递增子序列为dp[i] int[] dp = new int[nums.length]; // 初始化，每个元素长度为1 Arrays.fill(dp, 1); int res =1; for (int i = 1; i < nums.length; i++) { // 计算从0~i-1之间的最长递增子序列 for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } // 记录最长的递增子序列 res = Math.max(res, dp[i]); } return res; } \"]},\"134\":{\"h\":\"\",\"t\":[\"给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。\",\"连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。\",\"示例 1：\",\"输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \",\"示例 2：\",\"输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 \",\"提示：\",\"1 <= nums.length <= 104\",\"-109 <= nums[i] <= 109\"]},\"135\":{\"h\":\"思路分析\",\"t\":[\"该题要求连续的递增序列 ，可以用一个变量 length 维护到当前元素时的最长子序列，另一变量 res 维护整个序列最长子序列长度。\",\"class Solution { public int findLengthOfLCIS(int[] nums) { int length = 1; int res = 1; for (int i = 1; i < nums.length; i++) { if (nums[i] > nums[i-1]){ length++; res = Math.max(length,res); }else { // 不符合连续递增，将length重置 length = 1; } } return res; } } \"]},\"136\":{\"h\":\"\",\"t\":[\"给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\",\"示例 1：\",\"输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。 \",\"示例 2：\",\"输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] 输出：5 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 100\"]},\"137\":{\"h\":\"思路分析\",\"t\":[\"定义dp数组\",\"dp[i][j] : 表示以nums1以 i-1结尾，nums2以 j-1结尾的最长公共前缀为 dp[i][j]\",\"递推公式\",\"若 nums1[i-1] == nums2[j-1] ，则dp[i-1][j-1] + 1 ，相等 公共前缀长度+1\",\"注意：\",\"这里是 i-1、j-1，而不是i和j。这是为了初始化时的简便！\",\"i-1、j-1 说明遍历时要从下标为1开始，如果是 i 和 j 就需要考虑dp数组首个元素的初始化。\",\"即：如果nums1[i] 与 nums2[0] 相同的话，对应的 dp[i][0]就要初始为1， 因为此时最长重复子数组为1。 nums2[j] 与 nums1[0]相同的话，同理。\",\"for (int i = 0; i < nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1; for (int j = 0; j < nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1; \",\"遍历顺序\",\"从递推公式中可以看出，nums1 和 nums2 要从下标1开始遍历\",\"以nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 为例，最终dp数组如下图所示：\",\"image-20240204223442999\",\" public int findLength(int[] nums1, int[] nums2) { // 表示nums以 i-1结尾，nums2以 j-1结尾时，最长公共前缀为 dp[i] int[][] dp = new int[nums1.length + 1][nums2.length + 1]; int res = 0; for (int i = 1; i <= nums1.length; i++) { for (int j = 1; j <= nums2.length; j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } if (dp[i][j] > res) res = dp[i][j]; } } return res; } \"]},\"138\":{\"h\":\"\",\"t\":[\"给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\",\"一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\",\"例如，\\\"ace\\\" 是 \\\"abcde\\\" 的子序列，但 \\\"aec\\\" 不是 \\\"abcde\\\" 的子序列。\",\"两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\",\"示例 1：\",\"输入：text1 = \\\"abcde\\\", text2 = \\\"ace\\\" 输出：3 解释：最长公共子序列是 \\\"ace\\\" ，它的长度为 3 。 \",\"示例 2：\",\"输入：text1 = \\\"abc\\\", text2 = \\\"abc\\\" 输出：3 解释：最长公共子序列是 \\\"abc\\\" ，它的长度为 3 。 \",\"示例 3：\",\"输入：text1 = \\\"abc\\\", text2 = \\\"def\\\" 输出：0 解释：两个字符串没有公共子序列，返回 0 。 \",\"提示：\",\"1 <= text1.length, text2.length <= 1000\",\"text1 和 text2 仅由小写英文字符组成。\"]},\"139\":{\"h\":\"思路分析\",\"t\":[\"这道题其实和 718. 最长重复子数组 非常类似，唯一的区别就是这道题要求是不连续的子序列。\",\"因此在推导递推公式时，除了考虑俩个元素相等的情况，还要考虑不相等的情况。\",\"定义dp数组\",\"dp[i][j] : 表示text1从 （0 ,i-1），text2从（0,j-1）的最长公共子序列\",\"递推公式\",\"若 nums1[i-1] == nums2[j-1] ，则dp[i-1][j-1] + 1\",\"若不相等，则取 dp[i-1][j], dp[i][j-1] 的最大值\",\"dp[i-1][j] : 表示不考虑text1的第 i 个字符，与 text2的最长公共子序列\",\"dp[i][j-1] : 表示不考虑text2的第 j' 个字符，与 text1的最长公共子序列\",\" public int longestCommonSubsequence(String text1, String text2) { char[] char1 = text1.toCharArray(); char[] char2 = text2.toCharArray(); int[][] dp = new int[char1.length + 1][char2.length + 1]; for (int i = 1; i < char1.length; i++) { for (int j = 1; j <= char2.length; j++) { if (char1[i-1] == char2[j-1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[char1.length][char2.length]; } \"]},\"140\":{\"h\":\"\",\"t\":[\"在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\",\"现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：\",\"nums1[i] == nums2[j]\",\"且绘制的直线不与任何其他连线（非水平线）相交。\",\"请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\",\"以这种方法绘制线条，并返回可以绘制的最大连线数。\",\"示例 1：\",\"img\",\"输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 \",\"示例 2：\",\"输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3 \",\"示例 3：\",\"输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 500\",\"1 <= nums1[i], nums2[j] <= 2000\"]},\"141\":{\"h\":\"思路分析\",\"t\":[\"题目中要求求最大连线数 其实就是求俩个数组的最长公共子序列(保持相对顺序)！\",\"以 nums1 = [1,4,2], nums2 = [1,2,4] 为例，它的最长公共子序列为 1、4，因此它的连线数为2\",\"要保持相对的顺序，即 元素4 在 nums1中元素1的后面，那么在 nums2中也应该元素1的后面\",\" public int maxUncrossedLines(int[] nums1, int[] nums2) { int length1 = nums1.length; int length2 = nums2.length; // 表示nums1第i、nums2第j个元素的公共子序列的长度是dp[i][j] int[][] dp = new int[length1 + 1][length2 + 1]; for (int i = 1; i <= length1; i++) { for (int j = 1; j <= length2; j++) { // 这里对 i-1、j-1 进行比较，主要为了初始化的方便。 if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[length1][length2]; } \"]},\"142\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\",\"子数组 是数组中的一个连续部分。\",\"示例 1：\",\"输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 \",\"示例 2：\",\"输入：nums = [1] 输出：1 \",\"示例 3：\",\"输入：nums = [5,4,-1,7,8] 输出：23 \",\"提示：\",\"1 <= nums.length <= 105\",\"-104 <= nums[i] <= 104\"]},\"143\":{\"h\":\"思路分析\",\"t\":[\"这道题在 贪心 章节用贪心算法已经做过了，现在用动态规划在实现一遍。\",\"确定dp数组及下标含义\",\"dp[i]: 表示前i个元素(包括i)的最大和为dp[i]\",\"确定递推关系式\",\"dp[i] 有俩个方向可以推导出来:\",\"dp[i-1] + nums[i] : 加上当前元素的值\",\"nums[i]: 从头开始计算连续子数组的和\",\"初始化\",\"根据 dp 数组的定义可以看出: dp[0] = nums[0]\",\"模拟dp数组\",\"以 nums = [-2,1,-3,4,-1,2,1,-5,4] 为例\",\"image-20240218215042625\",\"从图中可以看出，最大和并不是最后一个元素，因此在遍历过程中我们需要一个额外变量来保存最大值。\",\" public int maxSubArray(int[] nums) { int length = nums.length; // 表示前i个元素(包括i)的最大和为dp[i] int[] dp = new int[length]; int res = nums[0]; dp[0] = nums[0]; for (int i = 1; i < length; i++) { dp[i] = Math.max(dp[i-1] + nums[i],nums[i]); if (dp[i] > res) res = dp[i]; } return res; } \"]},\"144\":{\"h\":\"编辑距离问题\"},\"145\":{\"h\":\"\",\"t\":[\"给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\",\"字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\\\"ace\\\"是\\\"abcde\\\"的一个子序列，而\\\"aec\\\"不是）。\",\"进阶：\",\"如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\",\"致谢：\",\"特别感谢 @pbrother 添加此问题并且创建所有测试用例。\",\"示例 1：\",\"输入：s = \\\"abc\\\", t = \\\"ahbgdc\\\" 输出：true \",\"示例 2：\",\"输入：s = \\\"axc\\\", t = \\\"ahbgdc\\\" 输出：false \",\"提示：\",\"0 <= s.length <= 100\",\"0 <= t.length <= 10^4\",\"两个字符串都只由小写字符组成。\"]},\"146\":{\"h\":\"思路分析\",\"t\":[\"方法一： 动态规划\",\"确定dp数组及下标含义\",\"dp[i][j] : 表示下标以 i-1 结尾的s 与 下标 j-1 结尾的t 的最长公共子序列的长度\",\"确定递推关系式\",\"还是分俩种情况:\",\"s.charAt(i-1) == t.charAt(i-1)： 表示找到一个公共元素，则: dp[i][j] = dp[i-1][j-1] + 1\",\"s.charAt(i-1) != t.charAt(i-1): 表示要删除t中的第i个元素，继续向后边匹配。则不考虑第i个元素。\",\"则 dp[i][j] = dp[i][j-1]\",\"遍历顺序\",\"通过递推关系式可以看出，从下标为1开始遍历，至于为什么不从0开始遍历，在718. 最长重复子数组 已经分析过。主要是为了初始化方便！\",\"初始化\",\"元素值初始化为0\",\"class Solution { public boolean isSubsequence(String s, String t) { int length1 = s.length(); int length2 = t.length(); // dp[i][j]: s中前 i-1 与 t中前 j-1 俩个字符串的子序列长度为 dp[i][j] int[][] dp = new int[length1 + 1][length2 + 1]; for (int i = 1; i <= length1; i++) { for (int j = 1; j <= length2; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { // 删除t中的第i个元素，也就是不考虑第i个元素 dp[i][j] = dp[i][j - 1]; } } } return dp[length1][length2] == length1; } } \",\"方法二：双指针\",\"采用双指针的方法，sIndex指向 s ,tIndex指向t\",\"如果 s.charAt(sIndex) == s.charAt(tIndex) 将 sIndex后移,每比较一次将 tIndex 后移。\",\"判断sIndex和 s.length 是否相等即可。\",\" public boolean isSubsequence1(String s, String t) { int length1 = s.length(); int length2 = t.length(); int sIndex = 0; int tIndex = 0; while(sIndex <= length1 && tIndex <= length2 && sIndex <= tIndex){ if (s.charAt(sIndex) == t.charAt(tIndex)){ sIndex++; } tIndex++; } return sIndex == s.length(); } \"]},\"147\":{\"h\":\"\",\"t\":[\"给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。\",\"示例 1：\",\"输入：s = \\\"rabbbit\\\", t = \\\"rabbit\\\" 输出：3 解释： 如下所示, 有 3 种可以从 s 中得到 \\\"rabbit\\\" 的方案。 rabbbit rabbbit rabbbit \",\"示例 2：\",\"输入：s = \\\"babgbag\\\", t = \\\"bag\\\" 输出：5 解释： 如下所示, 有 5 种可以从 s 中得到 \\\"bag\\\" 的方案。 babgbag babgbag babgbag babgbag babgbag \",\"提示：\",\"1 <= s.length, t.length <= 1000\",\"s 和 t 由英文字母组成\"]},\"148\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组及下标含义\",\"dp[i][j]: t(0~j-1) 在 s(0~i-1) 中的方案个数\",\"确定递推关系式\",\"这一类问题，基本是要分析两种情况\",\"s[i - 1] 与 t[j - 1]相等\",\"s[i - 1] 与 t[j - 1] 不相等\",\"当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。\",\"一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。\",\"一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。\",\"因此 dp\\\\[i][j] = dp\\\\[i - 1][j] + dp\\\\[i - 1][j - 1]\",\"为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。\",\"例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。\",\"当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。\",\"当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]\",\"所以递推公式为：dp\\\\[i][j] = dp\\\\[i - 1][j];\",\"初始化\",\"将dp数组的第一列初始化为1，因为空集是所有字符串子集, 所以我们第一列都是 1\",\"class Solution { public int numDistinct(String s, String t) { int[][] dp = new int[s.length() + 1][t.length() + 1]; // 将第一列初始化为1.因为空集是所有字符串的子集 for (int i = 0; i < s.length() + 1; i++) { dp[i][0] = 1; } for (int i = 1; i < s.length() + 1; i++) { for (int j = 1; j < t.length() + 1; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; }else{ dp[i][j] = dp[i - 1][j]; } } } return dp[s.length()][t.length()]; } } \"]},\"149\":{\"h\":\"\",\"t\":[\"给定两个单词 word1 和 word2 ，返回使得 word1 和 word2相同所需的最小步数。\",\"每步 可以删除任意一个字符串中的一个字符。\",\"示例 1：\",\"输入: word1 = \\\"sea\\\", word2 = \\\"eat\\\" 输出: 2 解释: 第一步将 \\\"sea\\\" 变为 \\\"ea\\\" ，第二步将 \\\"eat \\\"变为 \\\"ea\\\" \",\"示例 2:\",\"输入：word1 = \\\"leetcode\\\", word2 = \\\"etco\\\" 输出：4 \",\"提示：\",\"1 <= word1.length, word2.length <= 500\",\"word1 和 word2 只包含小写英文字母\"]},\"150\":{\"h\":\"思路分析\",\"t\":[\"题目要求所需的最小步数，其实就是求俩个字符串公共子序列的长度。\",\"然后将俩个字符串的长度 - 2倍的子序列长度。\",\"拿 word1 = \\\"sea\\\", word2 = \\\"eat\\\" 来说，子序列长度为 2\",\"3+3 - 2*2 = 2，最后求出最小步数为2\",\"class Solution { public int minDistance(String word1, String word2) { int length1 = word1.length(); int length2 = word2.length(); int[][] dp = new int[length1 + 1][length2 + 1]; for (int i = 1; i <= length1; i++) { for (int j = 1; j <= length2; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { // 相等，子序列长度+1 dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return length1 + length2 - 2 * dp[length1][length2]; } } \"]},\"151\":{\"h\":\"\",\"t\":[\"给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。\",\"你可以对一个单词进行如下三种操作：\",\"插入一个字符\",\"删除一个字符\",\"替换一个字符\",\"示例 1：\",\"输入：word1 = \\\"horse\\\", word2 = \\\"ros\\\" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') \",\"示例 2：\",\"输入：word1 = \\\"intention\\\", word2 = \\\"execution\\\" 输出：5 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') \",\"提示：\",\"0 <= word1.length, word2.length <= 500\",\"word1 和 word2 由小写英文字母组成\"]},\"152\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组及下标含义\",\"dp[i][j]: 表示下标以 i-1 结尾的word1 和 下标j-1 结尾的word2，最少得编辑距离为 dp[i][j]\",\"确定递推关系式\",\"对于这个题有俩种操作\",\"if (word1[i - 1] == word2[j - 1]) 不操作 if (word1[i - 1] != word2[j - 1]) 操作(增、删、换) \",\"对于以上四种情况依次进行讨论：\",\"if (word1[i - 1] == word2[j - 1]) , 这时不用编辑, dp[i][j] = dp[i-1][j-1]\",\"if (word1[i - 1] != word2[j - 1])\",\"考虑删除 word1 一个元素，即以下标 i-2 结尾的 word1 与以下标 j-1 结尾的word2 最少编辑距离 再加上一个删除操作，即：dp[i][j] = dp[i-1][j] + 1\",\"考虑删除 word2 一个元素，即以下标 i-1 结尾的 word1 与以下标 j-2 结尾的word2 最少编辑距离 再加上一个删除操作，即：dp[i][j] = dp[i][j-1] + 1\",\"替换操作,首先我们考虑替换的目的就是让俩个字符串相等，那么在 if (word1[i - 1] == word2[j - 1]) 中得知 dp[i][j] = dp[i-1][j-1]，那么此时我们在加上一个替换操作就能够满足要求，即：dp[i][j] = dp[i-1][j-1] + 1\",\"有的朋友会发现，上面这几种情况，为什么没有增加呢？\",\"其实增加和删除是一样，对word1增加，其实就是对word2的删除，相反也一样。\",\"例如：word1 = ac，word2 = a， 可以将word2增加一个c，也可以将word1删除一个c\",\"初始化\",\"从递推关系式中可以看出，递推关系式依赖于第一行和第一列的数据。\",\"因此我们需要初始化：dp[i][0], dp[0][j], 那么应该初始化成多少呢？\",\"首先要想清楚 dp[i][0], dp[0][j] 代表的是什么？\",\"dp[i][0]: 以下标 i-1 结尾的word1 和空串 wrod2，最少编辑距离 dp[i][0]\",\"dp[j][0]: 以下标 j-1 结尾的word2 和空串 wrod1，最少编辑距离 dp[0][j]\",\"因此有多少元素就需要多少的编辑距离！！！\",\" // 初始化, 有多少个元素就需要多少编辑距离变成空串 for (int i = 1; i <= length1; i++) dp[i][0] = i; for (int j = 1; j <= length2; j++) dp[0][j] = j; \",\"遍历顺序\",\"从左到右，从上到下~~\",\"class Solution { public int minDistance(String word1, String word2) { int length1 = word1.length(); int length2 = word2.length(); int[][] dp = new int[length1 + 1][length2 + 1]; // 初始化, 有多少个元素就需要多少编辑距离变成空串 for (int i = 1; i <= length1; i++) dp[i][0] = i; for (int j = 1; j <= length2; j++) dp[0][j] = j; for (int i = 1; i <= length1; i++) { for (int j = 1; j <= length2; j++) { if (word1.charAt(i-1) == word2.charAt(j-1)){ dp[i][j] = dp[i-1][j-1]; }else { /* * 删除word1：dp[i][j] = dp[i-1][j] + 1; * 删除word2：dp[i][j] = dp[i][j-1] + 1; * 替换：dp[i][j] = dp[i-1][j-1] + 1; * */ dp[i][j] = Math.min(dp[i-1][j] + 1,Math.min(dp[i][j-1] + 1,dp[i-1][j-1] + 1)); } } } return dp[length1][length2]; } } \"]},\"153\":{\"h\":\"总结\",\"t\":[\"这几道题可谓是循序渐进：\",\"判断子序列: 只涉及删除操作，不考虑增加和替换\",\"if (s[i - 1] == t[j - 1]) \",\"t中找到了一个字符在s中也出现了\",\"if (s[i - 1] != t[j - 1]) \",\"相当于t要删除元素，继续匹配\",\"不同的子序列： 虽然也只涉及到了删除操作，但是比 判断子序列 难了不少。\",\"主要是对于递推关系上的考虑有一些复杂，在针对 if (s[i - 1] == t[j - 1]) 这种情况时，有俩部分组成。\",\"s[i - 1] 与 t[j - 1]相等\",\"s[i - 1] 与 t[j - 1] 不相等\",\"当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。\",\"一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。\",\"一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。\",\"因此 dp\\\\[i][j] = dp\\\\[i - 1][j] + dp\\\\[i - 1][j - 1]\",\"为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。\",\"例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。\",\"当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。\",\"当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]\",\"所以递推公式为：dp\\\\[i][j] = dp\\\\[i - 1][j];\",\"俩个字符串的删除操作： 本题和动态规划：115.不同的子序列 (opens new window)相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。\",\"当word1[i - 1] 与 word2[j - 1]相同的时候\",\"当word1[i - 1] 与 word2[j - 1]不相同的时候\",\"当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];\",\"当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：\",\"情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1\",\"情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1\",\"情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2\",\"那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});\",\"编辑距离\",\"if (word1[i - 1] == word2[j - 1]) , 这时不用编辑, dp[i][j] = dp[i-1][j-1]\",\"if (word1[i - 1] != word2[j - 1])\",\"考虑删除 word1 一个元素，即以下标 i-2 结尾的 word1 与以下标 j-1 结尾的word2 最少编辑距离 再加上一个删除操作，即：dp[i][j] = dp[i-1][j] + 1\",\"考虑删除 word2 一个元素，即以下标 i-1 结尾的 word1 与以下标 j-2 结尾的word2 最少编辑距离 再加上一个删除操作，即：dp[i][j] = dp[i][j-1] + 1\",\"替换操作,首先我们考虑替换的目的就是让俩个字符串相等，那么在 if (word1[i - 1] == word2[j - 1]) 中得知 dp[i][j] = dp[i-1][j-1]，那么此时我们在加上一个替换操作就能够满足要求，即：dp[i][j] = dp[i-1][j-1] + 1\",\"有的朋友会发现，上面这几种情况，为什么没有增加呢？\",\"其实增加和删除是一样，对word1增加，其实就是对word2的删除，相反也一样。\",\"例如：word1 = ac，word2 = a， 可以将word2增加一个c，也可以将word1删除一个c\"]},\"154\":{\"h\":\"\",\"t\":[\"给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。\",\"回文字符串 是正着读和倒过来读一样的字符串。\",\"子字符串 是字符串中的由连续字符组成的一个序列。\",\"具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\",\"示例 1：\",\"输入：s = \\\"abc\\\" 输出：3 解释：三个回文子串: \\\"a\\\", \\\"b\\\", \\\"c\\\" \",\"示例 2：\",\"输入：s = \\\"aaa\\\" 输出：6 解释：6个回文子串: \\\"a\\\", \\\"a\\\", \\\"a\\\", \\\"aa\\\", \\\"aa\\\", \\\"aaa\\\" \",\"提示：\",\"1 <= s.length <= 1000\",\"s 由小写英文字母组成\"]},\"155\":{\"h\":\"思路分析\",\"t\":[\"确定dp数组及下标含义\",\"在刚开始看到这道题时，觉着dp数组的定义是：\",\"dp[i]: 以下标i结尾的字符串s的回文子串个数为 dp[i]\",\"但是我们仔细看一下，如果这样定义的话，我们很难找到 dp[i] 的递推关系式，他与 dp[i-1]、dp[i+1]都没有什么关系。\",\"因此我们可以通过回文串的性质下手：\",\"image-20240220223909726\",\"如果我们想要判断 [i~j] 范围内的字符串是否是回文子串，只需要判断 [i+1,j-1] 范围内的字符串是否是回文子串，如果是并且 i 和 j 的字符相等，那么 [i~j] 范围内的字符串就是回文子串，否则就不是\",\"因此我们要定义一个 boolean类型的二维数组 dp[i][j] : 表示[i,j] 范围内的字符串是否是回文子串\",\"确定递推关系式\",\"整体上有俩种情况：\",\"s[i] != s[j]\",\"s[i] == s[j]\",\"不相等时，dp[i][j]肯定是false，没什么好说的。\",\"相等时，又分为几种情况：\",\"当 j == i 时，说明指向同一个字符，肯定是回文子串，即dp[i][j] = true\",\"当 j - i == 1时，说明相差一个字符，例如 bb ，也是回文子串\",\"当 j - i > 1 时，此时要判断 [i+1,j-1] 是否是回文子串，如果是, 上面又有s[i] == s[j]的前提条件，那么 s[i,j] 就是回文子串。\",\"if (s[i] == s[j] && (j-i <= 1 || dp[i+1][j-1])) { res++; // 记录回文子串的数量 dp[i][j] = true; } \",\"初始化\",\"初始化全为false，默认肯定都不是回文子串\",\"遍历顺序\",\"通过上面的描述，我们可以得知，确定 dp[i][j] 需要用到 dp[i+1][j-1]\",\"如果是从上到下、从左到右，那么会先使用 dp[i][j]，就不知道 dp[i+1][j-1] 是 true 还是false 了\",\"因此遍历顺序应该为：从下到上，从左到右\",\"image-20240220225120684\",\"class Solution { public int countSubstrings(String s) { int length = s.length(); // dp[i][j] 表示s串从 i到j 的范围内是否是回文子串 boolean[][] dp = new boolean[length][length]; int res = 0; // 遍历顺序从下到上，从左到右 for (int i = length - 1; i >= 0; i--) { for (int j = i; j < length; j++) { // 不相等的情况为false，初始化就是false，不用考虑 if (s.charAt(i) == s.charAt(j) && (j-i <= 1 || dp[i+1][j-1])) { res++; dp[i][j] = true; } } } return res; } } \"]},\"156\":{\"h\":\"\",\"t\":[\"给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\",\"子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\",\"示例 1：\",\"输入：s = \\\"bbbab\\\" 输出：4 解释：一个可能的最长回文子序列为 \\\"bbbb\\\" 。 \",\"示例 2：\",\"输入：s = \\\"cbbd\\\" 输出：2 解释：一个可能的最长回文子序列为 \\\"bb\\\" 。 \",\"提示：\",\"1 <= s.length <= 1000\",\"s 仅由小写英文字母组成\"]},\"157\":{\"h\":\"思路分析\",\"t\":[\"定义dp数组及含义\",\"dp[i][j] : 表示下标在 [i~j] 范围内的s串，它的回文子串的长度为 dp[i][j]\",\"递推公式\",\"在求递推公式前，仍要利用回文串的特性：\",\"image-20240220223909726\",\"若 s[i] == s[j] ，则 s[i~j] 范围内的s串的回文串的长度为 dp[i+1][j-1] + 2 ,即： dp[i][j] = dp[i+1][j-1] + 2\",\"若 s[i] != s[j],仍然有俩种情况：\",\"加入 s[i], 计算 s[i~j-1] 范围内的回文串长度，即 dp[i][j] = dp[i][j-1]\",\"加入 s[j], 计算 s[i+1~j] 范围内的回文串长度，即 dp[i][j] = dp[i+1][j]\",\"俩种情况取最大值，则：dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j])\",\"初始化\",\"当 i 和 j 指向一个字符时，回文串的长度为 1\",\"for (int i = 0; i < length; i++) dp[i][i] = 1; \",\"遍历顺序\",\"class Solution { public int longestPalindromeSubseq(String s) { int length = s.length(); int[][] dp = new int[length][length]; for (int i = 0; i < length; i++) dp[i][i] = 1; // 遍历顺序为 从下到上，从左到右 for (int i = length - 1; i >= 0; i--) { for (int j = i + 1; j < length; j++) { if (s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][length - 1]; } } \"]},\"158\":{\"c\":[\"算法\"]},\"159\":{\"c\":[\"动态规划\"]},\"160\":{\"h\":\"哈希表\"},\"161\":{\"h\":\"\",\"t\":[\"给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。\",\"**注意：**若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。\",\"示例 1:\",\"输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true \",\"示例 2:\",\"输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false \",\"提示:\",\"1 <= s.length, t.length <= 5 * 104\",\"s 和 t 仅包含小写字母\"]},\"162\":{\"h\":\"思路分析\",\"t\":[\"第一种方法\",\"首先俩个字符串中的字符出现次数若是一样，具备以下特点：\",\"长度相等\",\"排序后，俩个字符串相等\",\"我们可以利用这个原理，先将俩个字符串排序，然后比较是否相等\",\"第二种方法\",\"利用hash表，记录s串中每个字符出现的次数，遍历t串中将 hash 表中的对应字符的次数递减。\",\"若hash表中每个字符的出现次数都为0，就说明 s 和 t 是 有效的字母异位词\"]},\"163\":{\"h\":\"代码实现\",\"t\":[\"第一种方法\",\" public static boolean isAnagram(String s, String t) { // 如果俩个字符串长度不相等，直接返回false if (s.length() != t.length()) return false; /** * 对s、t分别排序 * 如果字母出现次数都一样的话，排序后肯定是相等的 * */ String s1 = new String( Arrays.sort(s.toCharArray())); String s2 = new String(Arrays.sort(t.toCharArray())); return s1.equals(s2); } \",\"第二种方法\",\" public static boolean isAnagram1(String s, String t) { if (s.length() != t.length()) return false; // 保存字符出现的次数 int[] res = new int[26]; for (int i = 0; i < s.length(); i++) { /* * 这里为什么要减 'a' ？ * a~z的ASCII为 97~122，减去'a' 正好得该字符在数组中的位置 * */ // s串中出现字符的次数累加 res[s.charAt(i) - 'a']++; // t串中出现字符的次数递减 res[t.charAt(i) - 'a']--; } // 判断res数组中的值是否全为0，全为0说明s和t字符出现次数相同 for (int val : res) { if (val != 0) return false; } return true; } \"]},\"164\":{\"h\":\"\",\"t\":[\"给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\",\"字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\",\"示例 1:\",\"输入: strs = [\\\"eat\\\", \\\"tea\\\", \\\"tan\\\", \\\"ate\\\", \\\"nat\\\", \\\"bat\\\"] 输出: [[\\\"bat\\\"],[\\\"nat\\\",\\\"tan\\\"],[\\\"ate\\\",\\\"eat\\\",\\\"tea\\\"]] \",\"示例 2:\",\"输入: strs = [\\\"\\\"] 输出: [[\\\"\\\"]] \",\"示例 3:\",\"输入: strs = [\\\"a\\\"] 输出: [[\\\"a\\\"]] \",\"提示：\",\"1 <= strs.length <= 104\",\"0 <= strs[i].length <= 100\",\"strs[i] 仅包含小写字母\"]},\"165\":{\"h\":\"思路分析\",\"t\":[\"异位词的特点：\",\"字母相同，但是顺序可能不同\",\"长度小相同\",\"那么我们将 异位词 进行排序之后，那么所有的异位词都是相同的。可以利用这个特点，排序过后的 异位词 作为 hash表的key，若key相同则放入同一个集合内！\",\" public List<List<String>> groupAnagrams(String[] strs) { HashMap<String, List<String>> map = new HashMap<>(); for (int i = 0; i < strs.length; i++) { // 对每一个单词进行排序 char[] chars = strs[i].toCharArray(); Arrays.sort(chars); // 排完序之后，异位词变为相同的单词, 放入map集合 List<String> list = map.getOrDefault(String.valueOf(chars), new ArrayList<String>()); list.add(strs[i]); map.put(String.valueOf(chars),list); } // 保存map中分好组的集合 ArrayList<List<String>> res = new ArrayList<>(); map.forEach((key,value) ->{ res.add(value); }); return res; } \"]},\"166\":{\"h\":\"\",\"t\":[\"给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\",\"示例 1：\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] \",\"示例 2：\",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 1000\"]},\"167\":{\"h\":\"思路分析\",\"t\":[\"利用 set 集合不重复的特点，将 nums1、nums2都放入set集合中，然后求交集\"]},\"168\":{\"h\":\"代码实现\",\"t\":[\" public static int[] intersection(int[] nums1, int[] nums2) { Set<Integer> set1 = new HashSet<>(); for (int i : nums1) { set1.add(i); } Set<Integer> set2 = new HashSet<>(); for (int i : nums2) { set2.add(i); } // 求交集 set1.retainAll(set2); // 将交集转换回数组 Integer[] intersection = set1.toArray(new Integer[0]); // 将 Integer数组转换成 int 数组 return Arrays.stream(intersection).mapToInt(Integer::intValue).toArray(); } \"]},\"169\":{\"h\":\"\",\"t\":[\"编写一个算法来判断一个数 n 是不是快乐数。\",\"「快乐数」 定义为：\",\"对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\",\"然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\",\"如果这个过程 结果为 1，那么这个数就是快乐数。\",\"如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\",\"示例 1：\",\"输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 \",\"示例 2：\",\"输入：n = 2 输出：false \",\"提示：\",\"1 <= n <= 231 - 1\"]},\"170\":{\"h\":\"思路分析\",\"t\":[\"该题最主要的目的其实就是找和，对于一个数如果他不是快乐数，那么不断的累加平方和，最后肯定会得到一个相等的数，也就是会陷入循环当中。\",\"例如：37\",\"32 + 7 2 = 58\",\"52 + 8 2 = 89\",\"........\",\"22 + 9 2 = 85\",\"82 + 5 2 = 89\",\"........\",\"此时已经出现相同的数了，在求下去就没有必要了。\",\"那么我们的目的，就是要判断 这个和是否出现过，因此我们可以利用 set 集合。\",\"将每次求得平方和加入到这个 set 集合中，然后判断是否出现过，出现过则不是快乐数，没有出现过就知道求到 1 为止。\"]},\"171\":{\"h\":\"代码实现\",\"t\":[\" public static boolean isHappy(int n) { Set<Integer> set = new HashSet<Integer>(); while(n != 1 && !set.contains(n)) { // 如果n不等于1，并且不包含n，说明这个数还没有求过 set.add(n); n = getNextNum(n); } return n == 1; } // 获取下一个求和的数 public static int getNextNum(int n) { int sum = 0; while (n != 0) { // 对n的每个位置上的数进行求和 int digit = n % 10; sum = sum + digit * digit; n /= 10; } return sum; } \",\"刚开始想的是用递归，也可以实现此算法，不过LeetCode用不了，很遗憾~~\",\" static Set<Integer> set = new HashSet<Integer>(); public static boolean isHappy1(int n) { int sum = 0; while (n != 0) { // int digit = n % 10; sum = sum + digit * digit; n /= 10; } if (sum == 1) return true; if (set.contains(sum)) return false; set.add(sum); // 进行递归 return isHappy(sum); } \"]},\"172\":{\"h\":\"\",\"t\":[\"丑数 就是只包含质因数 2、3 和 5 的正整数。\",\"给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。\",\"示例 1：\",\"输入：n = 6 输出：true 解释：6 = 2 × 3 \",\"示例 2：\",\"输入：n = 1 输出：true 解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。 \",\"示例 3：\",\"输入：n = 14 输出：false 解释：14 不是丑数，因为它包含了另外一个质因数 7 。 \",\"提示：\",\"-231 <= n <= 231 - 1\"]},\"173\":{\"h\":\"思路分析\",\"t\":[\"简单来说将一个数的因数分解到不能再分解后，如果包含2、3、5就说明这个数是丑数！\",\"若是丑数，换成公式则为：n = 2a + 3b +5c\",\"为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5，直到 n 不再包含质因数 2,3,5。若剩下的数等于 1，则说明 n 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。\",\" public boolean isUgly(int n) { if (n < 1) return false; while (n % 2 == 0) { n /= 2; } while (n % 3 == 0) { n /= 3; } while (n % 5 == 0) { n /= 5; } return n == 1; } \"]},\"174\":{\"h\":\"\",\"t\":[\"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值target 的那 两个 整数，并返回它们的数组下标。\",\"你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\",\"你可以按任意顺序返回答案。\",\"示例 1：\",\"输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 \",\"示例 2：\",\"输入：nums = [3,2,4], target = 6 输出：[1,2] \",\"示例 3：\",\"输入：nums = [3,3], target = 6 输出：[0,1] \",\"提示：\",\"2 <= nums.length <= 104\",\"-109 <= nums[i] <= 109\",\"-109 <= target <= 109\",\"只会存在一个有效答案\"]},\"175\":{\"h\":\"思路分析\",\"t\":[\"最容易想到的无疑是暴力法，直接双层for循环，挨个去加。\",\" // 暴力法 public static int[] twoSum(int[] nums, int target) { int[] res = new int[2]; for (int i = 0; i < nums.length; i++) { for (int j = i+1; j < nums.length; j++) { int sum = nums[i] + nums[j]; if (sum == target) { res[0] = i; res[1] = j; break; } } } return res; } \",\"第二种方法：hash表\",\"使用hash表，可以考虑使用什么样的hash表？ set ？ map？\",\"题目中要求返回下标，并且我们还需要知道下标和值的对应关系，因此选用map。那么接下来考虑怎么存储？\",\"我们要根据某个值来返回对应的下标，因此存储关系为：\",\"当我们遍历数组时，只需要在 hash表中查找是否有与当前值匹配的值即可，若没有将当前值放入hash表，如果有直接返回下标即可。\",\"过程一\",\"过程二\",\" // hash：key存储值，value存储下标 public static int[] twoSum1(int[] nums, int target) { HashMap<Integer, Integer> map = new HashMap<>(); int[] res = new int[2]; for (int i = 0; i < nums.length; i++) { // target - nums[i] 作为key用来查找，map中有直接返回 if (map.containsKey(target - nums[i])) { res[0] = i; res[1] = map.get(target - nums[i]); }else { map.put(nums[i],i); } } return res; } \"]},\"176\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\",\"你返回所有和为 0 且不重复的三元组。\",\"**注意：**答案中不可以包含重复的三元组。\",\"示例 1：\",\"输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 \",\"示例 2：\",\"输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 \",\"示例 3：\",\"输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 \",\"提示：\",\"3 <= nums.length <= 3000\",\"-105 <= nums[i] <= 105\"]},\"177\":{\"h\":\"思路分析\",\"t\":[\"首先第一想法肯定也是暴力法，使用三层for循环，逐个遍历。但是题目中有个很关键的条件，三元组不能重复，但是每组结果里面的元素是可以重复的，如果使用暴力法，再去考虑去重，时间、空间非常的高，并不容易实现。\",\"使用hash法呢？ 使用俩层for循环，然后尝试获取 0 - a - b 。 使用hash算法去重的操作也是很麻烦的。\",\"因此可以使用双指针算法，使用一层 for 循环，i 指向数组第一个元素，left 指向 i+1 的位置上，right指向末尾元素。\",\"15.三数之和\",\"先对数组进行排序\",\"其次计算 $nums[i] + nums[left] + nums[right] $的和 sum \",\"若 sum < 0, 说明元素较小，将 left 右移\",\"若 sum > 0 , 说明元素较大，将right 左移\",\"若 sum= 0 ， i、left、right 则是一组解，加到集合中即可\",\"基本的逻辑是这样，如何去重呢？ 此时我就想到了能不能使用Set集合自动去重，不用我们手动去重呢，于是代码如下：\",\" public static List<List<Integer>> threeSum(int[] nums) { Arrays.sort(nums); // 使用set集合避免重复的三元组 Set<List<Integer>> res = new HashSet<>(); for (int i = 0; i < nums.length - 2; i++) { // 处理特殊情况 if (nums[i] > 0) return res; int left = i + 1; int right = nums.length - 1; while(left < right) { if (nums[i] + nums[left] + nums[right] > 0) { // 元素值太大，将right左移 right--; } else if (nums[i] + nums[left] + nums[right] < 0) { // 元素值太小，将left右移 left++; } else { // 相等 List<Integer> item = new ArrayList<>(); item.add(nums[i]); item.add(nums[left]); item.add(nums[right]); res.add(item); // 找到一组解之后，同时移动 right--; left++; } } } return new ArrayList<List<Integer>>(res); } \",\"这种方法的耗时较高，因为把重复的元素也都计算了一遍，因此我们可以考虑跳过重复元素【相邻元素进行比较】，跳过重复元素也就没有必要使用 Set 集合了，使用普通集合即可。代码如下：\",\" public static List<List<Integer>> threeSum1(int[] nums) { ArrayList<List<Integer>> res = new ArrayList<>(); Arrays.sort(nums); for (int i = 0; i < nums.length-2; i++) { // 处理特殊情况 if (nums[i] > 0) return res; int left = i+1; int right = nums.length -1; // 对i进行去重 /* * 这里只能使用nums[i] == nums[i-1] * 不能使用nums[i] == nums[i+1]，因为 i+1 可能会丢失 * 比如：-1,-1,2 这种情况 * */ if (i>0 && nums[i] == nums[i-1]) continue; while(left < right) { if (nums[i] + nums[left] + nums[right] < 0) { // 右移 left++; }else if (nums[i] + nums[left] + nums[right] > 0) { // 左移 right--; }else { res.add(Arrays.asList(nums[i],nums[left],nums[right])); // 对 left、right去重 while(left < right && nums[left] == nums[++left]); while(left < right && nums[right] == nums[--right]); } } } return res; } \"]},\"178\":{\"h\":\"\",\"t\":[\"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\",\"0 <= a, b, c, d < n\",\"a、b、c 和 d互不相同\",\"nums[a] + nums[b] + nums[c] + nums[d] == target\",\"你可以按 任意顺序 返回答案 。\",\"示例 1：\",\"输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] \",\"示例 2：\",\"输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] \",\"提示：\",\"1 <= nums.length <= 200\",\"-109 <= nums[i] <= 109\",\"-109 <= target <= 109\"]},\"179\":{\"h\":\"思路分析\",\"t\":[\"相较于三数之和，多了一层for循环，并且判断的条件值不在是0，而是 任意的 target。\",\"因此不能在简单的判断 $nums[i] > target$ 就返回了，比如：[-4, -3, -2, -1]，target是-10，不能因为-4 > -10而跳过。\",\"更改条件为： nums[i] > target nums[i] > 0\",\"五数、六数之和都是这个逻辑\",\"代码如下：\",\" // 相较于三数之和，多一层for循环 public static List<List<Integer>> fourSum(int[] nums, int target) { Arrays.sort(nums); ArrayList<List<Integer>> res = new ArrayList<>(); for (int i = 0; i < nums.length-2; i++) { // 特殊情况判断 if (nums[i] > 0 && nums[i] > target) return res; // 对 i 进行去重 if (i > 0 && nums[i] == nums[i-1]) continue; for (int j = i+1; j < nums.length-2; j++) { // 对 j 去重 if (j > i+1 && nums[j] == nums[j-1]) continue; int left = j+1; int right = nums.length-1; while(left < right) { if (nums[i] + nums[j] + nums[left] + nums[right] < target){ // 右移 left++; }else if (nums[i] + nums[j] + nums[left] + nums[right] > target) { // 左移 right--; }else { res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); // 对left、right去重 while (left < right && nums[left] == nums[++left]); while (left < right && nums[right] == nums[--right]); } } } } return res; } \"]},\"180\":{\"c\":[\"算法\"]},\"181\":{\"c\":[\"哈希表\"]},\"182\":{\"h\":\"回溯\"},\"183\":{\"h\":\"简单介绍\",\"t\":[\"回溯就是一种搜索的方式，它通常用于在搜索过程中撤销或回退一些步骤，以便在发现错误或达到某种条件时重新尝试其他路径。\",\"回溯算法的效率其实并不高，虽然可以通过剪枝操作来提高效一些效率，但是效率仍然不高！\",\"通过回溯做的题目类型：\",\"组合问题：N个数里面按一定规则找出k个数的集合\",\"切割问题：一个字符串按一定规则有几种切割方式\",\"子集问题：一个N个数的集合里有多少符合条件的子集\",\"排列问题：N个数按一定规则全排列，有几种排列方式\",\"棋盘问题：N皇后，解数独等等\",\"组合和排列的区别：\",\"组合不强调元素的顺序，而排列则强调元素的顺序。\",\"例如：{1、3} 和 {3、1} 对于组合来说就是一个集合，而对于排列来说就是俩种集合\"]},\"184\":{\"h\":\"如何理解回溯\",\"t\":[\"回溯基本上都是通过递归来解决问题，因此所有的回溯都可以抽象成树结构！递归的终止条件为二叉树的高度。\",\"回溯算法解决的基本都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。\",\"回溯算法理论基础\",\"PS：看到这里 \\\"懵\\\" 是很正常的，做了几道题就清晰了！\"]},\"185\":{\"h\":\"回溯模板\",\"t\":[\"回溯返回值及参数\",\"// 回溯的参数，一般都是用到啥写啥参数 void backtracking(参数) \",\"回溯的终止条件\",\"一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。\",\"if (终止条件) { 存放结果; return; } \",\"回溯算法的搜索过程\",\"在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。\",\"回溯算法理论基础\",\"注意图中：集合的大小和孩子的数量是相等的。\",\"伪代码如下：\",\"for (选择：本层集合中元素（孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } \",\"for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。\",\"回溯算法模板如下：\",\"void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } \"]},\"186\":{\"h\":\"\",\"t\":[\"给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\",\"你可以按 任何顺序 返回答案。\",\"示例 1：\",\"输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] \",\"示例 2：\",\"输入：n = 1, k = 1 输出：[[1]] \",\"提示：\",\"1 <= n <= 20\",\"1 <= k <= n\"]},\"187\":{\"h\":\"思路分析\",\"t\":[\"该题就是典型回溯问题。假设使用 for 循环，如例题中 的k=2，那么就得使用俩层 for 循环：\",\" for (int i = 0; i < n; i++) { for (int j = i+1; j < n; j++) { } } \",\"如果 k =3 ，就得用三层for循环，那么k=50呢？ 很明显暴力法是不行。\",\"虽然递归也算是暴力法，但不至于像for循环那样绝望~~\",\"在介绍回溯算法时，说过所有的回溯问题都可以抽象成一颗二叉树，那么将该题抽象成二叉树为：\",\"77.组合\",\"其实从图中可以看出，n就是树的宽度，k就是 树的高度，也决定了有多少次循环。\",\"首先，定义俩个集合，item 存放集合中的元素，·res存放所有的集合\",\" ArrayList<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> item = new LinkedList<>(); \",\"确定终止条件\",\"当 item 集合中的元素等于 k 时，说明符合题意，将该集合放入到 res 中\",\" // 终止条件 if (item.size() == k) { // 这里一定要new一个集合，不然操作的始终是同一个item集合 res.add(new ArrayList<>(item)); return; } \",\"返回值及参数\",\"由于横向遍历时，需要确定起始的元素是哪个，因此我们需要一个 startIndex 指针\",\" void backtracking(int n,int k,int startIndex) \",\"单层逻辑\",\"for循环就是横向遍历，递归调用的过程就是纵向遍历。不断递归达到叶子节点时，将元素放入到 item集合中。\",\"递归和回溯是息息相关的，每进行一次递归都要进行一次回溯。在257. 二叉树的所有路径 我们已经说过了！\",\"item.removeLast() 删除上一个增加到item 集合中的元素，简单来说，递归之前做了什么(增加元素)，递归之后就要做相同的逆操作(删除元素)，进行回溯！\",\" for (int i = startIndex; i <= n; i++) { // 处理结点 item.add(i); // 纵向递归遍历：控制树的纵向遍历，注意下一层搜索要从i+1开始 backtracking(n,k,i+1); // 回溯：撤销处理过的结点 item.removeLast(); } \",\"完整代码\",\" ArrayList<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> item = new LinkedList<>(); public List<List<Integer>> combine(int n, int k) { backtracking(n,k,1); return res; } /** * 回溯 * startIndex为每次回溯的起点 * */ public void backtracking(int n,int k,int startIndex) { // 终止条件 if (item.size() == k) { // 这里一定要new一个集合，不然操作的始终是同一个item集合 res.add(new ArrayList<>(item)); return; } for (int i = startIndex; i <= n; i++) { // 处理结点 item.add(i); // 纵向递归遍历：控制树的纵向遍历，注意下一层搜索要从i+1开始 backtracking(n,k,i+1); // 回溯：撤销处理过的结点 item.removeLast(); } } \"]},\"188\":{\"h\":\"剪枝优化\",\"t\":[\"假设n=4，k=4，那么在第一次 for 循环的过程中，其实就没必要再往后面遍历了。因为只剩下3个元素，肯定是不满足条件。\",\"item.size 为已经选择的元素\",\"k 为需要的元素\",\"k - item.size 为还需要选择的元素\",\"n - （k - item.size） + 1 为当前for循环中，起始元素的最大值。\",\"77.组合4\",\"举例说明\",\"假设 n = 5，k = 3\",\"当 item.size = 1 时，还需要选择 2 个元素，那么最大的起始元素为 4，组成的组合为: [4,5]\",\"当 item.size = 2 时，还需要选择 1 个元素，那么最大的起始元素为 5，组成的组合为: [5]\",\"因此以得出：\",\"$最大起始元素 + 还需要选择的元素个数 - 1 = n$\",\"$那么还需要选择的元素 = k - item.size$\",\"最后得出：\",\"$最大的起始元素 = n - (k-item.size) + 1$\",\"所以，剪枝的过程就是把 i<= n 替换成 i<=n - (k-item.size) + 1\",\" for (int i = startIndex; i <= n - (k - item.size()) + 1; i++) { // 剪枝 // 处理结点 item.add(i); // 纵向递归遍历：控制树的纵向遍历，注意下一层搜索要从i+1开始 backtracking(n,k,i+1); // 回溯：撤销处理过的结点 item.removeLast(); } \"]},\"189\":{\"h\":\"\",\"t\":[\"找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\",\"只使用数字1到9\",\"每个数字 最多使用一次\",\"返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\",\"示例 1:\",\"输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 \",\"示例 2:\",\"输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 \",\"示例 3:\",\"输入: k = 4, n = 1 输出: [] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。 \",\"提示:\",\"2 <= k <= 9\",\"1 <= n <= 60\"]},\"190\":{\"h\":\"思路分析\",\"t\":[\"做过 77. 组合 这道题就比较容易了。抽象为二叉树如下图所示：\",\"image-20231128230343416\",\"仍然需要定义俩个集合：\",\" ArrayList<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> item = new LinkedList<>(); \",\"返回值及条件\",\"除了需要定义 startIndex 起始索引之外，还需要定义一个 sum 用来收集 item 集合的和 (不定义sum，用n减也行，如果等于0 就收集起来)\",\" void backtracking(int k, int n, int sum, int startIndex) \",\"终止条件\",\"当 item 元素个数 等于 k，并且 sum = n\",\" if (item.size() == k && sum == n) { res.add(new ArrayList<>(item)); return; } \",\"单层搜索逻辑\",\"仍然通过 递归 将叶子结点增加到 item 集合中\",\"for (int i = startIndex; i <= 9 ; i++) { item.add(i); sum += i; backtracking(k, n, sum, i + 1); // 记住：递归之前干什么，递归之后就要逆向操作，也就是回溯！！！！ sum -= i; item.removeLast(); } \",\"完整代码\",\" ArrayList<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> item = new LinkedList<>(); public List<List<Integer>> combinationSum3(int k, int n) { backtracking(k, n, 0, 1); return res; } /** * @description * @date 2023/11/28 22:33 * @param k * @param n * @param sum 记录增加到item中元素的和 * @param startIndex 每次横向遍历时，起始的元素 * @return void */ public void backtracking(int k, int n, int sum, int startIndex) { if (item.size() == k && sum == n) { res.add(new ArrayList<>(item)); return; } for (int i = startIndex; i <= 9; i++) { item.add(i); sum += i; backtracking(k, n, sum, i + 1); // 记住：递归之前干什么，递归之后就要逆向操作，也就是回溯！！！！ sum -= i; item.removeLast(); } } \"]},\"191\":{\"h\":\"剪枝优化\",\"t\":[\"通过上图其实就可看出来了，有俩个地方可以进行剪枝\",\"当sum > n 时, 在往后遍历就没有意义了，直接剪掉\",\"和 77 一样，当所剩余元素不足需要选择的元素个数时，直接减掉【9 - (k - item.size) + 1】\",\" ArrayList<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> item = new LinkedList<>(); public List<List<Integer>> combinationSum3(int k, int n) { backtracking(k, n, 0, 1); return res; } /** * @description * @date 2023/11/28 22:33 * @param k * @param n * @param sum 记录增加到item中元素的和 * @param startIndex 每次横向遍历时，起始的元素 * @return void */ public void backtracking(int k, int n, int sum, int startIndex) { // 剪枝，如果当前和都已经大于n了，后面就没有必要在进行遍历了 if (sum > n) return; if (item.size() == k && sum == n) { res.add(new ArrayList<>(item)); return; } for (int i = startIndex; i <= 9 - (k - item.size()) + 1; i++) { item.add(i); sum += i; backtracking(k, n, sum, i + 1); // 记住：递归之前干什么，递归之后就要逆向操作，也就是回溯！！！！ sum -= i; item.removeLast(); } } \"]},\"192\":{\"h\":\"\",\"t\":[\"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\",\"给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\",\"img\",\"示例 1：\",\"输入：digits = \\\"23\\\" 输出：[\\\"ad\\\",\\\"ae\\\",\\\"af\\\",\\\"bd\\\",\\\"be\\\",\\\"bf\\\",\\\"cd\\\",\\\"ce\\\",\\\"cf\\\"] \",\"示例 2：\",\"输入：digits = \\\"\\\" 输出：[] \",\"示例 3：\",\"输入：digits = \\\"2\\\" 输出：[\\\"a\\\",\\\"b\\\",\\\"c\\\"] \",\"提示：\",\"0 <= digits.length <= 4\",\"digits[i] 是范围 ['2', '9'] 的一个数字。\"]},\"193\":{\"h\":\"思路分析\",\"t\":[\"看到回溯的题目，首先要将其抽象成一个二叉树，如下图所示：\",\"17. 电话号码的字母组合\",\"我们首先要知道 数字 和 字母要如何进行映射，给你一个数字字母串你得能找到对应的字母。\",\"使用数组和map集合都可以。使用数组的话，用下标表数组，字母代表值。map用key代表数字，value代表值。\",\"因此，定义如下：\",\" // 使用map保存数字和字母的映射关系。也可以用数组表示，值为字母，下标代表数字 HashMap<Character, List<String>> map = new HashMap<>(); map.put('2', Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\")); map.put('3', Arrays.asList(\\\"d\\\", \\\"e\\\", \\\"f\\\")); map.put('4', Arrays.asList(\\\"g\\\", \\\"h\\\", \\\"i\\\")); map.put('5', Arrays.asList(\\\"j\\\", \\\"k\\\", \\\"l\\\")); map.put('6', Arrays.asList(\\\"m\\\", \\\"n\\\", \\\"o\\\")); map.put('7', Arrays.asList(\\\"p\\\", \\\"q\\\", \\\"r\\\", \\\"s\\\")); map.put('8', Arrays.asList(\\\"t\\\", \\\"u\\\", \\\"v\\\")); map.put('9', Arrays.asList(\\\"w\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\")); \",\"终止条件\",\"通过图片我们可以看出来，给定的数字字符串长度为多少，那么每一种组合他的字母长度就为多少。也就是说树的深度与数组字符串的长度相等。\",\"假设我们 StringBuilder 用来保存字母，那么就有：\",\"此处我将数字字符串转换成字符数组 chars了。\",\" // sb保存字母，当字母长度等于数字长度时，说明为一组集合 if (sb.length() == chars.length) { res.add(sb.toString()); return; } \",\"返回值及参数：\",\"除了 chars数组以及map集合，我们仍需要使用 startIndex 指针，用来指向当前遍历的数字。也就是当前树的深度。\",\" public void backtracking(char[] chars, Integer startIndex, HashMap<Character, List<String>> map) {} \",\"单层递归逻辑\",\"在 for循环里，我们遍历的应该是数字对应的字母集合。因此我们先通过map集合找出数字对应的集合。\",\"然后通过递归将每一个字母加到 sb 中。\",\"此处需要注意的是，for循环不在以 startIndex 开始，因为我们需要使用 startIndex 来确定遍历的数字，而for循环遍历的是字母。\",\" // 当前数字代表的字母集合 List<String> letterList = map.get(chars[startIndex]); for (int i = 0; i < letterList.size(); i++) { sb.append(letterList.get(i)); backtracking(chars, startIndex + 1, map); sb.deleteCharAt(sb.length() - 1); // 回溯，删除上一个处理的字母，继续处理 } \",\"整体代码\",\" List<String> res = new ArrayList<>(); StringBuilder sb = new StringBuilder(); public List<String> letterCombinations(String digits) { if (digits == null || digits.length() == 0) return res; char[] chars = digits.toCharArray(); // 使用map保存数字和字母的映射关系。也可以用数组表示，值为字母，下标代表数字 HashMap<Character, List<String>> map = new HashMap<>(); map.put('2', Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\")); map.put('3', Arrays.asList(\\\"d\\\", \\\"e\\\", \\\"f\\\")); map.put('4', Arrays.asList(\\\"g\\\", \\\"h\\\", \\\"i\\\")); map.put('5', Arrays.asList(\\\"j\\\", \\\"k\\\", \\\"l\\\")); map.put('6', Arrays.asList(\\\"m\\\", \\\"n\\\", \\\"o\\\")); map.put('7', Arrays.asList(\\\"p\\\", \\\"q\\\", \\\"r\\\", \\\"s\\\")); map.put('8', Arrays.asList(\\\"t\\\", \\\"u\\\", \\\"v\\\")); map.put('9', Arrays.asList(\\\"w\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\")); backtracking(chars, 0, map); return res; } public void backtracking(char[] chars, Integer startIndex, HashMap<Character, List<String>> map) { // sb保存字母，当字母长度等于数字长度时，说明为一组集合 if (sb.length() == chars.length) { res.add(sb.toString()); return; } // 当前数字代表的字母集合 List<String> letterList = map.get(chars[startIndex]); for (int i = 0; i < letterList.size(); i++) { sb.append(letterList.get(i)); backtracking(chars, startIndex + 1, map); sb.deleteCharAt(sb.length() - 1); // 回溯，删除上一个处理的字母，继续处理 } } \"]},\"194\":{\"h\":\"\",\"t\":[\"给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\",\"candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\",\"对于给定的输入，保证和为 target 的不同组合数少于 150 个。\",\"示例 1：\",\"输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 \",\"示例 2：\",\"输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] \",\"示例 3：\",\"输入: candidates = [2], target = 1 输出: [] \",\"提示：\",\"1 <= candidates.length <= 30\",\"2 <= candidates[i] <= 40\",\"candidates 的所有元素 互不相同\",\"1 <= target <= 40\"]},\"195\":{\"h\":\"思路分析\",\"t\":[\"此题的唯一一个难点，就是选取的元素可以无限重复。但是在代码中，我们不可能让它无限重复，假设我们用 sum 保存集合的和，当 sum > tartget 时，就没有必须在选取了。因此：\",\"终止条件\",\"sum == target，保存当前组合\",\"sum > target 结束\",\" if (sum == target) { res.add(new ArrayList<>(path)); return; } if (sum > target) return; \",\"返回值及参数\",\"仍然需要 startIndex 指针，指向当前遍历的元素。\",\"当我们求同一个集合中的不同组合时，就需要用 startIndex，像 77、216 这俩道题\",\"当我们求不同集合之间的组合时，就不需要用 startIndex , 像 17 题\",\"public void backtracking(int[] candidates, int target, int sum, int startIndex) {} \",\"单层递归逻辑\",\" for (int i = startIndex; i < candidates.length; i++) { path.add(candidates[i]); sum += candidates[i]; backtracking(candidates, target, sum, i); // 由于元素可以重复，i 就无需+1 // 进行回溯 sum -= candidates[i]; path.remove(path.size() - 1); } \",\"完整代码\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> combinationSum(int[] candidates, int target) { backtracking(candidates, target, 0, 0); return res; } public void backtracking(int[] candidates, int target, int sum, int startIndex) { if (sum == target) { res.add(new ArrayList<>(path)); return; } if (sum > target) return; for (int i = startIndex; i < candidates.length; i++) { path.add(candidates[i]); sum += candidates[i]; backtracking(candidates, target, sum, i); // 由于元素可以重复，i 就无需+1 // 进行回溯 sum -= candidates[i]; path.remove(path.size() - 1); } } \"]},\"196\":{\"h\":\"\",\"t\":[\"给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\",\"candidates 中的每个数字在每个组合中只能使用 一次 。\",\"**注意：**解集不能包含重复的组合。\",\"示例 1:\",\"输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] \",\"示例 2:\",\"输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] \",\"提示:\",\"1 <= candidates.length <= 100\",\"1 <= candidates[i] <= 50\",\"1 <= target <= 30\"]},\"197\":{\"h\":\"思路分析\",\"t\":[\"该题相较于上面几题的区别就是： 选取元素的集合可能有重复元素，但是不能包含重复的组合。\",\"比如：\",\"输入: candidates = [10,1,2,7,6,1,5], target = 8,\",\"像 [1,1,6] 和 [6,1,1] 这样是不行的\",\"集合中可以存在重复的元素，就是在一个 \\\"树枝\\\" 中 可以重复\",\"不能有重复的组合，就是在同一 \\\"层\\\" 中不能有重复。\",\"如下图所示：\",\"40.组合总和II\",\"完整代码\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtracking(candidates, target, 0, 0); return res; } public void backtracking(int[] candidates, int target, int sum, int startIndex) { if (sum == target) { res.add(new ArrayList<>(path)); return; } for (int i = startIndex; i < candidates.length; i++) { // 剪枝 if (sum + candidates[i] >target) break; // i=startIndex 为同一层的第一个元素 // 去重操作,这里用 i > startIndex, 是因为去重主要是对同一层进行去重。 if (i > startIndex && candidates[i] == candidates[i - 1]) { continue; } path.add(candidates[i]); sum += candidates[i]; backtracking(candidates, target, sum, i + 1); // 回溯 sum -= candidates[i]; path.remove(path.size() - 1); } } \"]},\"198\":{\"h\":\"\",\"t\":[\"给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\",\"回文串 是正着读和反着读都一样的字符串。\",\"示例 1：\",\"输入：s = \\\"aab\\\" 输出：[[\\\"a\\\",\\\"a\\\",\\\"b\\\"],[\\\"aa\\\",\\\"b\\\"]] \",\"示例 2：\",\"输入：s = \\\"a\\\" 输出：[[\\\"a\\\"]] \",\"提示：\",\"1 <= s.length <= 16\",\"s 仅由小写英文字母组成\"]},\"199\":{\"h\":\"思路分析\",\"t\":[\"在我看来，解决该题，至少要知道：\",\"如何进行切割\",\"如何判断回文串\",\"首先看第一个问题，\\\"切割\\\"问题其实和 \\\"组合\\\" 问题一样，都可以使用回溯方法来做，都可以抽象成一颗二叉树，如下图所示：\",\"image-20231204232030986\",\"变量\",\"仍然需要俩个集合，一个 res 保存所有的切割方案，一个 path 用来保存每一个切割方案\",\" List<String> path = new ArrayList<>(); List<List<String>> res = new ArrayList<>(); \",\"终止条件\",\"这道题仍然需要一个 startIndex 来指向即将遍历的字符，也就是说当 startIndex 指向 s串的末尾时，说明已经有了一个切割方案，即加入到 res 中。\",\" if (startIndex == s.length()) { res.add(new ArrayList<>(path)); return; } \",\"返回值及参数\",\"public void backtracking(String s, int startIndex) {} \",\"单层递归逻辑\",\"通过上面图中可以看到，在截取每个字符时，都要判断当前截取的字符是否为回文串。如何截取呢？\",\"startIndex 为起始索引，而 for 循环中的 i 变量则表示，该次遍历的结束索引。那么 substring(startIndex, i + 1) 则为当前要截取的字符串，\",\" for (int i = startIndex; i < s.length(); i++) { // 判断是否是回文子串,[startIndex,i] 为当前遍历时要截取的子串 if (isPalindrome(s,startIndex,i)) { String substring = s.substring(startIndex, i + 1); path.add(substring); }else{ continue; } backtracking(s,i+1); path.remove(path.size()-1); } \",\"判断回文串\",\"采用双指针法，比较头尾字符\",\" // 判断字符串是否是回文串 public boolean isPalindrome(String s,int start,int end) { for (int i = start,j = end; i < j; i++,j--) { if (s.charAt(i) != s.charAt(j)) return false; } return true; } \",\"完整代码\",\" List<String> path = new ArrayList<>(); List<List<String>> res = new ArrayList<>(); public List<List<String>> partition(String s) { backtracking(s, 0); return res; } public void backtracking(String s, int startIndex) { if (startIndex == s.length()) { res.add(new ArrayList<>(path)); return; } for (int i = startIndex; i < s.length(); i++) { // 判断是否是回文子串,[startIndex,i] 为当前遍历时要截取的子串 if (isPalindrome(s,startIndex,i)) { String substring = s.substring(startIndex, i + 1); path.add(substring); }else{ continue; } backtracking(s,i+1); path.remove(path.size()-1); } } // 判断字符串是否是回文串 public boolean isPalindrome(String s,int start,int end) { for (int i = start,j = end; i < j; i++,j--) { if (s.charAt(i) != s.charAt(j)) return false; } return true; } \"]},\"200\":{\"h\":\"\",\"t\":[\"有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\",\"例如：\\\"0.1.2.201\\\" 和 \\\"192.168.1.1\\\" 是 有效 IP 地址，但是 \\\"0.011.255.245\\\"、\\\"192.168.1.312\\\" 和 \\\"192.168@1.1\\\" 是 无效 IP 地址。\",\"给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\",\"示例 1：\",\"输入：s = \\\"25525511135\\\" 输出：[\\\"255.255.11.135\\\",\\\"255.255.111.35\\\"] \",\"示例 2：\",\"输入：s = \\\"0000\\\" 输出：[\\\"0.0.0.0\\\"] \",\"示例 3：\",\"输入：s = \\\"101023\\\" 输出：[\\\"1.0.10.23\\\",\\\"1.0.102.3\\\",\\\"10.1.0.23\\\",\\\"10.10.2.3\\\",\\\"101.0.2.3\\\"] \",\"提示：\",\"1 <= s.length <= 20\",\"s 仅由数字组成\"]},\"201\":{\"h\":\"思路分析\",\"t\":[\"这道题思路分析 其实和 131. 分割回文串 是一样的，只不过上面是判断是否是回文串，这道题是判断是否是有效IP地址。\",\"那么对于有效的IP地址，应该满足以下三个条件：\",\"每一段不能以0开头，但是当该段只有一个字符时，可以是 0.比如：255.0.0.1 是有效的，255.0.01.1 是无效的\",\"每一段不能为非数字\",\"每一段不能超过255\",\"抽象成二叉树为：\",\"image-20231204232800781\",\"定义俩个变量\",\" // 保存所有合法的ip地址 List<String> res = new ArrayList<>(); // 保存ip地址的每一段，例如：[\\\"255\\\",\\\"255\\\",\\\"11\\\",\\\"135\\\"] List<String> path = new ArrayList<>(); \",\"终止条件\",\"仍然需要使用 startIndex 指针， 当 path.size = 4 时，说明有一组合法的IP地址，并且还需要判断 startIndex 的位置，一定要指向 s串的末尾。不然像 2.5.5.2 也会符合条件。\",\" if (path.size() == 4 && startIndex >= s.length()) { // 将ip地址保存到最终的集合中 res.add(String.join(\\\".\\\", path)); return; } \",\"返回值及参数\",\" public void backtracking(String s, int startIndex) {} \",\"单层递归逻辑\",\" for (int i = startIndex; i < s.length(); i++) { // 校验当前区间是否合法 if (isValid(s, startIndex, i)) { String substring = s.substring(startIndex, i + 1); path.add(substring); } else { continue; } backtracking(s, i + 1); path.remove(path.size() - 1); } \",\"判断是否为合法的IP地址\",\" // 校验该段ip地址是否合法 private boolean isValid(String s, int start, int end) { // if (start > end) return false; //1、每一段起始不能为0,start != end为了防止每段中只有一个元素，因为 0.0.0.0 是合法的 if (s.charAt(start) == '0' && start != end) return false; //2、每一段中不能含有非数字 //3、每一段中不能超过255 int nums = 0; for (int i = start; i <= end; i++) { if (s.charAt(i) > '9' || s.charAt(i) < '0') return false; // 将当前字符转换成int型 nums = (s.charAt(i) - '0') + nums * 10; if (nums > 255) return false; } return true; } \",\"完整代码\",\" // 保存所有合法的ip地址 List<String> res = new ArrayList<>(); // 保存ip地址的每一段，例如：[\\\"255\\\",\\\"255\\\",\\\"11\\\",\\\"135\\\"] List<String> path = new ArrayList<>(); public List<String> restoreIpAddresses(String s) { backtracking(s, 0); return res; } public void backtracking(String s, int startIndex) { // if (path.size() > 4) return; if (path.size() == 4 && startIndex >= s.length()) { // 将ip地址保存到最终的集合中 res.add(String.join(\\\".\\\", path)); return; } for (int i = startIndex; i < s.length(); i++) { // 校验当前区间是否合法 if (isValid(s, startIndex, i)) { String substring = s.substring(startIndex, i + 1); path.add(substring); } else { continue; } backtracking(s, i + 1); path.remove(path.size() - 1); } } // 校验该段ip地址是否合法 private boolean isValid(String s, int start, int end) { // if (start > end) return false; //1、每一段起始不能为0,start != end为了防止每段中只有一个元素，因为 0.0.0.0 是合法的 if (s.charAt(start) == '0' && start != end) return false; //2、每一段中不能含有非数字 //3、每一段中不能超过255 int nums = 0; for (int i = start; i <= end; i++) { if (s.charAt(i) > '9' || s.charAt(i) < '0') return false; // 将当前字符转换成int型 nums = (s.charAt(i) - '0') + nums * 10; if (nums > 255) return false; } return true; } \"]},\"202\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\",\"解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\",\"示例 1：\",\"输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] \",\"示例 2：\",\"输入：nums = [0] 输出：[[],[0]] \",\"提示：\",\"1 <= nums.length <= 10\",\"-10 <= nums[i] <= 10\",\"nums 中的所有元素 互不相同\"]},\"203\":{\"h\":\"思路分析\",\"t\":[\"到目前为止，对于回溯问题我遇见了三种：\",\"组合\",\"切割\",\"子集\",\"组合即从一组元素中，任意选取若干个元素组合成一个集合，不考虑元素的顺序。使用回溯时通常要在终止条件时，判断组成的集合是否符合条件。\",\"切割问题通常对给定的字符串进行切割，判断切割出来的序列是否符合条件，然后加到集合中。\",\"子集问题则是要遍历所有的元素，每遍历一个元素都要加入到集合中，形成新的子集。\",\"抽象为二叉树为：\",\"image-20231205213146498\",\"变量\",\"仍然需要俩个集合\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); \",\"终止条件\",\"子集问题要遍历所有元素，因此仍然需要使用 startIndex 记录遍历的元素，当 startIndex 指针指向最后一个元素时表示遍历完成\",\"if (startIndex >= nums.length)return; \",\"返回值及参数\",\"public void backtracking(int[] nums,int startIndex) {} \",\"单层递归逻辑\",\"在前面说过，子集问题通常要扫描所有元素，没遍历一个元素都要加入集合中去，形成一个新的子集\",\" for (int i = startIndex; i < nums.length; i++) { // 每遍历一个元素，就将该元素加入到path中，并加入到 res集合中。都算是一个子集 path.add(nums[i]); res.add(new ArrayList<>(path)); backtracking(nums,i+1); path.remove(path.size() -1); } \",\"完整代码：\",\"最后不要忘记，将 {0} 也加入到结果集当中\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> subsets(int[] nums) { // 空集合也算是一个子集 res.add(new ArrayList<>()); backtracking(nums,0); return res; } public void backtracking(int[] nums,int startIndex) { if (startIndex >= nums.length)return; for (int i = startIndex; i < nums.length; i++) { // 每遍历一个元素，就将该元素加入到path中，并加入到 res集合中。都算是一个子集 path.add(nums[i]); res.add(new ArrayList<>(path)); backtracking(nums,i+1); path.remove(path.size() -1); } } \"]},\"204\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\",\"解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\",\"示例 1：\",\"输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] \",\"示例 2：\",\"输入：nums = [0] 输出：[[],[0]] \",\"提示：\",\"1 <= nums.length <= 10\",\"-10 <= nums[i] <= 10\"]},\"205\":{\"h\":\"思路分析\",\"t\":[\"该题相较于 78. 子集 仅仅多了一个去重的步骤，而去重操作其实在 40. 组合总和 II 已经有过说明，再来看一下。\",\"先抽象成一个二叉树，如下图所示：\",\"image-20231205223420271\",\"通过图中可以看出，去重是针对同一层是否有重复元素，而对于同一个树枝是允许有重复元素的。\",\"每一层其实就是每次递归进行的 for循环，而 startIndex 则为for循环的起始下标。因此当 i> startIndex 时，也就是从每一层的第二个元素开始，进行判断前后俩个元素是否相等。相等则跳过(提前对数组进行排序)。\",\"List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> subsetsWithDup(int[] nums) { Arrays.sort(nums); res.add(new ArrayList<>()); backtracking(nums,0); return res; } public void backtracking(int[] nums,int startIndex) { if (startIndex >= nums.length) return; for (int i = startIndex; i < nums.length;i++) { // 进行去重 if (i > startIndex && nums[i] == nums[i-1]) continue; path.add(nums[i]); res.add(new ArrayList<>(path)); backtracking(nums,i+1); path.remove(path.size()-1); } } \"]},\"206\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。\",\"数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\",\"示例 1：\",\"输入：nums = [4,6,7,7] 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] \",\"示例 2：\",\"输入：nums = [4,4,3,2,1] 输出：[[4,4]] \",\"提示：\",\"1 <= nums.length <= 15\",\"-100 <= nums[i] <= 100\"]},\"207\":{\"h\":\"思路分析\",\"t\":[\"该题大概一看其实和 子集二 差不多，如果这样认为的话，其实就掉坑里了。\",\"这道题与 子集二 的区别就是： 子集二可以对序列排序，该题不能排序，因为排完序后会影响原序列的递增顺序。\",\"因此我们不能和 子集二 一样比较前后俩个元素进行去重。 可以使用 hash 进行去重，将每一层的元素都放到 hash 中。\",\"抽象成二叉树如下图所示：\",\"注意：hash是保存同一层的元素。这个 \\\"同一层\\\" 是指在同一个父结点下\",\"image-20231206215822477\",\"定义集合变量：\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); \",\"终止条件\",\"这里不要 return ，要一直递归到叶子结点。将所有的子集都加到集合中\",\" // 这里不要return, 要遍历当前 \\\"树枝\\\" 下的所有元素 if (path.size() >= 2) res.add(new ArrayList<>(path)); \",\"返回值及参数\",\"public void backtracking(int[] nums, int startIndex) {} \",\"单层递归逻辑\",\"for循环就是对 同一层 进行遍历，在 添加到 path 集合前，要进行去重(使用set去重)，并且判断是否符合递增的条件！\",\" // 此处不能在像 90/40 题一样，简单的比较前后俩个元素进行去重，因为该题不能进行排序 // 可以使用set对同一层的元素进行去重 HashSet<Integer> set = new HashSet<>(); for (int i = startIndex; i < nums.length; i++) { // 利用set进行去重，如果有重复的就无需在使用当前元素。或者path中最后一个元素大于当前元素，也不符合递增，也不使用当前元素 if (!path.isEmpty() && path.get(path.size() - 1) > nums[i] || set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.remove(path.size() - 1); } \",\"完整代码\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> findSubsequences(int[] nums) { backtracking(nums, 0); return res; } public void backtracking(int[] nums, int startIndex) { // 这里不要return, 要遍历当前 \\\"树枝\\\" 下的所有元素 if (path.size() >= 2) res.add(new ArrayList<>(path)); // 此处不能在像 90/40 题一样，简单的比较前后俩个元素进行去重，因为该题不能进行排序 // 可以使用set对同一层的元素进行去重 HashSet<Integer> set = new HashSet<>(); for (int i = startIndex; i < nums.length; i++) { // 利用set进行去重，如果有重复的就无需在使用当前元素。或者path中最后一个元素大于当前元素，也不符合递增，也不使用当前元素 if (!path.isEmpty() && path.get(path.size() - 1) > nums[i] || set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.remove(path.size() - 1); } } \"]},\"208\":{\"h\":\"\",\"t\":[\"给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\",\"示例 1：\",\"输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] \",\"示例 2：\",\"输入：nums = [0,1] 输出：[[0,1],[1,0]] \",\"示例 3：\",\"输入：nums = [1] 输出：[[1]] \",\"提示：\",\"1 <= nums.length <= 6\",\"-10 <= nums[i] <= 10\",\"nums 中的所有整数 互不相同\"]},\"209\":{\"h\":\"思路分析\",\"t\":[\"首先全排列问题是给定一个序列，求他的排列方式，抽象成二叉树如下图所示：\",\"image-20231206223245857\",\"通过图片其实也可以看出与组合、子集的不同之处，首先在同一层的遍历当中，也就是for循环中，使用过的元素在后续的遍历还会使用到。\",\"因此 for 循环不用在 从 startIndex 开始了，而是每次for循环都从0开始，重新遍历。但是还仍然有个问题，当我们重新遍历的时候，就有可能将元素重复放到 path集合中，因此我们还要判断集合中是否有这个元素。\",\"定义变量\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); \",\"终止条件\",\"由于是求序列的排列方式，因此元素个数肯定能是和原序列个数相等的\",\" // 找到nums的排列方式,因此每一种排列方式元素个数肯定都是一样的。 if (path.size() == nums.length) { res.add(new ArrayList<>(path)); return; } \",\"返回值及参数\",\"全排列问题无需在使用 startIndex\",\"public void backtracking(int[] nums) {} \",\"单层递归逻辑\",\"for循环从0开始，并且将元素增加到 path 集合之前，先判断是否已经重复添加\",\" for (int i = 0; i < nums.length; i++) { // 防止重复增加到集合中 if (path.contains(nums[i])) continue; path.add(nums[i]); backtracking(nums); path.remove(path.size()-1); } \",\"完整代码\",\" List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> permute(int[] nums) { backtracking(nums); return res; } public void backtracking(int[] nums) { // 找到nums的排列方式,因此每一种排列方式元素个数肯定都是一样的。 if (path.size() == nums.length) { res.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++) { // 防止重复增加到集合中 if (path.contains(nums[i])) continue; path.add(nums[i]); backtracking(nums); path.remove(path.size()-1); } } \"]},\"210\":{\"h\":\"\",\"t\":[\"给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\",\"示例 1：\",\"输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] \",\"示例 2：\",\"输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] \",\"提示：\",\"1 <= nums.length <= 8\",\"-10 <= nums[i] <= 10\"]},\"211\":{\"h\":\"思路分析\",\"t\":[\"该题相较于 46. 全排列多了一个去重的步骤，对于去重我们在 组合问题、子集问题已经遇见过了，但是对于全排列问题，没有 startIndex 指针 并且也不能比较前后俩个元素（因为我们for循环从0开始，很容易造成重复添加）\",\"因此我们可以使用一个 boolean 类型的数组来表示当前元素是否使用过，这里我用used表示。如果当前元素和前一个元素相等，并且前一个元素已经被使用了，我们就跳过当前元素。\",\"先给出代码:\",\"注意：去重问题均要先对数组进行排序，方便跳过重复元素！！\",\" public List<List<Integer>> permuteUnique(int[] nums) { boolean[] used = new boolean[nums.length]; Arrays.sort(nums); // Arrays.fill(used,false); backtracking(nums, used); return res; } List<List<Integer>> res = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public void backtracking(int[] nums, boolean[] used) { if (path.size() == nums.length) { res.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++) { // 这里的 used[i-1] == false 表示同一层上，num[i-1]被使用过，那么 nums[i]与之右相等，因此跳过nums[i] // 这里的 used[i-1] == true 表示同一树枝上，num[i-1]被使用过，在组合内是允许有重复元素的。 if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) continue; if (!used[i]) { path.add(nums[i]); used[i] = true; backtracking(nums, used); path.remove(path.size() - 1); used[i] = false; } } \",\"这段代码也就是我们去重的代码，也是较为不好理解的代码。\",\" if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) continue; \",\"先抽象成二叉树为：希望大家能有画图的习惯，对于回溯问题，画完图已经解决一半了。哈哈\",\"image-20231207234459580\",\"看了上面的图，可能大家会清晰不少，但是仍然可能会有一些疑问（至少我是有的，哈哈哈）：\",\"判断前一个元素被使用过，难道不是 used[i-1] == true 吗？ 为什么会判断 used[i-1] == false 呢？\",\"这是因为我们在回溯的过程中，其实是有步操作： used[i] = false , 因此只有 used[i-1] == false, 才能表示 nums[i] 是由 num[i-1] 回溯而来，也就可以判断 nums[i-1] 已经被使用了！\",\"image-20231207230757432\",\"我们也可以认为 used[i-1] == false 才是对 同一层重复元素的判断\",\"而 在递归之前，有步操作是 used[i] = true，因此 used[i-1] == true 则是对同一树枝重复元素的判断，继续看一下张图：\",\"image-20231207232714523\",\"对于 \\\"同一层\\\" 不能有重复元素可以理解为：不能有重复的组合\",\"对于 \\\"同一树枝\\\" 不能有重复元素可以理解为：集合内不能有重复的元素\"]},\"212\":{\"h\":\"\",\"t\":[\"给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\",\"所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\",\"例如，行程 [\\\"JFK\\\", \\\"LGA\\\"] 与 [\\\"JFK\\\", \\\"LGB\\\"] 相比就更小，排序更靠前。\",\"假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\",\"示例 1：\",\"img\",\"输入：tickets = [[\\\"MUC\\\",\\\"LHR\\\"],[\\\"JFK\\\",\\\"MUC\\\"],[\\\"SFO\\\",\\\"SJC\\\"],[\\\"LHR\\\",\\\"SFO\\\"]] 输出：[\\\"JFK\\\",\\\"MUC\\\",\\\"LHR\\\",\\\"SFO\\\",\\\"SJC\\\"] \",\"示例 2：\",\"img\",\"输入：tickets = [[\\\"JFK\\\",\\\"SFO\\\"],[\\\"JFK\\\",\\\"ATL\\\"],[\\\"SFO\\\",\\\"ATL\\\"],[\\\"ATL\\\",\\\"JFK\\\"],[\\\"ATL\\\",\\\"SFO\\\"]] 输出：[\\\"JFK\\\",\\\"ATL\\\",\\\"JFK\\\",\\\"SFO\\\",\\\"ATL\\\",\\\"SFO\\\"] 解释：另一种有效的行程是 [\\\"JFK\\\",\\\"SFO\\\",\\\"ATL\\\",\\\"JFK\\\",\\\"ATL\\\",\\\"SFO\\\"] ，但是它字典排序更大更靠后。 \",\"提示：\",\"1 <= tickets.length <= 300\",\"tickets[i].length == 2\",\"fromi.length == 3\",\"toi.length == 3\",\"fromi 和 toi 由大写英文字母组成\",\"fromi != toi\"]},\"213\":{\"h\":\"思路分析\",\"t\":[\"从题目中可以得知，机票中可能含有重复的机票，因此我们仍然需要使用 一个 used 数组来进行标记使用过的机票。\",\"并且如果能构成一个合理的行程，有以下的特点：\",\"当前机票的起点必然是上一个机票的终点\",\"一个合理的行程所经历的机场必然是机票数+1\",\"抽象成二叉树为：\",\"例子：[{JFK,KUL},{JFK,NRT},{NRT,JFK}]\",\"image-20231211222933758\",\"定义变量\",\"path保存行程，所经历的机场，res保存最终的一个行程\",\" private LinkedList<String> path = new LinkedList<>(); private LinkedList<String> res; \",\"返回值及参数\",\"回溯一般没有返回值，但是对于该题来说，我们仅需要一种结果，找到即返回！\",\" public boolean backtracking(List<List<String>> tickets, boolean[] used) {} \",\"终止条件\",\"经历的机场数 = 机票数 + 1\",\" if (path.size() == tickets.size() + 1) { res = new LinkedList<>(path); return true; } \",\"单层递归逻辑\",\"判断逻辑其实和 全排列二 一样，判断当前机票的标志： used[i] == false 表示当前机票没有被使用过，并且要构成合理的行程，当前机票的起点必然是上一个机票的终点\",\" if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) { path.add(tickets.get(i).get(1)); used[i] = true; // 找到一个合理的行程返回 if (backtracking(tickets, used)) return true; // 回溯 path.removeLast(); used[i] = false; } \",\"剪枝\",\" // 进行剪枝，如果不加会超时 // 如果当前航班和上一个航班相同，并且上一个航班没有使用过，说明是由上一个航班回溯来的。其实是已经使用过了，就跳过当前航班 if (i > 0 && tickets.get(i).get(0).equals(tickets.get(i - 1).get(0)) && tickets.get(i).get(1).equals(tickets.get(i - 1).get(1)) && !used[i - 1]) continue; \",\"完整代码\",\" public List<String> findItinerary(List<List<String>> tickets) { // 对航班进行排序 tickets.sort((a, b) -> a.get(1).compareTo(b.get(1))); path.add(\\\"JFK\\\"); backtracking(tickets, new boolean[tickets.size()]); return res; } private LinkedList<String> path = new LinkedList<>(); private LinkedList<String> res; /** * 此处的回溯有返回值是因为我们只需要找到一种合理的行程返回即可。 * */ public boolean backtracking(List<List<String>> tickets, boolean[] used) { if (path.size() == tickets.size() + 1) { res = new LinkedList<>(path); return true; } // 遍历所有的航班 for (int i = 0; i < tickets.size(); i++) { // 进行剪枝，如果不加会超时 // 如果当前航班和上一个航班相同，并且上一个航班没有使用过，说明是由上一个航班回溯来的。其实是已经使用过了，就跳过当前航班 if (i > 0 && tickets.get(i).get(0).equals(tickets.get(i - 1).get(0)) && tickets.get(i).get(1).equals(tickets.get(i - 1).get(1)) && !used[i - 1]) continue; // 先校验该航班是否已经飞过 // 并且当前航班的起点必须是上一个航班的终点才能构成一个合理的行程 if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) { path.add(tickets.get(i).get(1)); used[i] = true; // 找到一个合理的行程返回 if (backtracking(tickets, used)) return true; // 回溯 path.removeLast(); used[i] = false; } } return false; } \"]},\"214\":{\"h\":\"\",\"t\":[\"按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\",\"n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\",\"给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\",\"每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\",\"示例 1：\",\"img\",\"输入：n = 4 输出：[[\\\".Q..\\\",\\\"...Q\\\",\\\"Q...\\\",\\\"..Q.\\\"],[\\\"..Q.\\\",\\\"Q...\\\",\\\"...Q\\\",\\\".Q..\\\"]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 \",\"示例 2：\",\"输入：n = 1 输出：[[\\\"Q\\\"]] \",\"提示：\",\"1 <= n <= 9\"]},\"215\":{\"h\":\"思路分析\",\"t\":[\"通过题目可以知道，对于N皇后的约束条件：\",\"不能同行\",\"不能同列\",\"不能同一斜线\",\"对于N皇后问题，我们同样可以抽象成二叉树：\",\"51.N皇后\",\"棋盘的深度(行)决定了递归的深度，而宽度(列)决定了for循环的长度。\",\"利用上面那三个约束条件，不断的递归、回溯找到每个皇后的位置。\",\"返回值及参数\",\"row表示当前处理的是第几行，chessboard 用来表示棋盘\",\"public void backtracking(int row, int n,char[][] chessboard ) {} \",\"终止条件\",\"当处理完最后一行时，则表名所有皇后均放置完毕\",\" // 一行放入一个皇后，如果遍历的行数等于皇后数说明已经放置完毕 if (row == n) { res.add(newArrayList(chessboard)); return; } \",\"单层递归逻辑\",\"每次放置皇后前，要与其他皇后校验是否冲突，不冲突则放入棋盘内，冲突则换下一列\",\" for (int col = 0; col < n; col++) { // 检查放入的位置是否冲突 if (!isValid(row,col,chessboard,n)) { chessboard[row][col] = 'Q'; backtracking(row+1,n,chessboard); chessboard[row][col] = '.'; // 回溯 } } \",\"检验冲突\",\" // 判断当前位置[row][col] 是否有冲突 private boolean isValid(int row, int col, char[][] chessboard, int n) { // 检查同一列是否冲突 for (int i = 0; i < row; i++) { if (chessboard[i][col] == 'Q') return true; } // 检查45度是否有冲突,当前位置的左上方 for (int i = row -1 ,j = col -1; i >= 0 && j >=0; i--,j--) { if (chessboard[i][j] == 'Q') return true; } // 检查135度方向是否有冲突，当前位置的右上方 for (int i = row -1,j = col+1; i >= 0 && j < n; i--,j++) { if (chessboard[i][j] == 'Q') return true; } return false; } \",\"完整代码\",\" public List<List<String>> solveNQueens(int n) { char[][] chessboard = new char[n][n]; for (char[] strings : chessboard) { Arrays.fill(strings,'.'); } backtracking(0,n,chessboard); return res; } List<List<String>> res =new ArrayList<>(); /** * @description * @date 2023/12/11 23:01 * @param row 遍历的行数 * @param n 皇后数量 * @param chessboard 棋盘 * @return void */ public void backtracking(int row, int n,char[][] chessboard ) { // 一行放入一个皇后，如果遍历的行数等于皇后数说明已经放置完毕 if (row == n) { res.add(newArrayList(chessboard)); return; } for (int col = 0; col < n; col++) { // 检查放入的位置是否冲突 if (!isValid(row,col,chessboard,n)) { chessboard[row][col] = 'Q'; backtracking(row+1,n,chessboard); chessboard[row][col] = '.'; // 回溯 } } } private List<String> newArrayList(char[][] chessboard) { ArrayList<String> list = new ArrayList<>(); for (char[] strings : chessboard) { list.add(String.copyValueOf(strings)); } return list; } // 判断当前位置[row][col] 是否有冲突 private boolean isValid(int row, int col, char[][] chessboard, int n) { // 检查同一列是否冲突 for (int i = 0; i < row; i++) { if (chessboard[i][col] == 'Q') return true; } // 检查45度是否有冲突,当前位置的左上方 for (int i = row -1 ,j = col -1; i >= 0 && j >=0; i--,j--) { if (chessboard[i][j] == 'Q') return true; } // 检查135度方向是否有冲突，当前位置的右上方 for (int i = row -1,j = col+1; i >= 0 && j < n; i--,j++) { if (chessboard[i][j] == 'Q') return true; } return false; } \"]},\"216\":{\"h\":\"\",\"t\":[\"编写一个程序，通过填充空格来解决数独问题。\",\"数独的解法需 遵循如下规则：\",\"数字 1-9 在每一行只能出现一次。\",\"数字 1-9 在每一列只能出现一次。\",\"数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\",\"数独部分空格内已填入了数字，空白格用 '.' 表示。\",\"示例 1：\",\"img\",\"输入：board = [[\\\"5\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\"6\\\",\\\".\\\",\\\".\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\".\\\",\\\".\\\",\\\".\\\"],[\\\".\\\",\\\"9\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\"],[\\\"8\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"3\\\"],[\\\"4\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"1\\\"],[\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"6\\\"],[\\\".\\\",\\\"6\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"2\\\",\\\"8\\\",\\\".\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\"4\\\",\\\"1\\\",\\\"9\\\",\\\".\\\",\\\".\\\",\\\"5\\\"],[\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\"8\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\"9\\\"]] 输出：[[\\\"5\\\",\\\"3\\\",\\\"4\\\",\\\"6\\\",\\\"7\\\",\\\"8\\\",\\\"9\\\",\\\"1\\\",\\\"2\\\"],[\\\"6\\\",\\\"7\\\",\\\"2\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\"3\\\",\\\"4\\\",\\\"8\\\"],[\\\"1\\\",\\\"9\\\",\\\"8\\\",\\\"3\\\",\\\"4\\\",\\\"2\\\",\\\"5\\\",\\\"6\\\",\\\"7\\\"],[\\\"8\\\",\\\"5\\\",\\\"9\\\",\\\"7\\\",\\\"6\\\",\\\"1\\\",\\\"4\\\",\\\"2\\\",\\\"3\\\"],[\\\"4\\\",\\\"2\\\",\\\"6\\\",\\\"8\\\",\\\"5\\\",\\\"3\\\",\\\"7\\\",\\\"9\\\",\\\"1\\\"],[\\\"7\\\",\\\"1\\\",\\\"3\\\",\\\"9\\\",\\\"2\\\",\\\"4\\\",\\\"8\\\",\\\"5\\\",\\\"6\\\"],[\\\"9\\\",\\\"6\\\",\\\"1\\\",\\\"5\\\",\\\"3\\\",\\\"7\\\",\\\"2\\\",\\\"8\\\",\\\"4\\\"],[\\\"2\\\",\\\"8\\\",\\\"7\\\",\\\"4\\\",\\\"1\\\",\\\"9\\\",\\\"6\\\",\\\"3\\\",\\\"5\\\"],[\\\"3\\\",\\\"4\\\",\\\"5\\\",\\\"2\\\",\\\"8\\\",\\\"6\\\",\\\"1\\\",\\\"7\\\",\\\"9\\\"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： \",\"提示：\",\"board.length == 9\",\"board[i].length == 9\",\"board[i][j] 是一位数字或者 '.'\",\"题目数据 保证 输入数独仅有一个解\"]},\"217\":{\"h\":\"思路分析\",\"t\":[\"该题与N皇后的区别就是：\",\"N皇后是每一行只填充一个数，对于数独来说，所有的行和列都要填充。因此我们要用双层 for 循环遍历所有的行 和 列。\",\"返回值及参数\",\"返回值仍然为boolean类型，找到一种填充结果就返回\",\"public boolean backtracking(char[][] board) {} \",\"终止条件\",\"对于该题来说没有终止条件，遍历完所有的行和列就算完成递归。\",\"单层递归逻辑\",\"使用双层 for 循环遍历所有的行和列，逐个对 1~9个数字进行校验是否冲突并填入。\",\"而当 这9个数字都试过来之后，仍然没有填充结果，就返回 false，这也是没有终止条件而不陷入无线循环的原因。\",\" for (int row = 0; row < board.length; row++) { for (int col = 0; col < board[col].length; col++) { if (board[row][col] == '.') continue; for (char k = '1'; k <= '9';k++){// 遍历1~9个数，逐渐增加到board中 if (!isValid(row,col,k,board)){ board[row][col] = k; if (backtracking(board)) return true; board[row][col] = '.'; // 回溯 } } // 若9个数都试完了，都不行，就返回false return false; } } \",\"校验冲突\",\"同一行、同一列、3*3方格内均不能有重复的数字\",\"private boolean isValid(int row, int col, char k, char[][] board) { // 判断行 for (int i = 0; i < row; i++) { if (board[i][col] == k) return true; } // 判断列 for (int i = 0; i < row; i++) { if (board[row][i] == k) return true; } // 判断3*3方格内 int startRow = (row / 3) * 3; // 起始行 int startCol = (col / 3) * 3; // 起始列 for (int i = startRow; i < startRow+3; i++) { for (int j = startCol; j < startCol + 3; j++) { if (board[i][j] == 'k') return true; } } return false; } \",\"完整代码\",\"class Solution { public void solveSudoku(char[][] board) { backtracking(board); } public boolean backtracking(char[][] board) { // 由于我们需要遍历board所有位置，遍历完意味着结束递归，因此不需要返回值 // row表示行 col表示列,遍历完即结束递归 for (int row = 0; row < 9; row++) { for (int col = 0; col < 9; col++) { // 当前位置已有数字，跳过当前循环 if (board[row][col] != '.') continue; for (char k = '1'; k <= '9';k++){// 遍历1~9个数，逐渐增加到board中 if (!isValid(row,col,k,board)){ board[row][col] = k; if (backtracking(board)) return true; board[row][col] = '.'; // 回溯 } } // 若9个数都试完了，都不行，就返回false return false; } } return true; } // 判断是否冲突 private boolean isValid(int row, int col, char k, char[][] board) { // 判断行 for (int i = 0; i < 9; i++) { if (board[row][i] == k) return true; } // 判断列 for (int i = 0; i < 9; i++) { if (board[i][col] == k) return true; } // 判断3*3方格内 int startRow = (row / 3) * 3; // 起始行 int startCol = (col / 3) * 3; // 起始列 for (int i = startRow; i < startRow+3; i++) { for (int j = startCol; j < startCol + 3; j++) { if (board[i][j] == k) return true; } } return false; } } \"]},\"218\":{\"h\":\"总结\",\"t\":[\"回溯是递归的副产品，只要有递归就会有回溯，递归之前做了什么，递归之后就做相反的操作，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。\",\"回溯算法并不是什么高效的算法，就相当于是暴力搜索，最多在剪枝一下。\",\"对于回溯类型的题目：\",\"组合问题：N个数里面按一定规则找出k个数的集合\",\"排列问题：N个数按一定规则全排列，有几种排列方式\",\"切割问题：一个字符串按一定规则有几种切割方式\",\"子集问题：一个N个数的集合里有多少符合条件的子集\",\"棋盘问题：N皇后，解数独等等\",\"而对于以上的问题，经常遇到的去重问题：\",\"对于去重问题，能先排序就先排序，然后利用前后元素比较进行去重，比如：组合II，子集II\",\"而对于全排列问题和递增子序列问题，没有办法进行排序，就可以考虑使用一种数据结构进行标记。如比：used数组、set集合\"]},\"219\":{\"c\":[\"算法\"]},\"220\":{\"c\":[\"回溯\"]},\"221\":{\"h\":\"图论\"},\"222\":{\"h\":\"dfs 和 bfs 的区别\",\"t\":[\"深度优先遍历(dfs): 顺着一个方向遍历，就像是不到黄河不回头，直到没有元素了，再换另一个方向继续遍历。\",\"广度优先遍历(bfs): 先遍历与本节点连接的所有节点，然后在遍历与下一个节点相连接的所有节点\",\"其实dfs就是回溯，当遍历到头时，就需要回溯换另一个方向继续遍历。在二叉树中的递归遍历其实就是 dfs，而迭代遍历就是 bfs。\",\"下面通过俩张动图，体会一下dfs和bfs的区别：\",\"dfs：\",\"dfs\",\"从上面的动态图中可以看出，每次向下搜索都是递归的过程，而 '换方向' 拿图中来说，从 5 换到了 2 就是回溯的过程，因此递归 和回溯 是相辅相成的。\",\"再来回顾一下回溯算法的代码模板：\",\"在回溯章节中，已经练习了大量的回溯算法，一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。\",\"List<List<String>> res = new ArrayList<>(); List<String> path = new ArrayList<>(); void dfs(参数){ if (终止条件){ 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } } \",\"bfs:\",\"BFS是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。\",\"从某一个节点开始，先将该节点的上下左右四个方向的节点搜索出来，然后继续遍历下一个节点。\",\"bfs\",\"通常在 bfs 中需要使用一个容器来保存节点用来遍历。这个容器可以使用栈、队列、数组。\",\"在这里我使用队列，这样遍历不用考虑遍历顺序的问题。用栈的话还要考虑先进后出的顺序。\",\"除了容器之外，还需要一个 数组 用来记录当前节点是否被访问过，在 dfs 中不需要是因为在搜索的过程中，每个节点在被访问时就被标记为已访问，而在回溯时会将标记清除，这样每个节点都只会被访问一次\",\"总结起来，bfs做的步骤就是：入队 - 标记 - 出队 - 入队 - 标记.....\"]},\"223\":{\"h\":\"\",\"t\":[\"给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\",\"graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。\",\"示例 1：\",\"img\",\"输入：graph = [[1,2],[3],[3],[]] 输出：[[0,1,3],[0,2,3]] 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3 \",\"示例 2：\",\"img\",\"输入：graph = [[4,3,1],[3,2,4],[3],[4],[]] 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] \",\"提示：\",\"n == graph.length\",\"2 <= n <= 15\",\"0 <= graph[i][j] < n\",\"graph[i][j] != i（即不存在自环）\",\"graph[i] 中的所有元素 互不相同\",\"保证输入为 有向无环图（DAG）\"]},\"224\":{\"h\":\"思路分析\",\"t\":[\"dfs版本\",\"在上面已经说过了，dfs就可以看做是回溯算法！因此我们直接套用回溯算法模板！\",\"首先定义俩个集合，一个保存每一条路径，一个保存所有的路径\",\"List<List<Integer>> allPath = new ArrayList<>(); List<Integer> path = new ArrayList<>(); \",\"确定返回值及参数\",\"void dfs(graph,node) \",\"终止条件\",\"当前遍历的节点值等于图中最后一个元素值，就说明找到一条路径\",\"if (node == graph.length()-1){ allPath.add(path) return } \",\"单层递归逻辑\",\"当前结点为 node，那么要找到与node相连接的下一个节点，则 graph[node] 就是与node所有相连的节点列表。\",\"逐个将它加到path集合中，并往下递归，递归之后要进行回溯。每一次递归结束说明找到了一条路径。因此要回溯到上一个结点继续搜索\",\" // graph[node] 表示所有与node相连的节点列表 for (int i = 0; i < graph[node].length; i++) { path.add(graph[node][i]); dfs(graph,graph[node][i]); // 递归，继续找与graph[node][i]相连的节点 // 回溯：递归之前做了什么递归之后就要回溯 path.remove(path.size()-1); } \",\"完整代码\",\"class Solution { List<List<Integer>> allPath = new ArrayList<>(); List<Integer> path = new ArrayList<>(); public List<List<Integer>> allPathsSourceTarget(int[][] graph) { path.add(0); // 不要忘记将0结点加入到路径当中 dfs(graph,0); return allPath; } void dfs(int[][] graph,int node){ if (node == graph.length-1) { // 说明找到了一条路径 allPath.add(new ArrayList(path)); return; } // graph[node] 表示所有与node相连的节点列表 for (int i = 0; i < graph[node].length; i++) { path.add(graph[node][i]); dfs(graph,graph[node][i]); // 递归，继续找与graph[node][i]相连的节点 // 回溯：递归之前做了什么递归之后就要回溯 path.remove(path.size()-1); } } } \"]},\"225\":{\"h\":\"\",\"t\":[\"给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\",\"岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\",\"此外，你可以假设该网格的四条边均被水包围。\",\"示例 1：\",\"输入：grid = [ [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"], [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"] ] 输出：1 \",\"示例 2：\",\"输入：grid = [ [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"], [\\\"0\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\"], [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"1\\\",\\\"1\\\"] ] 输出：3 \",\"提示：\",\"m == grid.length\",\"n == grid[i].length\",\"1 <= m, n <= 300\",\"grid[i][j] 的值为 '0' 或 '1'\"]},\"226\":{\"h\":\"思路分析\",\"t\":[\"dfs\",\"遍历数组，如果当前值为1，将岛屿数量+1，并且进入到 感染函数里。\",\"感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。\",\"class Solution { public int numIslands(char[][] grid) { int landNums = 0; // 岛屿数量 for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[i].length; j++) { if (grid[i][j] == '1') { landNums++; infect(grid, i, j); } } } return landNums; } // 感染函数，目的就是将相连的岛屿进行标记，避免重复计算 private void infect(char[][] grid, int i, int j) { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') { return; } // 标记当前陆地 grid[i][j] = '2'; infect(grid, i + 1, j); infect(grid, i - 1, j); infect(grid, i, j + 1); infect(grid, i, j - 1); } } \",\"bfs\",\" public int numIslandsBFS(char[][] grid) { int landNums = 0; // 岛屿数量 visited = new boolean[grid.length][grid[0].length]; for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[i].length; j++) { if (grid[i][j] == '1' && !visited[i][j]) { landNums++; infectBFS(grid, i, j); } } } return landNums; } // 标记是否被访问 boolean[][] visited; // 上下左右四个方向 int[][] move = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // bfs 感染函数 public void infectBFS(char[][] grid, int i, int j) { Queue<int[]> queue = new ArrayDeque<>(); // 入队 queue.offer(new int[]{i, j}); // 标记 visited[i][j] = true; while(!queue.isEmpty()) { // 出队 int[] poll = queue.poll(); int x = poll[0]; int y = poll[1]; // 向四个方向移动 for (int k = 0; k < 4; k++) { int nextX = x + move[k][0]; int nextY = y + move[k][1]; // 下标越界，跳过 if (nextX < 0 || nextX >= grid.length || nextY <0 || nextY >= grid[0].length) continue; if (!visited[nextX][nextY] && grid[nextX][nextY] == '1') { queue.offer(new int[]{nextX, nextY}); visited[nextX][nextY] = true; } } } } \"]},\"227\":{\"h\":\"\",\"t\":[\"给你一个大小为 m x n 的二进制矩阵 grid 。\",\"岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\",\"岛屿的面积是岛上值为 1 的单元格的数目。\",\"计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。\",\"示例 1：\",\"img\",\"输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 输出：6 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。 \",\"示例 2：\",\"输入：grid = [[0,0,0,0,0,0,0,0]] 输出：0 \",\"提示：\",\"m == grid.length\",\"n == grid[i].length\",\"1 <= m, n <= 50\",\"grid[i][j] 为 0 或 1\"]},\"228\":{\"h\":\"思路分析\",\"t\":[\"和200. 岛屿数量一样，只不过在每次 \\\"感染\\\" 陆地时，记录一下陆地的数量。\",\"dfs\",\" int area = 0; public int maxAreaOfIsland(int[][] grid) { int maxArea = 0; for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[i].length; j++) { if (grid[i][j] == 1) { // 记录每块陆地的面积 area = 0; infect(grid,i,j); // 记录最大面积 maxArea = Math.max(maxArea,area); } } } return maxArea; } // dfs 感染函数: 将每块陆地 \\\"感染\\\"，避免重复计算 public void infect(int[][] grid, int x, int y) { if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] != 1) return; grid[x][y] = 2; area++; // 将当前陆地的面积+1 infect(grid, x + 1, y); infect(grid, x - 1, y); infect(grid, x, y - 1); infect(grid, x, y + 1); } \",\"bfs\",\" boolean[][] visited; int[][] move = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int area = 0; public int maxAreaOfIslandBFS(int[][] grid) { visited = new boolean[grid.length][grid[0].length]; int maxArea = 0; for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[i].length; j++) { if (grid[i][j] == 1 && !visited[i][j]) { area = 0; infectBFS(grid,i,j); // 记录最大面积 maxArea = Math.max(maxArea,area); } } } return maxArea; } // bfs public void infectBFS(int[][] grid, int x, int y) { Queue<int[]> queue = new ArrayDeque<>(); queue.offer(new int[]{x,y}); visited[x][y] = true; area++; while(!queue.isEmpty()) { int[] poll = queue.poll(); int i = poll[0]; int j = poll[1]; for (int k = 0; k < 4; k++) { int nextX = i + move[k][0]; int nextY = j + move[k][1]; if (nextX < 0 || nextY < 0 || nextX > grid.length || nextY >= grid[0].length ) continue; if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) { area++; queue.offer(new int[]{nextX, nextY}); visited[nextX][nextY] = true; } } } } \"]},\"229\":{\"h\":\"\",\"t\":[\"给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。\",\"一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。\",\"返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。\",\"示例 1：\",\"img\",\"输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 \",\"示例 2：\",\"img\",\"输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 \",\"提示：\",\"m == grid.length\",\"n == grid[i].length\",\"1 <= m, n <= 500\",\"grid[i][j] 的值为 0 或 1\"]},\"230\":{\"h\":\"思路分析\",\"t\":[\"题目要求不与边界相连的陆地单元格的数量，那么我们应该利用 \\\"感染\\\" 函数将边界陆地都 \\\"感染\\\" 为海洋，然后在统计陆地单元格的数量\",\"dfs\",\"class Solution { public int numEnclaves(int[][] grid) { int rowLength = grid.length; int colLength = grid[0].length; for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { // 将靠近边界的陆地都变成海洋 if ((i == 0 || j == 0 || i == rowLength - 1 || j == colLength - 1) && grid[i][j] == 1) infect(grid, i, j); } } int landNums = 0; // 统计陆地单元格的数量 for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { if (grid[i][j] == 1) landNums++; } } return landNums; } // 感染函数 public void infect(int[][] grid, int x, int y) { if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] == 0) return; // 将陆地变成海洋 grid[x][y] = 0; infect(grid, x - 1, y); infect(grid, x + 1, y); infect(grid, x, y - 1); infect(grid, x, y + 1); } } \",\"bfs\",\"这道题无需使用 visited 数组，不关心他是否重复访问，只要将边界的陆地变为海洋即可。\",\"class Solution { int[][] move = {{0,1},{0,-1},{1,0},{-1,0}}; public int numEnclaves(int[][] grid) { int rowLength = grid.length; int colLength = grid[0].length; for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { // 将靠近边界的陆地都变成海洋 if ((i == 0 || j == 0 || i == rowLength - 1 || j == colLength - 1) && grid[i][j] == 1 ) infectBFS(grid, i, j); } } int landNums = 0; // 统计陆地单元格的数量 for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { if (grid[i][j] == 1) landNums ++; } } return landNums; } public void infectBFS(int[][] grid, int x, int y){ Queue<int[]> queue = new ArrayDeque<>(); queue.offer(new int[]{x,y}); grid[x][y] = 0; while(!queue.isEmpty()) { int[] poll = queue.poll(); int m = poll[0]; int n = poll[1]; // 遍历四个方向 for (int i = 0; i < 4; i++) { int nextX = m + move[i][0]; int nextY = n + move[i][1]; if (nextX < 0 || nextY < 0 || nextX >= grid.length || nextY >= grid[nextX].length ) continue; if (grid[nextX][nextY] == 1) { queue.offer(new int[]{nextX,nextY}); grid[nextX][nextY] = 0; } } } } } \"]},\"231\":{\"h\":\"\",\"t\":[\"给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。\",\"示例 1：\",\"img\",\"输入：board = [[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]] 输出：[[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]] 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 \",\"示例 2：\",\"输入：board = [[\\\"X\\\"]] 输出：[[\\\"X\\\"]] \",\"提示：\",\"m == board.length\",\"n == board[i].length\",\"1 <= m, n <= 200\",\"board[i][j] 为 'X' 或 'O'\"]},\"232\":{\"h\":\"思路分析\",\"t\":[\"和 1020. 飞地的数量 思路一样，先将与边界相连的陆地，也就是O变成另外一个字符，比如我变成 A。遍历数组，将O变成X，将A变成O\",\"dfs\",\"class Solution { public void solve(char[][] board) { int rowLength = board.length; int colLength = board[0].length; for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { // 将靠近边界的O都改为A if ((i == 0 || j == 0 || i == rowLength - 1 || j == colLength - 1) && (board[i][j] == 'O') ) infect(board, i, j); } } // 将图中的O改为X，A改为A for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; if (board[i][j] == 'A') board[i][j] = 'O'; } } } // 感染函数 public void infect(char[][] board, int x, int y) { if (x < 0 || y < 0 || x >= board.length || y >= board[x].length || board[x][y] == 'A' ||board[x][y] == 'X' ) return; board[x][y] = 'A'; infect(board, x - 1, y); infect(board, x + 1, y); infect(board, x, y - 1); infect(board, x, y + 1); } } \",\"bfs\",\"class Solution { int[][] move = {{0,1},{0,-1},{1,0},{-1,0}}; public void solve(char[][] board) { int rowLength = board.length; int colLength = board[0].length; for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { // 将靠近边界的O都改为A if ((i == 0 || j == 0 || i == rowLength - 1 || j == colLength - 1) && board[i][j] == 'O') infectBFS(board, i, j); } } // 将图中的O改为X，A改为A for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; if (board[i][j] == 'A') board[i][j] = 'O'; } } } public void infectBFS(char[][] board, int x, int y){ Queue<int[]> queue = new ArrayDeque<>(); queue.offer(new int[]{x,y}); board[x][y] = 'A'; while(!queue.isEmpty()) { int[] poll = queue.poll(); int m = poll[0]; int n = poll[1]; // 遍历四个方向 for (int i = 0; i < 4; i++) { int nextX = m + move[i][0]; int nextY = n + move[i][1]; if (nextX < 0 || nextY < 0 || nextX >= board.length || nextY >= board[nextX].length || board[nextX][nextY] == 'X') continue; if ( board[nextX][nextY] == 'O' ) { queue.offer(new int[]{nextX,nextY}); board[nextX][nextY] = 'A'; } } } } } \"]},\"233\":{\"h\":\"\",\"t\":[\"有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。\",\"这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。\",\"岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\",\"返回网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。\",\"示例 1：\",\"img\",\"输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] 输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] \",\"示例 2：\",\"输入: heights = [[2,1],[1,2]] 输出: [[0,0],[0,1],[1,0],[1,1]] \",\"提示：\",\"m == heights.length\",\"n == heights[r].length\",\"1 <= m, n <= 200\",\"0 <= heights[r][c] <= 105\"]},\"234\":{\"h\":\"思路分\",\"t\":[\"该题目求：大西洋和太平洋都能够到达的坐标\",\"我们可以逆向分析，先从太平洋出发找到能够到达的坐标，将其标记，然后再从大西洋出发找到能够到达的坐标，将其标记。\",\"同时被标记的就是都能够到达的坐标\",\"dfs\",\"class Solution { int[][] move = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int rowLength, colLength; public List<List<Integer>> pacificAtlantic(int[][] heights) { List<List<Integer>> res = new ArrayList<>(); rowLength = heights.length; colLength = heights[0].length; // 保存太平洋可以到达的地点 boolean[][] pacific = new boolean[rowLength][colLength]; // 保存大西洋可以到达的地点 boolean[][] atlantic = new boolean[rowLength][colLength]; for (int i = 0; i < rowLength; i++) { infect(heights, i, 0, pacific); // 左边界 infect(heights, i, colLength - 1, atlantic);// 右边界 } for (int i = 0; i < colLength; i++) { infect(heights, 0, i, pacific); // 上边界 infect(heights, rowLength - 1, i, atlantic); // 下边界 } for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { if (atlantic[i][j] && pacific[i][j]) { // 大西洋、太平洋同时可以到达的地点 ArrayList<Integer> list = new ArrayList<>(); list.add(i); list.add(j); res.add(list); } } } return res; } // 感染函数 public void infect(int[][] heights, int x, int y, boolean[][] ocean) { // 地点已被标记,结束递归 if (ocean[x][y]) return; ocean[x][y] = true; for (int i = 0; i < 4; i++) { int nextX = x + move[i][0]; int nextY = y + move[i][1]; // 边界条件， // heights[x][y]当前单元格高度 // heights[nextX][nextY] 相连单元格高度 // 如果相连的单元格高度小于当前单元格高度，说明它到不了当前单元格(因为是由低->高)，因此跳过！ if (nextX < 0 || nextY < 0 || nextX >= rowLength || nextY >= colLength || heights[x][y] > heights[nextX][nextY]) continue; infect(heights, nextX, nextY, ocean); } } } \"]},\"235\":{\"c\":[\"算法\"]},\"236\":{\"c\":[\"图论\"]},\"237\":{\"h\":\"字符串\"},\"238\":{\"h\":\"双指针系列\"},\"239\":{\"h\":\"\",\"t\":[\"LeetCode题解\"]},\"240\":{\"h\":\"\",\"t\":[\"给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\",\"以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\",\"你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\",\"你所设计的解决方案必须只使用常量级的额外空间。\",\"示例 1：\",\"输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 \",\"示例 2：\",\"输入：numbers = [2,3,4], target = 6 输出：[1,3] 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。 \",\"示例 3：\",\"输入：numbers = [-1,0], target = -1 输出：[1,2] 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 \",\"提示：\",\"2 <= numbers.length <= 3 * 104\",\"-1000 <= numbers[i] <= 1000\",\"numbers 按 非递减顺序 排列\",\"-1000 <= target <= 1000\",\"仅存在一个有效答案\"]},\"241\":{\"h\":\"思路分析\",\"t\":[\"根据题目可知：\",\"numbers 是一个升序数组\",\"仅有一个有效答案\",\"下标从 1 开始\",\"该题目完全可以利用双指针的方法，首尾开始遍历。\",\"假设left指向首元素，right指向尾元素\",\"如果 $numbers [left] + numbers [right] < target $ , 说明当前数太小，将 left指针右移，相反如果大于，则将 right--\",\"相等则保存 left、right指针在数组中，并返回。返回时不要忘记将 left、right 加 1，因为下标从 1开始\"]},\"242\":{\"h\":\"代码实现\",\"t\":[\" public static int[] twoSum(int[] numbers, int target) { int left = 0; int right = numbers.length -1; int[] ints = new int[2]; while (left < right) { if (numbers[left] + numbers[right] > target){ right--; }else if (numbers[left] + numbers[right] < target){ left ++; }else { ints[0] = left+1; ints[1] = right+1; break; }; } return ints; } \"]},\"243\":{\"h\":\"反转字符串系列\"},\"244\":{\"h\":\"\",\"t\":[\"给你一个字符串 s ，请你反转字符串中 单词 的顺序。\",\"单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\",\"返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\",\"**注意：**输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\",\"示例 1：\",\"输入：s = \\\"the sky is blue\\\" 输出：\\\"blue is sky the\\\" \",\"示例 2：\",\"输入：s = \\\" hello world \\\" 输出：\\\"world hello\\\" 解释：反转后的字符串中不能存在前导空格和尾随空格。 \",\"示例 3：\",\"输入：s = \\\"a good example\\\" 输出：\\\"example good a\\\" 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 \",\"提示：\",\"1 <= s.length <= 104\",\"s 包含英文大小写字母、数字和空格 ' '\",\"s 中 至少存在一个 单词\"]},\"245\":{\"h\":\"思路分析\",\"t\":[\"在Java中提供了很多对字符串操作的API，可以直接使用API进行其操作\",\" public static String reverseWords(String s) { // 先去掉首尾空格 s = s.trim(); // \\\\s+ 可以匹配一个或者多个空字符 List<String> wordList = Arrays.asList(s.split(\\\"\\\\\\\\s+\\\")); // 进行反转 Collections.reverse(wordList); // 每个单词后边增加空格 return String.join(\\\" \\\", wordList); } \",\"第二种方法：双指针\",\"俩个指针倒序遍历字符串，遇到空格停止，然后截取字符串，并将单词放到 res 集合中\",\"image-20230927214123859\",\"、跳过单词间的所有空格，将 j 重新指向下一个单词的尾部\",\"img\",\"重复上面操作，直到 i 指针跳出循环\",\"img\",\" public static String reverseWords(String s) { // 先去掉首尾空格 s = s.trim(); // 将俩个指针指向尾部 int i = s.length()-1; int j = i; ArrayList<String> res = new ArrayList<>(); while (i >= 0) { // 遇到空格停止 while(i >= 0 && s.charAt(i) != ' ') i--; // 截取单词并加入到集合中 res.add( s.substring(i+1,j+1)); // 跳过空格 while(i >=0 && s.charAt(i) == ' ') i--; j = i; } return String.join(\\\" \\\",res); } \"]},\"246\":{\"h\":\"\",\"t\":[\"给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\",\"示例 1：\",\"输入：s = \\\"Let's take LeetCode contest\\\" 输出：\\\"s'teL ekat edoCteeL tsetnoc\\\" \",\"示例 2:\",\"输入： s = \\\"God Ding\\\" 输出：\\\"doG gniD\\\" \",\"****提示：******\",\"1 <= s.length <= 5 * 104\",\"s 包含可打印的 ASCII 字符。\",\"s 不包含任何开头或结尾空格。\",\"s 里 至少 有一个词。\",\"s 中的所有单词都用一个空格隔开。\"]},\"247\":{\"h\":\"思路分析\",\"t\":[\"利用Java中的API，先分割，在反转，在组合\"]},\"248\":{\"h\":\"代码实现\",\"t\":[\" public String reverseWords(String s) { String[] split = s.split(\\\"\\\\\\\\s+\\\"); for (int i = 0; i < split.length; i++) { split[i] = new StringBuilder(split[i]).reverse().toString(); } return String.join(\\\" \\\",split); } \"]},\"249\":{\"h\":\"\",\"t\":[\"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\"不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\",\"示例 1：\",\"输入：s = [\\\"h\\\",\\\"e\\\",\\\"l\\\",\\\"l\\\",\\\"o\\\"] 输出：[\\\"o\\\",\\\"l\\\",\\\"l\\\",\\\"e\\\",\\\"h\\\"] \",\"示例 2：\",\"输入：s = [\\\"H\\\",\\\"a\\\",\\\"n\\\",\\\"n\\\",\\\"a\\\",\\\"h\\\"] 输出：[\\\"h\\\",\\\"a\\\",\\\"n\\\",\\\"n\\\",\\\"a\\\",\\\"H\\\"] \",\"提示：\",\"1 <= s.length <= 105\",\"s[i] 都是 ASCII 码表中的可打印字符\"]},\"250\":{\"h\":\"\",\"t\":[\"题目要求，不允许使用额外数组，要原地修改。这就需要我们使用到双指针的思想：\",\"双指针情形一: 指针向中间或两端移动，移动方向始终相对\",\"双指针情形二： 指针向同侧移动，形成前后指针或快慢指针\",\"此道题目很明显是情形一，我们需要使用俩个指针，然后将指向的元素交换并移动，直到相遇为止\",\"2.gif\"]},\"251\":{\"h\":\"代码实现\",\"t\":[\" public static void reverseString(char[] s) { // 定义双指针 int left = 0; int right = s.length -1 ; while(left <= right) { // 将left与right指向的元素交换 char temp = s[left]; s[left] = s[right]; s[right] = temp; // 移动指针 left++; right--; } } \"]},\"252\":{\"h\":\"\",\"t\":[\"给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\",\"如果剩余字符少于 k 个，则将剩余字符全部反转。\",\"如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\",\"示例 1：\",\"输入：s = \\\"abcdefg\\\", k = 2 输出：\\\"bacdfeg\\\" \",\"示例 2：\",\"输入：s = \\\"abcd\\\", k = 2 输出：\\\"bacd\\\" \"]},\"253\":{\"h\":\"思路分析\",\"t\":[\"假设字符串的长度为 n:\",\"如果 k <= n < 2k , 就反转 前k个字符\",\"如果 n < k , 就反转n个字符\",\"所以在遍历字符串时，只需要每次移动 2k 个位置，找到反转字符串的起始点，判断该起始点与 n 的长度即可。\"]},\"254\":{\"h\":\"代码实现\",\"t\":[\" public static String reverseStr(String s, int k) { int n = s.length(); char[] chars = s.toCharArray(); // 每次都从 2k 的下标开始，如果长度不足k则全部翻转，否则翻转前k个字符 for (int i = 0; i < chars.length; i+= 2*k) { // 如果长度满足k个长度，结束下标就为 i+k // 否则就反转全部字符串，结束下标为 n reverse(chars,i,Math.min(i+k,n)-1); } return new String(chars); } public static void reverse(char[] chars, int left, int right) { while(left < right) { char temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left++; right++; } \"]},\"255\":{\"h\":\"\",\"t\":[\"某公司门禁密码使用动态口令技术。初始密码为字符串 password，密码更新均遵循以下步骤：\",\"设定一个正整数目标值 target\",\"将 password 前 target 个字符按原顺序移动至字符串末尾\",\"请返回更新后的密码字符串。\",\"示例 1：\",\"输入: password = \\\"s3cur1tyC0d3\\\", target = 4 输出: \\\"r1tyC0d3s3cu\\\" \",\"示例 2：\",\"输入: password = \\\"lrloseumgh\\\", target = 6 输出: \\\"umghlrlose\\\" \",\"提示：\",\"1 <= target < password.length <= 10000\"]},\"256\":{\"h\":\"思路分析\",\"t\":[\"如果不要求空间复杂度的话，极简版：\",\" public static String dynamicPassword(String password, int target) { // 截取移动后边的字符串 String substring = password.substring(target); // 截取移动的字符串 String front = password.substring(0, target); return substring + front; } \",\"如果要求只能在源字符串上进行修改呢？要求时间复杂度为 O(1)\",\"可以采用多次反转，第一次反转 0~target ，第二次反转 target~ n(n为字符串长度) ，第三次反转整个字符串！\",\"image-20231017222624936\",\" // 如果要求空间复杂度为O(1) public static String dynamicPassword1(String password, int target) { char[] arr = password.toCharArray(); // 第一次反转，0~target reverse(arr,0,target-1); // 第二次反转，target~n reverse(arr,target,password.length()-1); // 第三次反转，整个字符串 reverse(arr,0,password.length()-1); return new String(arr); } // 反转函数 public static void reverse(char[] arr,int left,int right) { while(left < right) { char temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; left++; right--; } } \"]},\"257\":{\"h\":\"\",\"t\":[\"给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。\",\"返回该 最大总和 。\",\"示例 1：\",\"输入：nums = [1,4,3,2] 输出：4 解释：所有可能的分法（忽略元素顺序）为： 1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4 所以最大总和为 4 \",\"示例 2：\",\"输入：nums = [6,2,6,5,1,2] 输出：9 解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9 \",\"提示：\",\"1 <= n <= 104\",\"nums.length == 2 * n\",\"-104 <= nums[i] <= 104\"]},\"258\":{\"h\":\"思路分析\",\"t\":[\"题目要求 求得每俩个元素的最小值加起来的和最大。\",\"那么就尽可能的让俩个元素的最小值较大，也就是较小元素和较小元素组合，较大元素和较大元素组合。\",\"因此我们可以先升序，然后每俩个元素组合在一起\"]},\"259\":{\"h\":\"代码实现\",\"t\":[\" public static int arrayPairSum(int[] nums) { Arrays.sort(nums); int sum = 0; for (int i = 0; i < nums.length; i+=2) { sum += Math.min(nums[i], nums[i+1]); } return sum; } \"]},\"260\":{\"h\":\"\",\"t\":[\"给你一个字符串 s，找到 s 中最长的回文子串。\",\"如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\",\"示例 1：\",\"输入：s = \\\"babad\\\" 输出：\\\"bab\\\" 解释：\\\"aba\\\" 同样是符合题意的答案。 \",\"示例 2：\",\"输入：s = \\\"cbbd\\\" 输出：\\\"bb\\\" \",\"提示：\",\"1 <= s.length <= 1000\",\"s 仅由数字和英文字母组成\"]},\"261\":{\"h\":\"思路分析\",\"t\":[\"像这种求最值问题基本都可以利用 动态规划 来求解，此题也不例外。\",\"**定义dp数组及下标含义: **\",\"dp[i][j] : 表示 s 串在下标 i 和 j区间内是否是回文子串\",\"确定递推公式\",\"s[i] 与 s[j] 无非就有俩种情况，相等或者不相等\",\"s[i] != s[j] ,那么 dp[i][j] = false, 这个无需考虑\",\"s[i] == s[j] ，有以下几种情况： \",\"i == j 说明指向同一个字符，那肯定是回文子串\",\"i - j == 1, 也就是 i 和 j相差一个字符，并且 s[i] == s[j] 还想等，那么 i ~ j 也是回文子串，例如： aba\",\"i - j > 1,若是相差多个字符，就需要判断 $S[i+1 , j-1] $ 是否是回文子串了，例如：wttw，子串 tt 是回文子串，那么 wttw 很明显也是，因为首尾元素相等\",\"因此 $ S[i] == S[j]$ 一共有俩种情况： $$ \\\\left{ \\\\begin{matrix} j - i <= 1 , true \\\\ dp[i+1 , j-1] , true \\\\end{matrix} \\\\right. $$ 遍历顺序\",\"如下图所示，由于我们要得到$ dp[i][j]$ ,是通过计算 $dp[i+1 , j-1] $ 而来，因此循环应该从下到上，从左到右\",\"image-20230925231243004\",\"更新回文子串\",\"再循环的过程中，要不断更新回文子串的长度\"]},\"262\":{\"h\":\"代码实现\",\"t\":[\" public String longestPalindrome(String s) { int length = s.length(); // dp数组，初始为 false // 保存 i~j 是否为回文子串 boolean[][] dp = new boolean[length][length]; // 保存回文子串 String res = \\\"\\\"; // 从下到上，从左到右 for (int i = length; i >=0; i--) { for (int j = i; j < length; j++) { // 是回文子串的俩种情况 if (s.charAt(i) == s.charAt(j) && (j-i < 2 || dp[i+1][j-1])) { dp[i][j] = true; } // 不断更新回文子串 if (dp[i][j] && (j-i+1) > res.length()) { res = s.substring(i,j+1); } } } return res; } \"]},\"263\":{\"c\":[\"算法\"]},\"264\":{\"c\":[\"字符串\",\"滑动窗口\"]},\"265\":{\"h\":\"数组\"},\"266\":{\"h\":\"217 存在重复元素\",\"t\":[\"给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。\",\"示例 1：\",\"输入：nums = [1,2,3,1] 输出：true \",\"示例 2：\",\"输入：nums = [1,2,3,4] 输出：false \",\"示例 3：\",\"输入：nums = [1,1,1,3,3,4,3,2,4,2] 输出：true \"]},\"267\":{\"h\":\"思路分析\",\"t\":[\"题比较简单，实现思路也有很多。\",\"可以转换成一个 Set 集合，因为 set 集合是不重复的。通过对比转换前后的长度就可以得知是否重复\",\"也可以先对数组进行排序，重复的肯定是相邻的俩个数，挨个比对判断就行了。\",\"使用 Jdk8 中 的 Stream流，通过去重操作，然后收集去重后的数据，比对长度即可。\"]},\"268\":{\"h\":\"代码实现\",\"t\":[\"由于题比较简单，就写出第三种方式的代码。\",\" /* * 利用JDK8的新特性,对nums数组进行去重操作，统计去重后数组的长度 * 比原来数组小就说明有重复的，反之则没有 * */ public static boolean containsDuplicate(int[] nums) { long count = Arrays.stream(nums).distinct().count(); return !(count == nums.length); } \"]},\"269\":{\"h\":\"704 二分查找\",\"t\":[\"给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\",\"示例 1:\",\"输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 \",\"示例 2:\",\"输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 \",\"提示：\",\"你可以假设 nums 中的所有元素是不重复的。\",\"n 将在 [1, 10000]之间。\",\"nums 的每个元素都将在 [-9999, 9999]之间。\"]},\"270\":{\"h\":\"思路分析\",\"t\":[\"二分查找是一个简单，但是一个非常经典的搜索算法，但是经常会将 while 条件搞混，例如到底是 while(left < right) 还是 while(left <= right)，到底是right = middle呢，还是要right = middle - 1呢？\",\"混淆的原因主要是区间没有定义好，在二分查找中一般有俩个常用的区间:\",\"左闭右闭 ：[ left, right ]\",\"左闭右开 : [ left, right )\"]},\"271\":{\"h\":\"代码实现\",\"t\":[\"第一种写法：左闭右闭\",\"确定好了左闭右闭区间，这就决定了我们如何写 while 条件以及right 的变化：\",\"while (left <= right) 要使用 <= ，因为 left == right 是有意义的，所以使用 <=\",\"if (nums[middle] > target) right = middle - 1，因为当前这个 nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\",\" // 定义区间: [left,right] public static int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 因为我们定义的是左闭右闭区间， left == right 是有意义的 while (left <= right) { // 找出中间索引 int middle = (left + right) / 2; if (nums[middle ] > target) { // 这里使用 middle-1,因为在 if 中已经判断了 middle 处的值一定不是 target // 因此在 middle-1 为终止条件 right = middle - 1; }else if (nums[middle] < target) { left = middle + 1; }else { return middle; } } return -1; } \",\"第二种：左闭右开区间\",\"while (left < right)，这里使用 < ,因为 left == right 在区间 [left, right) 是没有意义的\",\"if (nums[middle] > target) right = middle，在 if 中同样能看出，nums[middle] 一定不等于 target，因此需要从 middle -1 作为结束索引，但是在[left,middle)中，已经不包含 middle ，因此就无需 -1 。\",\" // 定义区间: [left,right) public static int search(int[] nums, int target) { int left = 0; int right = nums.length; // 因为我们定义的是左闭右开区间， left == right 是不成立的 while (left < right) { // 找出中间索引 int middle = (left + right) / 2; if (nums[middle ] > target) { // 这里使用 middle,是因为 [left,middle) 中已经不包含了 middle。 right = middle ; }else if (nums[middle] < target) { left = middle + 1; }else { return middle; } } return -1; } \"]},\"272\":{\"h\":\"相关题目\"},\"273\":{\"h\":\"35 搜索插入位置\",\"t\":[\"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\",\"请必须使用时间复杂度为 O(log n) 的算法。\",\"示例 1:\",\"输入: nums = [1,3,5,6], target = 5 输出: 2 \",\"示例 2:\",\"输入: nums = [1,3,5,6], target = 2 输出: 1 \",\"示例 3:\",\"输入: nums = [1,3,5,6], target = 7 输出: 4 \",\"提示:\",\"1 <= nums.length <= 104\",\"-104 <= nums[i] <= 104\",\"nums 为 无重复元素 的 升序 排列数组\",\"-104 <= target <= 104\",\"思路分析：\",\"在分析该题目时，不要太在意 左闭右开、左闭右闭区间 ，而是应该具体问题具体分析，根据题意确定 left、right 以及 mid 与 target的关系 的变化\",\"通过题目可以得知：要求返回第一个大于等于 target 的元素位置\",\"情况一: 如果 nums[mid] 小于 target 的值, 那么 mid 以及 mid 左边所有的位置都不符合题意。因此需要向右移动 left = mid + 1\",\"情况二：如果 nums[mid] 大于 target 的值，那么 mid 右边所有的位置肯定不符合题意，因此需要向左移动：right = mid，并且 mid 有可能是需要返回的位置， 但前提是 mid 左边的所有元素都不符合题意。也就是说 mid 左边的所有元素都小于或者不等于 target\",\"代码\",\" public static int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length; int mid = 0; while (left < right) { mid = (left + right) / 2; // 如果 nums[mid] < target 说明，mid及mid左边的所有位置都不符合题意 if (nums[mid] < target) { left = mid + 1; } else { // 相反如果等于 nums[mid] >= target, 此时说明 mid 有可能是需要返回的位置 // 但前提是 mid 左边的所有元素都不符合题意。也就是说 mid 左边的所有元素都小于或者不等于 target right = mid; } } return left; } } \",\"第二种思路：\",\"题目中重要的俩个条件：1、升序 2、无重复元素\",\"我们可以得知，在找到 target 合适的位置 i 时 ，那么它一定满足以下的条件：$ target >= nums[0]...nums[i-1]$\",\"我们就可以利用这个条件，不使用二分查找，直接使用 for 循环。\",\"代码如下：\",\" public int searchInsert(int[] nums, int target) { // 升序、无重复元素，只要某个元素大于target值，该元素的位置就是就是要返回的值 if(nums.length == 0) return -1; for (int i = 0; i < nums.length; i++) { if (nums[i] >= target) return i; } // 循环结束仍然没有位置，说明 target 在数组中是最大的，直接插入数组末尾即可。 return nums.length; } \"]},\"274\":{\"h\":\"\",\"t\":[\"你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\",\"假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\",\"你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\",\"示例 1：\",\"输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 \",\"示例 2：\",\"输入：n = 1, bad = 1 输出：1 \",\"提示：\",\"1 <= bad <= n <= 231 - 1\",\"思路分析\",\"题目要求和 35 题一样，该题是求出第一个错误版本。但是有一个小坑。\",\"int类型最大值为 2^31 - 1 , 这里如果单纯的使用: mid = (left + right) / 2; 可能会造成溢出\",\"因此使用：left + (right - left) / 2;\",\"public int firstBadVersion(int n) { int left = 1; int right = n; while(left < right) { int mid = left + (right - left) / 2; if (!isBadVersion(mid)) { // 当前mid版本没有错误，说明mid及mid之前都没有错误, left = mid + 1; }else { // 相反,mid出错，可能是mid是第一个出错的，也可能是mid前面版本出错 right = mid; } } return left; } \"]},\"275\":{\"h\":\"\",\"t\":[\"给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\",\"如果数组中不存在目标值 target，返回 [-1, -1]。\",\"你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\",\"示例 1：\",\"输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] \",\"示例 2：\",\"输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] \",\"示例 3：\",\"输入：nums = [], target = 0 输出：[-1,-1] \",\"提示：\",\"0 <= nums.length <= 105\",\"-109 <= nums[i] <= 109\",\"nums 是一个非递减数组\",\"-109 <= target <= 109\",\"思路分析\",\"第一种方法： 直接遍历\",\"第一次遍历找到第一个相等的元素下标，第二次遍历找到最后一个相等元素的下标\",\" public int[] searchRange(int[] nums, int target) { int start = -1; int end = -1; for (int i = 0; i < nums.length; i++) { if (nums[i] == target) { start = i; end = i; break; } } if (start == -1) return new int[]{start,end}; for (int i = start; i < nums.length; i++) { if (nums[i] != target) break; end++; } return new int[]{start,end}; } \",\"第二种方法：二分法\",\"通过二分法找到相等的元素后，向左继续搜索找到开始下标，向右继续搜索找到结束下标\",\"class Solution { public int[] searchRange(int[] nums, int target) { int left = 0; int right = nums.length-1; while(left<=right){ int mid = left+(right-left)/2; if(nums[mid]==target){ // 向两边扩张 int l = mid; while(l>=left&&nums[l]==target){ l--; } int r = mid; while(r<=right&&nums[r]==target){ r++; } return new int[]{++l,--r}; }else if(nums[mid]>target){ //左边 right = mid-1; }else{ left = mid+1; } } return new int[]{-1,-1}; } } \"]},\"276\":{\"h\":\"\",\"t\":[\"已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\",\"若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\",\"若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\",\"注意，数组 [a[0], a[1], a[2], ..., a[n-1]]旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\",\"给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\",\"你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\",\"示例 1：\",\"输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 \",\"示例 2：\",\"输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 \",\"示例 3：\",\"输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 \",\"提示：\",\"n == nums.length\",\"1 <= n <= 5000\",\"-5000 <= nums[i] <= 5000\",\"nums 中的所有整数 互不相同\",\"nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\",\"思路分析\",\"根据题意得知：\",\"输入数组是一个不重复的升序数组旋转 1~n 次得到的，具体旋转咱也不知道，但是不管旋转几次，肯定是有一部分是有序的，并且最小值一定是在无序的那部分上。因此可以利用二分法找无序的那一部分。\",\"$nums[mid] > nums[right]$ ， 说明最小值在右半边，舍弃左半边。即: left = mid + 1; \",\"这里为什么是 left = mid + 1;而不是 left = mid 呢？ 这是因为mid一定不是最小的，至少 nums[right] 比它小\",\"$nums[mid] <= nums[right]$ , 说明最小值在左半边，舍弃右半边，即:right = mid; \",\"这里 mid 有可能是最小值，因此保留mid的取值\",\"代码实现\",\" // 使用二分法 public int findMin1(int[] nums) { int low = 0; int high = nums.length -1 ; while (low < high) { int mid = (low + high) /2 ; if (nums[mid] < nums[high]) { // 如果中间值小于最大值，那么就抛弃右区间 high = mid; }else{ // 否则抛弃左区间 low = mid + 1; } } return nums[low]; } \",\"疑问：\",\"1、为什么要使用 $low < high$ , 使用 $low <= high$ 不行嘛？\",\"其实是可以的，但是需要多考虑一些情况，如果是 <= 的话，当 low=high时，还要执行一遍循环。\",\"如下图所示，此时 low=high，符合条件，仍需要执行一遍 low = mid - 1，此时 low = -1。所以当使用 <= 时，返回值有俩种写法：\",\"return nums[low+1]\",\"return nums[high]\",\"image-20231007220324257\"]},\"277\":{\"h\":\"\",\"t\":[\"整数数组 nums 按升序排列，数组中的值 互不相同 。\",\"在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\",\"给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\",\"你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\",\"示例 1：\",\"输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 \",\"示例 2：\",\"输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 \",\"示例 3：\",\"输入：nums = [1], target = 0 输出：-1 \",\"提示：\",\"1 <= nums.length <= 5000\",\"-104 <= nums[i] <= 104\",\"nums 中的每个值都 独一无二\",\"题目数据保证 nums 在预先未知的某个下标上进行了旋转\",\"-104 <= target <= 104\",\"思路分析\",\"题目要求 O(logN)的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。由于题目说数字了无重复，举个例子：1 2 3 4 5 6 7可以大致分为两类，\",\"第一类 2 3 4 5 6 7 1 这种，也就是 nums[left] <= nums[mid]。此例子中就是 2 <= 5。\",\"这种情况下，前半部分有序。因此如果 nums[left] <=target<nums[mid]，则在前半部分找，否则去后半部分找。\",\"第二类 6 7 1 2 3 4 5 这种，也就是 nums[left] > nums[mid]。此例子中就是 6 > 2。\",\"这种情况下，后半部分有序。因此如果 nums[mid] <target<=nums[right]，则在后半部分找，否则去前半部分找。\",\"class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] >= nums[left]) { // 中间值>最左边的值，说明左半段是有序的 if (target >= nums[left] && target < nums[mid]) { // 判断目标值在中间值的左边还是右边，以此调整left和right // 在左边，需要舍弃右边 right = mid - 1; } else { // 在右边,需要舍弃左边 left = mid + 1; } } else { // 中间值 < 最左边的值，说明右半段是有序的 if (target <= nums[right] && target > nums[mid]) { left = mid + 1; }else { right = mid - 1; } } } return -1; } } \"]},\"278\":{\"h\":\"\",\"t\":[\"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\",\"不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\",\"元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\",\"说明:\",\"为什么返回数值是整数，但输出的答案是数组呢?\",\"请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\",\"你可以想象内部操作如下:\",\"// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i < len; i++) { print(nums[i]); } \",\"示例 1：\",\"输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 \",\"示例 2：\",\"输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 \"]},\"279\":{\"h\":\"思路分析\",\"t\":[\"此题看着并不难，实际考察的是你对数据底层的一个存储原理。很多人，包括我自己，在初始认为只需要遍历数组，将指定值删除即可, 这时你就会掉入了一个误区。因为数组中的存储空间是连续的，一经开辟，是无法删除的，只能将后边的元素往前移覆盖\",\"双指针法\",\"首先需要确定是双指针的含义（一般来说对于数组使用双指针，一个用来遍历，一个用来执行具体操作。）：\",\"fast 指针： 指向可以输出的元素\",\"slow指针：指向被替换(删除)的元素【等于val的元素】\",\"其次定义双指针如何移动：\",\"如果 fast 指针指向不等于 val 的元素 ，就说明该元素是输出元素，不用替换的元素。此时就将 fast 指向的元素替换掉 slow 指向的元素，完整\\\"删除\\\"操作。同时将 slow 指针向右移动。\",\"如果 fast 指针指向等于val的元素，就说明该元素是需要被替换的元素，此时 slow 指针不动， fast 指针继续向右移动，直到找到一个输出元素。\",\"具体的流程：\",\"动画来源于：代码随想录 (programmercarl.com)\",\"、\"]},\"280\":{\"h\":\"代码实现\",\"t\":[\" /* * 采用双指针： * fast：指向输出元素【!= val的元素】 * slow：指向被替换的元素 【== val的元素】 * 当前元素是输出元素时，将fast指向的元素替换掉slow指向的元素。并移动双指针 * 当前元素不是输出元素时：只需要移动fast指针 * */ public static int removeElement(int[] nums, int val) { // 定义双指针 int slow = 0; for (int fast = 0; fast < nums.length; fast++) { // 找到输出元素 if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } } // 遍历检查 // for (int i = 0; i < slow; i++) { // System.out.println(nums[i]); // } // 此时 slow 就是新数组的长度 return slow; } \"]},\"281\":{\"h\":\"977 有序数组的平方\",\"t\":[\"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\",\"示例 1：\",\"输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] \",\"示例 2：\",\"输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] \"]},\"282\":{\"h\":\"思路分析\",\"t\":[\"从题目可以得知，原始数组是递增的，并且平方后的数组也要求是递增。\",\"暴力法：遍历数组，将每个数平方，然后将数组排序。\",\"双指针法：\",\"从题目可以得知，平方后最大的数不是在第一位【负数平方后变正数】就是最后一位。\",\"因此可以利用双指针 i ，j ，i 指向数组首端，j指向尾端。\",\"循环比较俩个数的值，将较大的数，放入一个新数组尾端【递增】,同时移动指向较大数的指针。\",\"if (nums[i] * nums[i] < nums[j] * nums[j]) result [k--] = nums[j] * nums[j]\",\"if (nums[i] * nums[i] >= nums[j] * nums[j]) result [k--] = nums[i] * nums[i]\",\"效果图来源于代码随想录：代码随想录 (programmercarl.com)\",\"img\"]},\"283\":{\"h\":\"代码实现\",\"t\":[\"暴力法：\",\" public static int[] sortedSquares(int[] nums) { for (int i = 0; i < nums.length; i++) { nums[i] *= nums[i]; } // 重新排序 Arrays.sort(nums); return nums; } \",\"双指针法：\",\" // 双指针法 public static int[] sortedSquares(int[] nums) { // 定义双指针 int i = 0; int j = nums.length -1 ; // 新数组 int[] result = new int[nums.length]; // 新数组指针 int k = j; // i 超过 j指针时，循环结束 while (i <= j) { // 将较大的数，放入新数组的尾端 if (nums[i] * nums[i] < nums[j] * nums[j]) { result[k--] = nums[j] * nums[j]; j--; }else { result[k--] = nums[i] * nums[i]; i++; } } return result; } \"]},\"284\":{\"h\":\"209 长度最小的子数组\",\"t\":[\"给定一个含有 n 个正整数的数组和一个正整数 target。\",\"找出该数组中满足其和 ≥ target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。\",\"示例 1：\",\"输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 \",\"示例 2：\",\"输入：target = 4, nums = [1,4,4] 输出：1 \",\"示例 3：\",\"输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 \"]},\"285\":{\"h\":\"思路分析\",\"t\":[\"暴力法：\",\"我直接想到的方法就是暴力法，通过俩层 for 循环，第一层循环是以某个元素为起始位置，第二层循环是以符合条件的终止位置。\",\"滑动窗口：\",\"所谓的滑动窗口，其实就是双指针，通过调节双指针的位置，确定滑动窗口的范围。在此范围内保证所有元素的和都 >= target\"]},\"286\":{\"h\":\"代码实现\",\"t\":[\" // 双指针法: 滑动窗口 public static int minSubArrayLen(int target, int[] nums) { int result = Integer.MAX_VALUE; // left 指向滑动窗口起始位置 int left = 0; int sum = 0; // 通过for循环，将 right 指针移动到滑动窗口终止的位置 for (int right = 0; right < nums.length; right++) { // sum 保存的是移动窗口内所有元素的和 sum += nums[right]; while (sum >= target){ // 符合条件 // 始终记录子数组的最小长度 result = Math.min(result,(right -left + 1)); // 由于left指针向右移动了一位，移动窗口缩小，因此sum也要减去移动的元素值 sum -= nums[left]; // 移动窗口 left++; } } return result==Integer.MAX_VALUE ? 0: result; } \"]},\"287\":{\"h\":\"59 螺旋矩阵 II\",\"t\":[\"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\",\"示例 1：\",\"img\",\"输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] \",\"示例 2：\",\"输入：n = 1 输出：[[1]] \"]},\"288\":{\"h\":\"思路分析\",\"t\":[\"矩阵的创建流程分俩种情况，第一种是偶数的情况，第二种是奇数的情况，如果是奇数，只需在循环结束后将矩阵中间的位置设置为最大值。因为最终都是到矩阵中间的位置结束。\",\"image-20230220221128972\",\"模拟顺时针画矩阵的过程:\",\"顶层从左到右\",\"右列从上到下\",\"底层从右到左\",\"左列从下到上\",\"由外向内一圈圈的画下去\",\"1、首先最重要的就是要确定 画矩阵 统一的规则，并且在画每一边时都要遵循这个规则。\",\"比如：采取左闭右开 的原则，每一边都留下最后一个元素，留给下一条边处理。这样在处理的过程中就不会乱。\",\"image-20230220221634769\",\"2、确定好规则，接下来就需要确定我们的循环的次数为：n/2 【如果不清楚，画一个找规律就知道为什么n/2了】\",\"3、确定好循环次数，接下来就是对每一边进行处理。\"]},\"289\":{\"h\":\"代码实现\",\"t\":[\"public static int[][] generateMatrix(int n) { int loop = 0; // 控制循环次数 int[][] res = new int[n][n]; // 存放矩阵 int start = 0; // 每次循环的开始点(start, start) int count = 1; // 定义填充数字 int i, j; // 模拟矩阵的行和列 while (loop++ < n / 2) { // 判断边界后，loop从1开始 // 模拟上侧从左到右 for (j = start; j < n - loop; j++) { res[start][j] = count++; } // 模拟右侧从上到下 for (i = start; i < n - loop; i++) { res[i][j] = count++; } // 模拟下侧从右到左 for (; j >= loop; j--) { res[i][j] = count++; } // 模拟左侧从下到上 for (; i >= loop; i--) { res[i][j] = count++; } // 每一次循环结束，下一次都会向里缩一圈。 // 所以起始位置+1 start++; } if (n % 2 == 1) { res[start][start] = count; } return res; } \"]},\"290\":{\"h\":\"1991 寻找数组的中心索引\",\"t\":[\"给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。\",\"中间位置 middleIndex 是满足 nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] 的数组下标。\",\"如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。\",\"请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。\",\"示例 1：\",\"输入：nums = [2,3,-1,8,4] 输出：3 解释： 下标 3 之前的数字和为：2 + 3 + -1 = 4 下标 3 之后的数字和为：4 = 4 \",\"示例 2：\",\"输入：nums = [1,-1,4] 输出：2 解释： 下标 2 之前的数字和为：1 + -1 = 0 下标 2 之后的数字和为：0 \",\"示例 3：\",\"输入：nums = [2,5] 输出：-1 解释： 不存在符合要求的 middleIndex 。 \",\"示例 4：\",\"输入：nums = [1] 输出：0 解释： 下标 0 之前的数字和为：0 下标 0 之后的数字和为：0 \",\"提示：\",\"1 <= nums.length <= 100\",\"-1000 <= nums[i] <= 1000\"]},\"291\":{\"h\":\"思路分析\",\"t\":[\"看到这道题的首先第一个想法就是暴力法，假设第一个位置为 midIndex ，分别计算 midIndex 左边的和 与 右边的和，判断是否相等，相等则返回，不相等则 将 midIndex++， 指向下一个元素\"]},\"292\":{\"h\":\"代码实现\",\"t\":[\" public int findMiddleIndex(int[] nums) { // 特殊情况 if (nums.length == 1) return 0; // 返回值值 int midIndex = 0; while(midIndex < nums.length) { // 分别保存左边和右边的和 int leftSum = 0; int rightSum = 0; // 左边和右边的指针 int left = 0; int right = midIndex + 1; // 计算左边的和 while (left < midIndex) { leftSum += nums[left]; left++; } // 计算右边的和 while(right < nums.length) { rightSum += nums[right]; right++; } // 如果相等返回 midIndex if (rightSum == leftSum) return midIndex; // 将midIndex继续指向下一个元素 midIndex++; } return -1; } \"]},\"293\":{\"h\":\"优化\",\"t\":[\"除了上面比较笨重的方法，在这里其实我们可以利用一个数学公式，已知 midIndex 左边与右边元素的和相等，假设用 leftSum 表示左边之和 , sum 表示 nums 数组总和，那么可以得出：\",\"$leftSum = sum - leftSum - nums[midIndex]$\",\"代码实现\",\" public static int findMiddleIndex2(int[] nums) { // 数组总和 int sum = 0; for (int i = 0; i < nums.length; i++) { sum += nums[i]; } int leftSum = 0; for (int i = 0; i < nums.length; i++) { if (leftSum == sum - leftSum - nums[i] ) return i; leftSum += nums[i]; } return -1; } \"]},\"294\":{\"h\":\"\",\"t\":[\"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\",\"示例 1：\",\"输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. \",\"示例 2：\",\"输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 \",\"提示：\",\"1 <= intervals.length <= 104\",\"intervals[i].length == 2\",\"0 <= starti <= endi <= 104\"]},\"295\":{\"h\":\"思路分析\",\"t\":[\"首先要按照每个区间的首元素进行升序 \",\"因为我们要根据首元素判断是否合并\",\"其次我们需要一个额外的集合，将不合并的区间放入进去\",\"判断是否可以合并\",\"首先我们看如果俩个区间合并的话，需要满足以下的条件：\",\"$$ intervals[i][0] <= intervals[i-1][1] (i >=1) $$\",\"第 i 个区间的首元素小于或者等于 第 i-1 个区间的末尾元素，就说明可以合并，例如：\",\"[1,4], [2,3] ==> [1,4]\",\"[2,5],[3,8] ==> [2,8]\",\"从上面例子中可以看出，如果进行合并的话，首元素就是俩个区间较小的那个，末尾元素则是俩个区间较大的那个。\"]},\"296\":{\"h\":\"代码实现\",\"t\":[\" public static int[][] merge(int[][] intervals) { // 结果集合 ArrayList<int[]> res = new ArrayList<>(); // 先对二维数组对初始元素进行排序 Arrays.sort(intervals, (o1, o2) -> Integer.compare(o1[0], o2[0])); // 先将二维数组中第一个元素放到结果数组中 res.add(intervals[0]); for (int i = 1; i < intervals.length; i++) { // 如果第二个区间的第一个元素 <= 结果集中最后一个区间的末尾元素，就进行合并 if (intervals[i][0] <= res.get(res.size() - 1)[1]) { res.get(res.size() - 1)[1] = Math.max(intervals[i][1],res.get(res.size() - 1)[1]); } else { // 否则，直接加入结果数组中 res.add(intervals[i]); } } return res.toArray(new int[res.size()][2]); } \"]},\"297\":{\"h\":\"\",\"t\":[\"给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\",\"你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\",\"示例 1：\",\"img\",\"输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] \",\"示例 2：\",\"img\",\"输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] \",\"提示：\",\"n == matrix.length == matrix[i].length\",\"1 <= n <= 20\",\"-1000 <= matrix[i][j] <= 1000\"]},\"298\":{\"h\":\"第一种方法：使用辅助矩阵\",\"t\":[\"首先要知道如何旋转，每次旋转有什么规律，以例二为例：\",\"在第一行旋转之后，变成了矩阵的最后一列：\",\"比如：\",\"第一个行第一个元素 ——》 倒数第一列第一个元素\",\"第一个行第二个元素 ——》 倒数第一列第二个元素\",\"....\",\"image-20230920220015959\",\"在第二行旋转之后，变成了矩阵的倒数第二列：\",\"image-20230920220039986\",\"第三行、第四行依次类推，因此我们可以得出结论：\",\"$在第 i 行 第j个元素，经过旋转之后出现在倒数第 i 列第j个位置$\",\"也就是说转换之前的列 是转换之后的行，而转换之后的列要根据转换之前的行计算\",\"由于我们下标从0开始，转换成代码为：\",\"$ temp[j][n-i-1] = matrix[i][j] $\",\"代码实现\",\" public static void rotate(int[][] matrix) { int n = matrix.length; // 辅助矩阵 int[][] temp = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { temp[j][n-i-1] = matrix[i][j]; } } // 复制会原矩阵 for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { matrix[i][j]= temp[i][j]; } } } \"]},\"299\":{\"h\":\"第二种方法：原地修改\",\"t\":[\"第二种方法不使用额外的矩阵，直接在原矩阵中修改。\",\"以矩阵的四个顶点为例，它的旋转路径为：$A <—— D<—— C<—— B<—— A$ ，但是通过下图我们也可以看见，在第一步中，A的值被D的值覆盖了，因此需要使用一个额外变量 temp 保存 A的值 ， 即 $A <—— D<—— C<—— B<—— temp$\",\"ccw-01-07.002.png\",\"如上图所示，一轮可以完成矩阵 4 个元素的旋转。因而，只要分别以矩阵左上角 1/4 的各元素为起始点执行以上旋转操作，即可完整实现矩阵旋转。\",\"当矩阵大小 n 为偶数时，取前 n/2作为行， n/2 列的元素作为起点\",\"当矩阵大小 n 为奇数时，取前 n/2作为行， （n+1）/2列作为元素的起点\",\"假设起点元素matrix[i][j], 由第一种方法得出的公式，可任意推导出下面任一公式： $$ 暂存: temp = matrix[i][j] $$ $$matrix[i][j] <—— matrix[n-1-j][i] <—— matrix[j][n-i-1] <—— matrix[n-j-1][n-i-1] <—— temp$$\",\"公式推导过程\",\"由方法一得到关键公式为： $ temp[j][n-i-1] = matrix[i][j] $ ，这是使用辅助矩阵，如果我们想要原地修改即： $$ matrix[j][n-i-1] = matrix[i][j] $$ 但是此时我们发现，$matrix[j][n-i-1]$ 原来的值会被 $ matrix[i$][j] 覆盖掉，因此我们可以使用临时变量 temp 存储：\",\"$$ \\\\left{ \\\\begin{matrix} temp = matrix[j][n-i-1] \\\\ matrix[j][n-i-1] = matrix[i][j] \\\\end{matrix} \\\\right. $$ 上面的公式表示 $matrix[i][j]$ 旋转后的位置是 $ matrix[j][n-i-1]$，那么 $ matrix[j][n-i-1]$ 旋转之后的位置是什么呢？\",\"接着将 i、j 带入关键公式，但此时的 i 和 j 变为： $$ \\\\left{ \\\\begin{matrix} i = j \\\\ j = n-i-1 \\\\end{matrix} \\\\right. $$ 带入之后得 $ matrix[n-i-1][n-j-1]$ ，该位置就是 $matrix[j][n-i-1]$ 旋转之后所在的位置，但是仍然存在被覆盖的问题，继续使用 temp 即可，因此得出： $$ \\\\left{ \\\\begin{matrix} temp = matrix[n-i-1][n-j-1] \\\\ matrix[n-i-1][n-j-1] = matrix[j][n-i-1] \\\\ matrix[j][n-i-1] = matrix[i][j] \\\\end{matrix} \\\\right. $$ 紧接着继续带入 i 和 j 到关键公式： $$ \\\\left{ \\\\begin{matrix} i = n-i-1 \\\\ j = n-j-1 \\\\end{matrix} \\\\right. $$ 带入之后得$ matrix[n-j-1][i] $ ， 该位置就是 $matrix[n-i-1][n-j-1]$ 旋转之后所在的位置，继续使用 temp 保存被覆盖的值，因此有： $$ \\\\left{ \\\\begin{matrix} temp = [n-j-1][i] \\\\ matrix[n-j-1][i] = matrix[n-i-1][n-j-1] \\\\ matrix[n-i-1][n-j-1] = matrix[j][n-i-1] \\\\ matrix[j][n-i-1] = matrix[i][j] \\\\end{matrix} \\\\right. $$ 紧接着继续带入 i 和 j 到关键公式： $$ \\\\left{ \\\\begin{matrix} i = n-j-1\\\\ j = i \\\\end{matrix} \\\\right. $$ 带入之后得$ matrix[i][j]$ , 该位置就是 $matrix[n-j-1][i]$ 旋转之后所在的位置 ，继续使用 temp 保存被覆盖的值 ，因此有： $$ \\\\left{ \\\\begin{matrix} temp = matrix[i][j] \\\\ matrix[i][j] = matrix[n-j-1][i] \\\\ matrix[n-j-1][i] = matrix[n-i-1][n-j-1] \\\\ matrix[n-i-1][n-j-1] = matrix[j][n-i-1] \\\\ matrix[j][n-i-1] = matrix[i][j] \\\\end{matrix} \\\\right. $$ 到这，我们发现又回到了起点，这几个公式为一个循环，每一个旋转之后的位置就是下一个要旋转的位置，因此我们可以使用临时变量保存： $$ \\\\left{ \\\\begin{matrix} temp = matrix[i][j] \\\\ matrix[i][j] = matrix[n-j-1][i] \\\\ matrix[n-j-1][i] = matrix[n-i-1][n-j-1] \\\\ matrix[n-i-1][n-j-1] = matrix[j][n-i-1] \\\\ matrix[j][n-i-1] = temp \\\\end{matrix} \\\\right. $$\",\"代码实现\",\"class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i < n / 2; i++) { for (int j = 0; j < (n + 1) / 2; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - j][i]; matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]; matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]; matrix[j][n - 1 - i] = tmp; } } } } \"]},\"300\":{\"h\":\"\",\"t\":[\"编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。\",\"示例 1：\",\"输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] \",\"示例 2：\",\"输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] \"]},\"301\":{\"h\":\"思路分析\",\"t\":[\"题目要求将为0元素所在的列和行都置为0，设计到查找某个元素首先肯定要遍历。找到为0的元素的位置，然后记录它所在的行和列。\",\"知道了哪行和哪列要置为0，通过第二次遍历修改原矩阵的值。\"]},\"302\":{\"h\":\"代码实现\",\"t\":[\" public static void setZeroes(int[][] matrix) { // 行和列的长度 int rowLength = matrix.length; int colLength = matrix[0].length; // 使用俩个标记数组，记录0元素的行和列 boolean[] row = new boolean[rowLength]; boolean[] col = new boolean[colLength]; // 第一次遍历找到所有0元素的行和列 for (int i = 0; i < rowLength; i++) { for (int j = 0; j < colLength; j++) { // 记录元素为0的位置 if (matrix[i][j] == 0) row[i] = col[j] = true; } } // 第二次遍历，将0元素的行和列的所有元素都置0 for (int i = 0; i < row.length; i++) { for (int j = 0; j < col.length; j++) { if (row[i] || col[j]) matrix[i][j] = 0; } } } \"]},\"303\":{\"h\":\"\",\"t\":[\"给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。\",\"示例 1：\",\"img\",\"输入：mat = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,4,7,5,3,6,8,9] \",\"示例 2：\",\"输入：mat = [[1,2],[3,4]] 输出：[1,2,3,4] \",\"提示：\",\"m == mat.length\",\"n == mat[i].length\",\"1 <= m, n <= 104\",\"1 <= m * n <= 104\",\"-105 <= mat[i][j] <= 105\"]},\"304\":{\"h\":\"思路分析\",\"t\":[\"遇到此类问题，需要找到其中的规律，既然我们要遍历对角线上的元素，我们就需要知道共有几条对角线，其次遍历对角线。\",\"假设对角线用 i 表示，那么就有： $ i <= m+n-1$ , 若 i 从 0 开始则：$ i ∈ [0, m+n-2]$\",\"知道了对角线的数量，我们就要找到每条对角线的规律：\",\"规律一：\",\"其实在例题中，我们也可以发现，颜色相同的对角线它的走向都是一样的， 红色都是从 下——》上，黄色从 上——》下，\",\"进而我们可以总结出来：\",\"i 为偶数： 元素遍历的顺序由 下 ——> 上\",\"i 为奇数： 元素遍历的元素由 上 ——> 下\",\"image-20230922094206193\",\"规律二：\",\"当 元素从下往上遍历时（i为偶数），其实也可以发现 他的行是逐渐递减的，列是逐渐递加的\",\"例如：\",\"遍历第二条对角线的元素： mat[2][0]、 mat[1][1]、 mat[0][2]\",\"行的变化：2——> 1 ——> 0\",\"列的变化: 0 ——> 1 ——> 2\",\"当 元素从上往下遍历时，其实也可以发现 他的行是逐渐递加的，列是逐渐递减的\",\"例如：\",\"遍历第一条对角线的元素： mat[0][1]、 mat[1][0]\",\"行的变化：0 ——> 1\",\"列的变化: 1 ——> 0\",\"规律三：\",\"知道了对角线的规律、每个元素的行和列的变化规律，我们还需要知道每条对角线的起点元素的位置。\",\"当 元素从下往上遍历时（i为偶数），分为俩种情况：\",\"当 i < m，对角线元素的起点位置为：$（i，0）$\",\"当 i >= m, 对角线元素的起点位置为：$（m-1, i-m+1）$\",\"当元素从上往下遍历时 （i为奇数），分为俩种情况：\",\"当 i < n，对角线元素的起点位置为：$（0，i）$\",\"当 i >= n, 对角线元素的起点位置为：$（ i-n+1,n-1）$\",\"当我第一次看到这里时，其实是很懵B的，有俩个疑问：\",\"1、为什么要和m比？为什么要和n比？\",\"2、起点位置又是怎么来的？\",\"问题说明：\",\"当元素从下往上遍历时（i为偶数），通过下图可以看出,\",\"对角线以上，起点元素的行坐标是和 i 相等的，而它的列坐标不变，一直是0，因此当 i < m，起点元素的坐标为 $（i，0）$\",\"对角线以下，无论有几条，起点元素的行坐标一直是 m-1 ，也就是最后一行，而它的列坐标相较于前一条对角线 的起点元素 递增加一， i - m + 1。 因此当 i >= m，起点元素的坐标为 $（ i-n+1,n-1）$\",\"image-20230922105341336\",\"当元素从上往下遍历时（i为奇数），通过下图可以看出, 逻辑和上面的一样：\",\"对角线以上，行坐标一直是0，列坐标等于 i ，因此起点元素的位置为：$（0，i）$\",\"对角线以下，列坐标一直都是最后一列，即 n-1 ，行坐标 = 前一条对角线起点元素行坐标 + 1 ，即 i-n+1，因此最终位置为 $（ i-n+1,n-1）$\",\"image-20230922114839267\"]},\"305\":{\"h\":\"代码实现\",\"t\":[\"class Solution { public int[] findDiagonalOrder(int[][] mat) { int m = mat.length; int n = mat[0].length; int[] res = new int[m * n]; int index = 0; // 遍历对角线 for (int i = 0; i < m + n - 1; i++) { if (i % 2 == 1) { // i是奇数，从上到下 int x = i < n ? 0 : i - n + 1; int y = i < n ? i : n - 1; while (x < m && y >= 0) { res[index++] = mat[x][y]; x++; y--; } } else { // i是偶数，从下到上 int x = i < m ? i : m - 1; int y = i < m ? 0 : i - m + 1; while(y < n && x >=0){ res[index++] = mat[x][y]; x--; y++; } } } return res; } } \"]},\"306\":{\"h\":\"\",\"t\":[\"给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。\",\"示例 1：\",\"输入：nums = [1,1,0,1,1,1] 输出：3 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3. \",\"示例 2:\",\"输入：nums = [1,0,1,1,0,1] 输出：2 \",\"提示：\",\"1 <= nums.length <= 105\",\"nums[i] 不是 0 就是 1.\"]},\"307\":{\"h\":\"思路分析\",\"t\":[\"遍历 $nums$ 数组，使用 $count$ 变量累加连续1的个数， $res$ 保存最大的连续1的个数。\",\"遇到不为1的元素停止，对 $count、res$ 去最大值，否则一直累加 $count$\",\"在遍历完 $nums$ , 需要在对$count、res$ 去最大值，防止连续的1在数组的末尾\"]},\"308\":{\"h\":\"代码实现\",\"t\":[\" public static int findMaxConsecutiveOnes(int[] nums) { // 保存结果 int res = 0; // 保存连续的1的个数 int count = 0; for (int i = 0; i < nums.length; i++) { if (nums[i] == 1) { count++; } else { // 如果不相等,计算1的个数 // 同时将1清0，继续计算下一个连续的1的个数 res = Math.max(count, res); count = 0; } } // 这里在进行比较是为了： 数组中连续的1在数组的末尾 res = Math.max(count, res); return res; } \"]},\"309\":{\"h\":\"\",\"t\":[\"给定一个非负整数 *numRows，*生成「杨辉三角」的前 numRows 行。\",\"在「杨辉三角」中，每个数是它左上方和右上方的数的和。\",\"img\",\"示例 1:\",\"输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] \",\"示例 2:\",\"输入: numRows = 1 输出: [[1]] \",\"提示:\",\"1 <= numRows <= 30\"]},\"310\":{\"h\":\"思路分析\",\"t\":[\"杨辉三角性质：\",\"行数与元素个数相等，即：第n行有n个元素\",\"每一行的首元素和尾元素都是1\",\"除开首尾元素，每一个元素的和都是它左上方元素和右上方元素的和\"]},\"311\":{\"h\":\"代码实现\",\"t\":[\" public static List<List<Integer>> generate(int numRows) { ArrayList<List<Integer>> res = new ArrayList<>(); for (int i = 0; i < numRows; i++) { // 每一行 ArrayList<Integer> row = new ArrayList<>(); // j表示每一行的元素 for (int j = 0; j <= i; j++) { // 每行的第一个元素，与最后一个元素都是1 if (j == 0 || j == i) { row.add(1); }else { // 除了首尾元素，每一个元素都是左上方与右上方的和 row.add(res.get(i-1).get(j-1) + res.get(i-1).get(j)); } } res.add(row); } return res; } \"]},\"312\":{\"h\":\"\",\"t\":[\"给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\",\"考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\",\"更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\",\"返回 k 。\",\"判题标准:\",\"系统会用下面的代码来测试你的题解:\",\"int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } \",\"如果所有断言都通过，那么您的题解将被 通过。\",\"示例 1：\",\"输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 \",\"示例 2：\",\"输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 \",\"提示：\",\"1 <= nums.length <= 3 * 104\",\"-104 <= nums[i] <= 104\",\"nums 已按 非严格递增 排列\"]},\"313\":{\"h\":\"思路分析\",\"t\":[\"题意很简单，就是删除数组中 重复的元素，并保持相对顺序。\",\"什么是相对顺序？比如 2、3， 2在3前面，删除后不能2跑到3后面去。\",\"众所周知，数组中无法删除元素，所以采用的是快慢指针覆盖的方法\",\"使用 l、r快慢指针\",\"l 指向重复的元素，r指向替换 l 的元素\",\"当 $nums[l] != nums[r] $, 将 r 指向的元素覆盖 l+1指向的元素。即：$nums[l+1] = nums[r]$\",\"当 $nums[l] == nums[r] $, 只需要移动 r 指针\",\"为什么要覆盖 l+1 呢？\",\"这是因为题目中要求保持相对顺序，l 指针指向的是重复元素的第一个，因此 nums[l+1] = nums[l]\",\"（1）如下图所示，l 作为慢指针，r作为快指针，因此循环条件应该是： r<nums.length\",\"image-20231007223129927\",\"(2) 当 l 和 r 指向的元素相等时，l 指针就停止，r继续移动，直到找到 l 与 r 不相等时，将 r 指向的元素覆盖 l + 1指向的元素\",\"image-20231007224209714\",\"image-20231007224359553\",\"需要注意的是，每次覆盖完，l指针是+1的，所以在执行完，此时的 l 指针应该为4 ，最终返回有效数组的长度为：l+1\",\"image-20231007224528548\"]},\"314\":{\"h\":\"代码实现\",\"t\":[\"class Solution { public int removeDuplicates(int[] nums) { int l = 0; int r = 1; while(r < nums.length) { // 如果不相等， 则覆盖 l+1处的重复元素 if (nums[l] != nums[r]) { nums[l+1] = nums[r]; // 覆盖完，将l指针右移 l++; } r++; } return l+1; } } \"]},\"315\":{\"h\":\"\",\"t\":[\"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\",\"请注意 ，必须在不复制数组的情况下原地对数组进行操作。\",\"示例 1:\",\"输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] \",\"示例 2:\",\"输入: nums = [0] 输出: [0] \",\"提示:\",\"1 <= nums.length <= 104\",\"-231 <= nums[i] <= 231 - 1\",\"**进阶：**你能尽量减少完成的操作次数吗？\"]},\"316\":{\"h\":\"思路分析\",\"t\":[\"思路和26题一样，仍然使用快慢指针。\",\"l指针指向元素0，r指针指向不为0的元素，将其交换即可。\"]},\"317\":{\"h\":\"代码实现\",\"t\":[\"需要注意的是，left和right指针都是从0开始\",\" public void moveZeroes(int[] nums) { if(nums == null || nums.length == 1) return; // 定义双指针 int left = 0, right = 0; while (right < nums.length) { if (nums[right] != 0) { // 交换 int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; } right++; } } \"]},\"318\":{\"c\":[\"算法\"]},\"319\":{\"c\":[\"数组\",\"二分法\"]},\"320\":{\"h\":\"栈和队列\"},\"321\":{\"h\":\"\",\"t\":[\"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\",\"实现 MyQueue 类：\",\"void push(int x) 将元素 x 推到队列的末尾\",\"int pop() 从队列的开头移除并返回元素\",\"int peek() 返回队列开头的元素\",\"boolean empty() 如果队列为空，返回 true ；否则，返回 false\",\"说明：\",\"你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\",\"你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\",\"示例 1：\",\"输入： [\\\"MyQueue\\\", \\\"push\\\", \\\"push\\\", \\\"peek\\\", \\\"pop\\\", \\\"empty\\\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false \",\"提示：\",\"1 <= x <= 9\",\"最多调用 100 次 push、pop、peek 和 empty\",\"假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\"]},\"322\":{\"h\":\"思路分析\",\"t\":[\"使用俩个栈实现队列，一个作为输入栈，一个作为输出栈。\",\"栈为先进后出，队列为先进先出，push 时往输入栈里面push，但是 pop 的时候，需要将输入栈导入到输出栈。此时输出栈的顺序才和队列一致。\",\"image-20231019212329144\"]},\"323\":{\"h\":\"代码实现\",\"t\":[\"class MyQueue { Stack<Integer> inputStack; Stack<Integer> outputStack; public MyQueue() { // 输入栈 inputStack = new Stack<>(); // 输出栈 outputStack = new Stack<>(); } public void push(int x) { // 直接压入输入栈 inputStack.push(x); } public int pop() { // 需要先将输入栈导入输出栈 exportInputStack(); return outputStack.pop(); } public int peek() { // 需要先将输入栈导入输出栈 exportInputStack(); return outputStack.peek(); } public boolean empty() { // 俩个栈都为空 return inputStack.empty() && outputStack.isEmpty(); } // 将输入栈导出到输出栈中 public void exportInputStack(){ if (!outputStack.empty()) return; while(!inputStack.isEmpty()) { outputStack.push(inputStack.pop()); } } } \"]},\"324\":{\"h\":\"\",\"t\":[\"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\",\"有效字符串需满足：\",\"左括号必须用相同类型的右括号闭合。\",\"左括号必须以正确的顺序闭合。\",\"每个右括号都有一个对应的相同类型的左括号。\",\"示例 1：\",\"输入：s = \\\"()\\\" 输出：true \",\"示例 2：\",\"输入：s = \\\"()[]{}\\\" 输出：true \",\"示例 3：\",\"输入：s = \\\"(]\\\" 输出：false \",\"提示：\",\"1 <= s.length <= 104\",\"s 仅由括号 '()[]{}' 组成\"]},\"325\":{\"h\":\"思路分析\",\"t\":[\"根据题意可知，有效的字符串一定是成双成对的，一定是2的倍数，并且左括号后面一定是对应的右括号！\",\"可以利用栈先进先出的特性，对其进行校验：\",\"如果遇到左括号，直接入栈\",\"如果遇到右括号，弹栈，判断是否符合()、[]、{} ，若不符合直接返回false\",\"如果是有效的字符串的话，一定是先入栈-弹栈-入栈-弹栈.....这种顺序，那么到最后一个操作时一定是弹栈，并且栈一定是空的！！！\"]},\"326\":{\"h\":\"代码实现\",\"t\":[\" public static boolean isValid(String s) { // 如果不是2的倍数，一定不是有效的括号 if (s.length() % 2 ==1) return false; Stack<Character> stack = new Stack<>(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); // 遇到左括号直接入栈 if (c == '(' || c == '[' || c == '{') { stack.push(s.charAt(i)); } else { // 遇到右括号弹栈，弹出一个左括号 if (stack.isEmpty()) return false; Character pop = stack.pop(); // 校验 if (c == ')' && '(' != pop) return false; if (c == ']' && '[' != pop) return false; if (c == '}' && '{'!= pop) return false; } } return stack.isEmpty(); } \"]},\"327\":{\"h\":\"\",\"t\":[\"给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\",\"在 S 上反复执行重复项删除操作，直到无法继续删除。\",\"在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\",\"示例：\",\"输入：\\\"abbaca\\\" 输出：\\\"ca\\\" 解释： 例如，在 \\\"abbaca\\\" 中，我们可以删除 \\\"bb\\\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \\\"aaca\\\"，其中又只有 \\\"aa\\\" 可以执行重复项删除操作，所以最后的字符串为 \\\"ca\\\"。 \",\"提示：\",\"1 <= S.length <= 20000\",\"S 仅由小写英文字母组成。\"]},\"328\":{\"h\":\"思路分析\",\"t\":[\"这个题目其实和 20题：有效的括号 思路一样\",\"当stack为空或者遇到不相等的元素，直接入栈\",\"遇到相等的元素弹栈，判断下一个元素\",\"最后stack中剩下的就是不重复的元素\"]},\"329\":{\"h\":\"代码实现\",\"t\":[\" public static String removeDuplicates(String s) { Stack<Character> stack = new Stack<>(); // 将不相等的字符入栈，相等的字符弹栈 for (int i = 0; i < s.length(); i++) { if (stack.isEmpty() || s.charAt(i) != stack.peek()) { stack.push(s.charAt(i)); } else { stack.pop(); } } // 剩下的就是不重复的元素 StringBuilder res = new StringBuilder(); while (!stack.isEmpty()) { res.append(stack.pop()); } return res.reverse().toString(); } \"]},\"330\":{\"h\":\"\",\"t\":[\"给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。\",\"请你计算该表达式。返回一个表示表达式值的整数。\",\"注意：\",\"有效的算符为 '+'、'-'、'*' 和 '/' 。\",\"每个操作数（运算对象）都可以是一个整数或者另一个表达式。\",\"两个整数之间的除法总是 向零截断 。\",\"表达式中不含除零运算。\",\"输入是一个根据逆波兰表示法表示的算术表达式。\",\"答案及所有中间计算结果可以用 32 位 整数表示。\",\"示例 1：\",\"输入：tokens = [\\\"2\\\",\\\"1\\\",\\\"+\\\",\\\"3\\\",\\\"*\\\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 \",\"示例 2：\",\"输入：tokens = [\\\"4\\\",\\\"13\\\",\\\"5\\\",\\\"/\\\",\\\"+\\\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 \",\"示例 3：\",\"输入：tokens = [\\\"10\\\",\\\"6\\\",\\\"9\\\",\\\"3\\\",\\\"+\\\",\\\"-11\\\",\\\"*\\\",\\\"/\\\",\\\"*\\\",\\\"17\\\",\\\"+\\\",\\\"5\\\",\\\"+\\\"] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 \",\"提示：\",\"1 <= tokens.length <= 104\",\"tokens[i] 是一个算符（\\\"+\\\"、\\\"-\\\"、\\\"*\\\" 或 \\\"/\\\"），或是在范围 [-200, 200] 内的一个整数\",\"逆波兰表达式：\",\"逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\",\"平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\",\"该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。\",\"逆波兰表达式主要有以下两个优点：\",\"去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\",\"适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\"]},\"331\":{\"h\":\"思路分析\",\"t\":[\"题目比较简单，只要弄清楚什么是逆波兰表达式即可。需要注意的是除法和减法，不要搞混运算顺序。\"]},\"332\":{\"h\":\"代码实现\",\"t\":[\" public static int evalRPN(String[] tokens) { Stack<Integer> stack = new Stack<>(); for (String token : tokens) { // 如果是字符，取出俩个数计算，并讲解结果放入栈中 switch (token){ case \\\"*\\\" : stack.push( stack.pop() * stack.pop()); break; case \\\"/\\\" : // 除法要特殊处理，先弹出来的是除数，后弹出来的是被除数 Integer op1 = stack.pop(); Integer op2 = stack.pop(); stack.push( op2 / op1); break; case \\\"+\\\" : stack.push( stack.pop() + stack.pop()); break; case \\\"-\\\" : // 减法也要特殊处理，先弹出来的是减数，后弹出来的是被减数 stack.push( - stack.pop() + stack.pop()); break; default: stack.push(Integer.valueOf(token)); } } return stack.pop(); } \"]},\"333\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\",\"示例 1：\",\"输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 \",\"示例 2：\",\"输入：nums = [1], k = 1 输出：[1] \",\"提示：\",\"1 <= nums.length <= 105\",\"-104 <= nums[i] <= 104\",\"1 <= k <= nums.length\"]},\"334\":{\"h\":\"思路分析\",\"t\":[\"该题目使用单调递减队列比较容易理解一些。我们只需要维护队首最大的元素即可，同时要保证队列中的元素保持递减。\",\"那么该如何维护呢？通过题意我们可以发现，每次移动窗口，都是在pop、push，那么在push 和 pop 要遵循以下原则：\",\"pop(): \",\"保证队列的单调递减，将 比当前值小的元素都弹出\",\"判断队首元素是否在该滑动区间内 , 如果不是直接弹出队首元素\",\"push： \",\"保证push的元素一定是当前队列中的最小值 或者 队列为空\",\"例\",\"nums = [1,3,-1,-3,5,3,6,7], k = 3\",\"初始状态设[L,R] = [0,0],队列 Q ={}，res = []\",\"i = 0, nums[0] = 1, 队列为空，直接入队 Q =\",\"i = 1, nums[1] = 3, 3 > 1 遇见比当前值小的，则依次弹出后加入，Q =\",\"i = 2, nums[2] = -1， -1 < 3, 直接入队，Q = {3,-1},此时L=0，R=2，i在区间之内，则res = [3]\",\"i=3,nums[3]=-3。队尾值为-1，-3<-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]\",\"i=4,nums[4]=5。队尾值为-3，5>-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]\",\"i=5,nums[5]=3。队尾值为5，3<5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]\",\"i=6,nums[6]=6。队尾值为3，6>3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]\",\"i=7,nums[7]=7。队尾值为6，7>6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]\",\"通过模拟可以发现：\",\"$R = i， L = R-k+1 = i- k + 1$， 判断队首元素是否在[L,R] 之内，只需要判断队首元素的下标是否大于 $ i-k+1$\",\"在队里中存储元素下标更为访问，因为要判断队首元素是否在滑动窗口之内！\"]},\"335\":{\"h\":\"\",\"t\":[\"class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int length = nums.length; ArrayDeque<Integer> queue = new ArrayDeque<>(); int[] res = new int[length - k + 1]; int index = 0; for (int i = 0; i < length; i++) { // 将队列中比当前元素小的都弹出，保证当前值为最小值或者队列为空 while (!queue.isEmpty() && nums[queue.peekLast()] < nums[i]) queue.pollLast(); // 增加元素到队尾 queue.offer(i); // 判断队首元素是否在滑动区间内[i-k+1,i]，若不在则弹出队首的元素 if (queue.peek() < i - k + 1) queue.poll(); if (i - k + 1 >= 0) { // 获取队列最大值，由于是单调递减，第一个元素就是最大值 res[index++] = nums[queue.peek()]; } } return res; } } \"]},\"336\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\",\"示例 1:\",\"输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] \",\"示例 2:\",\"输入: nums = [1], k = 1 输出: [1] \",\"提示：\",\"1 <= nums.length <= 105\",\"k 的取值范围是 [1, 数组中不相同的元素的个数]\",\"题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\",\"**进阶：**你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。\"]},\"337\":{\"h\":\"思路分析\",\"t\":[\"统计nums 数组中每个数字出现的频率\",\"类似这种统计，我们都可以使用map来存储 , 这道题key存储元素，value存储每个元素出现的次数\",\"需要对map中的元素按照 value 大小进行排序\",\"最重要的就是该步，时间复杂度也都取决于该步，可以使用冒泡, 选择, 插入等等等，但是他们的复杂度 >= $O(nlogn)$\",\"因此再次步，我们可以使用 优先级队列 当做存储容器，其实现方式通常由 小顶堆、大顶堆\",\"小顶堆：非叶子节点比左右孩子结点小\",\"大顶堆：非叶子节点比左右孩子结点大\",\"在 Java中可以使用PriorityQueue 表示优先级队列\",\"获取优先级队列前k个元素\"]},\"338\":{\"h\":\"代码实现\",\"t\":[\" public static int[] topKFrequent(int[] nums, int k) { HashMap<Integer, Integer> table = new HashMap<>(); // 统计nums中每个数字出现的次数 for (int num : nums) { // getOrDefault 获取value，如果不存在就存入默认值 table.put(num,table.getOrDefault(num,0) + 1); } // 使用优先级队列进行排序 /* * PriorityQueue默认创建的就是小顶堆，即从小到大排序 * (o1,o2) -> o2[0] - o1[0] : 创建的是大顶堆，即从大到小排序 * */ PriorityQueue<int[]> pq = new PriorityQueue<>((o1,o2) -> o2[0] - o1[0]); for (Entry<Integer, Integer> entry : table.entrySet()) { // 由于创建的大顶堆，比较数组中第一个元素。因此按照value值进行排序 pq.offer(new int[]{entry.getValue(),entry.getKey()}); } // 获取前k个元素 int[] ints = new int[k]; for (int i = 0; i < k; i++) { ints[i] = pq.poll()[1]; } return ints; } \"]},\"339\":{\"h\":\"总结\",\"t\":[\"此篇中，最重要的是学到了 单调队列 和 优先级队列\",\"单调队列通常用双端队列 实现，需要手动保持队列中的元素单调性，单调递增或者递减，通常用于解决 滑动窗口 类的问题。\",\"优先级队列通常用 小顶堆、大顶堆来实现, 在插入删除时自动保持顺序\"]},\"340\":{\"c\":[\"算法\"]},\"341\":{\"c\":[\"栈\",\"队列\"]},\"342\":{\"h\":\"贪心算法\",\"t\":[\"贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\",\"例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？\",\"指定每次拿最大的，最终结果就是拿走最大数额的钱。\",\"每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。\",\"贪心算法一般分为如下四步：\",\"将问题分解为若干个子问题\",\"找出适合的贪心策略\",\"求解每一个子问题的最优解\",\"将局部最优解堆叠成全局最优解\",\"这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。\",\"做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。\"]},\"343\":{\"h\":\"\",\"t\":[\"假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\",\"对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\",\"示例 1:\",\"输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 \",\"示例 2:\",\"输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. \",\"提示：\",\"1 <= g.length <= 3 * 104\",\"0 <= s.length <= 3 * 104\",\"1 <= g[i], s[j] <= 231 - 1\"]},\"344\":{\"h\":\"思路分析\",\"t\":[\"首先要清楚该题能不能用贪心算法来实现。注意：与其说贪心算法是一种算法，不如说它是一种思想。\",\"即： 每步找到最优解，从而达到全局的最优\",\"对于该题来说，每一步的最优解是什么？\",\"在我看来，就是尽量将尺寸大的饼干分配给胃口最大的孩子，这样即不会浪费饼干，也会让孩子得到满足！！\",\"class Solution { public int findContentChildren(int[] g, int[] s) { if (g.length == 0 || s.length == 0) return 0; // 进行升序序,原则就是尽量将 大尺寸的饼干分发给胃口大的孩子 Arrays.sort(g); Arrays.sort(s); // 记录孩子满足的个数 int res = 0; // s的索引 int index = s.length-1; for (int i = g.length-1; i >=0 && index >=0;i--) { if (s[index] >= g[i]) { // 满足胃口，继续为下一个孩子分配饼干 res++; index--; } // 不满足胃口，继续遍历下一个孩子 } return res; } } \"]},\"345\":{\"h\":\"\",\"t\":[\"如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\",\"例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\",\"相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\",\"子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\",\"给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\",\"示例 1：\",\"输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 \",\"示例 2：\",\"输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 \",\"示例 3：\",\"输入：nums = [1,2,3,4,5,6,7,8,9] 输出：2 \",\"提示：\",\"1 <= nums.length <= 1000\",\"0 <= nums[i] <= 1000\",\"**进阶：**你能否用 O(n) 时间复杂度完成此题?\"]},\"346\":{\"h\":\"思路分析\",\"t\":[\"求摆动序列的长度，其实就是求出在这个数组中的波峰和波谷的数量总和，要么就跳过上升到波峰的那些结点，要么跳过下降的波谷的那些结点。\",\"贪心算法：\",\"局部最优解：每次只记录波峰或波谷。全局最优解：整个nums数组波峰和波谷的数量。\",\"例如：[1，7,4,3,2,4]\",\"sum值用于记录摆动的个数，从数组第二个元素开始遍历，每一层循环中做的事有：\",\"跳过平坡，即遇到相等元素直接跳过\",\"记录上一次是上坡还是下坡\",\"若上一次是上坡，则只记录下坡，反之则只记录上坡 相当于只记录上坡和下坡数之和。\",\"image-20231213223205258\",\"class Solution { public int wiggleMaxLength(int[] nums) { // 记录波峰和波谷的数量 int sum = 1; // 记录是上坡还是下坡 int flag = 0; for (int i = 1; i < nums.length; i++) { // 当前元素比上一个元素大，当前为上坡，并且上一次是下坡，则符合摆动序列 if (nums[i] > nums[i - 1] && (flag == 0 || flag == -1)) { sum++; flag = 1; } else if (nums[i] < nums[i - 1] && (flag == 0 || flag == 1)) { // 当前元素比上一个元素小，当前是下坡，并且上一个是上坡，则符合摆动序列 sum++; flag = -1; } } return sum; } } \"]},\"347\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\",\"子数组 是数组中的一个连续部分。\",\"示例 1：\",\"输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 \",\"示例 2：\",\"输入：nums = [1] 输出：1 \",\"示例 3：\",\"输入：nums = [5,4,-1,7,8] 输出：23 \",\"提示：\",\"1 <= nums.length <= 105\",\"-104 <= nums[i] <= 104\",\"**进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\"]},\"348\":{\"h\":\"思路分析\",\"t\":[\"贪心算法\",\"对于求最大子数组和，毫无疑问负数会拉低 最大的和。\",\"假设我们用 count 保存子数组和，如果 count +nums[i] 出现 <= 0 的情况, 就立马舍弃 下标为 i 的元素，重新找 最大子数组 起始点。\",\"在舍弃之前，我们还需要进行判断，万一 count 就是最大子数组的和呢？ 因此我们还需要一个变量 res 来记录最大子数组的和。\",\" res = Math.max(count,res); \",\"完整代码\",\" public int maxSubArray(int[] nums) { // 记录最终结果 int res = Integer.MIN_VALUE; // 记录子数组和 int count = 0; for (int i = 0; i < nums.length; i++) { count+=nums[i]; res = Math.max(count,res); if (count <= 0) count = 0; // 如果当前count为负数了,将count进行重置。继续找下一个子数组的起始点。 } return res; } \"]},\"349\":{\"h\":\"\",\"t\":[\"给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\",\"判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\",\"示例 1：\",\"输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 \",\"示例 2：\",\"输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 \",\"提示：\",\"1 <= nums.length <= 104\",\"0 <= nums[i] <= 105\"]},\"350\":{\"h\":\"思路分析\",\"t\":[\"注意题目中这句话：数组中的每个元素代表你在该位置可以跳跃的最大长度。\",\"也就是说，假如元素等于3，可以选择跳1步，也可以选择跳2步、3步\",\"既然如此，我们可以将 nums 数组每个元素的能够跳的最远距离都计算一遍，用一个变量保存。 如果能跳到最后就说明成功了。\",\" public boolean canJump(int[] nums) { int cover = 0; // 把每一个位置都做为起跳点试一下 for (int i = 0; i < nums.length; i++) { // i>cover 说明 i的位置比最远距离还要远，因此永远也到不了 if (i > cover) return false; // i+nums[i]当前位置能够到达的最远距离，不断进行更新 cover = Math.max(cover,i+nums[i]); } return true; } \",\"优化\",\"上面是将所有的起跳点都尝试一遍，但如果当最大距离大于数组的长度了，就没有必要在继续尝试了\",\" public boolean canJump(int[] nums) { int cover = 0; // 把每一个位置都做为起跳点试一下 for (int i = 0; i < nums.length; i++) { // i>cover 说明 i的位置比最远距离还要远，因此永远也到不了 if (i > cover) return false; // i+nums[i]当前位置能够到达的最远距离，不断进行更新 cover = Math.max(cover,i+nums[i]); // 最远位置超过了数组长度，就没有必要在继续尝试了 if(cover >= nums.length-1) return true; } return true; } \",\"另一种思想\",\"我们以第一个元素为起跳点，然后在第一个元素所能覆盖的范围内，找到每一个元素能够跳跃的最远距离。如果在此范围内，最远距离仍然不能覆盖整个数组，即到不了终点。\",\" public boolean canJump1(int[] nums) { if (nums.length == 1) return true; int cover = 0; for (int i = 0; i <= cover; i++) { // 更新在cover范围内每个元素能够到达的最远距离 cover = Math.max(cover, i + nums[i]); if (cover >= nums.length - 1) return true; } return false; } \"]},\"351\":{\"h\":\"\",\"t\":[\"给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\",\"每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\",\"0 <= j <= nums[i]\",\"i + j < n\",\"返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\",\"示例 1:\",\"输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 \",\"示例 2:\",\"输入: nums = [2,3,0,1,4] 输出: 2 \",\"提示:\",\"1 <= nums.length <= 104\",\"0 <= nums[i] <= 1000\",\"题目保证可以到达 nums[n-1]\"]},\"352\":{\"h\":\"思路分析\",\"t\":[\"这道题相较于 55 的难点就是要统计 跳跃的次数 。\",\"我们可以利用俩个变量：\",\"curDistance：用来记录当前位置能够覆盖的最远距离\",\"nextDistance：用来记录下一步能够覆盖的元素距离\",\"当 i 指针指向 curDistance 时，即 i == curDistance，就说明已经走到当前位置能够覆盖的最远距离了，需要进行下一个跳跃。因此将 curDistance 更新为 nextDistance，相当于进行了一次跳跃。这个操作是为了确保我们在每一步都选择能够使下一步覆盖的范围最大化的位置。\",\" public int jump(int[] nums) { if (nums.length == 1) return 0; // 下一步覆盖的最大范围 int nextDistance = 0; // 当前位置覆盖的最大范围 int curDistance = 0; // 跳跃次数 int step = 0; for (int i = 0; i < nums.length; i++) { // 不断更新下一步所覆盖的最大范围 nextDistance = Math.max(nextDistance,i+nums[i]); // 如果i到了当前位置的最大范围，说明需要进行下一次跳跃。将当前位置所覆盖的范围更新为下一步覆盖的范围 if (i == curDistance){ step++; curDistance = nextDistance; if (nextDistance >= nums.length) return step; } } return step; } \"]},\"353\":{\"h\":\"\",\"t\":[\"给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：\",\"选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。\",\"重复这个过程恰好 k 次。可以多次选择同一个下标 i 。\",\"以这种方式修改数组后，返回数组 可能的最大和 。\",\"示例 1：\",\"输入：nums = [4,2,3], k = 1 输出：5 解释：选择下标 1 ，nums 变为 [4,-2,3] 。 \",\"示例 2：\",\"输入：nums = [3,-1,0,2], k = 3 输出：6 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 \",\"示例 3：\",\"输入：nums = [2,-3,-1,5,-4], k = 2 输出：13 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 \",\"提示：\",\"1 <= nums.length <= 104\",\"-100 <= nums[i] <= 100\",\"1 <= k <= 104\"]},\"354\":{\"h\":\"思路分析\",\"t\":[\"想要求得 可能的最大和，那我们尽可能的去反转绝对值较大的负数 ，若没有负数或者反转完 k 还有剩余，那我们尽可能反转较小的数。这俩步就是我们局部最优解。\",\"首先我们对数组按照绝对值进行升序\",\"从头到尾依次进行反转并且k-- ，反转的条件就是 必须是负数。正数反转没有意义\",\"反转完，若 k 还有剩余 \",\"若k最后为奇数，将数组最后一个元素，也就是最小的值进行反转。\",\"若k最后为偶数个，不用进行反转了，因为反转偶数次仍然是它本身。\",\"最后求和\",\" public int largestSumAfterKNegations(int[] nums, int k) { // 局部最优：对元素为负数并且绝对值较大的元素进行取反 // 根据绝对值大小，进行排序 nums = Arrays.stream(nums).boxed().sorted((a,b) -> Math.abs(b) - Math.abs(a)).mapToInt(Integer::intValue).toArray(); for (int i = 0; i < nums.length; i++) { // 将绝对值较大的负数进行反转 if (nums[i] < 0 && k > 0) { nums[i] = -nums[i]; k--; } } // 若k还有剩余，将最小的数进行反转 // k %2 == 1 判断是奇数还是偶数，偶数次反转等于它本身 if (k %2 == 1) nums[nums.length -1 ] = - nums[nums.length -1 ]; // 求和 return Arrays.stream(nums).sum(); } \"]},\"355\":{\"h\":\"\",\"t\":[\"在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\",\"你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\",\"给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\",\"示例 1:\",\"输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 \",\"示例 2:\",\"输入: gas = [2,3,4], cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。 \",\"提示:\",\"gas.length == n\",\"cost.length == n\",\"1 <= n <= 105\",\"0 <= gas[i], cost[i] <= 104\"]},\"356\":{\"h\":\"思路分析\",\"t\":[\"首先我们要知道，要想环绕走一圈，那么不管经过哪个加油站，油箱的剩余油量必然是 >= 0， 并且走完一圈后，油箱的总剩余油量一定是 >= 0\",\"假设我用 remain 表示从起始点到当前加油站所剩余油量\",\"total 表示总的剩余油量\",\"那么就有：remain += gas[i] - cost[i] ，total += gas[i] - cost[i]\",\"那么对于 remain 无非就有俩种情况：\",\"remain < 0 : 此时油量不足，也就是说无论从 [0,i] 哪个加油站开始走，到第 i 个加油站时，油量一定是不足的。 因此我们就可以假设将起始点设在 i+1 的加油站。假设用 start 表示，那么就有 start = i+1 ，同时将 remain 置0，重新从下一个加油站开始累加。\",\"remain >= 0 , 此时油量充足，继续向下一个加油站走\",\"遍历完得到的 total >=0 ，那么起始点就是我们记录的 start ，若 <0 则说明无解\",\" public int canCompleteCircuit(int[] gas, int[] cost) { int remain = 0; // 到当前加油站所剩油量 int total = 0; // 总剩余油量 int start = 0; // 起始点 for (int i = 0; i < gas.length; i++) { // 记录经过每个加油站时所剩余的油量 remain += gas[i] - cost[i]; // 记录总的剩余油量，如果i为起始点，可以走完一圈，那么 total 必然是 >=0的 total +=gas[i] - cost[i]; if (remain < 0) { // 经过当前加油站时，油量不够,说明[0,i] 这区间内的加油站都不能作为起始点。因此更新新的起始点 start = i+1; remain = 0; } } // total<0不能走完一圈 return total < 0 ? -1 : start; } \"]},\"357\":{\"h\":\"\",\"t\":[\"在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\",\"每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\",\"注意，一开始你手头没有任何零钱。\",\"给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\",\"示例 1：\",\"输入：bills = [5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 \",\"示例 2：\",\"输入：bills = [5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 \",\"提示：\",\"1 <= bills.length <= 105\",\"bills[i] 不是 5 就是 10 或是 20\"]},\"358\":{\"h\":\"思路分析\",\"t\":[\"对于该题无非有三种情况：\",\"收到5元，直接收下\",\"收到10元，找回5元\",\"收到20元，优先找：10+5，若10不够则找 3个5元 \",\"为什么要先找10+5呢？ 这是因为10元只能找给20元，而5元则比较万能，这也是贪心的局部最优解\",\" public boolean lemonadeChange(int[] bills) { int five = 0; // 记录5元的张数 int ten = 0; // 记录10元的张数 for (int i = 0; i < bills.length; i++) { if (bills[i] == 5){ // 5元直接收下 five++; }else if (bills[i] == 10) { // 10元：收下10元，找回5元 ten++; five--; }else if (ten > 0) { // 20的情况: 若有面额为10的，优先使用10+5 ten--; five--; }else { // 如果没有10，就使用3张5元 five -= 3; } if (five < 0) return false; } return true; } \"]},\"359\":{\"h\":\"\",\"t\":[\"n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\",\"你需要按照以下要求，给这些孩子分发糖果：\",\"每个孩子至少分配到 1 个糖果。\",\"相邻两个孩子评分更高的孩子会获得更多的糖果。\",\"请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\",\"示例 1：\",\"输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 \",\"示例 2：\",\"输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 \",\"提示：\",\"n == ratings.length\",\"1 <= n <= 2 * 104\",\"0 <= ratings[i] <= 2 * 104\"]},\"360\":{\"h\":\"思路分析\",\"t\":[\"其实我觉着这道题最不好理解的就是这句话：相邻两个孩子评分更高的孩子会获得更多的糖果。\",\"原本我以为将 ratings 数组遍历一遍，只要不相等就将糖果数量+1，结果不出所料....没这么简单。\",\"我们不仅要比较孩子的左边，还要比较孩子的右边，假设当前孩子的评分是相邻之间最高的，就要保证当前孩子获得的糖果比左右俩边的孩子都要多。\",\"因此我们要进行俩次遍历：\",\"第一次遍历从前往后，只比较 当前孩子 和 左孩子 的评分 ，如果 当前孩子 > 左孩子 ， 将 左孩子 的糖果+1 作为 当前孩子 糖果的数量\",\"candies[] 为每个孩子所需要糖果的数量，初始化都为1\",\" // 从前往后遍历: 若右边孩子分数 > 左边孩子的分数，保证右边孩子的糖果数量 > 左边孩子糖果数量 for (int i = 1; i < ratings.length; i++) { if (ratings[i] > ratings[i - 1]) { candies[i] = candies[i - 1] + 1; } } \",\"第二次遍历从后往前，比较 当前孩子 和右孩子，若 当前孩子 > 右孩子，此时有俩种选择：\",\"第一种选择：将右孩子的糖果数量+1作为 当前孩子 的糖果数量\",\"第二种选择：将第一次遍历得到的当前孩子糖果数量作为值\",\"此时在这俩种选择当中，我们就要选择较大的值，这样才能保证 当前孩子 比左、右孩子获得的糖果数量都多。\",\" // 从后往前遍历：若当前孩子分数 > 右边孩子的分数，保证当前孩子的糖果数量 > 右边孩子糖果数量 && 当前孩子的糖果数量 > 左边孩子的糖果数量 for (int i = ratings.length - 2; i >= 0; i--) { if (ratings[i] > ratings[i + 1]) { // 此时如果当前孩子 > 右，有俩个选择 // 1、选择将右孩子的糖果+1 2、选择将当前孩子的糖果(candies[i]是从前往后比较当前孩子>左孩子得到的) // 此时就要进行贪心选择，尽量选择最大的，保证当前孩子既比左孩子多又比右孩子多 candies[i] = Math.max(candies[i + 1] + 1,candies[i]); } } \",\"最后统计 candies 总和，即总共需要的糖果数量\",\" public int candy(int[] ratings) { // 记录每个学生所需要的糖果数 int[] candies = new int[ratings.length]; // 保证每个学生至少能够分到1个糖果 Arrays.fill(candies, 1); // 从前往后遍历: 若 当前孩子分数 > 左边孩子的分数，保证当前孩子的糖果数量 > 左边孩子糖果数量 for (int i = 1; i < ratings.length; i++) { if (ratings[i] > ratings[i - 1]) { candies[i] = candies[i - 1] + 1; } } // 从后往前遍历：若当前孩子分数 > 右边孩子的分数，保证当前孩子的糖果数量 > 右边孩子糖果数量 for (int i = ratings.length - 2; i >= 0; i--) { if (ratings[i] > ratings[i + 1]) { // 此时如果当前孩子 > 右，有俩个选择 // 1、选择将右孩子的糖果+1 2、选择将当前孩子的糖果(candies[i]是从前往后比较当前孩子>左孩子得到的) // 此时就要进行贪心选择，尽量选择最大的，保证当前孩子既比左孩子多又比右孩子多 candies[i] = Math.max(candies[i + 1] + 1,candies[i]); } } // 统计所需糖果数量 return Arrays.stream(candies).sum(); } \"]},\"361\":{\"h\":\"\",\"t\":[\"假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\",\"请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\",\"示例 1：\",\"输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 \",\"示例 2：\",\"输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] \",\"提示：\",\"1 <= people.length <= 2000\",\"0 <= hi <= 106\",\"0 <= ki < people.length\",\"题目数据确保队列可以被重建\"]},\"362\":{\"h\":\"思路分析\",\"t\":[\"这道题和135. 分发糖果有点类似，都是通过来个纬度来确定。像这种题，我们一定要先确定一个纬度，然后在确定另一个纬度。\",\"像135. 分发糖果 我们就是先从前往后遍历，确定 当前孩子 和 右孩子，然后从后往前，确定当前孩子 和 左孩子。\",\"那么对于这道题来说，我们先确定 h 还是 k 呢？\",\"如果我们先确定 k 的话，从大到小排列之后，会发现并不符合题意，和没确定一样。\",\"我们要确定 h 的话，至少我们能够确定身高一定是从大到小，让高个子在前面。若身高相同，根据k进行升序。\",\"身高排好序之后，我们就可以利用 k 作为 下标去进行插入了。\",\"举例说明\",\"排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]\",\"插入的过程：\",\"插入[7,0]：[[7,0]]\",\"插入[7,1]：[[7,0],[7,1]]\",\"插入[6,1]：[[7,0],[6,1],[7,1]]\",\"插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]\",\"插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]\",\"插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\",\"规则：\",\"根据 h 进行降序，若 h 相同，根据 k 升序\",\"排序完之后，根据 k 的值进行插入\",\" public int[][] reconstructQueue(int[][] people) { // 根据身高进行从大到小排序 // a[0] 表示h，a[1]表示k，按照身高大小降序,身高相同，按照k升序 Arrays.sort(people,(a,b) -> { if (a[0] == b[0]) return a[1] - b[1]; return b[0] - a[0]; }); LinkedList<int[]> que = new LinkedList<>(); // 按照k的值进行插入,将k作为index插入 for (int[] person : people) { que.add(person[1],person); } return que.toArray(new int[people.length][]); } \"]},\"363\":{\"h\":\"\",\"t\":[\"有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。\",\"一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\",\"给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\",\"示例 1：\",\"输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。 -在x = 11处发射箭，击破气球[10,16]和[7,12]。 \",\"示例 2：\",\"输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要4支箭。 \",\"示例 3：\",\"输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: - 在x = 2处发射箭，击破气球[1,2]和[2,3]。 - 在x = 4处射出箭，击破气球[3,4]和[4,5]。 \",\"提示:\",\"1 <= points.length <= 105\",\"points[i].length == 2\",\"-231 <= xstart < xend <= 231 - 1\"]},\"364\":{\"h\":\"思路分析\",\"t\":[\"好多人再看到题目时是懵逼得，这要干嘛？其实有了图之后就很清晰了。\",\"拿第一个例子来说：points = [[10,16],[2,8],[1,6],[7,12]]\",\"image-20231221220346622\",\"图中的每一个矩形都代表一个气球(直径)，想要用最少的箭射穿最多的气球，其实就是让气球尽可能的重叠。\",\"因此为了尽可能的让气球重叠，我们需要进行排序，那么这道题是根据start 还是 end 排序呢？\",\"其实都可以，无非就是处理方式有一些不一样，先以end来说，如图所示：\",\"先根据 end 进行升序\",\"每一箭我们都从 气球的尾端 射出（这是为了尽可能覆盖多的气球。），并且记录end值。\",\"只要气球的尾端 > end ，就需要重新射一箭，并记录 end\",\"image-20231221222403573\",\" public int findMinArrowShots(int[][] points) { // 根据end进行升序 Arrays.sort(points,(a,b) -> Integer.compare(a[1],b[1])); // 记录每一箭的end值，第一箭从第一个气球的尾端开始 int end = points[0][1]; // 需要的箭数 int count = 1; for (int i = 1; i < points.length; i++) { if (points[i][0] > end) { // 从第二个气球开始，如果气球的尾端 > end,说明需要重新射一箭 count++; // 更新end end = points[i][1]; } } return count; } \",\"对 start 进行降序\",\"此时就不是从气球的尾端射出，而是从首端(start)射出\",\"判断 气球的尾端 < start ，说明需要重新射一箭\",\"image-20231221223229285\",\" public int findMinArrowShots1(int[][] points) { // 根据start进行降序 Arrays.sort(points,(a,b) -> Integer.compare(b[0],a[0])); // 记录每一箭的开始位置，第一箭从第一个气球的首端开始 int start = points[0][0]; int count = 1; for (int i = 1; i < points.length; i++) { if (points[i][1] < start) { // 如果气球的尾端 < end,说明需要重新射一箭 count++; // 更新开始位置 start = points[i][0]; } } return count; } \"]},\"365\":{\"h\":\"\",\"t\":[\"给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\",\"示例 1:\",\"输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 \",\"示例 2:\",\"输入: intervals = [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 \",\"示例 3:\",\"输入: intervals = [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 \",\"提示:\",\"1 <= intervals.length <= 105\",\"intervals[i].length == 2\",\"-5 * 104 <= starti < endi <= 5 * 104\"]},\"366\":{\"h\":\"思路分析\",\"t\":[\"这道题和 452. 用最少数量的箭引爆气球 非常像，我们仍然先对 start 进行升序\",\"intervals = [[1,2],[2,3],[3,4],[1,3]] \",\"image-20231221230308320\",\"从图中可以直观的看见，只要将 [1,3]区间去掉就行了，但是在代码中如何展示呢？\",\"和引爆气球一样，我们仍然使用一个变量记录一个区间的 尾端，假设我用end\",\"只要区间的start < end ，就说名此时俩个区间重叠了。此时更新 end 我们尽量更新较小的值，因为这样我们才能拼接更多的区间 \",\"比如：在判断第二个区间 [1,3] 时，如果我们将 end 更新为 3，那么循环到 [2,3] 时，也是冲突的，这就需要去掉2个区间了，明显不是最少的\",\"当不重叠时，我们将 end 更新为当前区间的 end即可\",\" public int eraseOverlapIntervals(int[][] intervals) { // 对start升序 Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0])); // 记录移除的区间 int count = 0; // 从第一个区间开始，记录其尾端的值 int end = intervals[0][1]; for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] < end){ // 发生重叠，这里我们要尽量取得end值小的，这样才能拼接更多的区间 end = Math.min(end,intervals[i][1]); count++; }else { // 没有发生重叠，则直接更新尾端值 end = intervals[i][1]; } } return count; } \"]},\"367\":{\"h\":\"\",\"t\":[\"给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\",\"注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。\",\"返回一个表示每个字符串片段的长度的列表。\",\"示例 1：\",\"输入：s = \\\"ababcbacadefegdehijhklij\\\" 输出：[9,7,8] 解释： 划分结果为 \\\"ababcbaca\\\"、\\\"defegde\\\"、\\\"hijhklij\\\" 。 每个字母最多出现在一个片段中。 像 \\\"ababcbacadefegde\\\", \\\"hijhklij\\\" 这样的划分是错误的，因为划分的片段数较少。 \",\"示例 2：\",\"输入：s = \\\"eccbbbbdec\\\" 输出：[10] \",\"提示：\",\"1 <= s.length <= 500\",\"s 仅由小写英文字母组成\"]},\"368\":{\"h\":\"思路分析\",\"t\":[\"用一个数组记录每个字母出现的最远下标\",\"当遍历到这个最远下标时，就说明到了一个切割点\",\"class Solution { public List<Integer> partitionLabels(String s) { ArrayList<Integer> res = new ArrayList<>(); int[] maxDistance = new int[26]; char[] chars = s.toCharArray(); // 保存每个字符的最远下标 for (int i = 0; i < chars.length; i++) { maxDistance[chars[i] - 'a'] = i; } // 记录当前遍历时，每个字母的最远距离 int currIndex = 0; // 记录上一个区间的结束索引 int lastIndex = -1; for (int i = 0; i < chars.length; i++) { // 获取当前字母的最远距离 currIndex = Math.max(currIndex,maxDistance[chars[i] - 'a']); if (currIndex == i) { // 当遍历到某个字母的最远距离时，则到了分割点 res.add(i - lastIndex); lastIndex = i; } } return res; } } \"]},\"369\":{\"h\":\"\",\"t\":[\"当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。\",\"给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。\",\"示例 1:\",\"输入: n = 10 输出: 9 \",\"示例 2:\",\"输入: n = 1234 输出: 1234 \",\"示例 3:\",\"输入: n = 332 输出: 299 \",\"提示:\",\"0 <= n <= 109\"]},\"370\":{\"h\":\"思路分析\",\"t\":[\"遍历某个数字时，假设当前数字比前一个数字大时，说明不满足递增了。比如： 332 遍历到 3 和2 时，首先想到的就是 将 3-1 变成 2，然后 2 变成 9 ，32 变成 29 就符合条件了。\",\"那么我们是从前往后遍历，还是从后往前遍历？\",\"如果是从前往后遍历的话，拿332举例，他最后得 329 并不是单调递增的数字。\",\"因此我们要从后往前 ，最后得 299\",\" public int monotoneIncreasingDigits(int n) { String s = String.valueOf(n); char[] chars = s.toCharArray(); // 记录需要变成9的起始位置 int start = s.length(); // 从后往前遍历：若当前数字比后一个数字大，就让当前数字-1，后面所有的都变成9. for (int i = chars.length - 2; i >= 0; i--) { if (chars[i] > chars[i+1]) { chars[i]--; start = i+1; } } for (int i = start; i < chars.length; i++) { chars[i] = '9'; } return Integer.parseInt(String.valueOf(chars)); } \"]},\"371\":{\"h\":\"\",\"t\":[\"给定一个二叉树，我们在树的节点上安装摄像头。\",\"节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\",\"计算监控树的所有节点所需的最小摄像头数量。\",\"示例 1：\",\"img\",\"输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 \",\"示例 2：\",\"img\",\"输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 \",\"提示：\",\"给定树的节点数的范围是 [1, 1000]。\",\"每个节点的值都是 0。\"]},\"372\":{\"h\":\"思路分析\",\"t\":[\"根据题意我们可以得知，想要使摄像头数量少，尽量将摄像头放在非叶子节点上，这样能尽可能的监控多个结点。通过上面图片也可以得知，每隔俩个结点就会放一个监控。\",\"这道题的大体思路就是从下到上将叶子结点的父节点放上监控，然后每隔俩个结点放一个监控。\",\"二叉树的遍历\",\"如何隔两个节点放一个摄像头\",\"从下向上遍历我们可以采用后序遍历，即 左右根\",\"int traversal(TreeNode* cur) { // 空节点，该节点有覆盖 if (终止条件) return ; int left = traversal(cur->left); // 左 int right = traversal(cur->right); // 右 逻辑处理 // 中 return ; } \",\"如何隔两个节点放一个摄像头\",\"此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！\",\"来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：\",\"有如下三种：\",\"该节点无覆盖\",\"本节点有摄像头\",\"本节点有覆盖\",\"我们分别有三个数字来表示：\",\"0：该节点无覆盖\",\"1：本节点有摄像头\",\"2：本节点有覆盖\",\"其中无摄像头就是 有覆盖或者无覆盖的状态。还有一个问题就是如果节点为空，那么应该是什么状态？\",\"如果空结点是无覆盖，那么叶子结点就应该放置一个摄像头，这种情况是不对的，其次如果是有摄像头的状态，那叶子结点的父节点就没有必要放置摄像头了，这种情况也不对。因此空结点只能是有覆盖的状态\",\"情况1：左右节点都有覆盖\",\"左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。\",\"968.监控二叉树2\",\"// 左右节点都有覆盖 if (left == 2 && right == 2) return 0; \",\"情况二：左右节点至少有一个是无覆盖的情况，那么此时父节点就应该放置一个摄像头\",\"if (left == 0 || right == 0) { result++; return 1; } \",\"情况三：左右节点至少有一个有摄像头，此时父节点就是有覆盖的状态\",\"if (left == 1 || right == 1) return 2; \",\"情况四：头结点无覆盖的情况，那么头结点也应该放置一个摄像头\",\"递归结束后，还要判断头结点的覆盖状态\",\"int minCameraCover(TreeNode* root) { result = 0; if (traversal(root) == 0) { // root 无覆盖 result++; } return result; } \",\"完整代码\",\"class Solution { int res=0; public int minCameraCover(TreeNode root) { // 对根节点的状态做检验,防止根节点是无覆盖状态 . if(minCame(root)==0){ res++; } return res; } /** 节点的状态值： 0 表示无覆盖 1 表示 有摄像头 2 表示有覆盖 后序遍历，根据左右节点的情况,来判读 自己的状态 */ public int minCame(TreeNode root){ if(root==null){ // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 return 2; } int left=minCame(root.left); int right=minCame(root.right); // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头 if(left==2&&right==2){ //(2,2) return 0; }else if(left==0||right==0){ // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头 // (0,0) (0,1) (0,2) (1,0) (2,0) // 状态值为 1 摄像头数 ++; res++; return 1; }else{ // 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头， // 那么本节点就是处于被覆盖状态 return 2; } } } \"]},\"373\":{\"c\":[\"算法\"]},\"374\":{\"c\":[\"贪心\"]},\"375\":{\"h\":\"链表\"},\"376\":{\"h\":\"\",\"t\":[\"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\",\"示例 1：\",\"img\",\"输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] \",\"示例 2：\",\"输入：head = [], val = 1 输出：[] \",\"示例 3：\",\"输入：head = [7,7,7,7], val = 7 输出：[] \",\"提示：\",\"列表中的节点数目在范围 [0, 104] 内\",\"1 <= Node.val <= 50\",\"0 <= val <= 50\"]},\"377\":{\"h\":\"思路分析\",\"t\":[\"原理很简单：遍历链表，找到与val相等的结点，删除结点即可，即：$node.next = node.next.next$\",\"但是需要注意的是，如果删除的是头结点，那么和其他结点是不一样，其他结点可以通过 $上一结点.next$ 获得，而单链表中的头结点就不行了。\",\"那么如何让头结点和其他结点保持一样的操作呢？\",\"可以设置一个虚拟头结点， 这个虚拟头结点指向头结点，这样头结点和其他结点的操作都一致了。都可以通过 $上一结点.next$ 获得。\",\"头结点的上一结点就是虚拟头结点，当然我们可以在设置一个临时结点等于虚拟头结点 ，用来遍历\",\"image-20231008215639908\"]},\"378\":{\"h\":\"代码实现\",\"t\":[\" public static ListNode removeElements(ListNode head, int val) { /* * 需要留意的是： * 如果删除头结点是和其他结点不一样的，其他结点可以从上一结点获取，但是头结点就无法获取 * 那么如何让头结点和其他结点保持一样的处理方式呢？ * 增加一个虚拟头结点，指向头结点 * */ // 增加虚拟头结点 ListNode dummyHead = new ListNode(); dummyHead.next = head; // 使用一个临时结点，用来遍历，删除结点 ListNode p = dummyHead; while(p.next != null) { if (p.next.val == val) { // 删除的结点 p.next = p.next.next; }else { // 移动结点 p = p.next; } } // 返回头结点 return dummyHead.next; } \"]},\"379\":{\"h\":\"\",\"t\":[\"有一个单链表的 head，我们想删除它其中的一个节点 node。\",\"给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。\",\"链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。\",\"删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：\",\"给定节点的值不应该存在于链表中。\",\"链表中的节点数应该减少 1。\",\"node 前面的所有值顺序相同。\",\"node 后面的所有值顺序相同。\",\"自定义测试：\",\"对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。\",\"我们将构建链表，并将节点传递给你的函数。\",\"输出将是调用你函数后的整个链表。\",\"示例 1：\",\"img\",\"输入：head = [4,5,1,9], node = 5 输出：[4,1,9] 解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9 \",\"示例 2：\",\"img\",\"输入：head = [4,5,1,9], node = 1 输出：[4,5,9] 解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9 \",\"提示：\",\"链表中节点的数目范围是 [2, 1000]\",\"-1000 <= Node.val <= 1000\",\"链表中每个节点的值都是 唯一 的\",\"需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点\",\" public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } \"]},\"380\":{\"h\":\"\",\"t\":[\"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\",\"示例 1：\",\"img\",\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \",\"示例 2：\",\"img\",\"输入：head = [1,2] 输出：[2,1] \",\"示例 3：\",\"输入：head = [] 输出：[] \",\"提示：\",\"链表中节点的数目范围是 [0, 5000]\",\"-5000 <= Node.val <= 5000\"]},\"381\":{\"h\":\"思路分析\",\"t\":[\"思路很简单，无非就是修改指针。即：\",\"原来：$pre.next = cur;$\",\"反转：$cur.next = pre$\",\"cur 表示当前结点，pre表示上一结点\",\"唯一的问题是，我们如何找到当前结点与上一结点，只有都表示出来，我们才能修改指针。这时我们就可以采用双指针的方法，一个 pre指向上一结点，一个cur指向当前结点，不断移动双指针，并更改指针方向。\",\"注意：下图中演示的是cur先移动，但实际上应该pre先移动。\",\"img\"]},\"382\":{\"h\":\"代码实现\",\"t\":[\" public static ListNode reverseList(ListNode head) { // 处理特殊情况 if (head == null || head.next == null) return head; /* * 反转链表无非就是更改指针的方向，即： * 原来：pre.next = cur; * 反转：cur.next = pre * 但是对于单链表来说，获取下一结点很容易，但是获取上一个结点就不容易了，因此我们可以考虑额外使用一个指针，指向当前结点的上一结点 * 我们不断移动上一结点和当前结点，并更换俩者的指针方向 * */ // 指向当前结点 ListNode cur = head; // 上一结点 ListNode pre = null; // 使用一个临时结点用于移动结点 ListNode temp = null; while(cur != null) { // 先保存要移动到的结点，避免被覆盖 temp = cur.next; // 反转，改变指针方向 cur.next = pre; // 移动结点 // 这里一定要先移动 pre，为什么呢？ // 如果先移动 cur 的话，此时cur和pre指向的都是当前结点，自己指向自己，这不乱套了~~ pre = cur; cur = temp; } // 结束循环后，cur=null，因此返回它的上一结点pre，此时pre就是反转后的头结点 return pre; } \"]},\"383\":{\"h\":\"\",\"t\":[\"给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\",\"示例 1：\",\"img\",\"输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] \",\"示例 2：\",\"输入：head = [5], left = 1, right = 1 输出：[5] \",\"提示：\",\"链表中节点数目为 n\",\"1 <= n <= 500\",\"-500 <= Node.val <= 500\",\"1 <= left <= right <= n\",\"进阶： 你可以使用一趟扫描完成反转吗？\"]},\"384\":{\"h\":\"思路分析\",\"t\":[\"采用 “头插法” ，找到 待反转的第一个结点start ， 将 start.next 插入到 start 的前面，也就是 pre.next\",\"image-20240312230102351\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 定义虚拟结点 ListNode dummyNode = new ListNode(); dummyNode.next = head; // 指向带反转结点的前一个结点 ListNode pre = dummyNode; // 指向第一个待反转结点 ListNode start = dummyNode.next; // 首先先找到第一个反转结点和反转结点的前一个结点 for (int i = 1; i < left; i++) { pre = pre.next; start = start.next; } // 从start开始反转 for (int i = left; i < right; i++) { // 先保存下一个结点，避免被覆盖 ListNode next = start.next; // 完成第一条线 start.next = next.next; // 完成第二条线 next.next = pre.next; // 完成第三条线 pre.next = next; } return dummyNode.next; } } \"]},\"385\":{\"h\":\"\",\"t\":[\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\",\"示例 1：\",\"img\",\"输入：head = [1,2,3,4] 输出：[2,1,4,3] \",\"示例 2：\",\"输入：head = [] 输出：[] \",\"示例 3：\",\"输入：head = [1] 输出：[1] \",\"提示：\",\"链表中节点的数目在范围 [0, 100] 内\",\"0 <= Node.val <= 100\"]},\"386\":{\"h\":\"思路分析\",\"t\":[\"根据题目可以得知，每俩个结点的操作是一样的，换句话说，每一个子问题的处理方式都一样。因此我们可以考虑使用递归\",\"使用递归的时候，一定不要深究其细节，不然很容易懵的，我们只需要考虑其中一个小问题，问题自然解决。\",\"递归三部曲：\",\"终止条件\",\"返回值\",\"每一次调用做了什么\",\"终止条件： 只有俩个或者俩个以上的结点我们才可以交换，因此当 只有一个或者没有结点的时候，就可以终止了。即：$head == null || head.next == null$\",\"返回值： 返回值为交换完链表新的 头结点\",\"每一次调用做了什么：\",\"俩个结点交换时，新的头结点一直是第二个。设需要交换的两个点为 head 和 newHead，head 连接后面交换完成的子链表，newHead 连接 head，完成交换\",\"image-20231010151845350\"]},\"387\":{\"h\":\"代码实现\",\"t\":[\"public static ListNode swapPairs(ListNode head) { // 只有一个结点时 if (head == null || head.next == null) return head; // 临时保存下一个即将要交换的头结点 ListNode nextHead = head.next.next; // 进行交换 // 新的头结点，每次交换完，头结点都是第二个 ListNode newHead = head.next; newHead.next = head; // swapPairs(nextHead); 反转后的头结点 // head.next指向交换后后的结点 head.next = swapPairs(nextHead); // 返回新的头结点 return newHead; } \"]},\"388\":{\"h\":\"\",\"t\":[\"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\",\"示例 1：\",\"img\",\"输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] \",\"示例 2：\",\"输入：head = [1], n = 1 输出：[] \",\"示例 3：\",\"输入：head = [1,2], n = 1 输出：[1] \",\"提示：\",\"链表中结点的数目为 sz\",\"1 <= sz <= 30\",\"0 <= Node.val <= 100\",\"1 <= n <= sz\"]},\"389\":{\"h\":\"思路分析\",\"t\":[\"该题我们可以采用双次遍历的方法：\",\"第一次遍历，记录链表的个数\",\"第二次遍历，找到 被删除结点 的前一个结点\",\"假设找到的被删除结点的前一个结点为 temp，则进行删除操作为 $temp.next = temp.next.next$\",\"需要注意的是，有可能会删除头结点，因此为了保证头结点能和其他结点保持一致的操作，采用 虚拟结点 的方式\",\"代码实现\",\" public static ListNode removeNthFromEnd(ListNode head, int n) { // 处理特殊情况 if (head == null || head.next == null) return null; // 虚拟结点 ListNode dummyHead = new ListNode(); dummyHead.next = head; // 第一次遍历记录链表的长度 ListNode temp = head; int length = 0; while (temp != null) { length++; temp = temp.next; } // 第二次遍历找到被删除结点的前一个结点 length = length - n; temp = dummyHead; while (length > 0) { temp = temp.next; length--; } // 删除结点 temp.next = temp.next.next; return dummyHead.next; } \"]},\"390\":{\"h\":\"\",\"t\":[\"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\",\"图示两个链表在节点 c1 开始相交**：**\",\"img\",\"题目数据 保证 整个链式结构中不存在环。\",\"注意，函数返回结果后，链表必须 保持其原始结构 。\",\"示例 1：\",\"img\",\"输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 \",\"示例 2：\",\"img\",\"输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 \",\"示例 3：\",\"img\",\"输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 \",\"提示：\",\"listA 中节点数目为 m\",\"listB 中节点数目为 n\",\"0 <= m, n <= 3 * 104\",\"1 <= Node.val <= 105\",\"0 <= skipA <= m\",\"0 <= skipB <= n\",\"如果 listA 和 listB 没有交点，intersectVal 为 0\",\"如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\"]},\"391\":{\"h\":\"思路分析\",\"t\":[\"首先要知道相交的结点并不是根据结点的值相等而来的，而是要判断结点的内存地址，因此在Java中我们可以直接用 \\\"==\\\" 来判断相交的结点。\",\"所以如何找到内存地址相等的结点成为关键，可以采用快慢双指针的方法。\",\"双指针\",\"假设用 pA 指针初始指向 headA，pB 指向 headB，然后同时更新pA、pB，更新方法如下：\",\"如果pA指针为null，就移动到headB的头结点，否则就移动到headA的下一个结点\",\"如果pB指针为null，就移动到headA的头结点，否则就移动到headB的下一个结点\",\"最终pA和pB相遇的位置就是相交的结点\",\"为什么要这么移动呢？\",\"通过题目我们可以得知，对于俩个链表的相交结点的后面的结点个数是一样的，假设我们设为 c，而headA相交结点前的结点个数为a，headB相交结点前的结点个数为 b。\",\"这里只讨论headA与headB长度不相等的情况，如果相等 pA、pB会同时到达相交结点直接返回即可。\",\"如果 headA.length < headB.length ，则pA 会率先走完，然后指向 headB，当pA到达相交结点的移动次数为：a + c + b\",\"而 pB 的移动次数为： b + c + a，俩者的移动次数其实是一样的，最终一定会相遇！\",\"哈希表\",\"哈希表的方法比较容易理解，将其中一个链表的结点都放到 hash表中，最后遍历另一个链表的结点，如果hash表中包含该结点，则该结点为相交结点\"]},\"392\":{\"h\":\"代码实现\",\"t\":[\"双指针\",\" // 处理特殊情况 if (headA == null || headB == null) return null; // 定义双指针 ListNode pA = headA, pB = headB; while(pA != pB) { // 开始移动 pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } // 若有相交结点，此时pA=pB return pA; \",\"哈希表\",\" // 哈希表 public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { HashSet<ListNode> hash = new HashSet<>(); ListNode temp = headA; // 先将headA都放入hash表中 while(temp != null) { hash.add(temp); temp = temp.next; } temp = headB; while(temp != null) { // 看hash表中是否包含该结点 if (hash.contains(temp)) return temp; temp = temp.next; } // 如果不包含，说明没有相交结点 return null; } \"]},\"393\":{\"h\":\"\",\"t\":[\"给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\",\"如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\",\"不允许修改 链表。\",\"示例 1：\",\"img\",\"输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 \",\"示例 2：\",\"img\",\"输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 \",\"示例 3：\",\"img\",\"输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 \",\"提示：\",\"链表中节点的数目范围在范围 [0, 104] 内\",\"-105 <= Node.val <= 105\",\"pos 的值为 -1 或者链表中的一个有效索引\"]},\"394\":{\"h\":\"思路分析\",\"t\":[\"题目太废话，简单来说就是找到环的起始节点，我们可以利用hash表，将结点放入hash表中，若hash表中已经存在某个结点，就说明该结点就是环的起始点\"]},\"395\":{\"h\":\"代码实现\",\"t\":[\" public static ListNode detectCycle(ListNode head) { HashSet<ListNode> hash = new HashSet<>(); ListNode temp = head; // 若不存在环，尾结点.next一定是 while(temp != null) { if (hash.contains(temp)) { // 存在说明该结点为起始点 return temp; }else { hash.add(temp); } temp = temp.next; } // 说明没有环 return null; } \"]},\"396\":{\"c\":[\"算法\"]},\"397\":{\"c\":[\"链表\"]},\"398\":{\"h\":\"SpringCloud Alibaba\",\"t\":[\"提示\",\"本文档只讲解微服务的基础使用,想要了解深层次的原理请跳过，避免耽误时间！！\",\"所有代码均在GitHub,需要请自取\",\"https://github.com/yangzhaoguang/cloud2024.git\"]},\"399\":{\"h\":\"一、简介\",\"t\":[\"文档\",\"中文文档\",\"Spring Cloud Alibaba 参考文档 (spring-cloud-alibaba-group.github.io)\",\"github\",\"spring-cloud-alibaba/README-zh.md at 2022.x · alibaba/spring-cloud-alibaba · GitHub\",\"是什么\",\"Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\",\"主要功能\",\"服务限流降级：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud Gateway、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\",\"服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成对应 Spring Cloud 版本所支持的负载均衡组件的适配。\",\"分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\",\"消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\",\"分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\",\"阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\",\"分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。\",\"阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\",\"组件\",\"Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\",\"Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\",\"RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\",\"Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\",\"Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\",\"Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\",\"Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\",\"版本对应关系\",\"2022.x 分支对应的是 Spring Cloud 2022 与 Spring Boot 3.0.x，最低支持 JDK 17。\",\"2021.x 分支对应的是 Spring Cloud 2021 与 Spring Boot 2.6.x，最低支持 JDK 1.8。\",\"2020.0 分支对应的是 Spring Cloud 2020 与 Spring Boot 2.4.x，最低支持 JDK 1.8。\",\"2.2.x 分支对应的是 Spring Cloud Hoxton 与 Spring Boot 2.2.x，最低支持 JDK 1.8。\",\"greenwich 分支对应的是 Spring Cloud Greenwich 与 Spring Boot 2.1.x，最低支持 JDK 1.8。\",\"finchley 分支对应的是 Spring Cloud Finchley 与 Spring Boot 2.0.x，最低支持 JDK 1.8。\",\"1.x 分支对应的是 Spring Cloud Edgware 与 Spring Boot 1.x，最低支持 JDK 1.7。\",\"依赖\",\"<dependencyManagement> <dependencies> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-alibaba-dependencies</artifactId> <version>2022.0.0.0</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> \"]},\"400\":{\"h\":\"二、服务注册+配置Nacos\",\"t\":[\"一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\",\"Nacos = Consul\"]},\"401\":{\"h\":\"2.1 下载启动\",\"t\":[\"地址：https://github.com/alibaba/nacos/releases\",\"版本选择：2.3.0\",\"解压之后，进入到 /bin 目录，打开cmd命令行, 执行：\",\"startup.cmd -m standalone \",\"image-20240406175812435\",\"启动成功，访问：localhost:8848/nacos\"]},\"402\":{\"h\":\"2.2 服务注册\",\"t\":[\"新创建俩个模块 cloudalibaba-provider-payment9001 、 cloudalibaba-comsumer-order83.\",\"cloudalibaba-provider-payment9001\",\"yaml\",\"server: port: 9001 spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 \",\"POM\",\" <dependencies> <!--nacos-discovery--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> <!-- 引入自己定义的api通用包 --> <dependency> <groupId>com.atguigu.cloud</groupId> <artifactId>cloud-api-commons</artifactId> <version>1.0-SNAPSHOT</version> </dependency> <!--SpringBoot通用依赖模块--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.28</version> <scope>provided</scope> </dependency> <!--test--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"PayAlibabaController\",\"@RestController public class PayAlibabaController { @Value(\\\"${server.port}\\\") private String serverPort; @GetMapping(value = \\\"/pay/nacos/{id}\\\") public String getPayInfo(@PathVariable(\\\"id\\\") Integer id) { return \\\"nacos registry, serverPort: \\\" + serverPort + \\\"\\\\t id\\\" + id; } } \",\"cloudalibaba-comsumer-order83.\",\"yaml\",\"server: port: 83 spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 #消费者将要去访问的微服务名称(nacos微服务提供者叫什么你写什么) service-url: nacos-user-service: http://nacos-payment-provider \",\"POM\",\" <dependencies> <!--nacos-discovery--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> <!--loadbalancer--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-loadbalancer</artifactId> </dependency> <!--web + actuator--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"配置类\",\"在未整合 OpenFeign 之前，仍然可以使用 RestTemplate + LoadBalance 负责负载均衡+远程调用！这也就说明了为什么要在消费端引入 loadbalancer 依赖\",\"@Configuration public class RestTemplateConfig { @Bean @LoadBalanced //赋予RestTemplate负载均衡的能力 public RestTemplate restTemplate() { return new RestTemplate(); } } \",\"OrderNacosController\",\"@RestController public class OrderNacosController { @Resource private RestTemplate restTemplate; @Value(\\\"${service-url.nacos-user-service}\\\") private String serverURL; @GetMapping(\\\"/consumer/pay/nacos/{id}\\\") public String paymentInfo(@PathVariable(\\\"id\\\") Integer id) { String result = restTemplate.getForObject(serverURL + \\\"/pay/nacos/\\\" + id, String.class); return result+\\\"\\\\t\\\"+\\\" 我是OrderNacosController83调用者。。。。。。\\\"; } } \"]},\"403\":{\"h\":\"2.3 服务配置\",\"t\":[\"以 搭建cloudalibaba-config-nacos-client3377 模块为例：\",\"依赖\",\"基本上所有的外部配置中心都需要 bootstrap 配置文件\",\"<dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-bootstrap</artifactId> </dependency> \",\"bootstrap.yml\",\"注意：必须使用 bootstrap.properties 配置文件来配置 Nacos Server 地址\",\"# nacos配置 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 # nacos端配置文件DataId的命名规则是： # ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} # 本案例的DataID是:nacos-config-client-dev.yaml \",\"application.yml\",\"server: port: 3377 spring: profiles: active: dev # 表示开发环境 #active: prod # 表示生产环境 #active: test # 表示测试环境 \",\"主启动类\",\"@EnableDiscoveryClient @SpringBootApplication public class Main3377 { public static void main(String[] args) { SpringApplication.run(Main3377.class,args); } } \",\"NacosConfigClientController :\",\"⚡⚡⚡@RefreshScope 配置文件动态刷新功能！\",\"@RestController @RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。 public class NacosConfigClientController { @Value(\\\"${config.info}\\\") private String configInfo; @GetMapping(\\\"/config/info\\\") public String getConfigInfo() { return configInfo; } } \",\"⚡⚡⚡ Nacos配置规则\",\"${prefix}-${spring.profiles.active}.${file-extension} \",\"prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。\",\"spring.profiles.active 即为当前环境对应的 profile，：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}\",\"file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。\",\"image-20240407120504030\",\"演示\",\"image-20240407120907972\"]},\"404\":{\"h\":\"2.3.1 NameSpace-GroupID-DataId\",\"t\":[\"是什么？\",\"用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。\",\"Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。\",\"类似Java里面的package名和类名，最外层的Namespace是可以用于区分部署环境的 ，Group和DataID逻辑上区分两个目标对象\",\"三者之间的关系\",\"image-20240407121621452\",\"默认情况：Namespace=public，Group=DEFAULT_GROUP\",\"Nacos默认的命名空间是 public，Namespace主要用来实现隔离。比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去\",\"配置\",\"通过GROUP分组区分环境\",\"image-20240407123501816\",\"在bootstrap.yaml 中要通过 group 指明\",\"# nacos配置 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 group: PROD_GROUP \",\"通过NameSpace分组区分环境\",\"image-20240407124007126\",\"在bootstrap.yaml 中要通过 namespace 指明，字段值为 命名空间ID\",\"# nacos配置 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 group: PROD_GROUP namespace: b0bf3537-ec9e-4cd2-8f5e-85948a4692e9 \"]},\"405\":{\"h\":\"三、熔断限流 Sentinel\",\"t\":[\"文档\",\"中文文档\",\"introduction | Sentinel (sentinelguard.io)\",\"github\",\"GitHub - alibaba/Sentinel: A powerful flow control component enabling reliability, resilience and monitoring for microservices. (面向云原生微服务的高可用流控防护组件)\"]},\"406\":{\"h\":\"3.1 介绍\",\"t\":[\"是什么\",\"Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。\",\"主要特性‘\",\"丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\",\"完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\",\"广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。\",\"完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\",\"image-20240407125401206\"]},\"407\":{\"h\":\"3.2 下载安装\",\"t\":[\"Sentinel 分为两个部分:\",\"核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\",\"控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\",\"下载：Releases · alibaba/Sentinel (github.com)\",\"启动：java -jar\",\"访问： localhost:8080\",\"默认账号密码： sentinel\",\"image-20240407154325626\"]},\"408\":{\"h\":\"3.3 如何使用\",\"t\":[\"依赖\",\" <!--SpringCloud alibaba sentinel --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId> </dependency> \",\"yaml\",\"server: port: 8401 spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址 port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 \",\"由于 Sentinel 采用的是懒加载，有请求之后才会开始进行监控！\"]},\"409\":{\"h\":\"3.3.1 流控规则\",\"t\":[\"Sentinel能够对流量进行控制，主要是监控应用的QPS流量或者并发线程数等指标，如果达到指定的阈值时，就会被流量进行控制，以避免服务被瞬时的高并发流量击垮，保证服务的高可靠性。参数见最下方：\",\"image-20240407155401415\",\"资源名\",\"资源的唯一名称，默认就是请求的接口路径，可以自行修改，但是要保证唯一。\",\"针对来源\",\"具体针对某个微服务进行限流，默认值为default，表示不区分来源，全部限流。\",\"阈值类型\",\"QPS表示通过QPS进行限流，并发线程数表示通过并发线程数限流。\",\"单机阈值\",\"与阈值类型组合使用。如果阈值类型选择的是QPS，表示当调用接口的QPS达到阈值时，进行限流操作。如果阈值类型选择的是并发线程数，则表示当调用接口的并发线程数达到阈值时，进行限流操作。\",\"是否集群\",\"选中则表示集群环境，不选中则表示非集群环境。\"]},\"410\":{\"h\":\"流控模式\",\"t\":[\"直接\",\"如果 /testA 请求 1S以内有超过 2个请求数量，就会直接报错！\",\"image-20240407155927550\",\"效果\",\"image-20240407160023443\",\"关联\",\"当关联的资源达到阈值时，就限流自己！\",\"例如下面：\",\"当 /testB 请求 1S超过2个请求时，就会限流 /testA\",\"image-20240407160215658\",\"链路\",\"来自不同链路的请求对同一个目标访问时，实施针对性的不同限流措施！\",\"比如：C请求来访问common资源就限流、D请求来访问common资源就不限流\",\"image-20240409095139203\",\"测试\",\"FlowLimitService\",\"@Service public class FlowLimitService { @SentinelResource(value = \\\"common\\\") public void common() { System.out.println(\\\"------FlowLimitService come in\\\"); } } \",\"FlowLimitController\",\"/testC 、/testD 访问同一个资源common\",\" @GetMapping(\\\"/testC\\\") public String testC() { flowLimitService.common(); return \\\"------testC\\\"; } @GetMapping(\\\"/testD\\\") public String testD() { flowLimitService.common(); return \\\"------testD\\\"; } \",\"yaml\",\"spring: cloud: sentinel: web-context-unify: false # controller层的方法对service层调用不认为是同一个根链路 \"]},\"411\":{\"h\":\"流控效果\",\"t\":[\"快速失败 ： 直接报错\",\"Warm Up : 预热\",\"Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\\\"冷启动\\\"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。\",\"默认coldFactor为 3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值\",\"以下为例说明：\",\"阀值为10，预热时长设置5秒。\",\"系统初始化的阀值为10 / 3 约等于3, 即阀值刚开始为3；\",\"然后过了5秒后阀值才慢慢升高恢复到10。\",\"image-20240407162712647\",\"排队等待\",\"匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。\",\"图中所示，每1s处理一次/testB，5s过后的所有请求都会抛弃，也就是说只能处理 5个请求！\",\"image-20240407163626365\",\"Jmeter 设置 1s发送10个请求\",\"image-20240407163753693\",\"效果\",\"最终只执行了6次请求，剩余4次全被抛弃了\",\"执行6次是因为在最后1s请求进来了\",\"image-20240407163859059\"]},\"412\":{\"h\":\"3.3.2 熔断规则\",\"t\":[\"名词解释\",\"1.调用：一个请求发送到服务器，服务器给与响应，一个响应就是一个调用。\",\"2.最大RT：即最大的响应时间，指系统对请求作出响应的业务处理时间。\",\"3.慢调用：处理业务逻辑的实际时间 > 设置的最大RT时间，这个调用叫做慢调用。\",\"4.慢调用比例：在所以调用中，慢调用占有实际的比例＝慢调用次数➗总调用次数\",\"5.比例阈值：自己设定的 ， 比例阈值＝慢调用次数➗调用次数\",\"6.统计时长：时间的判断依据\",\"7.最小请求数：设置的调用最小请求数，上图比如1秒钟打进来10个线程（大于我们配置的5个了）调用被触发\",\"熔断状态\",\"1、熔断状态(保险丝跳闸断电，不可访问)：在接下来的熔断时长内请求会自动被熔断\",\"2、探测恢复状态(探路先锋)：熔断时长结束后进入探测恢复状态\",\"3、结束熔断(保险丝闭合恢复，可以访问)：在探测恢复状态，如果接下来的一个请求响应时间小于设置的慢调用 RT，则结束熔断，否则继续熔断。\"]},\"413\":{\"h\":\"慢调用比例\",\"t\":[\"进入熔断状态判断依据：在统计时长内，实际请求数目＞设定的最小请求数 且 实际慢调用比例＞比例阈值 ，进入熔断状态。\",\"image-20240407165310826\",\"拿上图的例子来说：\",\"在 1S（统计时长）内，若 总调用次数 > 5 并且 慢调用比例(响应时间超过200ms) > 10% 就会进入熔断状态，熔断时长为 5s\"]},\"414\":{\"h\":\"异常比例\",\"t\":[\"在1S（统计时长）内，总 调用数>5 并且 异常比例(异常调用/总调用数) > 10% 进入熔断状态，熔断时长为5S\",\"image-20240407170816884\"]},\"415\":{\"h\":\"异常数\",\"t\":[\"上面那个是 达到一定的异常比例之后进入熔断状态，这个是基于异常数量\",\"在1S（统计时长）内，总 调用数>5 并且 异常数 > 2 进入熔断状态，熔断时长为5S\",\"image-20240407171011182\"]},\"416\":{\"h\":\"3.3.3 @SentinelResource\",\"t\":[\"@SentinelResource 是一个流量防卫防护组件注解，用于指定防护资源，对配置的资源进行流程控制，熔断降级等功能！\",\"参数说明\",\"@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface SentinelResource { //资源名称 String value() default \\\"\\\"; //entry类型，标记流量的方向，取值IN/OUT，默认是OUT EntryType entryType() default EntryType.OUT; //资源分类 int resourceType() default 0; //处理BlockException的函数名称,函数要求： //1. 必须是 public //2.返回类型 参数与原方法一致 //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置blockHandlerClass ，并指定blockHandlerClass里面的方法。 String blockHandler() default \\\"\\\"; //存放blockHandler的类,对应的处理函数必须static修饰。 Class<?>[] blockHandlerClass() default {}; //用于在抛出异常的时候提供fallback处理逻辑。 fallback函数可以针对所 //有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求： //1. 返回类型与原方法一致 //2. 参数类型需要和原方法相匹配 //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定fallbackClass里面的方法。 String fallback() default \\\"\\\"; //存放fallback的类。对应的处理函数必须static修饰。 String defaultFallback() default \\\"\\\"; //用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进 //行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求： //1. 返回类型与原方法一致 //2. 方法参数列表为空，或者有一个 Throwable 类型的参数。 //3. 默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定 fallbackClass 里面的方法。 Class<?>[] fallbackClass() default {}; //需要trace的异常 Class<? extends Throwable>[] exceptionsToTrace() default {Throwable.class}; //指定排除忽略掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。 Class<? extends Throwable>[] exceptionsToIgnore() default {}; } \",\"简单来说，被 @SentinelResource 注解标注的资源也能够配置限流、降级等规则，那它和手动的配置，也就是通过访问路径 设置有什么不一样呢？\",\"其实很简单，想要自定义响应信息就使用 @SentinelResource 注解。\",\"触发限流规则会执行 blockHandler , 出现异常降级会执行 fallback\",\"案例演示\",\"若资源和 blockHandler、doActionFallback 不在同一个类中，使用 blockHandlerClass 、fallbackClass 指明！\",\" @GetMapping(\\\"/rateLimit/doAction/{p1}\\\") @SentinelResource(value = \\\"doActionSentinelResource\\\", blockHandler = \\\"doActionBlockHandler\\\", fallback = \\\"doActionFallback\\\") public String doAction(@PathVariable(\\\"p1\\\") Integer p1) { if (p1 == 0){ throw new RuntimeException(\\\"p1等于零直接异常\\\"); } return \\\"doAction\\\"; } public String doActionBlockHandler(@PathVariable(\\\"p1\\\") Integer p1, BlockException e){ log.error(\\\"sentinel配置自定义限流了:{}\\\", e); return \\\"sentinel配置自定义限流了\\\"; } public String doActionFallback(@PathVariable(\\\"p1\\\") Integer p1,Throwable e){ log.error(\\\"程序逻辑异常了:{}\\\", e); return \\\"程序逻辑异常了\\\"+\\\"\\\\t\\\"+e.getMessage(); } \",\"配置流控规则\",\"image-20240407173708083\",\"效果\",\"image-20240407173759088\"]},\"417\":{\"h\":\"3.3.4 热点规则\",\"t\":[\"热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作\",\"代码\",\" @GetMapping(\\\"/testHotKey\\\") @SentinelResource(value = \\\"testHotKey\\\",blockHandler = \\\"dealHandler_testHotKey\\\") public String testHotKey(@RequestParam(value = \\\"p1\\\",required = false) String p1, @RequestParam(value = \\\"p2\\\",required = false) String p2){ return \\\"------testHotKey\\\"; } public String dealHandler_testHotKey(String p1,String p2,BlockException exception) { return \\\"-----dealHandler_testHotKey\\\"; } \",\"热点规则配置\",\"参数索引从0开始，例如上面的代码中，p1、p2俩个参数，对应的索引：0、1\",\"下面规则的意思是：\",\"当携带p1参数的请求，超过1秒1次的时候，就会进行限流，执行dealHandler_testHotKey 方法\",\"image-20240407175012419\",\"参数例外项\",\"期望某个参数达到某个特殊值之后，它的阈值也会不同。\",\"例如下面：当 p1的参数值等于5时，单独设置它的阈值为 200。\",\"注意：参数类型必须为八个基本类型之一！\",\"image-20240407175308411\"]},\"418\":{\"h\":\"3.3.5 授权规则\",\"t\":[\"在某些场景下，需要根据调用接口的来源判断是否允许执行本次请求。此时就可以使用Sentinel提供的授权规则来实现，Sentinel的授权规则能够根据请求的来源判断是否允许本次请求通过。\",\"在Sentinel的授权规则中，提供了 白名单与黑名单 两种授权类型。白放行、黑禁止\",\"自定义一个请求转换器，设置针对哪一个参数名设置 白名单、黑名单\",\"@Component public class MyRequestOriginParser implements RequestOriginParser { @Override public String parseOrigin(HttpServletRequest httpServletRequest) { return httpServletRequest.getParameter(\\\"serverName\\\"); } } \",\"业务代码\",\" @RestController public class EmpowerController //Empower授权规则，用来处理请求的来源 { @GetMapping(value = \\\"/empower\\\") public String requestSentinel4(){ return \\\"Sentinel授权规则\\\"; } } \",\"配置授权规则\",\"image-20240407181056456\",\"当 serverName 参数名称等于 test1 或者 test2 会进入到黑名单！\",\"http://localhost:8401/empower?serverName=test2 http://localhost:8401/empower?serverName=test1 \"]},\"419\":{\"h\":\"3.3.6 持久化规则\",\"t\":[\"一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化\",\"方法\",\"将限流配置规则持久化进Nacos保存，只要Nacos里面的配置不删除，sentinel上的流控规则持续有效\",\"步骤\",\"1、增加依赖\",\" <dependency> <groupId>com.alibaba.csp</groupId> <artifactId>sentinel-datasource-nacos</artifactId> </dependency> \",\"2、yaml\",\"如果命名空间不是默认的 public ，则需要使用 namespace: 指明\",\"spring: cloud: sentinel: datasource: ds1: nacos: server-addr: localhost:8848 dataId: ${spring.application.name} groupId: DEFAULT_GROUP data-type: json rule-type: flow ds2: # 可以配置多个 nacos: server-addr: localhost:8848 dataId: ${spring.application.name} groupId: DEFAULT_GROUP data-type: json rule-type: System \",\"rule-type说明\",\"flow流量控制规则\",\"Degrade熔断降级规则\",\"Authority访问控制规则\",\"System系统保护规则\",\"param_flow热点规则\",\"3、Nacos配置说明\",\"DataId：服务名称\",\"配置格式一定要选择 json\",\"image-20240407182939752\",\"[ { \\\"resource\\\": \\\"/rateLimit/byUrl\\\", \\\"limitApp\\\": \\\"default\\\", \\\"grade\\\": 1, \\\"count\\\": 1, \\\"strategy\\\": 0, \\\"controlBehavior\\\": 0, \\\"clusterMode\\\": false } ] \",\"参数配置说明：\",\"流控规则：\",\"resource：资源名称； limitApp：来源应用； grade：阈值类型，0表示线程数，1表示QPS； count：单机阈值； strategy：流控模式，0表示直接，1表示关联，2表示链路； controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待； clusterMode：是否集群。\",\"熔断规则\",\"resource ：资源名 grade ：熔断策略，支持慢调用比例/异常比例/异常数策略。0：慢调用比例，1：异常比例，2：异常数。默认为 0，慢调用比例。 count ：慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值。 timeWindow ：熔断时长，单位为秒。 minRequestAmount ：熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断。默认为 5 。 statIntervalMs ：统计时长（单位为 ms），如 60*1000 代表分钟级。默认为 1000 ms。 slowRatioThreshold ：慢调用比例阈值，仅慢调用比例模式有效\",\"热点规则\",\"resource ：资源名\",\"paramIdx : 参数索引\",\"count: 单机阈值\",\"clusterMode : 是否集群模式，默认false\",\"grade : 阈值类型，固定为1 为QPS\",\"durationInSec: 统计窗口时长\",\"paramFlowItemList : 参数例外项，是一个数组 []\",\"classType: 参数类型，比如：java.lang.String\",\"count : 限流阈值\",\"object : 参数值\",\"[ { \\\"resource\\\": \\\"testHotKey\\\", \\\"paramIdx\\\": 0, \\\"grade\\\": 1, \\\"count\\\": 1, \\\"durationInSec\\\": 1, \\\"paramFlowItemList\\\": [ { \\\"classType\\\": \\\"java.lang.String\\\", \\\"count\\\":200, \\\"object\\\": 5 } ] } ] \"]},\"420\":{\"h\":\"3.4 sentinel 整合OpenFeign\",\"t\":[\"我们在使用 OpenFeign 访问失败的话， 访问者要有 fallback服务降级的情况，不要持续访问9001加大微服务负担，但是通过feign接口调用的又方法各自不同，如果每个不同方法都加一个fallback配对方法，会导致代码膨胀不好管理，工程埋雷\",\"我们可以看到每一个方法都配备了一个 blockHandler 和 fallback , 如果有几十个Controller 方法 , 难道我们也要配 好几十个 blockHandler 和 fallback ？\",\"这显然是很愚蠢的行为~\",\"image-20240407223223116\",\"处理方法\",\"fallback 统一在 OpenFeign 接口中定义\",\"执行步骤\",\"一定要清楚 Sentinel 监控的是 服务提供者，也就是被调用者。\",\"而消费者，也就是调用者 则是利用 OpenFeign 调用 被调用者！\",\"1、因此在 服务提供者9001 中加入 sentinel 监控：\",\"spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址 port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 \",\"2、将 fallback 统一放到 OpenFeign 的接口 中\",\"@FeignClient(value = \\\"nacos-payment-provider\\\",fallback = PayFeignSentinelApiFallBack.class) public interface PayFeignSentinelApi { @GetMapping(\\\"/pay/nacos/get/{orderNo}\\\") public ResultData getPayByOrderNo(@PathVariable(\\\"orderNo\\\") String orderNo); } \",\"通过 fallback 属性指明调用出错时的返回逻辑！\",\"注意，要实现OpenFeign 接口，并且要重写方法！\",\"@Component public class PayFeignSentinelApiFallBack implements PayFeignSentinelApi{ @Override public ResultData getPayByOrderNo(String orderNo) { return ResultData.fail(ReturnCodeEnum.RC500.getCode(),\\\"对方服务宕机或不可用，FallBack服务降级o(╥﹏╥)o\\\"); } } \",\"3、再消费端83使用OpenFeign远程调用，先在主启动类增加 @EnableFeignClients 注解！！\",\"激活sentinel对OpenFeign的支持\",\"# 激活Sentinel对Feign的支持 feign: sentinel: enabled: true \",\"故障\",\"image-20240408173757761\",\"出现的原因是由于 SpringBoot、SpringCloud版本太高，与阿里巴巴的Sentinel不兼容，降低版本即可，修改以下版本：\",\"<spring.boot.version>3.0.9</spring.boot.version> <spring.cloud.version>2022.0.2</spring.cloud.version> \"]},\"421\":{\"h\":\"3.5 sentinel整合GateWay\",\"t\":[\"从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：\",\"route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId\",\"自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组\",\"其实 sentinel 整合 Gateway 有俩种方式，一种是配置类 方式，一种是控制台\"]},\"422\":{\"h\":\"控制台方式\",\"t\":[\"手动在控制台增加流控规则。\",\"优点\",\"操作方便，图形化界面\",\"配置简单，无需更改代码\",\"缺点\",\"需要进行持久化配置\",\"新建网关模块 cloudalibaba-sentinel-gateway9528\",\"依赖\",\" <dependencies> <!--nacos-discovery--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <!-- spring cloud gateway整合sentinel的依赖--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-alibaba-sentinel-gateway</artifactId> </dependency> <!-- sentinel的依赖--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId> </dependency> </dependencies> \",\"yaml\",\"server: port: 9528 spring: application: name: cloudalibaba-sentinel-gateway # sentinel+gataway整合Case cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 gateway: routes: - id: pay_routh1 #pay_routh1 #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:9001 #匹配后提供服务的路由地址 predicates: - Path=/pay/** # 断言，路径相匹配的进行路由 \",\"增加 Vm Options\",\"-Dcsp.sentinel.app.type=1 \",\"image-20240408164942547\",\"启动成功后，向网关发送一次请求，\",\"http://localhost:9528/pay/nacos/1 \",\"看 sentinel 控制台，已经注册进来了，此时就可以随心所以得进行限流配置了！\",\"image-20240408165033508\",\"新增流控规则，API名称为 routeId\",\"image-20240408165157733\",\"此时如果出发流控规则，发现报以下错误，这是因为项目环境是JDK17，依赖的spring-cloud-alibaba-sentinel-gateway版本为2022.0.0.0 ，检查发现其下的sentinel-spring-cloud-gateway-adapter-1.8.6.jar是JDK8编译的，简单来说就是版本适配问题\",\"java.lang.NoSuchMethodError: 'org.springframework.web.reactive.function.server.ServerResponse$BodyBuilder org.springframework.web.reactive.function.server.ServerResponse.status(org.springframework.http.HttpStatus)' \",\"只需要自定义限流返回信息即可！有三种方式可以实现：\",\"1、yaml配置自定义返回信息\",\"spring: cloud: ## 整合sentinel，配置sentinel控制台的地址 sentinel: #配置限流之后，响应内容 scg: fallback: ## 两种模式，一种是response返回文字提示信息， ## 一种是redirect，重定向跳转，需要同时配置redirect(跳转的uri) mode: response ## 响应的状态 response-status: 200 ## 响应体 response-body: '{\\\"code\\\": 200,\\\"message\\\": \\\"限流啦！请稍后再试\\\"}' \",\"2、yaml配置重定向\",\"spring: cloud: ## 整合sentinel，配置sentinel控制台的地址 sentinel: #配置限流之后，响应内容 scg: fallback: ## 两种模式，一种是response返回文字提示信息，一种是redirect，重定向跳转，需要同时配置redirect(跳转的uri) mode: redirect ## 跳转的URL redirect: http://www.baidu.com \",\"3、配置类方式\",\"@Configuration public class GatewayConfig { /** * 自定义限流处理器 */ @PostConstruct public void initBlockHandlers() { BlockRequestHandler blockHandler = (serverWebExchange, throwable) -> { Map map = new HashMap(); map.put(\\\"code\\\",200); map.put(\\\"message\\\",\\\"请求失败，稍后重试！\\\"); return ServerResponse.status(HttpStatus.OK) .contentType(MediaType.APPLICATION_JSON_UTF8) .body(BodyInserters.fromObject(map)); }; GatewayCallbackManager.setBlockHandler(blockHandler); } } \"]},\"423\":{\"h\":\"配置类方式\",\"t\":[\"这种方式可以在代码中配置 流控规则，不需要持久化，每次启动都会重新生成规则。\",\"缺点就是 修改规则需要改动代码！\",\"POM\",\" <!--Sentinel整合GateWay第二种方式：配置类方式--> <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <dependency> <groupId>com.alibaba.csp</groupId> <artifactId>sentinel-transport-simple-http</artifactId> <version>1.8.6</version> </dependency> <dependency> <groupId>com.alibaba.csp</groupId> <artifactId>sentinel-spring-cloud-gateway-adapter</artifactId> <version>1.8.6</version> </dependency> <dependency> <groupId>javax.annotation</groupId> <artifactId>javax.annotation-api</artifactId> <version>1.3.2</version> <scope>compile</scope> </dependency> </dependencies> \",\"配置类\",\"@Configuration public class GatewayConfiguration { private final List<ViewResolver> viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider<List<ViewResolver>> viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) { this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; } @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() { // Register the block exception handler for Spring Cloud Gateway. return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); } @Bean @Order(-1) public GlobalFilter sentinelGatewayFilter() { return new SentinelGatewayFilter(); } @PostConstruct //javax.annotation.PostConstruct public void doInit() { initBlockHandler(); } //处理/自定义返回的例外信息 private void initBlockHandler() { Set<GatewayFlowRule> rules = new HashSet<>(); // 定义流控规则 rules.add(new GatewayFlowRule(\\\"pay_routh1\\\").setCount(2).setIntervalSec(1)); GatewayRuleManager.loadRules(rules); BlockRequestHandler handler = new BlockRequestHandler() { @Override public Mono<ServerResponse> handleRequest(ServerWebExchange exchange, Throwable t) { Map<String,String> map = new HashMap<>(); map.put(\\\"errorCode\\\", HttpStatus.TOO_MANY_REQUESTS.getReasonPhrase()); map.put(\\\"errorMessage\\\", \\\"请求太过频繁，系统忙不过来，触发限流(sentinel+gataway整合Case)\\\"); return ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS) .contentType(MediaType.APPLICATION_JSON) .body(BodyInserters.fromValue(map)); } }; GatewayCallbackManager.setBlockHandler(handler); } } \"]},\"424\":{\"h\":\"持久化规则\",\"t\":[\"上面说了通过 控制台 的方式，需要持久化，否则一重启服务 规则都没了。\",\"其实和 3.3.6 持久化规则 中讲解的方法一致，参数也一样。但是有俩点需要注意：\",\"配置中的 resource 名称是你的 routeId\",\"增加配置类（固定死的）：\",\"@Configuration @Order(2) public class SentinelPersistenceConfig { @Autowired private SentinelProperties sentinelProperties; @Bean public SentinelPersistenceConfig init() throws Exception { loadGWFlowRule(); return new SentinelPersistenceConfig(); } private void loadGWFlowRule() { sentinelProperties.getDatasource().entrySet().stream().filter(map -> { return map.getValue().getNacos() != null; }).forEach(map -> { NacosDataSourceProperties nacos = map.getValue().getNacos(); ReadableDataSource<String, Set<GatewayFlowRule>> gwFlowRuleDataSource = new NacosDataSource<>( nacos.getServerAddr(), nacos.getGroupId(), nacos.getDataId(), source -> JSON.parseObject(source, new TypeReference<Set<GatewayFlowRule>>() { })); GatewayRuleManager.register2Property(gwFlowRuleDataSource.getProperty()); }); } } \",\"举例说明\",\"image-20240408173040132\"]},\"425\":{\"h\":\"四、Seata\",\"t\":[\"在订单支付成功后，交易中心会调用订单中心的服务把订单状态更新，并调用物流中心的服务通知商品发货，同时还要调用积分中心的服务为用户增加相应的积分。如何保障分布式事务一致性，成为了确保订单业务稳定运行的核心诉求之一。\"]},\"426\":{\"h\":\"4.1 介绍\",\"t\":[\"Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。(本次只讲解了 AT 模式)\",\"官网文档：https://seata.apache.org/zh-cn/docs/overview/what-is-seata\",\"重要\",\"只需要使用一个 @GlobalTransactional 注解，seata就会帮我们管理分布式事务\",\"工作流程\",\"分布式事务处理过程的一ID+三组件模型\",\"Transaction ID XID：全局唯一的事务ID\",\"Transaction Coordinator (TC）： 可以理解为 Seata，负责维护全局事务和分支事务的状态，驱动全局事务提交或者回滚\",\"Transaction Manager (TM)：标注全局@GlobalTransactional 启动入口动作的微服务模块(比如订单模块)，他是事务的发起者，负责定义全局事务的范围，并根据 TC 维护的全局事务和分支事务状态，做出开始事务、提交事务、回滚事务的决议\",\"Resource Manager (RM）：就是 数据库本身，可以是多个RM，负责管理分支事务的资源，向TC注册分支事务，汇报分支事务的状态，驱动分支事务的提交或者回滚！\",\"image-20240408175204593\",\"TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；\",\"XID 在微服务调用链路的上下文中传播，可以通过 RootContent 获取；\",\"RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；\",\"TM 向 TC 发起针对 XID 的全局提交或回滚决议；\",\"TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。\"]},\"427\":{\"h\":\"4.2 下载\",\"t\":[\"https://seata.apache.org/zh-cn/unversioned/download/seata-server\"]},\"428\":{\"h\":\"4.2.1 数据库准备\",\"t\":[\"CREATE DATABASE seata; USE seata; \",\"SQL来源：https://github.com/apache/incubator-seata/blob/develop/script/server/db/mysql.sql\",\"-- -------------------------------- The script used when storeMode is 'db' -------------------------------- -- the table to store GlobalSession data CREATE TABLE IF NOT EXISTS `global_table` ( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store BranchSession data CREATE TABLE IF NOT EXISTS `branch_table` ( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store lock data CREATE TABLE IF NOT EXISTS `lock_table` ( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT '0' COMMENT '0:locked ,1:rollbacking', `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; CREATE TABLE IF NOT EXISTS `distributed_lock` ( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('AsyncCommitting', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('RetryCommitting', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('RetryRollbacking', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('TxTimeoutCheck', ' ', 0); \"]},\"429\":{\"h\":\"4.2.2 配置\",\"t\":[\"下载解压后，进入 conf/ 目录，修改 application.yaml 配置文件：\",\"# Copyright 1999-2019 Seata.io Group. # # Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \\\"AS IS\\\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. server: port: 7091 spring: application: name: seata-server logging: config: classpath:logback-spring.xml file: path: ${log.home:${user.home}/logs/seata} extend: logstash-appender: destination: 127.0.0.1:4560 kafka-appender: bootstrap-servers: 127.0.0.1:9092 topic: logback_to_logstash console: user: username: seata password: seata seata: config: type: nacos nacos: server-addr: 127.0.0.1:8848 namespace: group: SEATA_GROUP #后续自己在nacos里面新建,不想新建SEATA_GROUP，就写DEFAULT_GROUP username: nacos password: nacos registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848 group: SEATA_GROUP #后续自己在nacos里面新建,不想新建SEATA_GROUP，就写DEFAULT_GROUP namespace: cluster: default username: nacos password: nacos store: mode: db db: datasource: druid db-type: mysql driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/seata?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true user: root password: 123456 min-conn: 10 max-conn: 100 global-table: global_table branch-table: branch_table lock-table: lock_table distributed-lock-table: distributed_lock query-limit: 1000 max-wait: 5000 # server: # service-port: 8091 #If not configured, the default is '${server.port} + 1000' security: secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017 tokenValidityInMilliseconds: 1800000 ignore: urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.jpeg,/**/*.ico,/api/v1/auth/login,/metadata/v1/** \",\"启动命令：\",\"seata-server.bat\",\"控制台界面\",\"http://localhost:7091\"]},\"430\":{\"h\":\"4.3 案例搭建\",\"t\":[\"需求说明\",\"这里我们创建三个服务，一个订单服务，一个库存服务，一个账户服务。\",\"当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，最后在订单服务中修改订单状态为已完成\",\"image-20240408214052493\"]},\"431\":{\"h\":\"\",\"t\":[\"创建三个数据库、三张表、每个库中增加 undo_log 表\",\"SQL来源：https://github.com/apache/incubator-seata/blob/develop/script/client/at/db/mysql.sql\",\"#order CREATE DATABASE seata_order; USE seata_order; CREATE TABLE t_order( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `user_id` BIGINT(11) DEFAULT NULL COMMENT '用户id', `product_id` BIGINT(11)DEFAULT NULL COMMENT '产品id', `count` INT(11) DEFAULT NULL COMMENT '数量', `money` DECIMAL(11,0) DEFAULT NULL COMMENT '金额', `status` INT(1) DEFAULT NULL COMMENT '订单状态: 0:创建中; 1:已完结' )ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; SELECT * FROM t_order; -- for AT mode you must to init this sql for you business database. the seata server not need it. CREATE TABLE IF NOT EXISTS `undo_log` ( `branch_id` BIGINT NOT NULL COMMENT 'branch transaction id', `xid` VARCHAR(128) NOT NULL COMMENT 'global transaction id', `context` VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization', `rollback_info` LONGBLOB NOT NULL COMMENT 'rollback info', `log_status` INT(11) NOT NULL COMMENT '0:normal status,1:defense status', `log_created` DATETIME(6) NOT NULL COMMENT 'create datetime', `log_modified` DATETIME(6) NOT NULL COMMENT 'modify datetime', UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table'; ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`); \",\"#storage CREATE DATABASE seata_storage; USE seata_storage; CREATE TABLE t_storage( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `product_id` BIGINT(11) DEFAULT NULL COMMENT '产品id', `total` INT(11) DEFAULT NULL COMMENT '总库存', `used` INT(11) DEFAULT NULL COMMENT '已用库存', `residue` INT(11) DEFAULT NULL COMMENT '剩余库存' )ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; INSERT INTO t_storage(`id`,`product_id`,`total`,`used`,`residue`)VALUES('1','1','100','0','100'); SELECT * FROM t_storage; -- for AT mode you must to init this sql for you business database. the seata server not need it. CREATE TABLE IF NOT EXISTS `undo_log` ( `branch_id` BIGINT NOT NULL COMMENT 'branch transaction id', `xid` VARCHAR(128) NOT NULL COMMENT 'global transaction id', `context` VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization', `rollback_info` LONGBLOB NOT NULL COMMENT 'rollback info', `log_status` INT(11) NOT NULL COMMENT '0:normal status,1:defense status', `log_created` DATETIME(6) NOT NULL COMMENT 'create datetime', `log_modified` DATETIME(6) NOT NULL COMMENT 'modify datetime', UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table'; ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`); \",\"#account create database seata_account; use seata_account; CREATE TABLE t_account( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT 'id', `user_id` BIGINT(11) DEFAULT NULL COMMENT '用户id', `total` DECIMAL(10,0) DEFAULT NULL COMMENT '总额度', `used` DECIMAL(10,0) DEFAULT NULL COMMENT '已用余额', `residue` DECIMAL(10,0) DEFAULT '0' COMMENT '剩余可用额度' )ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO t_account(`id`,`user_id`,`total`,`used`,`residue`)VALUES('1','1','1000','0','1000'); SELECT * FROM t_account; -- for AT mode you must to init this sql for you business database. the seata server not need it. CREATE TABLE IF NOT EXISTS `undo_log` ( `branch_id` BIGINT NOT NULL COMMENT 'branch transaction id', `xid` VARCHAR(128) NOT NULL COMMENT 'global transaction id', `context` VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization', `rollback_info` LONGBLOB NOT NULL COMMENT 'rollback info', `log_status` INT(11) NOT NULL COMMENT '0:normal status,1:defense status', `log_created` DATETIME(6) NOT NULL COMMENT 'create datetime', `log_modified` DATETIME(6) NOT NULL COMMENT 'modify datetime', UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table'; ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`); \",\"MyBatis一键生成代码\",\"config.properties\",\"# seata_order #jdbc.driverClass = com.mysql.cj.jdbc.Driver #jdbc.url = jdbc:mysql://localhost:3306/seata_order?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true #jdbc.user = root #jdbc.password =root # seata_storage #jdbc.driverClass = com.mysql.cj.jdbc.Driver #jdbc.url = jdbc:mysql://localhost:3306/seata_storage?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true #jdbc.user = root #jdbc.password =root # seata_account jdbc.driverClass = com.mysql.cj.jdbc.Driver jdbc.url = jdbc:mysql://localhost:3306/seata_account?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true jdbc.user = root jdbc.password =root \",\"generatorConfig.xml\",\" <!-- seata_order --> <!-- <table tableName=\\\"t_order\\\" domainObjectName=\\\"Order\\\"> <generatedKey column=\\\"id\\\" sqlStatement=\\\"JDBC\\\"/> </table>--> <!--seata_storage--> <!-- <table tableName=\\\"t_storage\\\" domainObjectName=\\\"Storage\\\"> <generatedKey column=\\\"id\\\" sqlStatement=\\\"JDBC\\\"/> </table>--> <!--seata_account--> <table tableName=\\\"t_account\\\" domainObjectName=\\\"Account\\\"> <generatedKey column=\\\"id\\\" sqlStatement=\\\"JDBC\\\"/> </table> \",\"cloud-api-commons 增加 StorageFeignApi、AccountFeignApi 俩个OpenFeign调用接口\",\"@FeignClient(value = \\\"seata-account-service\\\") public interface AccountFeignApi { //扣减账户余额 @PostMapping(\\\"/account/decrease\\\") ResultData decrease(@RequestParam(\\\"userId\\\") Long userId, @RequestParam(\\\"money\\\") Long money); \",\"@FeignClient(value = \\\"seata-account-service\\\") public interface AccountFeignApi { //扣减账户余额 @PostMapping(\\\"/account/decrease\\\") ResultData decrease(@RequestParam(\\\"userId\\\") Long userId, @RequestParam(\\\"money\\\") Long money); } \"]},\"432\":{\"h\":\"\",\"t\":[\"将自动生成的 entity、mapper放到对应的文件夹，此步骤省略~\",\"POM\",\" <dependencies> <!-- nacos --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> <!--alibaba-seata--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-seata</artifactId> </dependency> <!--openfeign--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> <!--loadbalancer--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-loadbalancer</artifactId> </dependency> <!--cloud-api-commons--> <dependency> <groupId>com.atguigu.cloud</groupId> <artifactId>cloud-api-commons</artifactId> <version>1.0-SNAPSHOT</version> </dependency> <!--web + actuator--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <!--SpringBoot集成druid连接池--> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid-spring-boot-starter</artifactId> </dependency> <!-- Swagger3 调用方式 http://你的主机IP地址:5555/swagger-ui/index.html --> <dependency> <groupId>org.springdoc</groupId> <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId> </dependency> <!--mybatis和springboot整合--> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> </dependency> <!--Mysql数据库驱动8 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!--persistence--> <dependency> <groupId>javax.persistence</groupId> <artifactId>persistence-api</artifactId> </dependency> <!--通用Mapper4--> <dependency> <groupId>tk.mybatis</groupId> <artifactId>mapper</artifactId> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> </dependency> <!-- fastjson2 --> <dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.28</version> <scope>provided</scope> </dependency> <!--test--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> \",\"yaml\",\"server: port: 2001 spring: application: name: seata-order-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 # ==========applicationName + druid-mysql8 driver=================== datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_order?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true username: root password: root # ========================mybatis=================== mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.atguigu.cloud.entities configuration: map-underscore-to-camel-case: true # ========================seata=================== seata: registry: type: nacos nacos: server-addr: 127.0.0.1:8848 namespace: \\\"\\\" group: SEATA_GROUP application: seata-server tx-service-group: default_tx_group # 事务组，由它获得TC服务的集群名称 service: vgroup-mapping: # 点击源码分析 default_tx_group: default # 事务组与TC服务集群的映射关系 data-source-proxy-mode: AT logging: level: io: seata: info \",\"主启动类\",\"@SpringBootApplication @MapperScan(\\\"com.atguigu.cloud.mapper\\\") //import tk.mybatis.spring.annotation.MapperScan; @EnableDiscoveryClient //服务注册和发现 @EnableFeignClients public class SeataOrderMainApp2001 { public static void main(String[] args) { SpringApplication.run(SeataOrderMainApp2001.class,args); } } \",\"service\",\"public interface OrderService { /** * 创建订单 */ void create(Order order); } \",\"controller\",\"@RestController public class OrderController { @Resource private OrderService orderService; /** * 创建订单 */ @GetMapping(\\\"/order/create\\\") public ResultData create(Order order) { orderService.create(order); return ResultData.success(order); } } \",\"serviceImpl\",\"流程：\",\"插入订单 --》扣减库存 --》扣减账号余额 ---》修改订单状态\",\" String xid = RootContext.getXID(); 用于获取全局事务ID，建议每次使用都打印出来，方便检查！\",\"@Slf4j @Service public class OrderServiceImpl implements OrderService { @Resource private OrderMapper orderMapper; @Resource//订单微服务通过OpenFeign去调用库存微服务 private StorageFeignApi storageFeignApi; @Resource//订单微服务通过OpenFeign去调用账户微服务 private AccountFeignApi accountFeignApi; @Override @GlobalTransactional(name = \\\"zzyy-create-order\\\",rollbackFor = Exception.class) //AT //@GlobalTransactional @Transactional(rollbackFor = Exception.class) //XA public void create(Order order) { // !!!xid检查 String xid = RootContext.getXID(); //1. 新建订单 log.info(\\\"==================>开始新建订单\\\"+\\\"\\\\t\\\"+\\\"xid_order:\\\" +xid); //订单状态status：0：创建中；1：已完结 order.setStatus(0); int result = orderMapper.insertSelective(order); //插入订单成功后获得插入mysql的实体对象 Order orderFromDB = null; if(result > 0) { orderFromDB = orderMapper.selectOne(order); //orderFromDB = orderMapper.selectByPrimaryKey(order.getId()); log.info(\\\"-------> 新建订单成功，orderFromDB info: \\\"+orderFromDB); System.out.println(); //2. 扣减库存 log.info(\\\"-------> 订单微服务开始调用Storage库存，做扣减count\\\"); storageFeignApi.decrease(orderFromDB.getProductId(), orderFromDB.getCount()); log.info(\\\"-------> 订单微服务结束调用Storage库存，做扣减完成\\\"); System.out.println(); //3. 扣减账号余额 log.info(\\\"-------> 订单微服务开始调用Account账号，做扣减money\\\"); accountFeignApi.decrease(orderFromDB.getUserId(), orderFromDB.getMoney()); log.info(\\\"-------> 订单微服务结束调用Account账号，做扣减完成\\\"); System.out.println(); //4. 修改订单状态 //订单状态status：0：创建中；1：已完结 log.info(\\\"-------> 修改订单状态\\\"); orderFromDB.setStatus(1); // Example类似于MP中的QueryWrapper Example whereCondition=new Example(Order.class); Example.Criteria criteria=whereCondition.createCriteria(); criteria.andEqualTo(\\\"userId\\\",orderFromDB.getUserId()); criteria.andEqualTo(\\\"status\\\",0); int updateResult = orderMapper.updateByExampleSelective(orderFromDB, whereCondition); log.info(\\\"-------> 修改订单状态完成\\\"+\\\"\\\\t\\\"+updateResult); log.info(\\\"-------> orderFromDB info: \\\"+orderFromDB); } System.out.println(); log.info(\\\"==================>结束新建订单\\\"+\\\"\\\\t\\\"+\\\"xid_order:\\\" +xid); } } \"]},\"433\":{\"h\":\"新建库存 Storage 微服务\",\"t\":[\"启动类、yaml、POM 三个模块都一样，省略了~\",\"StorageMapper.xml\",\" <update id=\\\"decrease\\\"> UPDATE t_storage SET used = used + #{count}, residue = residue - #{count} WHERE product_id = #{productId} </update> \",\"StorageService\",\"public interface StorageService { /** * 扣减库存 */ void decrease(Long productId, Integer count); } \",\"StorageServiceImpl\",\"@Service @Slf4j public class StorageServiceImpl implements StorageService { @Resource private StorageMapper storageMapper; /** * 扣减库存 */ @Override public void decrease(Long productId, Integer count) { log.info(\\\"------->storage-service中扣减库存开始\\\"); storageMapper.decrease(productId,count); log.info(\\\"------->storage-service中扣减库存结束\\\"); } } \",\"StorageController\",\"@RestController public class StorageController { @Resource private StorageService storageService; /** * 扣减库存 */ @RequestMapping(\\\"/storage/decrease\\\") public ResultData decrease(Long productId, Integer count) { storageService.decrease(productId, count); return ResultData.success(\\\"扣减库存成功!\\\"); } } \"]},\"434\":{\"h\":\"新建库存 Account 微服务\",\"t\":[\"启动类、yaml、POM 三个模块都一样，省略了~\",\"AccountMapper.xml\",\" <update id=\\\"decrease\\\"> UPDATE t_account SET residue = residue - #{money},used = used + #{money} WHERE user_id = #{userId}; </update> \",\"AccountService\",\"public interface AccountService { /** * 扣减库存 */ void decrease(@Param(\\\"userId\\\") Long userId, @Param(\\\"money\\\") Long money); } \",\"AccountServiceImpl\",\"@Service @Slf4j public class AccountServiceImpl implements AccountService { @Resource AccountMapper accountMapper; /** * 扣减账户余额 */ @Override public void decrease(Long userId, Long money) { log.info(\\\"------->account-service中扣减账户余额开始\\\"); accountMapper.decrease(userId,money); //myTimeOut(); //int age = 10/0; log.info(\\\"------->account-service中扣减账户余额结束\\\"); } /** * 模拟超时异常，全局事务回滚 */ private static void myTimeOut() { try { TimeUnit.SECONDS.sleep(65); } catch (InterruptedException e) { e.printStackTrace(); } } } \",\"AccountController\",\"@RestController public class AccountController { @Resource AccountService accountService; /** * 扣减账户余额 */ @RequestMapping(\\\"/account/decrease\\\") public ResultData decrease(@RequestParam(\\\"userId\\\") Long userId, @RequestParam(\\\"money\\\") Long money){ accountService.decrease(userId,money); return ResultData.success(\\\"扣减账户余额成功！\\\"); } } \"]},\"435\":{\"h\":\"\",\"t\":[\"http://localhost:2001/order/create?userId=1&productId=1&count=10&money=100\",\"在没有增加 @GlobalTransactional 的情况下：\",\"在 seata-account-service2003 中，扣减账户时，设置超时，OpenFeign 默认超时 60S，\",\"超过 60S 就会报错！\",\"image-20240408231109741\",\"先来观察数据库的初始情况：\",\"image-20240408231312526\",\"发送请求完，发现订单创建了、库存扣减了、 但是在账户上却没有扣减，这就没有保证数据一致性的问题！\",\"image-20240408231538674\",\"增加 @GlobalTransactional 的情况下：\",\"再来看一下这个图，事务的发起者 TM 上增加 @GlobalTransactional 注解，在本案例中就是在订单服务中增加\",\"image-20240408232346946\",\"此时在发送请求时，数据库正常回滚了！\",\"image-20240408232842558\"]},\"436\":{\"h\":\"4.4 Seata 原理\",\"t\":[\"默认讲解的模式为 AT\",\"采用两阶段提交协议的演变，保证分布式事务：\",\"在一阶段 --- 加载，Seata 会拦截“业务 SQL”，\",\"解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成 before image，\",\"执行“业务 SQL”更新业务数据，在业务数据更新之后，\",\"其保存成 after image，最后生成行锁。\",\"image-20240409093644143\",\"第二阶段 ---- 提交\",\"二阶段如是顺利提交的话，因为“业务 SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。\",\"image-20240409093736742\",\"二阶段 ----- 回滚\",\"二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。 回滚方式便是用“before image”还原业务数据；\",\"但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。\"]},\"437\":{\"c\":[\"微服务\"]},\"438\":{\"c\":[\"SpringCloud Alibaba\",\"Nacos\",\"Sentinel\",\"Seata\"]},\"439\":{\"h\":\"SpringCloud\",\"t\":[\"提示\",\"本文档只讲解微服务的基础使用,想要了解深层次的原理请跳过，避免耽误时间！！\",\"所有代码均在GitHub,需要请自取\",\"https://github.com/yangzhaoguang/cloud2024.git\",\"目前常用的组件：\",\"image-20240403150037397\"]},\"440\":{\"h\":\"一、搭建示例项目\",\"t\":[\"注\",\"以下为详细的搭建流程，若嫌麻烦 可以接 clone 我的代码，回退到 BASE CODE 即可！！ https://github.com/yangzhaoguang/cloud2024.git\",\"业务图\",\"模拟订单支付的简单业务\",\"image-20240403190803023\",\"数据库表SQL\",\"DROP TABLE IF EXISTS `t_pay`; CREATE TABLE `t_pay` ( `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `pay_no` VARCHAR(50) NOT NULL COMMENT '支付流水号', `order_no` VARCHAR(50) NOT NULL COMMENT '订单流水号', `user_id` INT(10) DEFAULT '1' COMMENT '用户账号ID', `amount` DECIMAL(8,2) NOT NULL DEFAULT '9.9' COMMENT '交易金额', `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT '0' COMMENT '删除标志，默认0不删除，1删除', `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT='支付交易表'; INSERT INTO t_pay(pay_no,order_no) VALUES('pay17203699','6544bafb424a'); SELECT * FROM t_pay; \"]},\"441\":{\"h\":\"1.1 环境搭建\",\"t\":[\"版本要求\",\"重要\",\"由于Maven使用版本较高，可能需要将IDEA升级成2023（2022不知道行不行，反正2021不行~~）\",\"image-20240403150916271\",\"搭建Maven父工程\",\"image-20240403151142511\",\"一些Setting\",\"字符编码\",\"image-20240403151215573\",\"注解生效\",\"image-20240403151239930\",\"Java编译版本\",\"image-20240403151300525\",\"POM\",\"dependencyManagement 和 dependencies 的区别：\",\"dependencyManagement 是用来管理版本依赖版本号的 ，出现在父工程中 。所有的子项目都统一使用同一个版本号。 dependencyManagement 并不会引入 jar 包 ，而是声明 jar 包，真正引入 jar 应该在 子工程的 dependencies 下 ，而在子工程中不需要写另外的版本号，如果需要新的版本号在子工程中重新指明 version 即可 ！\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.atguigu.cloud</groupId> <artifactId>cloud2024</artifactId> <version>1.0-SNAPSHOT</version> <packaging>pom</packaging> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <hutool.version>5.8.22</hutool.version> <lombok.version>1.18.26</lombok.version> <druid.version>1.1.20</druid.version> <mybatis.springboot.version>3.0.2</mybatis.springboot.version> <mysql.version>8.0.11</mysql.version> <swagger3.version>2.2.0</swagger3.version> <mapper.version>4.2.3</mapper.version> <fastjson2.version>2.0.40</fastjson2.version> <persistence-api.version>1.0.2</persistence-api.version> <spring.boot.test.version>3.1.5</spring.boot.test.version> <spring.boot.version>3.2.0</spring.boot.version> <spring.cloud.version>2023.0.0</spring.cloud.version> <spring.cloud.alibaba.version>2022.0.0.0-RC2</spring.cloud.alibaba.version> </properties> <dependencyManagement> <dependencies> <!--springboot 3.2.0--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>${spring.boot.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!--springcloud 2023.0.0--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>${spring.cloud.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!--springcloud alibaba 2022.0.0.0-RC2--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-alibaba-dependencies</artifactId> <version>${spring.cloud.alibaba.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!--SpringBoot集成mybatis--> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>${mybatis.springboot.version}</version> </dependency> <!--Mysql数据库驱动8 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>${mysql.version}</version> </dependency> <!--SpringBoot集成druid连接池--> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid-spring-boot-starter</artifactId> <version>${druid.version}</version> </dependency> <!--通用Mapper4之tk.mybatis--> <dependency> <groupId>tk.mybatis</groupId> <artifactId>mapper</artifactId> <version>${mapper.version}</version> </dependency> <!--persistence--> <dependency> <groupId>javax.persistence</groupId> <artifactId>persistence-api</artifactId> <version>${persistence-api.version}</version> </dependency> <!-- fastjson2 --> <dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2</artifactId> <version>${fastjson2.version}</version> </dependency> <!-- swagger3 调用方式 http://你的主机IP地址:5555/swagger-ui/index.html --> <dependency> <groupId>org.springdoc</groupId> <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId> <version>${swagger3.version}</version> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> <version>${hutool.version}</version> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>${lombok.version}</version> <optional>true</optional> </dependency> <!-- spring-boot-starter-test --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <version>${spring.boot.test.version}</version> <scope>test</scope> </dependency> </dependencies> </dependencyManagement> </project> \"]},\"442\":{\"h\":\"1.2 Mapper4一键生成\",\"t\":[\"官网：https://github.com/abel533/Mapper\",\"创建一个名称为 mybatis_generator2024 的Maven工程\",\"image-20240403154635126\",\"引入 POM：\",\" <dependencies> <!--Mybatis 通用mapper tk单独使用，自己独有+自带版本号--> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.13</version> </dependency> <!-- Mybatis Generator 自己独有+自带版本号--> <dependency> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-core</artifactId> <version>1.4.2</version> </dependency> <!--通用Mapper--> <dependency> <groupId>tk.mybatis</groupId> <artifactId>mapper</artifactId> </dependency> <!--mysql8.0--> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!--persistence--> <dependency> <groupId>javax.persistence</groupId> <artifactId>persistence-api</artifactId> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> <exclusions> <exclusion> <groupId>org.junit.vintage</groupId> <artifactId>junit-vintage-engine</artifactId> </exclusion> </exclusions> </dependency> </dependencies> <build> <resources> <resource> <directory>${basedir}/src/main/java</directory> <includes> <include>**/*.xml</include> </includes> </resource> <resource> <directory>${basedir}/src/main/resources</directory> </resource> </resources> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.4.2</version> <configuration> <configurationFile>${basedir}/src/main/resources/generatorConfig.xml</configurationFile> <overwrite>true</overwrite> <verbose>true</verbose> </configuration> <dependencies> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.33</version> </dependency> <dependency> <groupId>tk.mybatis</groupId> <artifactId>mapper</artifactId> <version>4.2.3</version> </dependency> </dependencies> </plugin> </plugins> </build> \",\"创建配置文件\",\"properties：\",\"#t_pay表包名 package.name=com.atguigu.cloud # mysql8.0 jdbc.driverClass = com.mysql.cj.jdbc.Driver jdbc.url= jdbc:mysql://localhost:3306/cloud2024?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true jdbc.user = root jdbc.password =root \",\"generatorConfig.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE generatorConfiguration PUBLIC \\\"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\\\"> <generatorConfiguration> <properties resource=\\\"config.properties\\\"/> <context id=\\\"Mysql\\\" targetRuntime=\\\"MyBatis3Simple\\\" defaultModelType=\\\"flat\\\"> <property name=\\\"beginningDelimiter\\\" value=\\\"`\\\"/> <property name=\\\"endingDelimiter\\\" value=\\\"`\\\"/> <plugin type=\\\"tk.mybatis.mapper.generator.MapperPlugin\\\"> <property name=\\\"mappers\\\" value=\\\"tk.mybatis.mapper.common.Mapper\\\"/> <property name=\\\"caseSensitive\\\" value=\\\"true\\\"/> </plugin> <jdbcConnection driverClass=\\\"${jdbc.driverClass}\\\" connectionURL=\\\"${jdbc.url}\\\" userId=\\\"${jdbc.user}\\\" password=\\\"${jdbc.password}\\\"> </jdbcConnection> <!--包名--> <javaModelGenerator targetPackage=\\\"${package.name}.entities\\\" targetProject=\\\"src/main/java\\\"/> <sqlMapGenerator targetPackage=\\\"${package.name}.mapper\\\" targetProject=\\\"src/main/java\\\"/> <javaClientGenerator targetPackage=\\\"${package.name}.mapper\\\" targetProject=\\\"src/main/java\\\" type=\\\"XMLMAPPER\\\"/> <!--表名以及对应的实体类--> <table tableName=\\\"t_pay\\\" domainObjectName=\\\"Pay\\\"> <generatedKey column=\\\"id\\\" sqlStatement=\\\"JDBC\\\"/> </table> </context> </generatorConfiguration> \",\"一切就绪之后，双击插件即可：\",\"image-20240403175504845\"]},\"443\":{\"h\":\"1.3 新建支付模块\",\"t\":[\"新建一个支付模块\",\"image-20240403180158686\",\"POM\",\" <dependencies> <!--SpringBoot通用依赖模块--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <!--SpringBoot集成druid连接池--> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid-spring-boot-starter</artifactId> </dependency> <!-- Swagger3 调用方式 http://你的主机IP地址:5555/swagger-ui/index.html --> <dependency> <groupId>org.springdoc</groupId> <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId> </dependency> <!--mybatis和springboot整合--> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> </dependency> <!--Mysql数据库驱动8 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!--persistence--> <dependency> <groupId>javax.persistence</groupId> <artifactId>persistence-api</artifactId> </dependency> <!--通用Mapper4--> <dependency> <groupId>tk.mybatis</groupId> <artifactId>mapper</artifactId> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> </dependency> <!-- fastjson2 --> <dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.28</version> <scope>provided</scope> </dependency> <!--test--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"yaml配置文件\",\"server: port: 8001 # ==========applicationName + druid-mysql8 driver=================== spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/cloud2024?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true username: root password: root # ========================mybatis=================== mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.atguigu.cloud.entities configuration: map-underscore-to-camel-case: true \",\"PayService\",\"public interface PayService { public int add(Pay pay); public int delete(Integer id); public int update(Pay pay); public Pay getById(Integer id); public List<Pay> getAll(); } \",\"PayServiceImpl\",\"public class PayServiceImpl implements PayService { @Resource PayMapper payMapper; @Override public int add(Pay pay){ return payMapper.insertSelective(pay); } @Override public int delete(Integer id){ return payMapper.deleteByPrimaryKey(id); } @Override public int update(Pay pay){ return payMapper.updateByPrimaryKeySelective(pay); } @Override public Pay getById(Integer id){ return payMapper.selectByPrimaryKey(id); } @Override public List<Pay> getAll(){ return payMapper.selectAll(); } } \",\"PayController\",\"@RestController public class PayController{ @Resource PayService payService; @PostMapping(value = \\\"/pay/add\\\") public String addPay(@RequestBody Pay pay){ System.out.println(pay.toString()); int i = payService.add(pay); return \\\"成功插入记录，返回值：\\\"+i; } @DeleteMapping(value = \\\"/pay/del/{id}\\\") public Integer deletePay(@PathVariable(\\\"id\\\") Integer id) { return payService.delete(id); } @PutMapping(value = \\\"/pay/update\\\") public String updatePay(@RequestBody PayDTO payDTO){ Pay pay = new Pay(); BeanUtils.copyProperties(payDTO, pay); int i = payService.update(pay); return \\\"成功修改记录，返回值：\\\"+i; } @GetMapping(value = \\\"/pay/get/{id}\\\") public Pay getById(@PathVariable(\\\"id\\\") Integer id){ return payService.getById(id); }//全部查询getall作为家庭作业 } \",\"主启动类\",\"@SpringBootApplication @MapperScan(\\\"com.atguigu.cloud.mapper\\\") public class Main8001 { public static void main(String[] args) { SpringApplication.run(Main8001.class,args); } } \",\"PayDTO\",\"@Data @AllArgsConstructor @NoArgsConstructor public class PayDTO implements Serializable { private Integer id; //支付流水号 private String payNo; //订单流水号 private String orderNo; //用户账号ID private Integer userId; //交易金额 private BigDecimal amount; } \",\"将mybatis_generator2024中生成的 mapper、entity拷贝到此模块！\",\"最后使用postman、Swagger测试\"]},\"444\":{\"h\":\"1.4 解决时间格式、同一返回结果\",\"t\":[\"时间格式修改\",\"修改yaml\",\"spring: jackson: date-format: yyyy-MM-dd HH:mm:ss \",\"指定字段上使用注解\",\" @Column(name = \\\"update_time\\\") @JsonFormat(pattern = \\\"yyyy-MM-dd HH:mm:ss\\\", timezone = \\\"GMT+8\\\") private Date updateTime; @Column(name = \\\"create_time\\\") @JsonFormat(pattern = \\\"yyyy-MM-dd HH:mm:ss\\\", timezone = \\\"GMT+8\\\") private Date createTime; \",\"统一返回结果\",\"通用HTTP返回状态码：\",\"image-20240403184340723\",\"枚举类\",\"@Getter public enum ReturnCodeEnum { /**操作失败**/ RC999(\\\"999\\\",\\\"操作XXX失败\\\"), /**操作成功**/ RC200(\\\"200\\\",\\\"success\\\"), /**服务降级**/ RC201(\\\"201\\\",\\\"服务开启降级保护,请稍后再试!\\\"), /**热点参数限流**/ RC202(\\\"202\\\",\\\"热点参数限流,请稍后再试!\\\"), /**系统规则不满足**/ RC203(\\\"203\\\",\\\"系统规则不满足要求,请稍后再试!\\\"), /**授权规则不通过**/ RC204(\\\"204\\\",\\\"授权规则不通过,请稍后再试!\\\"), /**access_denied**/ RC403(\\\"403\\\",\\\"无访问权限,请联系管理员授予权限\\\"), /**access_denied**/ RC401(\\\"401\\\",\\\"匿名用户访问无权限资源时的异常\\\"), RC404(\\\"404\\\",\\\"404页面找不到的异常\\\"), /**服务异常**/ RC500(\\\"500\\\",\\\"系统异常，请稍后重试\\\"), RC375(\\\"375\\\",\\\"数学运算异常，请稍后重试\\\"), INVALID_TOKEN(\\\"2001\\\",\\\"访问令牌不合法\\\"), ACCESS_DENIED(\\\"2003\\\",\\\"没有权限访问该资源\\\"), CLIENT_AUTHENTICATION_FAILED(\\\"1001\\\",\\\"客户端认证失败\\\"), USERNAME_OR_PASSWORD_ERROR(\\\"1002\\\",\\\"用户名或密码错误\\\"), BUSINESS_ERROR(\\\"1004\\\",\\\"业务逻辑异常\\\"), UNSUPPORTED_GRANT_TYPE(\\\"1003\\\", \\\"不支持的认证模式\\\"); /**自定义状态码**/ private final String code; /**自定义描述**/ private final String message; ReturnCodeEnum(String code, String message){ this.code = code; this.message = message; } //遍历枚举V1 public static ReturnCodeEnum getReturnCodeEnum(String code) { for (ReturnCodeEnum element : ReturnCodeEnum.values()) { if(element.getCode().equalsIgnoreCase(code)) { return element; } } return null; } //遍历枚举V2 public static ReturnCodeEnum getReturnCodeEnumV2(String code) { return Arrays.stream(ReturnCodeEnum.values()).filter(x -> x.getCode().equalsIgnoreCase(code)).findFirst().orElse(null); } /*public static void main(String[] args) { System.out.println(getReturnCodeEnumV2(\\\"200\\\")); System.out.println(getReturnCodeEnumV2(\\\"200\\\").getCode()); System.out.println(getReturnCodeEnumV2(\\\"200\\\").getMessage()); }*/ } \",\"统一返回结果\",\"@Data @Accessors(chain = true) public class ResultData<T> { private String code;/** 结果状态 ,具体状态码参见枚举类ReturnCodeEnum.java*/ private String message; private T data; private long timestamp ; public ResultData (){ this.timestamp = System.currentTimeMillis(); } public static <T> ResultData<T> success(T data) { ResultData<T> resultData = new ResultData<>(); resultData.setCode(ReturnCodeEnum.RC200.getCode()); resultData.setMessage(ReturnCodeEnum.RC200.getMessage()); resultData.setData(data); return resultData; } public static <T> ResultData<T> fail(String code, String message) { ResultData<T> resultData = new ResultData<>(); resultData.setCode(code); resultData.setMessage(message); return resultData; } } \"]},\"445\":{\"h\":\"1.5 全局异常处理\",\"t\":[\"@Slf4j @RestControllerAdvice public class GlobalExceptionHandler { /** * 默认全局异常处理。 * @param e the e * @return ResultData */ @ExceptionHandler(RuntimeException.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData<String> exception(Exception e) { System.out.println(\\\"----come in GlobalExceptionHandler\\\"); log.error(\\\"全局异常信息exception:{}\\\", e.getMessage(), e); return ResultData.fail(ReturnCodeEnum.RC500.getCode(),e.getMessage()); } } \"]},\"446\":{\"h\":\"1.6 新建订单模块\",\"t\":[\"image-20240403190958476\",\"POM\",\" <dependencies> <!--web + actuator--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <!--lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <!--hutool-all--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> </dependency> <!--fastjson2--> <dependency> <groupId>com.alibaba.fastjson2</groupId> <artifactId>fastjson2</artifactId> </dependency> <!-- swagger3 调用方式 http://你的主机IP地址:5555/swagger-ui/index.html --> <dependency> <groupId>org.springdoc</groupId> <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"yaml\",\"server: port: 80 \",\"主启动类\",\"@SpringBootApplication public class Main80 { public static void main(String[] args) { SpringApplication.run(Main80.class,args); } } \",\"由于订单模块需要调用支付模块，在未使用微服务之前，暂时通过 RESTTemplate 调用：\",\"配置类\",\"@SpringBootApplication public class Main80 { public static void main(String[] args) { SpringApplication.run(Main80.class,args); } } \",\"Controller\",\"@RestController public class OrderController{ public static final String PaymentSrv_URL = \\\"http://localhost:8001\\\";//先写死，硬编码 @Autowired private RestTemplate restTemplate; /** * 一般情况下，通过浏览器的地址栏输入url，发送的只能是get请求 * 我们底层调用的是post方法，模拟消费者发送get请求，客户端消费者 * 参数可以不添加@RequestBody * @param payDTO * @return */ @GetMapping(\\\"/consumer/pay/add\\\") public ResultData addOrder(PayDTO payDTO){ return restTemplate.postForObject(PaymentSrv_URL + \\\"/pay/add\\\",payDTO,ResultData.class); } // 删除+修改操作作为家庭作业，O(∩_∩)O。。。。。。。 @GetMapping(\\\"/consumer/pay/get/{id}\\\") public ResultData getPayInfo(@PathVariable(\\\"id\\\") Integer id){ return restTemplate.getForObject(PaymentSrv_URL + \\\"/pay/get/\\\"+id, ResultData.class, id); } } \"]},\"447\":{\"h\":\"1.7 目前项目存在的问题\",\"t\":[\"项目中有大量重复的代码，类，通常在开发中，会将共同的类都存放在另一个模块下\",\"因此我们重新创建一个 cloud-api-commons 模块，用来存放公共的类！\",\"image-20240404085317620\",\"上面的Controller中，我们使用 RESTTemplate调用 支付接口，这样有什么问题？\",\"1、如果订单微服务和支付微服务的IP地址或者端口号发生了变化，则需要重新修改\",\"2、如果系统中提供了多个订单微服务和支付微服务，则无法实现微服务的负载均衡功能\",\"3、如果系统需要支持更高的并发，需要部署更多的订单微服务和支付微服务，硬编码订单微服务则后续的维护会变得异常复杂\",\"因此，就下来就学习 微服务！！\"]},\"448\":{\"h\":\"二、Consul\"},\"449\":{\"h\":\"2.1 介绍、安装\",\"t\":[\"Consul 是一套开源的分布式服务发现和 配置管理系统，由 HashiCorp 公司用 Go 语言开发。\",\"提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\",\"功能\",\"服务发现 ： 提供 HTTP 和 DNS 俩中发现方式\",\"健康检测：支持多种方式，HTTP、TCP\",\"KV 存储：Key、Value 的存储方式\",\"多数据中心\",\"可视化 Web 界面\",\"下载\",\"https://www.consul.io/downloads.html\",\"下载后只有一个 exe 文件，使用 cmd 命令行查看 consul 版本信息：\",\"consul -version \",\"使用开发者模式启动：\",\"consul agent -dev \",\"访问 web 管理界面：\",\"http://localhost:8500\"]},\"450\":{\"h\":\"2.2 服务注册\",\"t\":[\"POM增加依赖\",\" <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-consul-discovery</artifactId> </dependency> \",\"配置\",\"spring: application: name: cloud-payment-service cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name} # 服务名 \",\"主启动类增加 @EnableDiscoveryClient 注解！\",\"启动报错\",\"image-20240404093343196\",\"与 commons-logging 包冲突，需要在依赖中排除\",\" <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-consul-discovery</artifactId> <exclusions> <exclusion> <groupId>commons-logging</groupId> <artifactId>commons-logging</artifactId> </exclusion> </exclusions> </dependency> \"]},\"451\":{\"h\":\"2.3 小问题\",\"t\":[\"此时已经将俩个模块注册到 Consul 中，在 OrderController 中就可以使用 服务名 替代具体的 IP地址了\",\"image-20240404094642750\",\" public static final String PaymentSrv_URL = \\\"http://cloud-payment-service\\\";//服务注册中心上的微服务名称 \",\"此时访问 http://localhost:80/consumer/pay/get/1 报错，\",\"image-20240404095040744\",\"这是因为 Consul 天生支持负载均衡，默认有多个cloud-payment-service，需要配置负载均衡，在 RestTemplate 方法上增加 @LoadBalanced 注解\",\"image-20240404095624490\"]},\"452\":{\"h\":\"2.4 分布式配置\",\"t\":[\"由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。比如某些配置文件中的内容大部分都是相同的，只有个别的配置项不同。就拿数据库配置来说吧，如果每个微服务使用的技术栈都是相同的，则每个微服务中关于数据库的配置几乎都是相同的，有时候主机迁移了，我希望一次修改，处处生效。\",\"在 Consul 中提供了 分布式配置 的功能，下面看看如何使用！\",\"Consul 配置规则\",\"默认是 config/应用名,环境/data ，默认读取data 配置文件\",\"config/application,dev/data config/application/data \",\"分隔符可通过: spring.cloud.consul.config.profile-separator 设置\",\"读取的配置文件可以通过: spring.cloud.consul.config.data-key 配置\",\"1、引入依赖\",\" <!--SpringCloud consul config--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-consul-config</artifactId> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-bootstrap</artifactId> </dependency> \",\"2、新增 bootstrap.yaml 配置文件\",\"spring: application: name: cloud-payment-service ####Spring Cloud Consul for Service Discovery cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name} config: profile-separator: '-' # default value is \\\",\\\"，we update '-' format: YAML \",\"3、application.yaml\",\"server: port: 8001 # ==========applicationName + druid-mysql8 driver=================== spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/cloud2024?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8&rewriteBatchedStatements=true&allowPublicKeyRetrieval=true username: root password: root # ========================mybatis=================== mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.atguigu.cloud.entities configuration: map-underscore-to-camel-case: true \",\"applicaiton.yml是用户级的资源配置项\",\"bootstrap.yml是系统级的，优先级更加高\",\"4、在 Consul 中创建配置文件，一定要符合 规则\",\"一共有三层：\",\"第一层为 config/\",\"第二层为：应用名-环境/\",\"第三层为 data配置文件\",\"注意右上角的格式为 Yaml，要和你配置的format 一样\",\"image-20240404153112431\"]},\"453\":{\"h\":\"2.5 动态刷新\",\"t\":[\"当修改 Consul 上的配置时，客户端无法做到实时更新\",\"在主启动类上@RefreshScope 注解\",\"可以设置 spring.cloud.consul.config.watch.wait-time 指明等待多少时间同步更新，默认是 55s\"]},\"454\":{\"h\":\"2.6 配置持久化\",\"t\":[\"当Consul 重启之后，在上面的配置就会消失 ， 因此需要配置 持久化 , 保证 配置不会丢失\",\"1、创建一个 myData 文件夹，将配置保存在此处\",\"image-20240404161459754\",\"2、在此目录下创建 consul_start.bat 启动脚本\",\"将 -data-dir、binpath 改成你自己 的路径\",\"@echo.服务启动...... @echo off @sc create Consul binpath= \\\"C:\\\\Java\\\\java_notes\\\\13.SpringCloud\\\\software\\\\consul.exe agent -server -ui -bind=127.0.0.1 -client=0.0.0.0 -bootstrap-expect 1 -data-dir C:\\\\Java\\\\java_notes\\\\13.SpringCloud\\\\software\\\\myData\\\" @net start Consul @sc config Consul start= AUTO @echo.Consul start is OK......success @pause \",\"若你第一次因为 路径错误 找不到文件启动失败，以管理员身份启动 cmd , 执行 sc delete Consul 后, 修改正确的路径，再次管理员身份运行 bat\",\"3、以管理员身份运行，启动成功\",\"image-20240404162958313\",\"4、此时在 Consul 上增加的配置就会保存到 myData 目录下\",\"image-20240404163255634\"]},\"455\":{\"h\":\"三、服务调用\"},\"456\":{\"h\":\"3.1 LoadBalance\"},\"457\":{\"h\":\"3.1.1 介绍\",\"t\":[\"由于 SpringCloud 的 Ribbon 已经停更，官网明确说明使用 LoadBalance替换 Ribbon\",\"LB负载均衡(Load Balance)是什么\",\"简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。常见的负载均衡有软件Nginx，LVS，硬件 F5等。\",\"LoadBalance本地负载均衡客户端 VS Nginx服务端负载均衡区别\",\"Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\",\"LoadBalance本地负载均衡，在调用其他微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\"]},\"458\":{\"h\":\"3.1.2 如何使用\",\"t\":[\"官网地址\",\"https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer\",\"从官网得知 LB 为负载均衡器的抽象和实现\",\"image-20240404160254565\",\"具体的通过 RestTemplate 实现 LB\",\"image-20240404160411124\",\"可通过增加 @LoadBalanced 、 @Bean 俩个注解实现 LB\",\"image-20240404160450799\"]},\"459\":{\"h\":\"3.1.3 案例演示\",\"t\":[\"拷贝 8001 为 8002 微服务，通过调用 80 服务，来实现 8001/8002 的负载均衡\",\"启动成功后，Consul中 cloud-payment-service 服务已经变成俩个，一个8001，一个8002\",\"image-20240404165630286\",\"修改80订单服务，通过负载均衡调用 8001/8002\",\"1、新增 loadbalance 依赖\",\" <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-loadbalancer</artifactId> </dependency> \",\"2、修改Controller\",\" @GetMapping(value = \\\"/consumer/pay/get/info\\\") private String getInfoByConsul() { return restTemplate.getForObject(PaymentSrv_URL + \\\"/pay/get/info\\\", String.class); } \",\"3、访问 /consumer/pay/get/info\"]},\"460\":{\"h\":\"3.1.4 负载均衡原理\",\"t\":[\"rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标\",\"每次服务重启动后rest接口计数从 1 开始。\",\"例如：\",\"List<ServiceInstance> instances = discoveryClient.getInstances(\\\"CLOUD-PAYMENT-SERVICE\\\"); 如： List [0] instances = 127.0.0.1:8002 List [1] instances = 127.0.0.1:8001 8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理： 当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为 127.0.0.1:8001 当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为 127.0.0.1:8002 当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为 127.0.0.1:8001 当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为 127.0.0.1:8002 如此类推...... \"]},\"461\":{\"h\":\"3.2 OpenFeign\"},\"462\":{\"h\":\"3.2.1 介绍\",\"t\":[\"官网地址\",\"https://github.com/spring-cloud/spring-cloud-openfeign\",\"Feign 是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加 @FeignClient 注解即可\",\"OpenFeign 较与 Loadbalance 的优势？\",\"前面在使用 LoadBalance 时，我们需要手动 New RestTemplate 去调用服务端接口，但实际上一个项目中可能有多处需要调用，每一个都要自己去 New， 一是管理不方便，二是并没有实现接口编程！\",\"而 OpenFeign 的出现正解决了这一难题，通过定义一个接口 + 一个注解 完成 对外暴露可以被调用的接口方法清单。大大简化和降低了调用客户端的开发量。\",\"OpenFeign同时还集成SpringCloud LoadBalancer、阿里巴巴Sentinel来提供熔断、降级等功能。\"]},\"463\":{\"h\":\"3.2.2 如何使用\",\"t\":[\"1、增加依赖\",\" <!--openfeign--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> \",\"2、在客户端的主启动类上增加 @EnableFeignClients 注解\",\"需要调用接口的 模块 增加 @EnableFeignClients\",\"@SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } \",\"3、再客户端中暴露的接口清单中增加 @FeignClient(\\\"stores\\\") ， 里面的value值为 服务端名称，也就是实现这些方法的模块！\",\"@FeignClient(\\\"stores\\\") public interface StoreClient { @RequestMapping(method = RequestMethod.GET, value = \\\"/stores\\\") List<Store> getStores(); @RequestMapping(method = RequestMethod.GET, value = \\\"/stores\\\") Page<Store> getStores(Pageable pageable); @RequestMapping(method = RequestMethod.POST, value = \\\"/stores/{storeId}\\\", consumes = \\\"application/json\\\") Store update(@PathVariable(\\\"storeId\\\") Long storeId, Store store); @RequestMapping(method = RequestMethod.DELETE, value = \\\"/stores/{storeId:\\\\\\\\d+}\\\") void delete(@PathVariable Long storeId); } \"]},\"464\":{\"h\":\"3.2.3 案例演示\",\"t\":[\"将服务端提供的接口清单 放在通用模块 common 中，通过OpenFeign 调用服务端中具体的Controller 方法！\",\"image-20240404180225749\",\"1、在 commons 公共模块中增加 OpenFeign 依赖\",\"2、提供服务端暴露的接口清单，使用 @FeignClient 指明服务端名称！\",\"@FeignClient(\\\"cloud-payment-service\\\") // 指明服务端的服务名 public interface PayFeignApi{ /** * 新增一条支付相关流水记录 * @param payDTO * @return */ @PostMapping(\\\"/pay/add\\\") public ResultData addPay(@RequestBody PayDTO payDTO); /** * 按照主键记录查询支付流水信息 * @param id * @return */ @GetMapping(\\\"/pay/get/{id}\\\") public ResultData getPayInfo(@PathVariable(\\\"id\\\") Integer id); // public ResultData getPayInfo(@PathVariable Integer id); // 这样写是错误的，必须指明路径参数名称 /** * openfeign天然支持负载均衡演示 * @return */ @GetMapping(value = \\\"/pay/get/info\\\") public String mylb(); } \",\"3、新建模块 cloud-consumer-feign-order80\",\"POM 和 cloud-consumer-order80 一样\",\"YAML\",\"server: port: 80 spring: application: name: cloud-consumer-openfeign-order ####Spring Cloud Consul for Service Discovery cloud: consul: host: localhost port: 8500 discovery: prefer-ip-address: true #优先使用服务ip进行注册 service-name: ${spring.application.name} \",\"主启动类\",\"再客户端的主启动类上增加 @EnableFeignClients\",\"@SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class MainOpenFeign80 { public static void main(String[] args) { SpringApplication.run(MainOpenFeign80.class,args); } } \",\"Controller\",\"使用了 OpenFeign，此时在 Controller 中就无需在使用 RestTemplate，引入所创建的 PayFeignApi 接口清单\",\"@RestController public class OrderController{ @Autowired private PayFeignApi payFeignApi; @PostMapping(\\\"/feign/pay/add\\\") public ResultData addOrder(@RequestBody PayDTO payDTO) { System.out.println(\\\"第一步：模拟本地addOrder新增订单成功(省略sql操作)，第二步：再开启addPay支付微服务远程调用\\\"); ResultData resultData = payFeignApi.addPay(payDTO); return resultData; } @GetMapping(\\\"/feign/pay/get/{id}\\\") public ResultData getPayInfo(@PathVariable(\\\"id\\\") Integer id) { System.out.println(\\\"-------支付微服务远程调用，按照id查询订单支付流水信息\\\"); ResultData resultData = payFeignApi.getPayInfo(id); return resultData; } /** * openfeign天然支持负载均衡演示 * * @return */ @GetMapping(value = \\\"/feign/pay/mylb\\\") public String mylb() { return payFeignApi.mylb(); } } \",\"执行流程\",\"客户端order80服务 通过PayFeignApi调用服务端暴露的接口，在PayFeignApi中通过 @FeignClient 中的服务端名称去Consul 中找到对应的服务，最后调用服务端提供的服务接口！\"]},\"465\":{\"h\":\"3.2.4 高级特性\"},\"466\":{\"h\":\"1、超时控制\",\"t\":[\"OpenFeign的默认超时时间为60s\",\"image-20240404185845647\",\"全局配置\",\"spring: cloud: openfeign: client: config: default: connect-timeout: 5000 read-timeout: 5000 \",\"局部配置(指定哪个服务的超时时间)\",\"spring: cloud: openfeign: client: config: cloud-payment-service: #连接超时时间 connectTimeout: 5000 #读取超时时间 readTimeout: 5000 \",\"image-20240404190229058\"]},\"467\":{\"h\":\"2、重试机制\",\"t\":[\"默认关闭\",\"增加配置类开启重试机制：\",\"最大请求次数3次：\",\"初始请求一次\",\"重试俩次\",\"@Configuration public class FeignConfig { @Bean public Retryer myRetryer() { // return Retryer.NEVER_RETRY; //Feign默认配置是不走重试策略的 // 最大请求次数为3(1+2)，初始间隔时间为100ms，重试间最大间隔时间为1s return new Retryer.Default(100,1,3); } } \",\"测试\",\"在上面我将超时时间设置了5s，重试3次，那么执行间隔为 15S\",\"image-20240404190854797\",\"提示\",\"目前控制台没有看到3次重试过程，只看到结果，正常的，正确的，是feign的日志打印问题\"]},\"468\":{\"h\":\"3、默认HttpClient修改\",\"t\":[\"OpenFeign中http client 如果不做特殊配置，OpenFeign默认使用JDK自带的 HttpURLConnection发送HTTP请求，由于默认HttpURLConnection没有连接池、性能和效率比较低\",\"因此使用 Apache HttpClient5 替换默认的HttpURLConnection\",\"1、增加依赖\",\" <!-- httpclient5--> <dependency> <groupId>org.apache.httpcomponents.client5</groupId> <artifactId>httpclient5</artifactId> <version>5.3</version> </dependency> <!-- feign-hc5--> <dependency> <groupId>io.github.openfeign</groupId> <artifactId>feign-hc5</artifactId> <version>13.1</version> </dependency> \",\"2、开启\",\"# Apache HttpClient5 配置开启 spring: cloud: openfeign: httpclient: hc5: enabled: true \",\"测试\",\"image-20240404191738868\"]},\"469\":{\"h\":\"4、请求/响应压缩\",\"t\":[\"开启请求/响应压缩、设置出发压缩大小\",\"spring: cloud: openfeign: compression: request: # 请求压缩 enabled: true response: # 响应压缩 enabled: true min-request-size: 2024 #最小触发压缩的大小 mime-types: text/xml,application/xml,application/json #触发压缩数据类型 \"]},\"470\":{\"h\":\"5、日志打印功能\",\"t\":[\"Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节，说白了就是对Feign接口的调用情况进行监控和输出\",\"日志级别\",\"NONE：默认的，不显示任何日志；\",\"BASIC：仅记录请求方法、URL、响应状态码及执行时间；\",\"HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；\",\"FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。\",\"在FeignConfig中注册\",\" @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } \",\"在配置文件中指明哪个接口需要打印：\",\"# 公式(三段)：logging.level + 含有@FeignClient注解的完整带包名的接口名+debug logging: level: com: atguigu: cloud: feignService: PayFeignApi: debug \",\"测试\",\"image-20240404193126160\"]},\"471\":{\"h\":\"四、熔断降级\",\"t\":[\"复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败\",\"多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的 “扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\",\"解决方法\",\"有问题的节点，快速熔断（快速返回失败处理或者返回默认兜底数据【服务降级】）。\"]},\"472\":{\"h\":\"4.1 概念介绍\",\"t\":[\"降级\",\"简单来说就是服务器出现问题时，返回给用户一个友好提示，例如 服务器忙，请稍后再试\",\"一般情况下，程序运行异常、超时、服务熔断触发降级、线程池打满 都会触发降级！\",\"熔断\",\"在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。 这种牺牲局部，保全整体的措施就叫做熔断。\",\"image-20240404224526487\",\"一旦下游服务C因某些原因变得不可用，积压了大量请求，服务B的请求线程也随之阻塞。线程资源逐渐耗尽，使得服务B也变得不可用。紧接着，服务 A也变为不可用，整个调用链路被拖垮。\",\"因此，需要服务熔断来确保整个系统的可用性\",\"限流\",\"秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行\"]},\"473\":{\"h\":\"4.2 Resilience4J\"},\"474\":{\"h\":\"4.2.1 介绍\",\"t\":[\"Circuit breaker提供了跨不同断路器实现的抽象, 它提供了一致的 API 供您在应用程序中使用.\",\"而 Resilience4J 正是Circuit breaker的实现！\",\"Resilience4j 是一个用于帮助构建弹性和容错性应用程序的 Java 库。它提供了一组工具和模式，使开发人员能够更容易地编写可靠、高可用的应用程序。\",\"image-20240404222812716\",\"作用\",\"resilience4j-circuitbreaker: Circuit breaking（断路）\",\"resilience4j-ratelimiter: Rate limiting （限流）\",\"resilience4j-bulkhead: Bulkheading （隔离）\",\"resilience4j-retry: Automatic retrying (sync and async) （自动重试）\",\"resilience4j-timelimiter: Timeout handling （超时处理）\",\"resilience4j-cache: Result caching （结果缓存）\"]},\"475\":{\"h\":\"4.2.2 熔断机制\",\"t\":[\"中文文档\",\"https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/CircuitBreaker.md\",\"避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\",\"断路器(Circuit Breaker)是熔断机制的一种实现方式。它是熔断机制的具体实现，类似于电路中的断路器，用于监控对依赖服务的调用。当依赖服务的故障率超过阈值时，断路器会切换到开启状态，阻止对该服务的请求，从而防止故障的传播。在开启状态下，断路器会暂时拒绝所有请求，并在一段时间后尝试重新请求依赖服务。如果这次请求成功，断路器会恢复到关闭状态，继续允许请求通过；\",\"断路器的状态\",\"关闭(CLOSE)\",\"断路器关闭时，所有请求均可通过，属于正常状态\",\"开启(OPEN)\",\"当请求的失败率达到一定的阈值后，断路器就会由 关闭转换为开启状态，并拒绝所有请求。\",\"半开(HALF_OPEN)\",\"断路开启经过一段时间后，会转换到 半开 状态 ， 并允许通过一定数量的请求，尝试重新计算失败率 , 如果失败率超过阈值，仍然为开启状态，否则变为关闭状态！\",\"禁用（DISABLE） \",\"始终允许访问\",\"强制开启（FORCED_OPEN） \",\"始终拒绝访问\",\"断路器使用滑动窗口来统计调用结果，有俩种计算阈值的方式\",\"基于调用数量的滑动窗口： 统计最近N次的调用结果\",\"基于时间的滑动窗口： 统计最近N秒的调用结果\"]},\"476\":{\"h\":\"1、断路器配置参数\",\"t\":[\"failure-rate-threshold\",\"以百分比配置失败率峰值\",\"sliding-window-type\",\"断路器的滑动窗口期类型 可以基于“次数”（COUNT_BASED）或者“时间”（TIME_BASED）进行熔断，默认是COUNT_BASED。\",\"sliding-window-size\",\"若COUNT_BASED，则10次调用中有50%失败（即5次）打开熔断断路器；若为TIME_BASED则，此时还有额外的两个设置属性，含义为：在N秒内（sliding-window-size）100%（slow-call-rate-threshold）的请求超过N秒（slow-call-duration-threshold）打开断路器\",\"slowCallRateThreshold\",\"以百分比的方式配置，断路器把调用时间大于slowCallDurationThreshold的调用视为慢调用，当慢调用比例大于等于峰值时，断路器开启，并进入服务降级。\",\"slowCallDurationThreshold\",\"配置调用时间的峰值，高于该峰值的视为慢调用。\",\"permitted-number-of-calls-in-half-open-state\",\"运行断路器在HALF_OPEN状态下时进行N次调用，如果故障或慢速调用仍然高于阈值，断路器再次进入打开状态。\",\"minimum-number-of-calls\",\"在每个滑动窗口期样本数，配置断路器计算错误率或者慢调用率的最小调用数。比如设置为5意味着，在计算故障率之前，必须至少调用5次。如果只记录了4次，即使4次都失败了，断路器也不会进入到打开状态。\",\"wait-duration-in-open-state\",\"从OPEN到HALF_OPEN状态需要等待的时间\"]},\"477\":{\"h\":\"2、基于调用数量统计的案例演示\",\"t\":[\"断路器应该配置在哪个模块？\",\"配置在客户端，也就是调用方！我们可以这样想，断路器相当于家庭的保险丝，客户端就相当于家里的电器(调用方)， 服务端就相当于 国家电网 (被调用方)。\",\"cloud-provider-payment8001 模块模块新建一个 PayCircuitController ，并且通过OpenFeign 暴露出去\",\"@RestController public class PayCircuitController { //=========Resilience4j CircuitBreaker 的例子 @GetMapping(value = \\\"/pay/circuit/{id}\\\") public String myCircuit(@PathVariable(\\\"id\\\") Integer id) { if(id == -4) throw new RuntimeException(\\\"----circuit id 不能负数\\\"); if(id == 9999){ try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } } return \\\"Hello, circuit! inputId: \\\"+id+\\\" \\\\t \\\" + IdUtil.simpleUUID(); } } \",\"cloud-api-commons 模块\",\" /** * Resilience4j CircuitBreaker 的例子 * @param id * @return */ @GetMapping(value = \\\"/pay/circuit/{id}\\\") public String myCircuit(@PathVariable(\\\"id\\\") Integer id); \",\"在客户端也就是 cloud-consumer-feign-order80 模块配置熔断机制。\",\"增加依赖：\",\" <!--resilience4j-circuitbreaker--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId> </dependency> <!-- 由于断路保护等需要AOP实现，所以必须导入AOP包 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> \",\"yaml配置\",\"spring: cloud: openfeign: circuitbreaker: enabled: true group: enabled: true #没开分组永远不用分组的配置。精确优先、分组次之(开了分组)、默认最后 # Resilience4j CircuitBreaker 按照次数：COUNT_BASED 的例子 # 6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。 # 等待5秒后，CircuitBreaker 将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。 # 如还是异常CircuitBreaker 将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。 resilience4j: circuitbreaker: configs: default: #设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态 failureRateThreshold: 50 。 # 滑动窗口的类型 slidingWindowType: COUNT_BASED #滑动窗⼝的⼤⼩配置COUNT_BASED表示6个请求，配置TIME_BASED表示6秒 slidingWindowSize: 6 #断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。如果minimumNumberOfCalls为10，则必须最少记录10个样本，然后才能计算失败率。如果只记录了9次调用，即使所有9次调用都失败，断路器也不会开启。 minimumNumberOfCalls: 6 # 是否启用自动从开启状态过渡到半开状态，默认值为true。如果启用，CircuitBreaker将自动从开启状态过渡到半开状态，并允许一些请求通过以测试服务是否恢复正常 automaticTransitionFromOpenToHalfOpenEnabled: true #从OPEN到HALF_OPEN状态需要等待的时间 waitDurationInOpenState: 5s #半开状态允许的最大请求数，默认值为10。在半开状态下，CircuitBreaker将允许最多permittedNumberOfCallsInHalfOpenState个请求通过，如果其中有任何一个请求失败，CircuitBreaker将重新进入开启状态。 permittedNumberOfCallsInHalfOpenState: 2 recordExceptions: - java.lang.Exception # 计入失败的异常 instances: cloud-payment-service: baseConfig: default \",\"创建OrderCircuitController\",\"@RestController public class OrderCircuitController { @Resource private PayFeignApi payFeignApi; @GetMapping(value = \\\"/feign/pay/circuit/{id}\\\") // name要和配置中的instances保持一致 // fallbackMethod兜底方法，当断路器开启时，要给用户一个友好的反馈！ @CircuitBreaker(name = \\\"cloud-payment-service\\\", fallbackMethod = \\\"myCircuitFallback\\\") public String myCircuitBreaker(@PathVariable(\\\"id\\\") Integer id) { return payFeignApi.myCircuit(id); } //myCircuitFallback就是服务降级后的兜底处理方法 public String myCircuitFallback(Integer id,Throwable t) { // 这里是容错处理逻辑，返回备用结果 return \\\"myCircuitFallback，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~\\\"; } } \",\"测试\",\"正常的请求：localhost/feign/pay/circuit/1\",\"错误的请求：localhost/feign/pay/circuit/-4\",\"在 PayCircuitController中当ID = -4 时 ，会抛出 RuntimeException 异常，在配置中我们配置了 recordExceptions ， 因此会计入失败的请求！。\",\"若异常不相同或者不是父子类的关系，则不会计入！\",\"当我们访问6次，错误的请求占 50% 时，就会开启断路器，执行fallback兜底方法！\"]},\"478\":{\"h\":\"3、基于调用时间 统计的案例演示\",\"t\":[\"配置\",\"# Resilience4j CircuitBreaker 按照时间：TIME_BASED 的例子 resilience4j: timelimiter: configs: default: timeout-duration: 10s #神坑的位置，timelimiter 默认限制远程1s，超于1s就超时异常，配置了降级，就走降级逻辑 circuitbreaker: configs: default: failureRateThreshold: 50 #设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。 slowCallDurationThreshold: 2s #慢调用时间阈值，高于这个阈值的视为慢调用并增加慢调用比例。 slowCallRateThreshold: 30 #慢调用百分比峰值，断路器把调用时间⼤于slowCallDurationThreshold，视为慢调用，当慢调用比例高于阈值，断路器打开，并开启服务降级 slidingWindowType: TIME_BASED # 滑动窗口的类型 slidingWindowSize: 2 #滑动窗口的大小配置，配置TIME_BASED表示2秒 minimumNumberOfCalls: 2 #断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。 permittedNumberOfCallsInHalfOpenState: 2 #半开状态允许的最大请求数，默认值为10。 waitDurationInOpenState: 5s #从OPEN到HALF_OPEN状态需要等待的时间 recordExceptions: - java.lang.Exception instances: cloud-payment-service: baseConfig: default \"]},\"479\":{\"h\":\"4.2.3 隔离\",\"t\":[\"文档\",\"https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/bulkhead.md\",\"依赖隔离&负载保护：用来限制对于下游服务的最大并发数量\",\"Resilience4j提供了两种隔离的实现方式，可以限制并发执行的数量:\",\"SemaphoreBulkhead使用了信号量\",\"FixedThreadPoolBulkhead使用了有界队列和固定大小线程池\"]},\"480\":{\"h\":\"1、SemaphoreBulkhead\",\"t\":[\"这个和JUC中的 Semaphore 原理是一样的。\",\"通过维持一组许可证 来实现阻塞和通行\",\"image-20240405154506118\",\"如何使用\",\"增加依赖\",\"<!--resilience4j-bulkhead--> <dependency> <groupId>io.github.resilience4j</groupId> <artifactId>resilience4j-bulkhead</artifactId> </dependency> \",\"配置参数\",\"####resilience4j bulkhead 的例子 resilience4j: bulkhead: configs: default: maxConcurrentCalls: 2 # 隔离允许并发线程执行的最大数量 maxWaitDuration: 1s # 当达到并发调用数量时，新的线程的阻塞时间，我只愿意等待1秒，过时不候进舱壁兜底fallback instances: cloud-payment-service: baseConfig: default timelimiter: configs: default: timeout-duration: 20s \",\"在调用方的Controller使用注解 @Bulkhead 标注，指明隔离类型为：Bulkhead.Type.SEMAPHORE\",\" /** *(船的)舱壁,隔离 * @param id * @return */ @GetMapping(value = \\\"/feign/pay/bulkhead/{id}\\\") @Bulkhead(name = \\\"cloud-payment-service\\\",fallbackMethod = \\\"myBulkheadFallback\\\",type = Bulkhead.Type.SEMAPHORE) public String myBulkhead(@PathVariable(\\\"id\\\") Integer id) { return payFeignApi.myBulkhead(id); } public String myBulkheadFallback(Throwable t) { return \\\"myBulkheadFallback，隔板超出最大数量限制，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~\\\"; } \"]},\"481\":{\"h\":\"2、FixedThreadPoolBulkhead\",\"t\":[\"这个和JUC 中的 ThreadPool 原理是一样的。\",\"image-20240405160342750\",\"如何使用\",\"依赖\",\"<!--resilience4j-bulkhead--> <dependency> <groupId>io.github.resilience4j</groupId> <artifactId>resilience4j-bulkhead</artifactId> </dependency> \",\"配置\",\"####resilience4j bulkhead -THREADPOOL的例子 resilience4j: timelimiter: configs: default: timeout-duration: 10s #timelimiter默认限制远程1s，超过报错不好演示效果所以加上10秒 thread-pool-bulkhead: configs: default: core-thread-pool-size: 4 # 最大线程数 max-thread-pool-size: 2 # 核心线程数 queue-capacity: 2 # 等待队列 # 并发的线程数：最大线程数 + 等待队列 = 6 instances: cloud-payment-service: baseConfig: default \",\"在调用方的Controller使用注解 @Bulkhead 标注，指明隔离类型为：Bulkhead.Type.THREADPOOL\",\"并且 FixedThreadPoolBulkhead 要求的返回类型为 CompletableFuture\",\"/** * (船的)舱壁,隔离,THREADPOOL * @param id * @return */ @GetMapping(value = \\\"/feign/pay/bulkhead/{id}\\\") @Bulkhead(name = \\\"cloud-payment-service\\\",fallbackMethod = \\\"myBulkheadPoolFallback\\\",type = Bulkhead.Type.THREADPOOL) public CompletableFuture<String> myBulkheadTHREADPOOL(@PathVariable(\\\"id\\\") Integer id) { System.out.println(Thread.currentThread().getName()+\\\"\\\\t\\\"+\\\"enter the method!!!\\\"); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\\\"\\\\t\\\"+\\\"exist the method!!!\\\"); return CompletableFuture.supplyAsync(() -> payFeignApi.myBulkhead(id) + \\\"\\\\t\\\" + \\\" Bulkhead.Type.THREADPOOL\\\"); } public CompletableFuture<String> myBulkheadPoolFallback(Integer id,Throwable t) { return CompletableFuture.supplyAsync(() -> \\\"Bulkhead.Type.THREADPOOL，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~\\\"); } \"]},\"482\":{\"h\":\"4.2.4 限流\",\"t\":[\"文档\",\"https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/ratelimiter.md\",\"依赖\",\" <!--resilience4j-ratelimiter--> <dependency> <groupId>io.github.resilience4j</groupId> <artifactId>resilience4j-ratelimiter</artifactId> </dependency> \",\"配置\",\"####resilience4j ratelimiter 限流的例子 resilience4j: ratelimiter: configs: default: limitForPeriod: 2 #在一次刷新周期内，允许执行的最大请求数 limitRefreshPeriod: 1s # 限流器每隔limitRefreshPeriod刷新一次，将允许处理的最大请求数量重置为limitForPeriod timeout-duration: 1 # 线程等待权限的默认等待时间 instances: cloud-payment-service: baseConfig: default \",\"使用 @RateLimiter 注解标注\",\" @GetMapping(value = \\\"/feign/pay/ratelimit/{id}\\\") @RateLimiter(name = \\\"cloud-payment-service\\\",fallbackMethod = \\\"myRatelimitFallback\\\") public String myBulkhead(@PathVariable(\\\"id\\\") Integer id) { return payFeignApi.myRatelimit(id); } public String myRatelimitFallback(Integer id,Throwable t) { return \\\"你被限流了，禁止访问/(ㄒoㄒ)/~~\\\"; } \"]},\"483\":{\"h\":\"五、分布式链路追踪\",\"t\":[\"在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\",\"image-20240405170221197\",\"在分布式与微服务场景下，我们需要解决如下问题：\",\"在大规模分布式与微服务集群下，如何实时观测系统的整体调用链路情况。\",\"在大规模分布式与微服务集群下，如何快速发现并定位到问题。\",\"在大规模分布式与微服务集群下，如何尽可能精确的判断故障对系统的影响范围与影响程度。\",\"在大规模分布式与微服务集群下，如何尽可能精确的梳理出服务之间的依赖关系，并判断出服务之间的依赖关系是否合理。\",\"在大规模分布式与微服务集群下，如何尽可能精确的分析整个系统调用链路的性能与瓶颈点。\",\"在大规模分布式与微服务集群下，如何尽可能精确的分析系统的存储瓶颈与容量规划。\"]},\"484\":{\"h\":\"5.1 Micrometer + Zipkin\",\"t\":[\"Micrometer 提供了一套完整的服务跟踪的解决方案\",\"在分布式系统中提供追踪解决方案并且兼容支持了zipkin\",\"一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来\",\"image-20240405171318573\"]},\"485\":{\"h\":\"5.1.1 下载 ZipKin\",\"t\":[\"下载 zipkin：\",\"https://zipkin.io/pages/quickstart\",\"执行 jar 包：\",\"java -jar zipkin-server-2.12.9-exec.jar\",\"访问：\",\"http://localhost:9411/zipkin/\"]},\"486\":{\"h\":\"5.1.2 搭建链路监控\",\"t\":[\"1、父工程引入\",\" <micrometer-tracing.version>1.2.0</micrometer-tracing.version> <micrometer-observation.version>1.12.0</micrometer-observation.version> <feign-micrometer.version>12.5</feign-micrometer.version> <zipkin-reporter-brave.version>2.17.0</zipkin-reporter-brave.version> <!--micrometer-tracing-bom导入链路追踪版本中心 1--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing-bom</artifactId> <version>${micrometer-tracing.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!--micrometer-tracing指标追踪 2--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing</artifactId> <version>${micrometer-tracing.version}</version> </dependency> <!--micrometer-tracing-bridge-brave适配zipkin的桥接包 3--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing-bridge-brave</artifactId> <version>${micrometer-tracing.version}</version> </dependency> <!--micrometer-observation 4--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-observation</artifactId> <version>${micrometer-observation.version}</version> </dependency> <!--feign-micrometer 5--> <dependency> <groupId>io.github.openfeign</groupId> <artifactId>feign-micrometer</artifactId> <version>${feign-micrometer.version}</version> </dependency> <!--zipkin-reporter-brave 6--> <dependency> <groupId>io.zipkin.reporter2</groupId> <artifactId>zipkin-reporter-brave</artifactId> <version>${zipkin-reporter-brave.version}</version> </dependency> \",\"2、子工程引入以下五个即可\",\" <!--micrometer-tracing指标追踪 1--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing</artifactId> </dependency> <!--micrometer-tracing-bridge-brave适配zipkin的桥接包 2--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing-bridge-brave</artifactId> </dependency> <!--micrometer-observation 3--> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-observation</artifactId> </dependency> <!--feign-micrometer 4--> <dependency> <groupId>io.github.openfeign</groupId> <artifactId>feign-micrometer</artifactId> </dependency> <!--zipkin-reporter-brave 5--> <dependency> <groupId>io.zipkin.reporter2</groupId> <artifactId>zipkin-reporter-brave</artifactId> </dependency> \",\"3、配置，哪个服务需要监控就配置哪个服务！\",\"# ========================zipkin=================== management: zipkin: tracing: endpoint: http://localhost:9411/api/v2/spans tracing: sampling: probability: 1.0 #采样率默认为0.1(0.1就是10次只能有一次被记录下来)，值越大收集越及时。 \"]},\"487\":{\"h\":\"六、Gateway 网关\",\"t\":[\"什么是网关？\",\"网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问\",\"GateWay 和 Nginx都作为网关，有什么区别？\",\"image-20240405215124906\",\"通常可以将Nginx至于 Gateway 网关前，负责对 Gateway 网关的负载均衡，然后再由网关决定进入根据判定到哪个真实的web 服务器。 让两者的分工更加明确，也就是：Gateway 网关聚合服务，Nginx请求转发\"]},\"488\":{\"h\":\"6.1 Gateway 三大核心\",\"t\":[\"Route（路由）: 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\",\"Predicate（谓词）: 参考的是Java8的 java.util.function.Predicate 开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由\",\"Filter（过滤器）: 这些是 GatewayFilter 的实例，已经用特定工厂构建。在这里，你可以在发送下游请求之前或之后修改请求和响应。\",\"工作流程：\",\"Spring Cloud Gateway Diagram\",\"客户端向 Spring Cloud Gateway 发出请求。\",\"如果 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送到 Gateway Web Handler。\",\"Handler 再通过指定的 过滤器链 来将请求发送到我们实际的服务执行业务逻辑，然后返回。\",\"过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\",\"核心就是： Gateway Handler Mapping 、Gateway Web Handler、Fileter Chian\",\"有点类似于SpringMVC的执行流程\"]},\"489\":{\"h\":\"6.2 简单配置\",\"t\":[\"网关也是一个单独的服务模块，因此需要单独的创建 网关模块\",\"1、创建网关服务模块\",\"image-20240405220811768\",\"2、POM\",\" <dependencies> <!--gateway--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-consul-discovery</artifactId> </dependency> <!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> \",\"3、yaml\",\"server: port: 9527 spring: application: name: cloud-gateway #以微服务注册进consul或nacos服务列表内 cloud: consul: #配置consul地址 host: localhost port: 8500 discovery: prefer-ip-address: true service-name: ${spring.application.name} gateway: routes: #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名 - id: pay_routh1 #pay_routh1 # 路由地址：lb表示负载均衡LoadBalance uri: lb://cloud-payment-service # 断言，路径相匹配的进行路由 predicates: - Path=/pay/gateway/get/** - id: pay_routh2 #pay_routh2 uri: lb://cloud-payment-service predicates: - Path=/pay/gateway/info/** \",\"4、启动类\",\"@EnableDiscoveryClient @SpringBootApplication public class Main9527 { public static void main(String[] args) { SpringApplication.run(Main9527.class,args); } } \",\"此时访问 9527 端口，网关就能够替我们转发到 8001 端口\"]},\"490\":{\"h\":\"6.3 高级特性\"},\"491\":{\"h\":\"6.3.1 Predicate断言\",\"t\":[\"中文文档\",\"https://springdoc.cn/spring-cloud-gateway/\",\"GateWay自带的RoutePredicateFactory\",\"image-20240406093526625\",\"Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping 基础设施的一部分。Spring Cloud Gateway包括许多内置的 RoutePredicateFactory。所有这些Predicate都与HTTP请求的不同属性相匹配。你可以用逻辑 and 语句组合多个RoutePredicateFactory。\",\"有两种方式来配置谓词和过滤器：快捷方式和完全展开的参数\",\"快捷方式：过滤器名称（filter name）后面跟一个等号 (=)，然后是用逗号 (,) 分隔的参数值。\",\"spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - Cookie=mycookie,mycookievalue \",\"完全展开：完全展开的参数看起来更像标准的yaml配置，有名称/值对。一般来说，会有一个 name key和一个 args key。args key是一个键值对的映射，用于配置谓词或过滤器。\",\"spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - name: Cookie args: name: mycookie regexp: mycookievalue \"]},\"492\":{\"h\":\"（1）After、Before、Between\",\"t\":[\"以下三个表示匹配在指定日期之后、之前、之间的请求，均是 java ZonedDateTime 格式\",\"After：在指定日期之后\",\"spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - After=2024-04-06T10:15:38.866925800+08:00[Asia/Shanghai] \",\"Before:\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Before=2024-04-06T10:42:38.866925800+08:00[Asia/Shanghai] # 在指定时间之前 \",\"Between:\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Between=2024-04-06T10:22:38.866925800+08:00[Asia/Shanghai],2024-04-06T10:27:38.866925800+08:00[Asia/Shanghai] \",\"若不符合 predicates ：\",\"image-20240406102807150\"]},\"493\":{\"h\":\"（2）Cookie、Header、HOST、PATH\",\"t\":[\"Cookie：匹配具有给定名称且其值符合正则表达式的cookie\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Cookie=username,123 # 指定Cookie \",\"Header：与具有给定名称且其值与正则表达式相匹配的 header 匹配\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: # Header中带有X-Request-Id为整数才可访问 - Header=X-Request-Id, \\\\d+ \",\"HOST: 一个主机（Host）名称的 patterns 列表。该pattern是Ant风格的模式，以 . 为分隔符。这个谓词匹配符合该pattern的Host header\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: # 参数中带有：以HOST为name，value符合**.atguigu.com - Host=**.atguigu.com \",\"测试\",\"image-20240406110445918\",\"PATH: 路径匹配\"]},\"494\":{\"h\":\"(3) Query\",\"t\":[\"Query 路由谓词工厂需要两个参数：一个必需的 param 和一个可选的 regexp（这是一个Java正则表达式）。下面的例子配置了一个 query 路由谓词。\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: # 参数中必须带有username且值是整数 - Query=username, \\\\d+ \",\"测试：\",\"image-20240406110126338\"]},\"495\":{\"h\":\"（4）RemoteAddr\",\"t\":[\"RemoteAddr 路由谓词工厂接受一个 sources 集合（最小长度为1），它是CIDR注解（IPv4或IPv6）字符串，如 192.168.0.1/16（其中 192.168.0.1 是一个IP地址，16 是一个子网掩码）\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: # 外部访问我的IP限制，最大跨度不超过32，目前是1~24它们是 CIDR 表示法。 - RemoteAddr=192.168.124.1/24 \",\"CIDR 使用了更灵活的方式来表示 IP 地址和子网掩码，而不是简单地将它们分成几个固定的类别。CIDR 地址由 IP 地址和一个后缀表示，后缀通常用斜杠（/）后面跟着一个数字表示子网掩码的位数。例如，192.168.1.0/24 表示一个拥有 24 位子网掩码的网络。\",\"例如：\",\"192.168.1.0/30\",\"有30位用于网络地址和子网掩码，剩下的2位用于主机地址。所以可用的主机地址数是2的幂次方，即2^2 = 4\",\"这四个IP地址包括网络地址、广播地址和两个可用的主机地址。网络地址和广播地址分别是每个子网的第一个和最后一个地址，因此对于CIDR地址 192.168.1.0/30：\",\"网络地址是 192.168.1.0\",\"第一个主机地址是 192.168.1.1\",\"第二个主机地址是 192.168.1.2\",\"广播地址是 192.168.1.3\"]},\"496\":{\"h\":\"（5）Methods\",\"t\":[\"Method 路由谓词工厂接受一个 methods 参数，它是一个或多个参数：要匹配的HTTP方法。\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Method=GET,POST \"]},\"497\":{\"h\":\"（6）自定义Predicate断言\",\"t\":[\"需求: 希望用一个 userType 字段来描述用户的会员等级(diamonds, gold, silver)。\",\"在配置文件中可以配置哪种等级的会员可以访问\",\"先来看看，GateWay中原有Predicate是怎么写的\",\"创建一个 XXXRoutePredicateFactory 类，注意后缀必须是 RoutePredicateFactory, 前面无所谓\",\"继承 AbstractRoutePredicateFactory<Config> 抽象类或者实现 RoutePredicateFactory<C> 接口\",\"自定义的 XXXRoutePredicateFactory 类中包含4部分： \",\"空参构造器： 调用父类的构造器\",\"Config配置类 : 说明要校验的参数，，在本案例中也就是 userType\",\"apply方法： 具体的校验过程\",\"shortcutFieldOrder: 实现快捷方式，若不实现此方法，只能够使用完全展开的配置方式\",\"image-20240406114040874\",\"示例代码\",\"@Component public class MyRoutePredicateFactory extends AbstractRoutePredicateFactory<MyRoutePredicateFactory.Config> { // 1、空参构造器，调用父类的构造器 public MyRoutePredicateFactory() { super(MyRoutePredicateFactory.Config.class); } // 2、配置类 @Validated public static class Config { @Getter@Setter@NotEmpty private String userType; } // 3、具体的校验规则 public Predicate<ServerWebExchange> apply(MyRoutePredicateFactory.Config config) { return new GatewayPredicate() { @Override public boolean test(ServerWebExchange serverWebExchange) { // 获取请求参数中的第一个参数 String userType = serverWebExchange.getRequest().getQueryParams().getFirst(\\\"userType\\\"); // 若为null返回false if (StringUtil.isNullOrEmpty(userType)) return false; // 请求参数中的userTYpe与配置的userType相等，则返回true if (userType.equalsIgnoreCase(config.getUserType())) return true; return false; } }; } // 4、快捷方式 public List<String> shortcutFieldOrder() { return Collections.singletonList(\\\"userType\\\"); } } \",\"此时，将网关模块重新启动，在控制台可以看见自定义的断言工厂：\",\"image-20240406120715377\",\"接下来就可以配置使用了：\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - My=diamonds # 自定义的断言，请求参数中的userType=diamonds \"]},\"498\":{\"h\":\"6.3.2 Filter过滤器\",\"t\":[\"和 SpringMVC 中的拦截器，Servlet中的过滤器一个意思\",\"能干嘛：\",\"请求鉴权\",\"异常处理\",\"记录接口调用时长统计\",\"类型\",\"GatewayFilter ：全局过滤器\",\"GlobalFilter： 单一内置的过滤器\",\"自定义过滤器\"]},\"499\":{\"h\":\"（1）请求头相关\",\"t\":[\"AddRequestHeader : 需要一个 name 和 value 参数，增加到请求头中\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Path=/pay/gateway/filter/** filters: # 请求头kv，若一头含有多参则重写一行设置 - AddRequestHeader=X-Request-atguigu1,atguiguValue1 - AddRequestHeader=X-Request-atguigu2,atguiguValue2 \",\"RemoveRequestHeader:需要一个 name 参数。它是要被删除的header的名称\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Path=/pay/gateway/filter/** filters: - RemoveRequestHeader=sec-fetch-site # 删除请求头sec-fetch-site \",\"SetRequestHeader:接受 name 和 value 参数, 根据name修改成为 value\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Path=/pay/gateway/filter/** filters: - SetRequestHeader=sec-fetch-mode, Blue-updatebyzzyy # 将请求头sec-fetch-mode对应的值修改为Blue-updatebyzzyy \"]},\"500\":{\"h\":\"（2）请求参数相关\",\"t\":[\"AddRequestParameter : 需要一个 name 和 value 参数, 增加请求参数\",\"RemoveRequestParameter ： 需要一个 name 参数。它是要删除的查询参数的名称\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service predicates: - Path=/pay/gateway/filter/** filters: # 新增请求参数Parameter：k ，v - AddRequestParameter=customerId,9527001 # 删除url请求参数customerName，你传递过来也是null - RemoveRequestParameter=customerName \"]},\"501\":{\"h\":\"（3）回应头相关\",\"t\":[\"AddResponseHeader : 需要一个 name 和 value增加回应头，\",\"RemoveResponseHeader需要一个 name 参数。它是要被移除的 header 的名称\",\"SetResponseHeader 接受 name 和 value 参数 ,修改名称为 name 的回应头\"]},\"502\":{\"h\":\"（4）前缀和路径相关\",\"t\":[\"PrefixPath : 自动添加路径前缀, 下面这个例子把 /mypath 作为所有匹配请求的路径的前缀\",\"spring: cloud: gateway: routes: - id: pay_routh1 uri: lb://cloud-payment-service filters: - PrefixPath=/mypath \",\"SetPath：修改路径，接受一个路径模板参数。它提供了一种简单的方法，通过允许模板化的路径段来操作请求路径\",\"对于请求路径为 /red/blue 的情况，在进行下行请求之前，将路径设置为 /blue。\",\"spring: cloud: gateway: routes: - id: setpath_route uri: https://example.org predicates: - Path=/red/{segment} filters: - SetPath=/{segment} \",\"RedirectTo 需要两个参数，status 和 url。status 参数应该是一个300系列的重定向 HTTP 状态码，如301。url 参数应该是一个有效的URL\",\"spring: cloud: gateway: routes: - id: prefixpath_route uri: https://example.org filters: - RedirectTo=302, http://www.atguigu.com/ # 访问http://localhost:9527/pay/gateway/filter跳转到http://www.atguigu.com/ \"]},\"503\":{\"h\":\"（5）自定义全局过滤器\",\"t\":[\"需求：统计所有接口调用耗时\",\"解决方法：自定义过滤器\",\"@Component @Slf4j public class MyGlobalFilter implements GlobalFilter, Ordered { /** * 数字越小优先级越高 * @return */ @Override public int getOrder() { return 0; } private static final String BEGIN_VISIT_TIME = \\\"begin_visit_time\\\";//开始访问时间 /** *第2版，各种统计 * @param exchange * @param chain * @return */ @Override public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) { //先记录下访问接口的开始时间 exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis()); return chain.filter(exchange).then(Mono.fromRunnable(()->{ Long beginVisitTime = exchange.getAttribute(BEGIN_VISIT_TIME); if (beginVisitTime != null){ log.info(\\\"访问接口主机: \\\" + exchange.getRequest().getURI().getHost()); log.info(\\\"访问接口端口: \\\" + exchange.getRequest().getURI().getPort()); log.info(\\\"访问接口URL: \\\" + exchange.getRequest().getURI().getPath()); log.info(\\\"访问接口URL参数: \\\" + exchange.getRequest().getURI().getRawQuery()); log.info(\\\"访问接口时长: \\\" + (System.currentTimeMillis() - beginVisitTime) + \\\"ms\\\"); log.info(\\\"我是美丽分割线: ###################################################\\\"); System.out.println(); } })); } } \"]},\"504\":{\"h\":\"（6）自定义单一内置过滤器\",\"t\":[\"上面是全局过滤器，只要发送请求就会执行\",\"下面定义单一内置过滤器\",\"先看看GateWay原厂的过滤器如何实现：\",\"看源码其实能看出来，和自定义Predicate非常相似。\",\"创建 XXXGatewayFilterFactory, 后缀必须是 GatewayFilterFactory, 前面无所谓\",\"继承 AbstractGatewayFilterFactory<Config> 抽象类或者实现 GatewayFilterFactory<C> 接口\",\"自定义的 XXXGatewayFilterFactory 类中包含4部分： \",\"空参构造器： 调用父类的构造器\",\"Config配置类 : 说明要校验的参数\",\"apply方法： 具体的校验过程\",\"shortcutFieldOrder: 实现快捷方式，若不实现此方法，只能够使用完全展开的配置方式\",\"image-20240406170813435\",\"代码\",\"判断请求参数中是否包含：atguigu , 不包含直接返回400\",\"@Component public class MyGatewayFilterFactory extends AbstractGatewayFilterFactory<Config> { public MyGatewayFilterFactory() { super(MyGatewayFilterFactory.Config.class); } @Override public GatewayFilter apply(MyGatewayFilterFactory.Config config) { return new GatewayFilter() { @Override public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); System.out.println(\\\"进入了自定义网关过滤器MyGatewayFilterFactory，status：\\\"+config.getStatus()); if(request.getQueryParams().containsKey(\\\"atguigu\\\")){ return chain.filter(exchange); }else{ exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST); return exchange.getResponse().setComplete(); } } }; } @Override public List<String> shortcutFieldOrder() { return Arrays.asList(\\\"status\\\"); } public static class Config { @Getter @Setter private String status;//设定一个状态值/标志位，它等于多少，匹配和才可以访问 } } //单一内置过滤器GatewayFilter \",\"配置\",\"spring: cloud: gateway: routes: - id: prefixpath_route uri: https://example.org filters: - My=atguigu \"]},\"505\":{\"c\":[\"微服务\"]},\"506\":{\"c\":[\"SpringCloud\",\"Consul\",\"GateWay\",\"ZipKin\",\"OpenFeign\",\"Resilience4J\"]},\"507\":{\"h\":\"一、概述\"},\"508\":{\"h\":\"1.1 RDBMS 和 非 RDBMS\",\"t\":[\"关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、 MySQL 和 SQL Server。\",\"这些都是关系型数据库（RDBMS）。\"]},\"509\":{\"h\":\"1.1.1 关系型数据库(RDBMS)\",\"t\":[\"这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系 （即二维表格形式）。\",\"image-20240107131342618.png\",\"关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被\",\"SQL就是关系型数据库的查询语句\",\"优势\",\"可以使用SQL语句方便在一个表或者多个表进行复杂查询\",\"使得对于安全性能很高的数据访问要求得以实现\"]},\"510\":{\"h\":\"1.1.2 非关系型数据库(非RDBMS)\",\"t\":[\"非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层 的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。 目前基本上大部分主流的非关系型数据库都是免费的。\",\"有哪些非关系型数据库？\",\"键值型数据库\",\"键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\",\"典型的键值型数据库使用场景是作为缓存。比如：Redis\",\"文档型数据库\",\"此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位， 一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。\",\"搜索引擎数据库\",\"虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在 搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检 索的时候才能保证性能最优。核心原理是“倒排索引”。 典型产品：Solr、Elasticsearch、Splunk 等。\"]},\"511\":{\"h\":\"1.2 关系型数据库的设计规则\",\"t\":[\"一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。\",\"表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。\"]},\"512\":{\"h\":\"1.2.1 表、记录、字段\",\"t\":[\"E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。\",\"image-20240107133218203\",\"数据库中的一张表 <----> Java中的类 数据库中的一条记录 <----> Java中的对象 数据库中的一个列 <----> Java中的一个字段、属性 \"]},\"513\":{\"h\":\"1.2.2 表的关联关系\",\"t\":[\"四种：一对一关联、一对多关联、多对多关联、自我引用\",\"一对一(one to one)\",\"在实际的开发中应用不多，因为一对一可以创建成一张表。\",\"一条记录对应另一个表中的一条记录\",\"两种建表原则：\",\"外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\",\"外键是主键：主表的主键和从表的主键，形成主外键关系。\",\"image-20240107134006553\",\"一对多关系(one to many)\",\"一条记录对应另一个表中的多条记录\",\"一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\",\"image-20240107134232352\",\"多对多关系(many to many)\",\"要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，它将多对多关系划分为两个一对多关 系。将这两个表的主键都插入到第三个表中。\",\"image-20240107134510774\",\"自我引用(self reference)\",\"image-20240107134613344\"]},\"514\":{\"c\":[\"数据库\"]},\"515\":{\"c\":[\"数据库\",\"MySQL\"]},\"516\":{\"h\":\"二、SQL\",\"t\":[\"SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言， 与数据直 接打交道 ，由 IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准， 先后有 SQL-86 ， SQL-89 ， SQL-92 ， SQL-99 等标准。\"]},\"517\":{\"h\":\"2.1 SQL的分类\",\"t\":[\"DDL（Data Definition Languages、数据定义语言）\",\"这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\",\"主要的语句关键字包括 CREATE 、 DROP 、 ALTER、TRUNCATE 等。\",\"DML（Data Manipulation Language、数据操作语言）\",\"用于添加、删除、更新和查询数据库记 录，并检查数据完整性。\",\"主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。\",\"DML 是SQL中最基础的，也是最为重要的\",\"DCL（Data Control Language、数据控制语言）\",\"用于定义数据库、表、字段、用户的访问权限和 安全级别。\",\"主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。\",\"因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。 还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语 言）。\"]},\"518\":{\"h\":\"2.2 SQL规范\",\"t\":[\"(建议遵守)\",\"MySQL 在 Windows 环境下是大小写不敏感的\",\"MySQL 在 Linux 环境下是大小写敏感的\",\"数据库名、表名、表的别名、变量名是严格区分大小写的\",\"关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。\",\"推荐采用统一的书写规范：\",\"数据库名、表名、表别名、字段名、字段别名等都小写\",\"SQL 关键字、函数名、绑定变量等都大写\",\"（必须遵守）\",\"SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进\",\"每条命令以 ; 或 \\\\g 或 \\\\G 结束\",\"关键字不能被缩写也不能分行\",\"关于标点符号 必须保证所有的()、单引号、双引号是成对结束的 ，必须使用英文状态下的半角输入方式\",\"字符串型和日期时间类型的数据可以使用单引号（' '）表示，列的别名，尽量使用双引号（\\\" \\\"），而且不建议省略as\"]},\"519\":{\"h\":\"2.3 DML中的SELECT\"},\"520\":{\"h\":\"2.3.1 基本SELECT\",\"t\":[\"-- 基本结构: SELECT 字段1,字段2 FROM 表名; SELECT first_name,last_name FROM employees; -- * 表示查询出所有字段 SELECT * FROM employees; -- 也可以省略 FROM SELECT 1+1, 2*3; -- DUAL表示伪表 SELECT 1+1, 2*3 FROM DUAL; \"]},\"521\":{\"h\":\"(1) 列的别名\",\"t\":[\"为指定字段设置别名，可以使用空格或者 AS 或者 \\\" \\\" , 在MYSQL中使用 '' 不会报错，但是尽量别用 '' ！！！\",\"SELECT first_name firstName,last_name AS lastName,salary \\\"month salary\\\" FROM employees; \",\"image-20240107145437984\"]},\"522\":{\"h\":\"(2) 去掉重复行\",\"t\":[\"# 去掉重复的department_id SELECT DISTINCT department_id FROM employees \",\"错误的使用\",\"SELECT salary, DISTINCT department_id FROM employees \",\"查询出来的 salary 和 department_id 数量不对，因此会报错\",\"image-20240107150425601\",\"如果我们改成这样：\",\"SELECT DISTINCT department_id,salary FROM employees \",\"他会对 department_id，salary 组合起来进行去重，如下图所示： 会将 department_id + salary 组合在一起看是否一样。这样虽然不报错，但是没有意义\",\"image-20240107150527876\"]},\"523\":{\"h\":\"(3) 空值参与运算\",\"t\":[\"空值: 就是为null的列，null不等同于0或者'', 如果空值参与运算，那么结果也一定是 null\",\"# commission_pct可能存在null的情况 SELECT department_id,commission_pct,salary \\\"月工资\\\" , salary * (1 + commission_pct) * 12 \\\"年工资\\\" FROM employees \",\"image-20240107151645420\"]},\"524\":{\"h\":\"(4) 着重号\",\"t\":[\"着重号: `` , 如果你的表名、字段名与MYSQL中的关键字重复，使用 `` 括起来。\",\"SELECT * FROM `order` \"]},\"525\":{\"h\":\"2.3.2 过滤器WHERE\",\"t\":[\"WHERE 用来筛选符合条件的结果，一定是紧跟在FROM后面的。\",\"# 查询部门编号为90的员工 SELECT * FROM employees WHERE department_id = '90' \"]},\"526\":{\"h\":\"2.3.3 运算符\"},\"527\":{\"h\":\"算数运算符\",\"t\":[\"image-20240107153620324\",\"值得注意的是: 使用 + 号进行计算时，如果数值和字符串类型进行计算，会将字符串转换为数值类型(隐形转换)\",\"SELECT 100 + '2' 结果: 102 \"]},\"528\":{\"h\":\"比较运算符\",\"t\":[\"比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。\",\"比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。\",\"image-20240107155017501\",\"(1) 等号运算符\",\"如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等\",\"如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。\",\"如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。\",\"SELECT 1 = 1, 1 = '1', 1 = 'a', 'ab' = 'ab', 1 = NULL, NULL = NULL \",\"image-20240107155807921\",\"(2) 安全等于运算符\",\"与 = 类似，唯一区别的就是，<=> 增加了对 NULL 的判断，若俩边有一个为 NULL，则结果为 0，都为NULL，则结果为 1\",\"SELECT NULL <=> NULL, 1 <=>NULL \",\"image-20240107160009260\"]},\"529\":{\"h\":\"符号运算符\",\"t\":[\"image-20240107161107200\",\"转义字符的使用\",\"我想查询名字第二个字符带有 _ 并且含有'a'的员工\",\"此时可以使用 \\\\ 将_ 进行转移，不在表示前面有单个字符\",\"SELECT department_id,last_name FROM employees WHERE last_name LIKE '_\\\\_a%' \",\"545 206 = 751\"]},\"530\":{\"h\":\"逻辑运算符\",\"t\":[\"image-20240107163418942\"]},\"531\":{\"h\":\"位运算符\",\"t\":[\"image-20240107163939637\"]},\"532\":{\"h\":\"2.3.4 多表查询\",\"t\":[\"笛卡尔积\",\"笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能 组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素 个数的乘积数。\",\"image-20240107182127530\"]},\"533\":{\"h\":\"(1) 等值连接\",\"t\":[\"假设我想查询每一个员工所在得部门名称，如果想要简单得进行如下查询, 就会产生 笛卡尔积\",\"image-20240107183549127\",\"SELECT last_name,department_name FROM employees,departments \",\"产生的笛卡尔积得原因:\",\"省略多个表的连接条件（或关联条件）\",\"连接条件（或关联条件）无效\",\"所有表中的所有行互相连接\",\"因此为了避免产生笛卡尔积，应该增加WHERE条件\",\"SELECT last_name,department_name FROM employees,departments WHERE employees.department_id = departments.department_id \",\"注意：多表查询时，如果涉及到一个字段在多个表中都存在时，一定要指明查询得表。\",\"如下图所示，我想要查询部门ID，但是部门ID在俩张表中都存在，MYSQL就不知道去哪张表里面查了。\",\"image-20240107182920238\",\"正确写法，在多表查询时，在优化角度来说，建议每个字段前都指明其所在的表：\",\"SELECT employees.last_name,departments.department_name,departments.department_id FROM employees,departments WHERE employees.department_id = departments.department_id \",\"为了避免混乱，可以对表起别名：\",\"SELECT emp.last_name,dept.department_name,dept.department_id FROM employees emp,departments dept WHERE emp.department_id = dept.department_id \",\"案例2\",\"查询每一个员工的 姓名、部门名称、部门所在城市名称\",\"SELECT emp.last_name,dept.department_name,lo.city FROM employees emp,departments dept,locations lo WHERE emp.department_id = dept.department_id AND dept.location_id = lo.location_id \",\"假设有n张表进行查询，则最少需要 n-1 个连接条件！\"]},\"534\":{\"h\":\"(2) 非等值连接\",\"t\":[\"image-20240107185420069\",\"查询出每一个员工的工资等级。其工资范围在 JOB_GRADES 表中\",\"SELECT emp.last_name,emp.salary,jg.grade_level FROM employees emp,job_grades jg WHERE emp.salary BETWEEN jg.lowest_sal AND jg.highest_sal \"]},\"535\":{\"h\":\"(3) 非自连接\",\"t\":[\"只要涉及到多张表进行连接的，都是非自连接！！\"]},\"536\":{\"h\":\"(4) 自连接\",\"t\":[\"image-20240107185812138\",\"查询出每个员工的管理者名称，其中管理者也在 EMPLOYEES 表中。\",\"SELECT emp.last_name,emp.manager_id, mgr.last_name,mgr.employee_id FROM employees emp ,employees mgr WHERE emp.manager_id = mgr.employee_id \"]},\"537\":{\"h\":\"(5) 内连接 VS 外连接\",\"t\":[\"内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行\",\"外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。\",\"如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。\",\"如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。\"]},\"538\":{\"h\":\"内连接\",\"t\":[\"语法： INNER JOIN 表名 ON 连接条件\",\"INNER 可省略\",\"SELECT last_name,department_name FROM employees emp JOIN departments dept ON emp.department_id = dept.department_id \",\"连接多张表可使用多次JOIN...ON\",\"SELECT last_name,department_name,city FROM employees emp JOIN departments dept ON emp.department_id = dept.department_id JOIN locations lo ON dept.location_id = lo.location_id \"]},\"539\":{\"h\":\"外连接\",\"t\":[\"左外连接： LEFT OUTER JOIN 表名 ON 连接条件\",\"右外连接： RIGHT OUTER JOIN 表名 ON 连接条件\",\"OUTER 可省略\",\"-- employees为为主表 -- departments为从表 -- 左外连接 SELECT last_name,department_name FROM employees emp LEFT OUTER JOIN departments dept ON emp.department_id = dept.department_id -- 右外连接 SELECT last_name,department_name FROM employees emp LEFT OUTER JOIN departments dept ON emp.department_id = dept.department_id \",\"外连接可以将不符合条件的行也都查询出来，而内连接只能查询符合条件的行。\",\"因此如果在SQL题目中有 所有 的关键字，优先考虑外连接！！！\",\"通过查询结果查看左右连接区别：\",\"左连接：\",\"image-20240120164036256\",\"右连接：\",\"image-20240120164123647\",\"在我们使用左连接时，会将左表不符合条件的行查询出来，也就是 last_name为 Grant 的，没有部门，但是也查询出来了。\",\"使用右连接时，会将右表不符合条件的行查询出来, 也就是department表中有16个部门没有员工！\",\"需求\",\"如果现在我想把左表、右表不符合条件的行都查询出来。这就是满外连接\",\"在说慢外连接的前提，我们先了解MYSQL 的七种 JOIN 的方式，而在此之前，还需要了解一个关键字 UNION\"]},\"540\":{\"h\":\"UNION（ALL）\",\"t\":[\"合并查询结果 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并 时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。\",\"语法格式\",\"SELECT column,... FROM table1 UNION [ALL] SELECT column,... FROM table2 \",\"image-20240120165244443\",\"UNION 操作符返回两个查询的结果集的并集，去除重复记录。\",\"UNION ALL\",\"image-20240120165311267\",\"UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。\",\"注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据 不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效 率。\"]},\"541\":{\"h\":\"七种JOIN的使用\",\"t\":[\"A可以用employees表表示，B可以用departments表表示\",\"image-20240120165502981\",\"1、中图: 内连接，查询员工的姓名以及所在部门名称，没有部门的员工不会查询出来\",\"SELECT last_name,department_name FROM employees emp INNER JOIN departments dept ON emp.department_id = dept.department_id \",\"2、左上图：左外连接，查询员工的姓名以及所在部门名称，没有部门的员工也会查询出来，也就是说会将主表中不符合条件的行也查询出来\",\"-- 左外连接 SELECT last_name,department_name FROM employees emp LEFT OUTER JOIN departments dept ON dept.department_id =emp.department_id \",\"3、右上图： 右外连接，查询员工的姓名以及所在部门名称，会将部门下没有员工的部门也会查询出来，也就是说会将从表中不符合条件的行也查询出来\",\"-- 右外连接 SELECT last_name,department_name FROM employees emp RIGHT OUTER JOIN departments dept ON emp.department_id = dept.department_id \",\"4、左中图： 在左外连接的基础上，将A、B的交集去掉，查询出A表也就是employees表中不符合条件的行\",\"SELECT last_name,department_name FROM employees emp LEFT JOIN departments dept ON dept.department_id =emp.department_id WHERE dept.department_id IS NULL \",\"5、右中图： 在右外连接的基础上，将A、B的交集去掉，查询出B表也就是departments表中不符合条件的行\",\"-- 右外连接 SELECT last_name,department_name FROM employees emp RIGHT JOIN departments dept ON emp.department_id = dept.department_id WHERE emp.department_id IS NULL \",\"6、左下图：慢外连接，左上图的查询结果 + 右中图的查询结果\",\"-- 满外连接 SELECT last_name,department_name FROM employees emp LEFT OUTER JOIN departments dept ON dept.department_id =emp.department_id UNION ALL SELECT last_name,department_name FROM employees emp RIGHT JOIN departments dept ON dept.department_id =emp.department_id WHERE emp.department_id IS NULL \",\"7、右下图： 左中图+右中图的查询结果\",\"SELECT last_name,department_name FROM employees emp LEFT JOIN departments dept ON dept.department_id =emp.department_id WHERE dept.department_id IS NULL UNION ALL SELECT last_name,department_name FROM employees emp RIGHT JOIN departments dept ON emp.department_id = dept.department_id WHERE emp.department_id IS NULL \"]},\"542\":{\"h\":\"2.4 DML之增删改\",\"t\":[\"插入数据\",\"# 按字段的默认顺序插入数据 INSERT INTO 表名 VALUES (value1,value2,....); # 指定字段的顺序及插入数据的顺序 INSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]); # 插入多条数据 INSERT INTO table_name VALUES (value1 [,value2, …, valuen]), (value1 [,value2, …, valuen]), …… (value1 [,value2, …, valuen]); # 或者 INSERT INTO table_name(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]), (value1 [,value2, …, valuen]), …… (value1 [,value2, …, valuen]); # 将查询结果插入到表中，表的字段名保持一致 INSERT INTO 目标表名 (tar_column1 [, tar_column2, …, tar_columnn]) SELECT (src_column1 [, src_column2, …, src_columnn]) FROM 源表名 [WHERE condition] \",\"一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句 在处理过程中 效率更高。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句 快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。\",\"更新数据\",\"UPDATE 表名 SET 字段名1 = '', 字段名2 = '' WHERE 条件 \",\"删除数据\",\"# table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，语句将删除表中的所有记录。 DELETE FROM table_name [WHERE <condition>]; \"]},\"543\":{\"c\":[\"数据库\"]},\"544\":{\"c\":[\"数据库\",\"MySQL\"]},\"545\":{\"h\":\"三、函数\",\"t\":[\"函数的分类\",\"image-20240120180848000\",\"操作数据对象\",\"接受参数返回一个结果\",\"只对一行进行变换\",\"每行返回一个结果\",\"可以嵌套\",\"参数可以是一列或一个值\"]},\"546\":{\"h\":\"3.1 单行函数\"},\"547\":{\"h\":\"3.1.1 数值函数\"},\"548\":{\"h\":\"（1）基本函数\",\"t\":[\"函数\",\"解释\",\"ABS(x)\",\"返回x的绝对值\",\"SIGN(X)\",\"返回X的符号。正数返回1，负数返回-1，0返回0\",\"PI()\",\"返回圆周率的值\",\"CEIL(x)，CEILING(x)\",\"返回大于或等于某个值的最小整数\",\"FLOOR(x)\",\"返回小于或等于某个值的最大整数\",\"LEAST(e1,e2,e3…)\",\"返回列表中的最小值\",\"GREATEST(e1,e2,e3…)\",\"返回列表中的最大值\",\"MOD(x,y)\",\"返回X除以Y后的余数\",\"RAND()\",\"返回0~1的随机值\",\"RAND(x)\",\"返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机 数\",\"ROUND(x)\",\"返回一个对x的值进行四舍五入后，最接近于X的整数\",\"ROUND(x,y)\",\"返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位\",\"TRUNCATE(x,y)\",\"返回数字x截断为y位小数的结果\",\"SQRT(x)\",\"返回x的平方根。当X的值为负数时，返回NULL\",\"RAND：随机数\",\"对于 RAND(x) 函数，如果种子相同的话，那么获取的随机数也是一样的！\",\"SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1) FROM DUAL; \",\"image-20240120182018969\",\"ROUND、TRUNCATE: 四舍五入、截断\",\"ROUND(12.324,-1)：-1看小数点前1位，尽心四舍五入\",\"SELECT ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1) FROM DUAL; \",\"image-20240120182229805\"]},\"549\":{\"h\":\"（2）三角函数\",\"t\":[\"函数\",\"解释\",\"RADIANS(x)\",\"将角度转化为弧度，其中，参数x为角度值\",\"DEGREES(x)\",\"将弧度转化为角度，其中，参数x为弧度值\",\"SIN(x)\",\"返回x的正弦值，其中，参数x为弧度值\",\"ASIN(x)\",\"返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL\",\"COS(x)\",\"返回x的余弦值，其中，参数x为弧度值\",\"ACOS(x)\",\"返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL\",\"TAN(x)\",\"返回x的正切值，其中，参数x为弧度值\",\"ATAN(x)\",\"返回x的反正切值，即返回正切值为x的值\",\"COT(x)\",\"返回x的余切值，其中，X为弧度值\",\"ATAN2(m,n)\",\"返回两个参数的反正切值\"]},\"550\":{\"h\":\"（4） 指数和对数\",\"t\":[\"函数\",\"解释\",\"POW(x,y)，POWER(X,Y)\",\"返回x的y次方\",\"EXP(X)\",\"返回e的X次方，其中e是一个常数，2.718281828459045\",\"LN(X)，LOG(X)\",\"返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL\",\"LOG10(X)\",\"返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL\",\"LOG2(X)\",\"返回以2为底的X的对数，当X <= 0 时，返回NULL\"]},\"551\":{\"h\":\"（5） 进制间的转换\",\"t\":[\"函数\",\"解释\",\"BIN(x)\",\"返回x的二进制编码\",\"HEX(x)\",\"返回x的十六进制编码\",\"OCT(x)\",\"返回x的八进制编码\",\"CONV(x,f1,f2)\",\"返回f1进制数变成f2进制数\"]},\"552\":{\"h\":\"3.1.2 字符串函数\",\"t\":[\"注意：MySQL中，字符串的位置是从1开始的。\",\"​\",\"函数\",\"解释\",\"ASCII(S)\",\"返回字符串S中的第一个字符的ASCII码值\",\"CHAR_LENGTH(s)\",\"返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同\",\"LENGTH(s)\",\"返回字符串s的字节数，和字符集有关\",\"CONCAT(s1,s2,......,sn)\",\"连接s1,s2,......,sn为一个字符串\",\"CONCAT_WS(x, s1,s2,......,sn)\",\"同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x\",\"INSERT(str, idx, len, replacestr)\",\"将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr\",\"REPLACE(str, a, b)\",\"用字符串b替换字符串str中所有出现的字符串a\",\"UPPER(s) 或 UCASE(s)\",\"将字符串s的所有字母转成大写字母\",\"LOWER(s) 或LCASE(s)\",\"将字符串s的所有字母转成小写字母\",\"LEFT(str,n)\",\"返回字符串str最左边的n个字符\",\"RIGHT(str,n)\",\"返回字符串str最右边的n个字符\",\"LPAD(str, len, pad)\",\"用字符串pad对str最左边进行填充，直到str的长度为len个字符\",\"RPAD(str ,len, pad)\",\"用字符串pad对str最右边进行填充，直到str的长度为len个字符\",\"LTRIM(s)\",\"去掉字符串s左侧的空格\",\"RTRIM(s)\",\"去掉字符串s右侧的空格\",\"TRIM(s)\",\"去掉字符串s开始与结尾的空格\",\"TRIM(s1 FROM s)\",\"去掉字符串s开始与结尾的s1\",\"TRIM(LEADING s1 FROM s)\",\"去掉字符串s开始处的s1\",\"TRIM(TRAILING s1 FROM s)\",\"去掉字符串s结尾处的s1\",\"REPEAT(str, n)\",\"返回str重复n次的结果\",\"SPACE(n)\",\"返回n个空格\",\"STRCMP(s1,s2)\",\"比较字符串s1,s2的ASCII码值的大小\",\"SUBSTR(s,index,len)\",\"返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同\",\"LOCATE(substr,str)\",\"返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同 。未找到，返回0\",\"ELT(m,s1,s2,…,sn)\",\"返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如 果m=n，则返回sn\",\"FIELD(s,s1,s2,…,sn)\",\"返回字符串s在字符串列表中第一次出现的位置\",\"FIND_IN_SET(s1,s2)\",\"返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分 隔的字符串\",\"REVERSE(s)\",\"返回s反转后的字符串\",\"NULLIF(value1,value2)\",\"比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1\"]},\"553\":{\"h\":\"3.1.3 日期函数\"},\"554\":{\"h\":\"(1) 获取日期、时间\",\"t\":[\"函数\",\"解释\",\"CURDATE() ，CURRENT_DATE()\",\"返回当前日期，只包含年、 月、日\",\"CURTIME() ， CURRENT_TIME()\",\"返回当前时间，只包含时、 分、秒\",\"NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()\",\"返回当前系统日期和时间\",\"UTC_DATE()\",\"返回UTC（世界标准时间） 日期\",\"UTC_TIME()\",\"返回UTC（世界标准时间） 时间\",\"日期与时间戳的转换\",\"函数\",\"解释\",\"UNIX_TIMESTAMP()\",\"以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - >1634348884\",\"UNIX_TIMESTAMP(date)\",\"将时间date以UNIX时间戳的形式返回。\",\"FROM_UNIXTIME(timestamp)\",\"将UNIX时间戳的时间转换为普通格式的时间\",\"-- 获取日期与时间 SELECT CURDATE(),CURTIME(),NOW(),UNIX_TIMESTAMP(),UNIX_TIMESTAMP(CURDATE()),FROM_UNIXTIME(UNIX_TIMESTAMP()) \",\"image-20240121102332562\"]},\"555\":{\"h\":\"(2) 获取月份、星期、星期数、天数等函数\",\"t\":[\"函数\",\"用法\",\"YEAR(date) / MONTH(date) / DAY(date)\",\"返回 年份/月份/天\",\"HOUR(time) / MINUTE(time) / SECOND(time)\",\"返回 时/分/秒\",\"MONTHNAME(date)\",\"返回月份：January，..\",\"DAYNAME(date)\",\"返回星期几：MONDAY，TUESDAY.....SUNDAY\",\"WEEKDAY(date)\",\"返回周几，注意，周1是0，周2是1，。。。周日是6\",\"QUARTER(date)\",\"返回日期对应的季度，范围为1～4\",\"WEEK(date) ， WEEKOFYEAR(date)\",\"返回一年中的第几周\",\"DAYOFYEAR(date)\",\"返回日期是一年中的第几天\",\"DAYOFMONTH(date)\",\"返回日期位于所在月份的第几天\",\"DAYOFWEEK(date)\",\"返回周几，注意：周日是1，周一是2，。。。周六是 7\",\"EXTRACT(type FROM date)\",\"返回指定日期中特定的部分，type指定返回的值\",\"EXTRACT(type FROM date)函数中type的取值与含义：\",\"image-20240121102811237\"]},\"556\":{\"h\":\"(3) 时间和秒钟的转换\",\"t\":[\"函数\",\"解释\",\"TIME_TO_SEC(time)\",\"将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 *60+秒\",\"SEC_TO_TIME(seconds)\",\"将 seconds 描述转化为包含小时、分钟和秒的时\"]},\"557\":{\"h\":\"(4) 计算日期和时间的函数\",\"t\":[\"函数\",\"解释\",\"DATE_ADD(datetime, INTERVAL expr type) ADDDATE(date,INTERVAL expr type)\",\"返回与给定日期时间相差INTERVAL时 间段的日期时间\",\"DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type)\",\"返回与date相差INTERVAL时间间隔的 日期\",\"上述中type 的取值：\",\"image-20240121103503504\",\"-- 后天 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY) -- 前天 SELECT DATE_SUB(NOW(),INTERVAL 2 DAY) \",\"函数\",\"解释\",\"ADDTIME(time1,time2)\",\"返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数\",\"SUBTIME(time1,time2)\",\"返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数\",\"DATEDIFF(date1,date2)\",\"返回date1 - date2的日期间隔天数\",\"TIMEDIFF(time1, time2)\",\"TIMEDIFF(time1, time2) 返\",\"FROM_DAYS(N)\",\"返回从0000年1月1日起，N天以后的日期\",\"TO_DAYS(date\",\"返回日期date距离0000年1月1日的天数\",\"LAST_DAY(date)\",\"返回date所在月份的最后一天的日期\",\"MAKEDATE(year,n)\",\"针对给定年份与所在年份中的天数返回一个日期\",\"MAKETIME(hour,minute,second)\",\"将给定的小时、分钟和秒组合成时间并返回\",\"PERIOD_ADD(time,n\",\"返回time加上n后的时间\",\"SELECT ADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),'1:1:3'),DATEDIFF(NOW(),'2021-10- 01'), TIMEDIFF(NOW(),'2021-10-25 22:10:10'),FROM_DAYS(366),TO_DAYS('0000-12-25'), LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101, 10) FROM DUAL; \"]},\"558\":{\"h\":\"(5) 日期的格式化与解析\",\"t\":[\"函数\",\"解释\",\"DATE_FORMAT(date,fmt)\",\"按照字符串fmt格式化日期date值\",\"TIME_FORMAT(time,fmt)\",\"按照字符串fmt格式化时间time值\",\"GET_FORMAT(date_type,format_type)\",\"返回日期字符串的显示格式\",\"STR_TO_DATE(str, fmt)\",\"按照字符串fmt对str进行解析，解析为一个日期\",\"上述函数 fmt 通用的格式：\",\"image-20240121104255210\",\"GET_FORMAT函数中date_type和format_type参数取值如下：\",\"image-20240121104516378\",\"SELECT STR_TO_DATE('09/01/2009','%m/%d/%Y') FROM DUAL; SELECT STR_TO_DATE('20140422154706','%Y%m%d%H%i%s') FROM DUAL; SELECT STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s') FROM DUAL; \"]},\"559\":{\"h\":\"3.1.4 流程控制函数\",\"t\":[\"流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。\",\"函数\",\"解释\",\"IF(value,value1,value2)\",\"如果value的值为TRUE，返回value1， 否则返回value2\",\"IFNULL(value1, value2)\",\"如果value1不为NULL，返回value1，否 则返回value2\",\"CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END\",\"相当于Java的if...else if...else..\",\"CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END\",\"相当于Java的switch...case..\",\"SELECT IF(1 > 0,'正确','错误') ->正确 SELECT CASE WHEN 1 > 0 THEN '1 > 0' WHEN 2 > 0 THEN '2 > 0' ELSE '3 > 0' END ->1 > 0 SELECT employee_id,salary, CASE WHEN salary>=15000 THEN '高薪' WHEN salary>=10000 THEN '潜力股' WHEN salary>=8000 THEN '屌丝' ELSE '草根' END \\\"描述\\\" FROM employees; \"]},\"560\":{\"h\":\"3.2 多行函数\"},\"561\":{\"h\":\"3.2.1 聚合函数\",\"t\":[\"聚合（或聚集、分组）函数，它是对 一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。\"]},\"562\":{\"h\":\"(1) 常用的聚合函数\",\"t\":[\"AVG()/SUM()\",\"AVG: 求平均值\",\"SUM：求总和\",\"只适用于数值类型的\",\"SELECT SUM(salary) FROM employees SELECT AVG(salary) FROM employees \",\"MAX()/MIN()\",\"MAX：最大值 MIN：最小值\",\"可以适用于字符串、数值、日期类型！\",\"SELECT MAX(salary),MIN(salary) FROM employees SELECT MAX(last_name),MIN(last_name) FROM employees \",\"COUNT()\",\"COUNT(expr) 返回expr不为空的记录总数。\",\"SELECT COUNT(salary) FROM employees \",\"上面这几个聚合函数都会自动过滤NULL值\",\"问题：用count(*)，count(1)，count(列名)谁好呢\",\"其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。\",\"Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。\"]},\"563\":{\"h\":\"(2) GROUP BY\",\"t\":[\"可以使用GROUP BY子句将表中的数据分成若干组\",\"SELECT column, group_function(column) FROM table [WHERE condition] [GROUP BY group_by_expression] [ORDER BY column]; \",\"在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中\",\"反之， GROUP BY子句中的字段可以不出现在SELECT后\",\"SELECT department_id, AVG(salary) FROM employees GROUP BY department_id ; \"]},\"564\":{\"h\":\"(3) HAVIGN\",\"t\":[\"作用：用来过滤数据的\",\"举例：查询各个部门中最高工资比10000高的部门信息\",\"-- 错误写法 SELECT department_id, MAX(salary) FROM employees WHERE MAX(salary) > 10000 GROUP BY department_id ; \",\"要求1：如果过滤条件中使用到啊了聚合函数 ， 则必须使用 HAVING 替换 WHERE 否则就会报错\",\"要求2： 如果要使用 HAVING，则必须在 GROUP BY 后面\",\"要求3： HAVIGN 一般会和 GROUP BY搭配使用，如果单独使用HAVING 不会报错，但是没有意义，将整个查询结果作为一组。\",\"-- 正确写法 SELECT department_id, MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary) > 10000 \",\"结论：\",\"当过滤条件中有聚合函数时，则过滤条件一定要放在HAVIGN中\",\"当过滤条件中没有聚合函数时，则过滤条件放在 WHERE和HAVING都可以，但是建议放在WHERE中，WEHRE 的执行效率会比放在 HAVIGN 中效率高\"]},\"565\":{\"h\":\"(4) SQL的完整结构及执行原理\",\"t\":[\"SELECT ...,....,... FROM ... JOIN ... ON 多表的连接条件 JOIN ... ON ... WHERE 不包含组函数的过滤条件 AND/OR 不包含组函数的过滤条件 GROUP BY ...,... HAVING 包含组函数的过滤条件 ORDER BY ... ASC/DESC LIMIT ...,... \",\"SQL的执行顺序\",\"FROM -> (LEFT/RIGHT) JOIN ON -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT \",\"SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5 FROM player JOIN team ON player.team_id = team.team_id # 顺序 1 WHERE height > 1.80 # 顺序 2 GROUP BY player.team_id # 顺序 3 HAVING num > 2 # 顺序 4 ORDER BY num DESC # 顺序 6 LIMIT 2 # 顺序 7 \",\"在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。\",\"了解了SQL的执行顺序，我们在来说为什么WHERE会比HAVIGN执行效率高，假设我们有百万条数据，在经历过WHERE之后可能就剩非常少的数据，在这些数据在分组, HAVIGN过滤就非常轻松了。\",\"但是将条件放在HAVIGN中，先对百万条数据进行分组，这个操作就非常耗时了！\"]},\"566\":{\"c\":[\"数据库\"]},\"567\":{\"c\":[\"数据库\",\"函数\",\"MySQL\"]},\"568\":{\"h\":\"四、子查询\",\"t\":[\"子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。\",\"SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者 需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集 合）进行比较。\",\"子查询其实就相当于变成语言中的嵌套FOR循环\"]},\"569\":{\"h\":\"4.1 提出需求并解决\",\"t\":[\"image-20240121190639539\",\"#方式一： SELECT salary FROM employees WHERE last_name = 'Abel'; SELECT last_name,salary FROM employees WHERE salary > 11000; #方式二：自连接 SELECT e2.last_name,e2.salary FROM employees e1,employees e2 WHERE e1.last_name = 'Abel' AND e1.`salary` < e2.`salary` #方式三：子查询 SELECT last_name,salary FROM employees WHERE salary > ( SELECT salary FROM employees WHERE last_name = 'Abel' ); \",\"子查询（内查询）在主查询之前一次执行完成。\",\"子查询的结果被主查询（外查询）使用 。\",\"注意事项\",\"子查询要包含在括号内\",\"将子查询放在比较条件的右侧\",\"单行操作符对应单行子查询，多行操作符对应多行子查询\"]},\"570\":{\"h\":\"4.2 子查询的分类\",\"t\":[\"分类方式一：我们按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。\",\"单行子查询返回一条记录\",\"image-20240121192239686\",\"多行子查询返回多条记录\",\"image-20240121192306003\",\"分类方式二：我们按内查询是否被执行多次，将子查询划分为 相关(或关联)子查询 和 不相关(或非关联)子查询 。\",\"子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条 件进行执行，那么这样的子查询叫做不相关子查询。\",\"同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查 询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。\"]},\"571\":{\"h\":\"4.2.1 单行子查询\"},\"572\":{\"h\":\"(1) 单行比较操作符\",\"t\":[\"image-20240121195145554\"]},\"573\":{\"h\":\"(2) 案例\",\"t\":[\"题目：返回公司工资最少的员工的last_name,job_id和salary\",\"SELECT last_name, job_id, salary FROM employees WHERE salary = ( SELECT MIN(salary) FROM employees ); \",\"题目：查询与141号员工的manager_id和department_id相同的其他员工的employee_id， manager_id，department_id\",\"-- 实现方式一 SELECT employee_id, manager_id, department_id FROM employees WHERE manager_id = ( SELECT manager_id FROM employees WHERE employee_id = 141 ) AND department_id = ( SELECT department_id FROM employees WHERE employee_id = 141 ) AND employee_id != 141 -- 实现方式二 SELECT employee_id, manager_id, department_id FROM employees WHERE (department_id,manager_id) = ( SELECT department_id,manager_id FROM employees WHERE employee_id = 141 ) AND employee_id != 141 \"]},\"574\":{\"h\":\"(3) HAVING中的子查询\",\"t\":[\"题目：查询最低工资大于50号部门最低工资的 部门id和其最低工资\",\"SELECT department_id, MIN(salary) FROM employees GROUP BY department_id HAVING MIN(salary) > ( SELECT MIN(salary) FROM employees WHERE department_id = 50 ) \"]},\"575\":{\"h\":\"(4) CASE 中的子查询\",\"t\":[\"题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’。\",\"SELECT employee_id, last_name, (CASE department_id WHEN (SELECT department_id FROM departments WHERE location_id = 1800) THEN 'Canada' ELSE 'USA' END) \\\"location\\\" FROM employees; \"]},\"576\":{\"h\":\"4.2.2 多行子查询\",\"t\":[\"也称为集合比较子查询\",\"内查询返回多行\",\"使用多行比较操作符\"]},\"577\":{\"h\":\"(1) 多行比较操作符\",\"t\":[\"image-20240121200231681\"]},\"578\":{\"h\":\"(2) 案例\",\"t\":[\"题目：返回其它job_id中比job_id为‘IT_PROG’部门【任一】工资都低的员工的员工号、姓名、job_id以及 salary\",\"SELECT employee_id,last_name,job_id,salary FROM employees WHERE job_id != 'IT_PROG' AND salary < ANY( SELECT salary FROM employees WHERE job_id = 'IT_PROG' ) \",\"题目：返回其它job_id中比job_id为‘IT_PROG’部门【所有】工资都低的员工的员工号、姓名、job_id以及 salary\",\"SELECT employee_id,last_name,job_id,salary FROM employees WHERE job_id != 'IT_PROG' AND salary < ALL( SELECT salary FROM employees WHERE job_id = 'IT_PROG' ) \",\"题目：查询平均工资最低的部门id\",\"-- 错误的，聚合函数不能嵌套 SELECT MIN(AVG(salary)) FROM employees GROUP BY department_id \",\"查询出所有部门的平均工资\",\"SELECT AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id \",\"将结果作为一张新表，查询出这个新表中最低的平均工资\",\"SELECT MIN(avg_salary) FROM ( SELECT AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id ) dept_avg_salary \",\"查询平均工资等于这个最低的平均工资的部门ID\",\"SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary) = ( SELECT MIN(avg_salary) FROM ( SELECT AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id ) dept_avg_salary ) \",\"优化\",\"SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary) <= ALL ( SELECT AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id ) \"]},\"579\":{\"h\":\"4.2.3 相关子查询\",\"t\":[\"如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。\",\"相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。\",\"image-20240121204418557\",\"image-20240121204606375\",\"说明： 子查询中使用主查询的列\",\"题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id\",\"由外向里思考：\",\"第一种方式：\",\"先查询出员工的last_name,salary和其department_id\",\"SELECT last_name,salary,department_id FROM employees WHERE salary > (本部门的平均工资) \",\"查询本部门的平均工资 \",\"需要注意的是：这个本部门是要使用到主查询中的部门ID，它不是固定的，子查询中使用到了主查询中的列，这就是相关子查询！！！！\",\"SELECT last_name,salary,department_id FROM employees e WHERE salary > ( SELECT AVG(salary) FROM employees WHERE department_id = e.department_id ) \",\"image-20240121205834432\",\"第二种方式：\",\"查询结果都能当做一张新表使用，我们可以将每个部门的ID、平均工资查询出来当做一张新表。\",\"将主表与这个新表进行连接，通过部门ID查询出工资比平均工资大的员工\",\"将每个部门的ID、平均工资查询出来当做一张新表\",\"SELECT department_id,AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id \",\"将主表与这个新表进行连接，通过部门ID查询出工资比平均工资大的员工\",\"SELECT e1.last_name,salary,e1.department_id FROM employees e1, ( SELECT department_id,AVG(salary) AS \\\"avg_salary\\\" FROM employees GROUP BY department_id ) t_dept_avg_salary WHERE e1.department_id = t_dept_avg_salary.department_id AND e1.salary > t_dept_avg_salary.avg_salary \",\"注意事项：\",\"在子查询中如果用到聚合函数作为列，一定要为其起一个别名，类似上面的 \\\"avg_salary\\\"\",\"俩张表连接，至少要有一个连接条件，否则会出现 \\\"笛卡尔积\\\"\",\"题目：查询员工的id,salary,按照department_name 排序\",\"SELECT employee_id,salary FROM employees e ORDER BY ( SELECT department_name FROM departments d WHERE e.`department_id` = d.`department_id` ); \",\"题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同 id的员工的employee_id,last_name和其job_id\",\"SELECT e.employee_id, last_name,e.job_id FROM employees e WHERE 2 <= ( SELECT COUNT(*) FROM job_history WHERE employee_id = e.employee_id ); \",\"结论:  除了GROUP BY 和 LIMIT不能使用子查询，其他地方都可以使用！\"]},\"580\":{\"c\":[\"数据库\"]},\"581\":{\"c\":[\"数据库\",\"MySQL\"]},\"582\":{\"h\":\"五、 创建和管理表\",\"t\":[\"一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。\",\"image-20240225160621281\"]},\"583\":{\"h\":\"5.1 标识符命名规则\",\"t\":[\"数据库名、表名不得超过30个字符，变量名限制为29个\",\"必须只能包含 A–Z, a–z, 0–9, _共63个字符\",\"数据库名、表名、字段名等对象名中间不要包含空格\",\"同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名\",\"必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来\",\"保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了\"]},\"584\":{\"h\":\"5.2 创建和管理数据库\"},\"585\":{\"h\":\"5.2.1 创建数据库\",\"t\":[\"CREATE DATABASE 数据库名; # 创建数据库并指定字符集 CREATE DATABASE 数据库名 CHARACTER SET '字符集'; # 查看系统内使用的字符集 SHOW VARIABLES LIKE 'CHARACTER_%' # 判断数据库是否已经存在，不存在则创建数据库 CREATE DATABASE IF NOT EXISTS 数据库名; \"]},\"586\":{\"h\":\"5.2.2 管理数据库\",\"t\":[\"-- 查看所有的数据库 SHOW DATABASES -- 切换数据库 USE boot_gm -- 查看当前数据库中有哪些表 SHOW TABLES -- 查看数据库的创建信息 show CREATE DATABASE testdatabase \",\"-- 更改数据库字符集 ALTER DATABASE testdatabase CHARACTER SET 'utf8' -- 如果存在则删除数据库 DROP DATABASE IF EXISTS 数据库名; \"]},\"587\":{\"h\":\"5.2.3 创建表\",\"t\":[\"-- 创建方式一 CREATE TABLE [IF NOT EXISTS] 表名( 字段1, 数据类型 [约束条件] [默认值], 字段2, 数据类型 [约束条件] [默认值], 字段3, 数据类型 [约束条件] [默认值], …… [表约束条件] ); -- 创建方式二 -- 基于 employees 表创建 dept80 新表。 -- 不仅会创建 employee_id, last_name,ANNSAL，hire_date 字段，还会将其值复制过去 CREATE TABLE dept80 AS SELECT employee_id, last_name, salary*12 ANNSAL, hire_date FROM employees WHERE department_id = 80; -- 如果不想要数据，可通过WHERE条件控制 CREATE TABLE dept80 AS SELECT employee_id, last_name, salary*12 ANNSAL, hire_date FROM employees WHERE 1 = 2; \"]},\"588\":{\"h\":\"5.2.4 修改表\",\"t\":[\"# 增加字段 ALTER TABLE 表名 ADD 【COLUMN】 字段类型 ; # 修改字段数据类型、长度、默认值、位置的语法格式如下 ALTER TABLE 表名 MODIFY 【COLUMN】 字段类型 【DEFAULT 默认值】 # 重命名字段 ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; # 删除某个字段的语法格式 ALTER TABLE 表名 DROP 【COLUMN】字段名 # 重命名表 RENAME TABLE 表名 to 新表名 # 删除表 DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n]; # 清空表 TRUNCATE TABLE 表名; \"]},\"589\":{\"h\":\"5.2.5 TRUNCATE 与 DELETE 对比\",\"t\":[\"相同点：\",\"都可以实现对表中的所有数据进行删除，同时保留表的结构\",\"不同点：\",\"DELETE 属于 DML 语句，执行操作后可以进行回滚(前提是提交前设置 SET autocommit = false)\",\"TRUNCATE 属于 DDL 语句，执行操作后不可回滚\",\"TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。\"]},\"590\":{\"c\":[\"数据库\"]},\"591\":{\"c\":[\"数据库\",\"MySQL\"]},\"592\":{\"h\":\"六、 MYSQL中的数据类型\",\"t\":[\"常见数据类型的属性，如下：\",\"image-20240302134320608\"]},\"593\":{\"h\":\"6.1 整型\",\"t\":[\"整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。\",\"它们的区别如下表所示\",\"image-20240302133735988\"]},\"594\":{\"h\":\"6.1.1 可选属性\"},\"595\":{\"h\":\"(1) M\",\"t\":[\"M : 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。\",\"如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？\",\"答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 显示宽度与类型可以存储的 值范围无关。从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。\",\"整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。\",\"create TABLE IF NOT EXISTS `int_test` ( f1 TINYINT(3) ZEROFILL, // 当插入的数据不足3位，则使用0在前面填充 f2 SMALLINT, f3 MEDIUMINT, f4 INTEGER, f5 BIGINT ) \",\"当使用 ZEROFILL 时，自动会添加 unsigned，表示默认从0开始\",\"image-20240302135427089\"]},\"596\":{\"h\":\"(2) UNSIGEND\",\"t\":[\"UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设 置为无符号类型。\",\"如果设置 UNSIGEND ，当插入数据为负数时，会报错： \"]},\"597\":{\"h\":\"(3) ZEROFILL\",\"t\":[\"ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指 定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。\",\"原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间。也就是说，int(M)，必须和 UNSIGNED ZEROFILL 一起使用才有意义。如果整 数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充\"]},\"598\":{\"h\":\"6.1.2 适用场景\",\"t\":[\"TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。\",\"SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。\",\"MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。\",\"INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。\",\"BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。\",\"在评估用哪种整数类型的时候，你需要考虑 存储空间和 可靠性的平衡问题：\",\"一方 面，用占用字节数少 的整数类型可以节省存储空间；\",\"另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起 系统错误，影响可靠性。\",\"举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每 天都有旧商品下架，新商品上架，这样不断迭代，日积月累。 如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。\",\"相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 你要注意的是，在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因 此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。\"]},\"599\":{\"h\":\"6.2 浮点类型\",\"t\":[\"浮点数和定点数类型的特点是可以 处理小数，你可以把整数看成小数的一个特例。因此，浮点数和定点 数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。\",\"FLOAT 表示单精度浮点数；\",\"DOUBLE 表示双精度浮点数；\",\"image-20240302140543685\",\"REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：\",\"SET sql_mode = “REAL_AS_FLOAT”; \",\"问题1：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？\",\"FLOAT 占用字节少，取值范围小，DOUBLE 占用字节多，取值范围大\",\"问题2：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？\",\"MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮 点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于 零的部分。\",\"问题3\",\"在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： DECIMAL 。\"]},\"600\":{\"h\":\"6.3 定点数类型\",\"t\":[\"MySQL中的定点数类型只有 DECIMAL 一种类型\",\"使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。(M,D)中 M=整数位+小数位，D=小数位。 D<=M<=255，0<=D<=30。\",\"定点数在MySQL内部是以 字符串的形式进行存储，这就决定了它一定是精准的。\",\"当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。\",\"浮点数 vs 定点数\",\"浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用 于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等）\",\"定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）\"]},\"601\":{\"h\":\"6.4 位类型\",\"t\":[\"BIT类型中存储的是二进制值，类似010110\",\"image-20240302142649063\",\"BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的 位数，位数最小值为1，最大值为64。\"]},\"602\":{\"h\":\"6.5 日期和时间类型\",\"t\":[\"MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间 类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型\",\"YEAR 类型通常用来表示年\",\"DATE 类型通常用来表示年、月、日\",\"TIME 类型通常用来表示时、分、秒\",\"DATETIME 类型通常用来表示年、月、日、时、分、秒\",\"TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒\",\"image-20240302142903236\",\"从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)， 从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。\"]},\"603\":{\"h\":\"6.6 文本字符串类型\",\"t\":[\"在实际的项目中，我们还经常遇到一种数据，就是字符串数据。\",\"MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 LONGTEXT 、 ENUM 、 SET 等类型。\",\"image-20240302143552379\"]},\"604\":{\"h\":\"6.6.1 CHAR 与 VARCHAR\",\"t\":[\"CHAR和VARCHAR类型都可以存储比较短的字符串。\",\"image-20240302143727048\",\"CHAR类型\",\"CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。\",\"如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充空格以达到指定的长 度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。\",\"定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数\",\"VARCHAR类型：\",\"VARCHAR(M) 定义时， 必须指定长度M，否则报错\",\"MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。\",\"检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间 为字符串实际长度加1个字节\",\"哪些情况用CHAR 哪些情况用 VARCHAR\",\"image-20240302144050785\",\"情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失。\",\"情况2：情况2:固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。\",\"情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个 非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。\",\"情况4 具体存储引擎的情况\",\"MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长 度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快，用空间换时间。\",\"MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用 CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。\",\"·InnoDB· 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区 分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素 是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的， 其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好\"]},\"605\":{\"h\":\"6.6.2 TEXT 类型\",\"t\":[\"在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、 MEDIUMTEXT 和 LONGTEXT 类型\",\"在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同\",\"image-20240302145016780\",\"由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)\",\"说明\",\"TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用 一个表。\"]},\"606\":{\"h\":\"6.6.3 ENUM 类型\",\"t\":[\"ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值\",\"image-20240302145246557\",\"当ENUM类型包含1～255个成员时，需要1个字节的存储空间；\",\"当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。\",\"ENUM类型的成员个数的上限为65535个。\",\"CREATE TABLE test_enum( season ENUM('春','夏','秋','冬','unknow') ); # 正确使用 INSERT INTO test_enum VALUES('春'),('秋'); # 忽略大小写 INSERT INTO test_enum VALUES('UNKNOW'); # 允许按照角标的方式获取指定索引位置的枚举值 INSERT INTO test_enum VALUES('1'),(3); # Data truncated for column 'season' at row 1 INSERT INTO test_enum VALUES('ab'); # 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的 INSERT INTO test_enum VALUES(NULL); \"]},\"607\":{\"h\":\"6.6.4 SET 类型\",\"t\":[\"当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下\",\"image-20240302145741574\",\"SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次 选择多个成员，这一点与ENUM类型不同。\",\"CREATE TABLE test_set( s SET ('A', 'B', 'C') ); INSERT INTO test_set (s) VALUES ('A'), ('A,B'); #插入重复的SET类型成员时，MySQL会自动删除重复的成员 INSERT INTO test_set (s) VALUES ('A,B,C,A'); #向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。 INSERT INTO test_set (s) VALUES ('A,B,C,D'); SELECT * FROM test_set; \"]},\"608\":{\"h\":\"6.6.5 JSON 类型\",\"t\":[\"JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式。简洁和清晰的层次结构使得 JSON 成 为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效 率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻 松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式\",\"当需要检索JSON类型的字段中数据的某个具体值时，可以使用“->”和“->>”符号。\",\"# 创建表 CREATE TABLE json_test( js JSON ) # 插入数据 INSERT INTO json_test (js) VALUES ('{\\\"name\\\":\\\"songhk\\\", \\\"age\\\":18, \\\"address\\\":{\\\"province\\\":\\\"beijing\\\", \\\"city\\\":\\\"beijing\\\"}}'); # 取出json中的数据 SELECT js -> '$.name' AS NAME,js -> '$.age' AS age ,js -> '$.address.province' AS province, js -> '$.address.city' AS city FROM json_test; \"]},\"609\":{\"c\":[\"数据库\"]},\"610\":{\"c\":[\"数据库\",\"MySQL\"]},\"611\":{\"h\":\"七、 约束\"},\"612\":{\"h\":\"7.1 约束概念\",\"t\":[\"为什么需要约束？\",\"数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中 存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。\",\"为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：\",\"实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录\",\"域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女\",\"引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门\",\"用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门 经理的工资不得高于本部门职工的平均工资的5倍\",\"什么是约束？\",\"约束是表级的强制规定。\",\"可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束。\"]},\"613\":{\"h\":\"7.2 约束的分类\",\"t\":[\"根据约束数据列的限制，约束可分为：\",\"单列约束：每个约束只约束一列\",\"多列约束：每个约束可约束多列数据\",\"根据约束的作用范围，约束可分为：\",\"列级约束：只能作用在一个列上，跟在列的定义后面\",\"表级约束：可以作用在多个列上，不与列一起，而是单独定义\",\"根据约束起的作用，约束可分为：\",\"NOT NULL 非空约束，规定某个字段不能为空\",\"UNIQUE 唯一约束，规定某个字段在整个表中是唯一的\",\"PRIMARY KEY 主键(非空且唯一)约束\",\"FOREIGN KEY 外键约束\",\"CHECK 检查约束\",\"DEFAULT 默认值约束\",\"查看某张表的约束：\",\"#information_schema数据库名（系统库） #table_constraints表名称（专门存储各个表的约束） SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称'; \"]},\"614\":{\"h\":\"7.2.1 非空约束\",\"t\":[\"限定某个字段/某列的值不允许为空\",\"关键字：NOT NULL\",\"特点\",\"默认所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型\",\"非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空\",\"一个表可以有很多列都分别限定了非空\",\"空字符串''不等于NULL，0也不等于NULL\",\"增加\",\"# 建表时 CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL ); # 建表之后 alter table 表名称 modify 字段名 数据类型 not null; \"]},\"615\":{\"h\":\"7.2.2 唯一性约束\",\"t\":[\"用来限制某个字段/某列的值不能重复\",\"**关键字：**UNIQUE\",\"特点\",\"同一个表可以有多个唯一约束。\",\"唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。\",\"唯一性约束允许列值为空。\",\"在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。\",\"MySQL会给唯一约束的列上默认创建一个唯一索引。\",\"增加约束\",\"字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的\",\"# 建表时： create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名) ); # 建表后： #方式1： alter table 表名称 add unique key(字段列表); #方式2： alter table 表名称 modify 字段名 字段类型 unique \",\"删除唯一约束\",\"添加唯一性约束的列上也会自动创建唯一索引。\",\"删除唯一约束只能通过删除唯一索引的方式删除。\",\"删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。\",\"如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和() 中排在第一个的列名相同。也可以自定义唯一性约束名。\",\"SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪些约束 # 删除索引 ALTER TABLE USER DROP INDEX uk_name_pwd; \",\"注意：可以通过 show index from 表名称; 查看表的索引\"]},\"616\":{\"h\":\"7.2.3 主键约束\",\"t\":[\"用来唯一标识表中的一行记录\",\"关键字：primary key\",\"特点：\",\"主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。\",\"一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建\",\"如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。\",\"MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。\",\"当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询 的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。\",\"需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的 值，就有可能会破坏数据的完整性。\",\"添加主键约束\",\"建表时：\",\"create table 表名称( 字段名 数据类型 primary key #列级模式, 字段名 数据类型, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段列表....) #表级模式 #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键 ); \",\"建表后：\",\"ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); \",\"删除主键\",\"alter table 表名称 drop primary key; \"]},\"617\":{\"h\":\"7.2.4 自增列\",\"t\":[\"某个字段的值自增\",\"关键字：auto_increment\",\"特点\",\"（1）一个表最多只能有一个自增长列\",\"（2）当需要产生唯一标识符或顺序值时，可设置自增长\",\"（3）自增长列约束的列必须是键列（主键列，唯一键列）\",\"（4）自增约束的列的数据类型必须是整数类型 \",\"（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 赋值为具体值。\",\"添加约束\",\"错误演示\",\"# 不能单独使用，配合唯一列、主键列使用 create table employee( eid int auto_increment, ename varchar(20) ); # ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key # 必须是整型 create table employee( eid int primary key, ename varchar(20) unique key auto_increment ); # ERROR 1063 (42000): Incorrect column specifier for column 'ename' 因为ename不是整数类 型 \",\"正确使用\",\"create table 表名称( 字段名 数据类型 primary key auto_increment, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, ); create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值,, primary key(字段名) ); alter table 表名称 modify 字段名 数据类型 auto_increment; \",\"删除约束\",\"#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束 alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 \"]},\"618\":{\"h\":\"7.2.5 外键约束\",\"t\":[\"限定某个表的某个字段的引用完整性。\",\"比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。\",\"image-20240302163657908\",\"**关键字：**FOREIGN KEY\",\"主表/从表 和 父表/子表\",\"主表（父表）：被引用的表，被参考的表 【部门表】\",\"从表（子表）：引用别人的表，参考别人的表【员工表】\",\"特点\",\"（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列\",\"为什么？因为被依赖/被参考的值必须是唯一的\",\"（2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。\",\"（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表\",\"（4）删表时，先删从表（或先删除外键约束），再删除主表\",\"（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖 该记录的数据，然后才可以删除主表的数据\",\"（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束\",\"（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类 型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。\",\"（9）删除外键约束后，必须 手动删除对应的索引\",\"总结：\",\"约束关系是针对双方的 添加了外键约束后，主表的修改和删除数据受约束\",\"添加了外键约束后，从表的添加和修改数据受约束\",\"在从表上建立外键，要求主表必须存在\",\"删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除\",\"添加约束\",\"建表时：\",\"create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型 ); create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) ); \",\"建表后：\",\"ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx]; \",\"举例\",\"# 主表 CREATE TABLE dept ( id VARCHAR(30) PRIMARY KEY , dept_name VARCHAR(30) ) # 从表 CREATE TABLE emp ( id VARCHAR(30) PRIMARY KEY , name VARCHAR(30) not NULL, dept_id VARCHAR(30), # 增加外键 CONSTRAINT pk_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ) \",\"约束等级\",\"Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录\",\"Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null\",\" No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作\",\"Restrict方式 ：同no action， 都是立即检查外键约束\",\"Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别\",\"如果没有指定等级，就相当于Restrict方式\",\"对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式\",\"就是当主表更新时，子表跟着更新，主表删除时，如果子表有对应的数据，就不允许删除\",\"create table dept( did int primary key, dname varchar(50) ); create table emp( eid int primary key, ename varchar(5), deptid int, foreign key (deptid) references dept(did) ON UPDATE CASCADE ON DELETE RESTRICT ); \",\"删除外键约束：\",\"# (1)第一步先查看约束名和删除外键约束 SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称'; ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; # （2）第二步查看索引名和删除索引。（注意，只能手动删除） SHOW INDEX FROM 表名称; #查看某个表的索引名 ALTER TABLE 从表名 DROP INDEX 索引名; \",\"总结\",\"在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会 不允许你使用系统自带的外键约束，在 因为外键约束的系统开销而变得非常慢。所以， MySQL 允 应用层面完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。\"]},\"619\":{\"h\":\"7.2.6 CHECK约束\",\"t\":[\"检查某个字段的值是否符号xx要求，一般指的是值的范围\",\"关键字： CHECK\",\"MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告 但是MySQL 8.0中可以使用check约束了。\",\"添加约束\",\"CREATE TABLE temp( id INT AUTO_INCREMENT, NAME VARCHAR(20), age INT CHECK(age > 20), PRIMARY KEY(id) ); \"]},\"620\":{\"h\":\"7.2.7 DEFAULT 约束\",\"t\":[\"给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默 认值\",\"**关键字：**DEFAULT\",\"添加约束\",\"create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, ); alter table 表名称 modify 字段名 数据类型 default 默认值 \"]},\"621\":{\"c\":[\"数据库\"]},\"622\":{\"c\":[\"数据库\",\"MySQL\"]},\"623\":{\"h\":\"八、 MYSQL架构\"},\"624\":{\"h\":\"8.1 逻辑架构剖析\",\"t\":[\"首先 MySQL 是典型的 C/s 架构，即 client/Server 架构，服务器端程序使用的 mysqld\",\"不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是:客户端进程向服务器进程发送一段文本(SOL语句)段文本，服务器进程处理后在向客户端进程发送一段文本(处理结果)，\",\"image-20240303143605705\"]},\"625\":{\"h\":\"8.1.1 第一层：连接层\",\"t\":[\"系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立TCP 连接 ， 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。\",\"用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行\",\"用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限\",\"TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后 面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。\"]},\"626\":{\"h\":\"8.1.2 第二层：服务层\"},\"627\":{\"h\":\"SQL接口\",\"t\":[\"接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ... FROM就是调用SQL Interface\",\"MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口\"]},\"628\":{\"h\":\"Parser: 解析器\",\"t\":[\"在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的\",\"在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 典丰富查询语法树，会 语法树，并根据数据字 验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还 会对SQl查询进行语法上的优化，进行查询重写。\"]},\"629\":{\"h\":\"Optimizer: 查询优化器\",\"t\":[\"SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划。\",\"这个执行计划表明应该 使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。\"]},\"630\":{\"h\":\"Caches & Buffers： 查询缓存组件\",\"t\":[\"MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。\",\"这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等\",\"这个查询缓存可以在 不同客户端之间共享。\",\"从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除\"]},\"631\":{\"h\":\"8.1.3 第三层：引擎层\",\"t\":[\"插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别 维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同\",\"MySQL 8.0.25默认支持的存储引擎如下\",\"image-20240303144634632\"]},\"632\":{\"h\":\"8.1.4 第四层：存储层\",\"t\":[\"所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统上，以 文件的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。\"]},\"633\":{\"h\":\"总结\",\"t\":[\"image-20240303145041888\",\"简化为三层结构：\",\"连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；\",\"SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；\",\"存储引擎层：与数据库文件打交道，负责数据的存储和读取。\"]},\"634\":{\"h\":\"8.2 SQL执行流程\",\"t\":[\"image-20240303145118032\",\"1、**查询缓存:**Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能\",\"2、解析器： 在解析器中对 SQL 语句进行语法分析、语义分析\",\"分析器先做“ 词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的\\\"select\\\"这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。\",\"4、优化器：：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索，还是根据索引检索等。\",\"在查询优化器中，可以分为 逻辑查询优化阶段和 物理查询优化阶段。\",\"5、执行器 截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段。\",\"在执行之前需要判断该用户是否 具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。\",\"SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器。\",\"image-20240303150535429\"]},\"635\":{\"h\":\"8.3 存储引擎\",\"t\":[\"为了管理方便，人们把 连接管理 、 査询缓存 、 语法解析、 査询优化 这些并不涉及真实数据存储的功能划分为MySQL server 的功能，把真实存取数据的功能划分为 存储引擎的功能。\",\"所以在 MySQL server 完成了查询优化后，只需按照生成的 执行计划 调用底层存储引擎提供的 API，获取到数据后返回给客户端就好了。\",\"MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型，表以什么文件格式存储。 其实存储引擎以前叫做表处理器，后来改名为 存储引擎 ，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。\",\"# 查看MYSQL的存储引擎 SHOW ENGINES # MEMORY # MRG_MYISAM # CSV # FEDERATED # PERFORMANCE_SCHEMA # MyISAM # InnoDB # ndbinfo # BLACKHOLE # ARCHIVE # ndbcluster # 查看默认的存储引擎 show variables like '%storage_engine%'; # 临时修改存储引擎 SET DEFAULT_STORAGE_ENGINE=MyISAM; # 永久生效，修改 my.cnf 文件： default-storage-engine=MyISAM # 重启服务 systemctl restart mysqld.service \"]},\"636\":{\"h\":\"8.3.1 InnoDB引擎\",\"t\":[\"MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎。\",\"InnoDB是MySQL的 默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务 的完整提交(Commit)和回滚(Rollback)。\",\"除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎\",\"数据文件结构： \",\"表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）\",\"表名.ibd 存储数据和索引\",\"InnoDB是 为处理巨大数据量的最大性能设计。\",\"对比MyISAM的存储引擎， InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和 索引。\",\"MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，因此占用内存 高，而且内存大小对性能有决定性的影响。\"]},\"637\":{\"h\":\"8.3.2 MyISAM引擎\",\"t\":[\"MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。\",\"优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用 \",\"这是因为 MyISAM不需要维护额外的事务日志和事务控制\",\"数据和索引存储在不同的文件中，这可以使 MyISAM 更容易进行快速的全表扫描\",\"针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高\",\"数据文件结构： \",\"表名.frm 存储表结构\",\"表名.MYD 存储数据 (MYData)\",\"表名.MYI 存储索引 (MYIndex)\",\"应用场景：只读应用或者以读为主的业务\"]},\"638\":{\"c\":[\"数据库\"]},\"639\":{\"c\":[\"数据库\",\"MySQL\"]},\"640\":{\"h\":\"九、 索引\"},\"641\":{\"h\":\"9.1 为什么要使用索引\",\"t\":[\"索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则 通过索引査找 相关数据，如果不符合则需要 全表扫描 ，即需要一条一条地查找记录，直到找到与条件符合的记录。\",\"使用索引的目的就是为了减少磁盘IO的次数，加快查询效率\"]},\"642\":{\"h\":\"9.2 索引的特点及优缺点\",\"t\":[\"MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。\",\"索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法。\",\"索引是在存储引擎中实现的 ，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 最大索引数 和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。\",\"优点\",\"（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本，这也是创建索引最主 要的原因。 （2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性。\",\"（3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。\",\"（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间，降低了CPU的消耗。\",\"缺点\",\"（1）创建索引和维护索引要 耗费时间 且随着数据量的增加，所耗费的时间也会增加。\",\"（2）索引需要占 磁盘空间，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。\",\"（3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。\"]},\"643\":{\"h\":\"9.3 一个简单索引的设计方案\",\"t\":[\"创建一个表\",\"mysql> CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1)) ROW_FORMAT = Compact; \",\"这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：\",\"image-20240303161708066\",\"record_type ：记录头信息的一项属性，表示记录的类型，0表示普通记录、1表示目录项记录、2表示最小记 录、3表示最大记录\",\"next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁\",\"各个列的值：这里只记录在 index_demo 表中的三个列，分别是 c1 、c2和c3。\",\"其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息\",\"把一些记录放到页里示意图如下：\",\"image-20240303161921543\",\"我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。\",\"所以如果 我们 想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而 建 立一个目录，建这个目录必须完成下边这些事\",\"下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。 （主键值是依次递增的）\",\"给所有的页建立一个目录项。\",\"image-20240303162213065\",\"至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引\"]},\"644\":{\"h\":\"9.4 InnoDB中的索引方案\"},\"645\":{\"h\":\"9.4.1 目录项记录的页\",\"t\":[\"上图中，每个目录项并没有关联起来，若是新增一个目录项或者删除一个目录项，想要重新维护是非常麻烦的。\",\"因此我们可以将多个目录项放到一个页中，并使用 类似 链表 的形式关联起来。如下图所示：\",\"image-20240303162601117\",\"从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 和普通的 用户记录的不同点：\",\"目录项记录的 record_type 值是1，而普通用户记录的 record_type 值是0。\",\"目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含 很多列，另外还有InnoDB自己添加的隐藏列。\",\"相同点:\",\"两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键 值进行查找时可以使用 二分法来加快查询速度。\"]},\"646\":{\"h\":\"9.4.2 多个目录项记录的页\",\"t\":[\"虽然说 目录项记录 中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有 16KB 大小，能存放的 目录项记录 也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，因此就需要在增加一个目录页\",\"image-20240303163423317\"]},\"647\":{\"h\":\"9.4.3 目录项记录页得目录页\",\"t\":[\"当目录页较多时，可以为目录页在抽取出一个目录页\",\"image-20240303163724778\"]},\"648\":{\"h\":\"9.4.4 B+Tree\",\"t\":[\"上面的图其实就是 B+Tree的数据结构，简化为：\",\"image-20240303164233160\",\"不论是存放用户记录 的数据页，还是存放 目录项记录 的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。\",\"从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为 叶子节点，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点，其中B+树最上边的那个节点也称为 根节点。\",\"树的高度越低，IO次数就越少，一般B+树的高度不会超过4层！！！\",\"假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么:\",\"如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。\",\"如果B+树有2层，最多能存放1000x100=10,0000条记录。\",\"如果B+树有3层，最多能存放1000x1000x100=1,0000,0000条记录\",\"如果B+树有4层，最多能存放1000x1800x1000x100=1000,0000,0000条记录\"]},\"649\":{\"h\":\"9.5 常见索引概念\",\"t\":[\"索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。\"]},\"650\":{\"h\":\"9.5.1 聚簇索引\",\"t\":[\"聚簇索引并不是一种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是 所谓的 索引即数据，数据即索引(索引的叶子节点包含实际的数据行，而不是指向数据行的指针)。\",\"特点\",\"使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： \",\"普通用户记录 按照主键的大小 排成一个单向链表\",\"各个存放 用户记录的页也是根据页中用户记录的主键大小顺序排成一个 双向链表。\",\"存放 目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表。\",\"B+树的 叶子节点存储的是完整的用户记录。 \",\"所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。\",\"优点\",\"数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快\",\"聚簇索引对于主键的 排序查找和 范围查找速度非常快\",\"按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的IO操作。\",\"缺点\",\"插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键\",\"更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新\",\"二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据\",\"限制\",\"对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。\",\"由于数据物理存储排序方式只能有一种，所以每个MySQL的 表只能有一个聚簇索引。一般情况下就是该表的主键。\",\"如果没有定义主键，Innodb会选择 非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。\",\"为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量 选用有序的顺序id ，而不建议用无序的id, 比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。\"]},\"651\":{\"h\":\"9.5.2 二级索引（辅助索引、非聚簇索引）\",\"t\":[\"二级索引就是除主键列之外的列创建的索引。假设以C2列作为二级索引，那么就需要以C2在创建一颗B+树：\",\"image-20240303171428003\",\"假设我们要执行这样一条SQL 语句：\",\"select * from xxx where c2 = ? \",\"首先通过C2的值定位到 叶子节点, 由于我们想要查询 所有列的值，包括C1、C2、C3, 而二级索引中只包含 C2 和 C1 的值，所以还需要拿着C1再去聚簇索引中查找。因此需要查询俩次B+树，这种情况就叫做 回表\",\"回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引中再查一遍，这个过程称为 回表。也就 是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！\",\"那么，为什么不将完整的用户记录都放到叶子节点中呢？\",\"如果将完整的用户记录都放到叶子结点中，确实不用回表，但是没创建一颗 B+树都要拷贝一份用户完整的记录，太浪费空间！\"]},\"652\":{\"h\":\"9.5.3 联合索引\",\"t\":[\"联合索引其实就是非聚簇索引的一种。\",\"同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照c2 和c3列 的大小进行排序，这个包含两层含义\",\"先把各个记录和页按照c2列进行排序。\",\"在记录的c2列相同的情况下，采用c3列进行排序\"]},\"653\":{\"h\":\"9.6 MyISAM索中的索引方案\",\"t\":[\"image-20240303174134511\",\"即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。(这里的B-Tree 其实就是B+ Tree)\",\"MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址。\"]},\"654\":{\"h\":\"9.6.1 MyISAM索引原理\",\"t\":[\"我们知道 InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了而 MyISAM 的索引方案虽然也使用树形结构，但是却 将索引和数据分开存储:\",\"image-20240303174517529\",\"将表中的记录 按照记录的插入顺序 单独存储在一个文件中，称之为 数据文件（MYD文件）。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并 没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。\",\"使用 MYISAM 存储引擎的表会把索引信息另外存储到一个称为 索引文件(MYI文件) 的另一个文件中。 MYISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 数据记录地址 的组合。\",\"image-20240303175258390\"]},\"655\":{\"h\":\"9.7 InnoDB引擎与MyISAM引擎对比\",\"t\":[\"InnoDB支持事物，而MyISAM不支持事物\",\"InnoDB支持MVCC, 而MyISAM不支持\",\"InnoDB支持外键，而MyISAM不支持\",\"InnoDB不支持全文索引，而MyISAM支持。\",\"InnoDB的索引方式为 \\\"聚簇索引\\\",表数据和索引都保存到一个表中, 而MyISAM是非聚簇索引！表数据和索引保存在俩个文件中！\",\"InnoDB支持行级锁，而MyISAM支持表级锁,因此在高并发的场景下建议使用 InnoDB，MyISAM适合适合用于非事务场景下，比如以读为主或者只读的应用！\",\"对比MyISAM的存储引擎， InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和 索引。\",\"MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 占用内存高，而且内存大小对性能有决定性的影响\",\"image-20240303153135717\"]},\"656\":{\"h\":\"9.8 索引的代价\",\"t\":[\"空间上的代价\",\"每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。\",\"时间上的代价\",\"每次对表中的数据进行 增、删、改操作时，都需要去修改各个B+树索引。\",\"B+树每 层节点都是按照索引列的值 从小到大的顺序排序而组成了 双向链表。。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位， 页面分裂、 页面回收等操作来维护好节点和记录的排序。\"]},\"657\":{\"h\":\"9.9 MySQL数据结构选择的合理性\",\"t\":[\"从MYSOL的角度讲，不得不考虑一个现实问题就是磁盘 IO。如果我们能让索引的数据结构尽量减少硬盘的 IO 操作，所消耗的时间也就越小。可以说，磁盘的I/0 操作次数 对索引的使用效率至关重要。\"]},\"658\":{\"h\":\"(1) HASH结构\",\"t\":[\"Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。\",\"Hash 算法是通过某种确定性的算法(比如 MD5、SHA1、SHA2、SHA3)将输入转变为输出。 相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。\",\"加速查找速度的数据结构，常见的有两类\",\"(1)树，Java例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是0(1og2N);\",\"(2)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是0(1);\",\"image-20240303220727904\",\"上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞，在数据库中一般采用 拉链法来解决。在拉链法中，将散列到同一槽位的元素放在一个链表中，如下图所示：\",\"image-20240303220848923\",\"Hash结构效率高，那为什么索引结构要设计成树型呢？\",\"原因1: Hash 索引仅能满足(=)(<>)和 IN 查询。如果进行范围査询 ，哈希型的索引，时间复杂度会退化为0(n);而树型的“有序”特性，依然能够保持0(log2N) 的高效率。\",\"原因2:Hash 索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。\",\"原因3:对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。\",\"原因4:对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低 。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。\",\"Hash索引使用存储引擎\",\"image-20240303221323044\"]},\"659\":{\"h\":\"(2) 二叉搜索树\",\"t\":[\"一个节点只能有两个子节点，也就是一个节点度不能超过2\",\"左子节点<本节点;右子节点>=本节点，比我大的向右，比我小的向左\",\"但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是(5,22,23,34,77,89,91)，创\",\"造出来的二分搜索树如下图所示:\",\"image-20240303221843260\"]},\"660\":{\"h\":\"(3) AVL\",\"t\":[\"为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:\",\"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\",\"这里说一下，常见的平衡二叉树有很多种，包括了 平衡二叉搜索树、 红黑树 、 数堆 、 伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是O(log2n)。\",\"image-20240303222055598\",\"每访问一次节点就需要进行一次磁盘 I/0 操作，对于上面的树来说，我们需要进行5次 I0 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 IO 操作次数多，会影响整体数据査询的效率。\",\"针对同样的数据，如果我们把二叉树改成 M 叉树（M>2）呢？当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储\",\"image-20240303222227748\"]},\"661\":{\"h\":\"(4) B-Tree\",\"t\":[\"8 树的英文是 Balance Tree，也就是 多路平衡査找树。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二又树的高度。\",\"B 树的结构如下图所示：\",\"image-20240303222538988\",\"image-20240303223129942\"]},\"662\":{\"h\":\"(5) B+ Tree\",\"t\":[\"B+ Tree 和 B-Tree 的差异\",\"image-20240303223348532\",\"B+ 树的中间结点不存储数据，这样有什么好处呢？\",\"1、B+树的查询效率更加稳定，因为数据都存储在叶子结点上，而B树的中间节点也有可能存储数据，这就导致可能放到叶子结点获取结果，也可能访问非叶子结点得到结果\",\"2、B+树的查询效率更高，这是因为B+树的中间结点不存储数据，因此同样的磁盘页大小，B+存储的数据就更多，树的高度就会越矮，需要的IO操作就越少！\",\"3、不仅是对单个关键字的查询上，在范围查询上，B+树的效率也比B树高，这是因为所有关键字都存储在叶子结点中，叶子结点之间有指针相互关联，数据又是递增的，因此范围查找可以通过指针连接查找\"]},\"663\":{\"c\":[\"数据库\"]},\"664\":{\"c\":[\"数据库\",\"MySQL\"]},\"665\":{\"h\":\"十、 InnoDB数据存储结构\"},\"666\":{\"h\":\"10.1 磁盘与内存交互的基本单位: 页\",\"t\":[\"InnoDB 将数据划分为若干个页，InnoDB中页的大小默认为 16KB\",\"以 页 作为磁盘和内存之间交豆的 基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库 I/0 操作的最小单位是页。一个页中可以存储多个行记录，\"]},\"667\":{\"h\":\"10.2 数据页的内部结构\",\"t\":[\"页如果按类型划分的话，常见的有数据页(保存 B+ 树节点)系统页、 Undo 页和 事务数据页 等。数据页是我们最常使用的页。\",\"数据页的 16KB大小的存储空间被划分为七个部分**，分别是文件头(File Header)、页头(Page Header)、最大页目录(Page最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、Directory)和文件尾(File Tailer)**。 页结构的示意图如下所示:\",\"image-20240309164149462\"]},\"668\":{\"h\":\"10.2.1\",\"t\":[\"描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）\",\"文件头内部组成：\",\"image-20240309164615169\",\"FIL_PAGE_OFFSET（4字节）\",\"每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。\",\"FIL_PAGE_TYPE（2字节）\",\"这个代表当前页的类型。\",\"image-20240309164803163\",\"FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）\",\"InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。\",\"image-20240309164857546\",\"FIL_PAGE_SPACE_OR_CHKSUM（4字节）\",\"代表当前页面的校验和（checksum）。\",\"什么是校验和？ 就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。\",\"在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。\",\"文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM\",\"作用 InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。\",\"为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。\",\"FIL_PAGE_LSN（8字节）\",\"页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）\"]},\"669\":{\"h\":\"10.2.2 文件尾\",\"t\":[\"前4个字节代表页的校验和：\",\"这个部分是和File Header中的校验和相对应的。\",\"后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：\",\"这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。\"]},\"670\":{\"h\":\"10.2.3 Free Space (空闲空间)\",\"t\":[\"我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。\",\"image-20240309170452315\"]},\"671\":{\"h\":\"10.2.4 User Records (用户记录)\",\"t\":[\"User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。\",\"**用户记录里的一条条数据如何记录？**详情看COMPACT行格式中的记录头信息\"]},\"672\":{\"h\":\"10.2.5 Infimum + Supremum（最小最大记录）\",\"t\":[\"记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。\",\"InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示\",\"image-20240309174017828\"]},\"673\":{\"h\":\"10.2.6 Page Directory（页目录）\",\"t\":[\"为什么需要页目录？\",\"在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。\"]},\"674\":{\"h\":\"10.2.7 Page Header（页面头部）\",\"t\":[\"为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。\",\"image-20240309175046593\"]},\"675\":{\"h\":\"10.3 InnoDB 行格式\",\"t\":[\"我们平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。InnoDB存储引擎设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。\",\"SELECT @@innodb_default_row_format; \"]},\"676\":{\"h\":\"10.3.1 指定行格式的语法\",\"t\":[\"-- 创建表格时指定 CREATE TABLE 表名 ( ) ROW_FORMAT=行格式名称; -- 创建表格后指定 ALTER TABLE 表名 ROW_FORMAT=行格式名称 -- 举例 CREATE TABLE record_test_table ( col1 VARCHAR(8), col2 VARCHAR(8) NOT NULL, col3 CHAR(8), col4 VARCHAR(8) ) CHARSET=ascii ROW_FORMAT=COMPACT; INSERT INTO record_test_table(col1, col2, col3, col4) VALUES ('zhangsan', 'lisi', 'wangwu', 'songhk'), ('tong', 'chen', NULL, NULL); \"]},\"677\":{\"h\":\"10.3.1 COMPACT行格式\",\"t\":[\"在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。\",\"image-20240309172255360\"]},\"678\":{\"h\":\"变长字段长度列表\",\"t\":[\"MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。\"]},\"679\":{\"h\":\"NULL值列表\",\"t\":[\"Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。\"]},\"680\":{\"h\":\"记录头像信息\",\"t\":[\"image-20240309172420461\",\"记录头信息中各个属性如下：\",\"image-20240309172436494\",\"简化后的行格式示意图：\",\"image-20240309172929988\",\"插入数据： INSERT INTO page_demo VALUES (1, 100, 'song'), (2, 200, 'tong'), (3, 300, 'zhan'), (4, 400, 'lisi'); \",\"示意图如下：\",\"image-20240309173013323\",\"delete_mask\",\"这个属性标记着当前记录是否被删除，占用1个二进制位。\",\"值为0：代表记录并没有被删除\",\"值为1：代表记录被删除掉了\",\"min_rec_mask\",\"B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。 我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。\",\"record_type\",\"这个属性表示当前记录的类型，一共有4种类型的记录： 0：表示普通记录 1：表示B+树非叶节点记录 2：表示最小记录 3：表示最大记录\",\"从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。至于record_type为1的情况，我们在索引的数据结构章节讲过。\",\"heap_no\",\"这个属性表示当前记录在本页中的位置。\",\"从图中可以看出来，我们插入的4条记录在本页中的位置分别是：2、3、4、5。\",\"怎么不见heap_no值为0和1的记录呢？\",\"MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。\",\"n_owned\",\"页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。\",\"next_record\",\"记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。 比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。\"]},\"681\":{\"h\":\"记录的真实数据\",\"t\":[\"记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：\",\"image-20240309174802116\",\"实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。\",\"一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。\",\"事务ID和回滚指针在后面的《第14章_MySQL事务日志》章节中讲解。\"]},\"682\":{\"c\":[\"数据库\"]},\"683\":{\"c\":[\"数据库\",\"MySQL\"]},\"684\":{\"h\":\"十一、索引的创建与设计原则\"},\"685\":{\"h\":\"11.1 索引的声明与使用\"},\"686\":{\"h\":\"11.1.1 索引的分类\",\"t\":[\"MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。\",\"从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。\",\"按照 物理实现 方式，索引可以分为 2 种：聚簇索引和非聚簇索引。\",\"按照 作用字段个数进行划分，分成单列索引和联合索引\",\"（1）普通索引\",\"在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 任何数据类型 中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。\",\"（2）唯一性索引\",\"使用 UNIQUE参数 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里 可以有多个 唯一索引。\",\"（3）主键索引\",\"主键索引就是一种 特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里 最多只有一个 主键索引。\",\"why? 这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。\",\"（4）单列索引\",\"在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索.还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以 有多个 单列索引,\",\"（5）多列(组合、联合)索引\",\"多列索引是在表的 多个字段组合 上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引 idx_id_name_gender ，只有在査询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循 最左前缀集合。\",\"（6）全文索引\",\"全文索引(也称全文检索)是目前 搜索引擎 使用的一种关键技术。它能够利用【分词技术 】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，\\\"它的用处比较小。\"]},\"687\":{\"h\":\"11.1.2 增加、删除索引\",\"t\":[\"MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句 CREATE IABLE 中指定索引列，使用ALTER TABLE语在存在的表上创建索引，或者使用 CREATE INDEX语句在已已存在的表上添加索引。\",\"CREATE TABLE dept( dept_id INT PRIMARY KEY AUTO_INCREMENT, dept_name VARCHAR(20) ); CREATE TABLE emp( emp_id INT PRIMARY KEY AUTO_INCREMENT, emp_name VARCHAR(20) UNIQUE, dept_id INT, CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) ); # 查看索引 SHOW INDEX FROM emp \",\"这种通过在字段上声明 主键约束、外键约束、唯一性约束 会字段创建出索引！！(隐式方式)\",\"显示的创建索引\",\"CREATE TABLE table_name [col_name data_type] （ -- 字段信息 [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC] ） \",\"UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引\",\"INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；\",\"index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；\",\"col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；\",\"length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；\",\"ASC 或 DESC 指定升序或者降序的索引值存储。\",\"创建表之后增加索引\",\"ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC] -- 或者 CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC] \",\"删除索引\",\"ALTER TABLE table_name DROP INDEX index_name; -- 或者 DROP INDEX index_name ON table_name \"]},\"688\":{\"h\":\"11.1.3 索引的设计原则\"},\"689\":{\"h\":\"（1）哪些情况适合创建索引\",\"t\":[\"1、字段的数值有唯一性的限制\",\"业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）\",\"说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\",\"2、频繁作为 WHERE 查询条件的字段\",\"3、经常 GROUP BY 和 ORDER BY 的列\",\"索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者 使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引。如果待排序的列有多 个，那么可以在这些列上建立 组合索引。\",\"4、 UPDATE、DELETE 的 WHERE 条件列\",\"5、DISTINCT 字段需要创建索引\",\"6、多表 JOIN 连接操作时，创建索引注意事项:\",\"首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。\",\"其次， 对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。\",\"最后， 对用于连接的字段创建索引，并且该字段在多张表中的 类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\",\"7、使用列的类型小的创建索引\",\"我们这里所说的 类型大小 指的就是该类型表示的数据范围的大小\",\"8、使用字符串前缀创建索引\",\"在使用varchar作为索引时，一定要指明长度！！\",\"9、区分度高(散列性高)的列适合作为索引\",\"列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。\",\"也就是说，\\\"在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中。\\\"这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好\",\"可以使用公式 select count(distinct a)/count(*)from t1'计算区分度，越接近1越好，一般超过 33% 就算是比较高效的索引了。\",\"10、使用最频繁的列放到联合索引的左侧\",\"11、在多个字段都要创建索引的情况下，联合索引优于单值索引\"]},\"690\":{\"h\":\"（2）哪些情况不适合创建索引\",\"t\":[\"1、 在where中使用不到的字段，不要设置索引\",\"2. 数据量小的表最好不要使用索引\",\"3、 有大量重复数据的列上不要建立索引\",\"在学生表的“ 性别”字段上只有“男”与“女”两个不同值，因此无须建立索引。 反而会严重降低数据更新速度:如果建立索引，不但不会提高查询效率\",\"4、避免对经常更新的表创建过多的索引\",\"第一层含义:频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。\",\"第二层含义:避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。\",\"5、不建议用无序的值作为索引\",\"例如：UUID、身份证号、无需长字符串。。。\",\"6、删除不再使用或者很少使用的索引\",\"7、不要定义冗余或重复的索引\"]},\"691\":{\"c\":[\"数据库\"]},\"692\":{\"c\":[\"数据库\",\"MySQL\"]},\"693\":{\"h\":\"十二、性能分析工具的使用\"},\"694\":{\"h\":\"12.1 数据库服务器的优化步骤\",\"t\":[\"当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。\",\"整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。\",\"image-20240309204147339\",\"image-20240309204157480\",\"image-20240309204229520\"]},\"695\":{\"h\":\"12.2 查看系统性能参数\",\"t\":[\"在MySQL中，可以使用SHOW STATUS语句查询一些MySQL数据库服务器的 性能参数、 SHOW STATUS语句语法如下\",\"SHOW [GLOBAL|SESSION] STATUS LIKE '参数' \",\"性能参数如下：\",\"image-20240309204534652\"]},\"696\":{\"h\":\"12.3 统计SQL的查询成本：last_query_cost\",\"t\":[\"如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：\",\"SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001; \",\"运行结果（1 条记录，运行时间为 0.042s ）\",\"然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：\",\"mysql> SHOW STATUS LIKE 'last_query_cost'; +-----------------+----------+ | Variable_name | Value | +-----------------+----------+ | Last_query_cost | 1.000000 | +-----------------+----------+ \",\"如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？\",\"SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100; \",\"运行结果（100 条记录，运行时间为 0.046s ）： 然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。\",\"mysql> SHOW STATUS LIKE 'last_query_cost'; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | Last_query_cost | 21.134453 | +-----------------+-----------+ \",\"你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间。\",\"使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。\"]},\"697\":{\"h\":\"12.4 定位执行慢的SQL：慢查询日志\",\"t\":[\"MySQL的慢查询日志，用来记录在MySQL中 响应时间超过阀值 的语句，具体指运行时间超过long_query_time 值的SQL，则会被记录到慢査询日志中。 long_query_time的默认值为10，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。\",\"默认情况下，MySQL数据库 没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。\"]},\"698\":{\"h\":\"12.4.1 开启/关闭/删除 慢查询日志\",\"t\":[\"查看慢查询日志是否开启\",\"SHOW VARIABLES LIKE '%slow_query_log%' \",\"开启慢查询日志\",\"set global slow_query_log='ON' \",\"查看慢查询的时间阈值设置，使用如下命令：\",\" show variables like '%long_query_time%' \",\"设置慢查询时间阈值\",\"set [global] long_query_time = 1; # 不加global只是当前窗口有效 \",\"关闭慢查询日志：\",\"永久关闭\",\"[mysqld] slow_query_log=OFF \",\"或者删掉slow_query_log=OFF\",\"临时性方式\",\"SET GLOBAL slow_query_log=off \",\"删除慢查询日志\",\"image-20240309213148974\",\"手动删除后，使用命令 mysqladmin flush-1ogs 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。\",\"mysqladmin -uroot -p flush-logs slow \"]},\"699\":{\"h\":\"12.4.2 慢查询日志分析工具：mysqldumpslow\",\"t\":[\"在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 mysqldumpslow \",\"查看mysqldumpslow帮助信息：\",\"mysqldumpslow --help \",\"image-20240309212058249\",\"-a: 不将数字抽象成N，字符串抽象成S\",\"-s: 是表示按照何种方式排序： \",\"c: 访问次数\",\"l: 锁定时间\",\"r: 返回记录\",\"t: 查询时间\",\"al:平均锁定时间\",\"ar:平均返回记录数\",\"at:平均查询时间 （默认方式）\",\"ac:平均查询次数\",\"-t: 即为返回前面多少条的数据；\",\"-g: 后边搭配一个正则匹配模式，大小写不敏感的；\",\"工作中常用的\",\"#得到查询时间最多的10个SQL mysqldumpslow -s t -t 10 /var/lib/mysql/atguigu-slow.log #得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log #得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log #得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \\\"left join\\\" /var/lib/mysql/atguigu-slow.log #另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more \"]},\"700\":{\"h\":\"\",\"t\":[\"定位了查询慢的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句。 。DESCRIBE 语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。\",\"能做什么？\",\"表的读取顺序\",\"数据读取操作的操作类型\",\"哪些索引可以使用\",\"哪些索引被实际使用\",\"表之间的引用\",\"每张表有多少行被优化器查询\",\"基本语法\",\"EXPLAIN SELECT select_options 或者 DESCRIBE SELECT select_options \",\"EXPLAIN 语句输出的各个列的作用如下\",\"image-20240310083958313\"]},\"701\":{\"h\":\"12.5.1 table\",\"t\":[\"不论我们的查询语句有多复杂，里边儿 包含了多少个表，到最后也是需要对每个表进行 单表访问的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。\",\"mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9895 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9895 | 100.00 | Using join buffer (hash join) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+ 2 rows in set, 1 warning (0.00 sec) \"]},\"702\":{\"h\":\"12.5.2 id\",\"t\":[\"查询语句中每出现一个 SELECT 关键字，MYSQL 就会为它分配一个唯一的ID\",\"mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2; \",\"image-20240310090045821\",\"当涉及多个SELECT时，id值为多个\",\"image-20240310090133802\",\"需要注意的是，并不是有多少个SELECT就会有多少ID，因此查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作\",\"image-20240310090245790\",\"在使用 UNION 表进行去重的时候，可能会涉及到临时表\",\"image-20240310090328759\",\"使用 UNION ALL 就无需使用临时表\",\"image-20240310090400721\",\"总结\",\"id值相同，可以认为是一组\",\"id值越大，优先级越高，越先执行\",\"关注点：id号每个号码，表示一趟独立的查询，一个sql查询的趟数越少越好\"]},\"703\":{\"h\":\"12.5.3 select_type\",\"t\":[\"一条大的查询语句里边可以包含若干个SELECT关键字，每个SELECT关键字代表着一个小的査询语句，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接査询)，每一张表都对应着执行计划输出中的一条记录 ，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。\",\"MySQL为每一个SELECT关键字代表的小査询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小査询的 select_type属性，就知道了这个 小査询在整个大査询中扮演了一个什么角色，我们看一下select_type都能取哪些值，请看官方文档:\",\"image-20240310090854664\",\"查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型\",\"image-20240310091146963\",\"连接查询也算是SIMPLE类型\",\"image-20240310091215725\",\"对于包含UNION或者UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY\",\"对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION\",\"其中 UNION RESULT 就是临时表！\",\"image-20240310091400898\",\"如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询。该子查询的第一个SELECT关键字代表的那个查询的select_type就是SUBQUERY\",\"image-20240310091643267\",\"如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY\",\"image-20240310091731883\",\"注意的是，select_type为DEPENDENT SUBQUERY的查询可能会被执行多次。\",\"在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION。\",\"image-20240310091919576\",\"对于包含派生表的查询，该派生表对应的子查询的select_type就是DERIVED\",\"image-20240310092030111\",\"#当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type属性就是MATERIALIZED\",\"image-20240310092129260\"]},\"704\":{\"h\":\"12.5.4 type△\",\"t\":[\"执行计划的一条记录就代表着MySQL对某个表的 执行査询时的访问方法，又称“访问类型”，其中的 type 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL 即将使用 ref访问方法来执行对 s1 表的查询。\",\"完整的访问方法如下: system ， const ， eq_ref ， ref ， index_merge ， unique_subquery ， fulltext ， ref_or_null ， index_subquery ,range,index,ALL\",\"system\",\"当表中 只有一条记录 并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访 问方法就是 system 。比方说我们新建一个 MyISAM 表，并为其插入1条记录\",\"例如：MyISAM表中只有一条记录，执行 count(*) 时type就是system\",\"MyISAM中维护一个计数器，记录表中的总记录数，使用 count(*) 直接返回\",\" CREATE TABLE t(i INT) ENGINE=MYISAM; INSERT INTO t VALUES(1); EXPLAIN SELECT * FROM t; \",\"image-20240310092716677\",\"cost\",\"当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const\",\" EXPLAIN SELECT * FROM s1 WHERE id = 10005; EXPLAIN SELECT * FROM s1 WHERE key2 = 10066; \",\"image-20240310092957534\",\"eq_ref\",\"在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的,（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref\",\" EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; \",\"image-20240310094837880\",\"ref\",\"当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref\",\"EXPLAIN SELECT * FROM s1 WHERE key1 = 'a'; \",\"image-20240310095023881\",\"ref_or_null\",\"当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null\",\" EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL; \",\"image-20240310095108269\",\"index_merge\",\"单表访问方法时在某些场景下可以使用Intersection、Union、Sort-Union这三种索引合并的方式来执行查询\",\"image-20240310102153604\",\"unique_subquery\",\"unique_subquery是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询 #转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type #列的值就是unique_subquery\",\" EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = 'a'; \",\"image-20240310095346237\",\"range\",\"如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法\",\" EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c'); \",\"image-20240310095527031\",\"index\",\"当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index\",\" EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a'; \",\"image-20240310095627040\",\"all\",\"全表扫描\",\"EXPLAIN SELECT * FROM s1 \",\"结果值从最好到最坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL \"]},\"705\":{\"h\":\"\",\"t\":[\"可能用到的索引 和 实际上使用的索引\",\"EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a'; \",\"image-20240310095915180\"]},\"706\":{\"h\":\"12.5.6 key_len ☆\",\"t\":[\"实际使用到的索引长度(即：字节数)\",\"帮你检查是否充分的利用上了索引，值越大越好,主要针对于联合索引，有一定的参考意义。\"]},\"707\":{\"h\":\"12.5.7 ref\",\"t\":[\"当使用索引列等值查询时，与索引列进行等值匹配的对象信息。比如只是一个常数或者是某个列。\",\" EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; \",\"image-20240310100526181\"]},\"708\":{\"h\":\"12.5.8 rows\",\"t\":[\"预估的需要读取的记录条数值越小越好\",\" EXPLAIN SELECT * FROM s1 WHERE key1 > 'z'; \",\"image-20240310100628691\"]},\"709\":{\"h\":\"12.5.9 filtered\",\"t\":[\"某个表经过搜索条件过滤后剩余记录条数的百分比\",\" #对于单表查询来说，这个filtered列的值没什么意义，我们`更关注在连接查询 #中驱动表对应的执行计划记录的filtered值`，它决定了被驱动表要执行的次数(即：rows * filtered) EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a'; \",\"image-20240310100857719\"]},\"710\":{\"h\":\"12.5.10 Extra ☆\",\"t\":[\"一些额外的信息.更准确的理解MySQL到底将如何执行给定的查询语句\",\" #当查询语句的没有`FROM`子句时将会提示该额外信息 EXPLAIN SELECT 1; #查询语句的`WHERE`子句永远为`FALSE`时将会提示该额外信息 EXPLAIN SELECT * FROM s1 WHERE 1 != 1; #当我们使用全表扫描来执行对某个表的查询，并且该语句的`WHERE` #子句中有针对该表的搜索条件时，在`Extra`列中会提示上述额外信息。 EXPLAIN SELECT * FROM s1 WHERE common_field = 'a'; #当使用索引访问来执行对某个表的查询，并且该语句的`WHERE`子句中 #有除了该索引包含的列之外的其他搜索条件时，在`Extra`列中也会提示上述额外信息。 EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a'; #当查询列表处有`MIN`或者`MAX`聚合函数，但是并没有符合`WHERE`子句中 #的搜索条件的记录时，将会提示该额外信息 EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg'; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'NlPros'; #NlPros 是 s1表中key1字段真实存在的数据 #当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以 #使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只 #需要用到`idx_key1`而不需要回表操作： EXPLAIN SELECT key1,id FROM s1 WHERE key1 = 'a'; #有些搜索条件中虽然出现了索引列，但却不能使用到索引 #看课件理解索引条件下推 EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a'; #在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为 #其分配一块名叫`join buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法` #见课件说明 EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field; #当我们使用左（外）连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件， #而且那个列又是不允许存储`NULL`值的，那么在该表的执行计划的Extra列就会提示`Not exists`额外信息 EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL; #如果执行计划的`Extra`列出现了`Using intersect(...)`提示，说明准备使用`Intersect`索引 #合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称； #如果出现了`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询； #出现了`Using sort_union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。 EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a'; #当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息 EXPLAIN SELECT * FROM s1 LIMIT 0; #有一些情况下对结果集中的记录进行排序是可以使用到索引的。 #比如： EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10; #很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候） #进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`）。 #如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的`Extra`列中显示`Using filesort`提示 EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10; #在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们 #在执行许多包含`DISTINCT`、`GROUP BY`、`UNION`等子句的查询过程中，如果不能有效利用索引来完成 #查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行 #计划的`Extra`列将会显示`Using temporary`提示 EXPLAIN SELECT DISTINCT common_field FROM s1; #EXPLAIN SELECT DISTINCT key1 FROM s1; #同上。 EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field; #执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以 #我们`最好能使用索引来替代掉使用临时表`。比如：扫描指定的索引idx_key1即可 EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1; \"]},\"711\":{\"c\":[\"数据库\"]},\"712\":{\"c\":[\"数据库\",\"MySQL\"]},\"713\":{\"h\":\"十三、索引优化与查询优化\"},\"714\":{\"h\":\"13.1 索引失效的11种情况\"},\"715\":{\"h\":\"1、全值匹配\",\"t\":[\"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId = 4; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId = 4 AND name = 'abcd'; \",\"分别创建三条索引：\",\"CREATE INDEX idx_age ON student(age); CREATE INDEX idx_age_classid ON student(age,classId); CREATE INDEX idx_age_classid_name ON student(age,classId,NAME); \",\"然后执行上面的三条SQL，当执行到最后一个SQL时可以发现，使用的是 idx_age_classid_name 索引\",\"image-20240310105838510\"]},\"716\":{\"h\":\"2、最佳左前缀法则\",\"t\":[\"索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引\",\"# 由于索引没有以 classId 开头的，因此没有索引可以使用 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE classId = 4 AND name = 'abcd'; \"]},\"717\":{\"h\":\"3、计算、函数、类型转换导致索引失效\",\"t\":[\"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name = 'abc%'; # 无法使用索引，相较于上一条效率低 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(name,3) = 'abc'; \",\"image-20240310110623960\",\"类型转换\",\"由于 name 是 varchar类型，会自动进行类型转换\",\"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name = 123; \",\"image-20240310111121929\"]},\"718\":{\"h\":\"4、范围条件右边的列索引失效\",\"t\":[\" # 创建联合索引 create index idx_age_name_classid on student(age,classid,name); # 执行以下SQL语句 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student.name = 'abc' ; \",\"这种情况由于在查询时，classId是范围查询，因此name就无法使用索引。\",\" 因此在我们创建索引，考虑先将 等值 查询的列放在左边，修改索引：\",\" create index idx_age_name_classid on student(age,name,classId); \",\"再去执行SQL语句。发现name已经使用了索引\",\"image-20240310151442469\"]},\"719\":{\"h\":\"5、不等于(!= 或者<>)索引失效\",\"t\":[\" EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age !=30 ; \",\"image-20240310151827814\",\"如果不使用 * 使用具体的索引列 + 主键 索引则不会失效：\",\" EXPLAIN SELECT SQL_NO_CACHE age,classid FROM student WHERE student.age !=30 ; \",\"image-20240310164656309\",\"这是因为 使用覆盖索引，无需进行回表，那么MYSQL优化器就会认为 使用索引比不适用索引效率要高！\"]},\"720\":{\"h\":\"6、isNULL 可使用索引，IS NOT NULL无法使用\",\"t\":[\" EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age IS NULL ; \",\"image-20240310151935806\",\" EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age IS NOT NULL ; \",\"image-20240310152010416\"]},\"721\":{\"h\":\"7、like以通配符%开头索引失\",\"t\":[\" EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age LIKE '%a'; \",\"image-20240310164838342\",\"和 != 、<> 一样，如果指定列为索引的列则不会失效：\",\" EXPLAIN SELECT SQL_NO_CACHE age FROM student WHERE student.age LIKE '%a'; \",\"image-20240310164918993\"]},\"722\":{\"h\":\"8、OR 前后存在非索引的列，索引失效\"},\"723\":{\"h\":\"13.2 关联查询的优化\"},\"724\":{\"h\":\"13.3 子查询优化\",\"t\":[\"子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因:\",\"① 执行子査询时，MySQL需要为内层查询语句的査询结果 建立一个临时表，然后外层査询语句从临时表中查询记录。查询完毕后，再 撤销这些临时表。这样会消耗过多的CPU和I0资源，产生大量的慢查询。\",\"② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引，所以查询性能会受到一定的影响。\",\"在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询 不需要建立临时表，其 要快，如果查询中使用索引的话，性能就会更好。\"]},\"725\":{\"h\":\"13.4 排序优化\",\"t\":[\"问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？\",\"在 MySQL中，支持两种排序方式，分别是 FileSort 和 Index 排序。\",\"Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。\",\"Filesort 排序则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 IO 到磁盘进行排序的情况，效率较低。\",\"优化建议：\",\"SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 描，在 ORDER BY 子句 避免全表扫 避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\",\"尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。\",\"无法使用 Index 时，需要对 FileSort 方式进行调优。\",\"INDEX a_b_c(a,b,c) ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */ WHERE g = const ORDER BY b,c /*丢失a索引*/ WHERE a = const ORDER BY c /*丢失b索引*/ WHERE a = const ORDER BY a,d /*d不是索引的一部分*/ WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/ \",\"FileSort 算法\",\"双路排序 （慢） \",\"MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取 对应的数据输出\",\"从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段\",\"取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。\",\"单路排序 （快） \",\"从磁盘读取查询需要的 所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输 出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空 间， 因为它把每一行都保存在内存中了\"]},\"726\":{\"h\":\"13.5 GROUP BY 和 分页优化\",\"t\":[\"GROUP BY\",\"group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接 使用索引。\",\"group by 先排序再分组，遵照索引建的最佳左前缀法则\",\"where效率高于having，能写在where限定的条件就不要写在having中了\",\"减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。\",\"包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢\",\"分页优化一\",\"般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 imit 2000000,10此时需要MySQL排序前2000010 记录，仅仅返回2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大\",\"EXPLAIN SELECT * FROM student LIMIT 2000000, 10; \",\"优化方案一：\",\"在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容\",\"EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) WHERE t.id = a.id; \",\"优化方案二：\",\"该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。\",\"EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10; \"]},\"727\":{\"h\":\"13.6 优先考虑覆盖索引\",\"t\":[\"什么是覆盖索引？\",\"一个索引包含了满足查询结果的数据就叫做覆盖索引。简单来说，就是 索引列名称 + 主键 就是你 SELECT 时的列名。\",\"普通索引创建的B+树只包含当前索引的列和主键，假如只SELECT 这俩个列 不用回表，这就是覆盖索引！\",\"好处\",\"避免Innodb表进行索引的二次查询（回表）\",\"可以把随机IO变成顺序IO加快查询效率\",\"弊端\",\"索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。\"]},\"728\":{\"h\":\"13.7 索引下推\",\"t\":[\"Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优 化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。\",\" INDEX (age,classId,name) EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId != 20 \",\"以上面的SQL为例，由于 classId 使用 != 号因为它无法使用索引\",\"假设没有ICP\",\"首先从二级索引中筛选出 age = 30 的记录，然后拿着筛选出的记录的主键去 聚簇 索引中找到记录，也就是回表操作，然后在将这些记录进行二次筛选。\",\"操作步骤: 第一次筛选 ---- 回表 ---- 第二次筛选\",\"使用ICP\",\"但实际上在MYSQL中并不是这么操作的，假设第一次筛选出 10万条数据，然后拿着这10万条数据进行回表，最后假设就筛选出 1万条数据，那么就浪费了很多的CPU资源，影响效率。\",\"在MYSQL中，它会在回表前就会过滤掉所有不满足条件的行，也就是先筛选出 age=30、classId != 20 的数据，最后在进行回表！ 这样就大大减少了回表操作。提高了效率！\",\"**操作步骤: 第一次筛选 ---- 第二次筛选 ---- 回表 **\",\"需要注意的是，条件下推的列必须是索引中包含的列！\",\"ICP使用条件\",\"只能用于二级索引(secondary index)\",\"explain显示的执行计划中type值（join 类型）为 range 、 ref 、 eq_ref 或者 ref_or_null 。\",\"并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录 到server端做where过滤\",\"当SQL使用覆盖索引时，不支持ICP优化方法\",\"ICP可以用于MyISAM和InnnoDB存储引擎\"]},\"729\":{\"h\":\"13.8 其他优化策略\",\"t\":[\"1、 EXISTS 和 IN 的区分\",\"选择与否，主要看表的大小，可以理解为选择的标准就是 小表驱动大表\",\"# A表大，B表小 SELECT * FROM A WHERE CC IN(SELECT CC FROM B) # A表小，B表大 SELECT * FROM A WHERE EXISTS(SELECT CC FROM B WHERE B.CC=A.CC) \",\"2、COUNT(*) 和 COUNT(1) 和 COUNT(具体的字段)哪个效率更高？\",\"三者的效率差不多。\",\"在不同的存储引擎中，COUNT的时间复杂度可能会不同，由于在 MyISAM 中维护了一个计数器，可直接将计数器的值返回，因此时间复杂度为 O(1), 而在 InnoDB 中则需要循环+计数，因此复杂度为 O(n)\",\"**3、关于SELECT ***\",\"在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT<字段列表>查询。\",\"原因\",\"① MySQL 在解析的过程中，会通过 査询数据字典 将\\\"*\\\"按序转换成所有列名，这会大大的耗费资源和时间\",\"② 无法使用 覆盖索引\",\"4、 LIMIT 1 对优化的影响\",\"针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 到一条结果的时候就不会继续扫描了，这样会加快查询速度\",\"如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加 上 LIMIT 1\"]},\"730\":{\"h\":\"13.9 主键的设计\"},\"731\":{\"h\":\"13.9.1 自增Id的问题\",\"t\":[\"自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单其他都是缺点，总体来看存在以下几方面的问题:\",\"可靠性不高 存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。\",\"全性不高 对外暴露的接口可以非常容易猜测对应的信息。比如:/ser/1/这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。\",\"性能差 自增ID的性能较差，需要在数据库服务器端生成。\",\"交互多 业务还需要额外执行一次类似 1ast_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交亘。在海量并发的系统中，多1条SQL，就多一次性能上的开销。\",\"局部唯一性\",\"最重要的一点，自增ID是局部唯一的，只在当前数据库实例中唯一，而不是全局唯一，在分布式系统中，无疑是 噩梦\"]},\"732\":{\"h\":\"13.9.2 业务字段做主键\",\"t\":[\"image-20240320230855090\",\"像上面这种 会员信息表 假设我用卡号作为主键，看似很合理，但是卡号可能会出现注销，易主的问题，产生数据的混乱。\",\"比如： 100000001 是张三使用，现在转移给了王五，那么之前张三购买的东西，现在到了王五的名下。显然是不合理的。\",\"所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。\"]},\"733\":{\"h\":\"13.9.3 推荐的主键设计\",\"t\":[\"非核心业务：对应表的主键自增ID，如警告、日志、监控等信息\",\"核心业务： 至少保证全局唯一性且单调递增，单调递增主要是希望插入时不要影响数据库性能。\",\"在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。 另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。\"]},\"734\":{\"c\":[\"数据库\"]},\"735\":{\"c\":[\"数据库\",\"MySQL\"]},\"736\":{\"h\":\"十四、数据库的设计规范\",\"t\":[\"在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。\",\"目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美 范式）\",\"image-20240319232051189\",\"键和相关属性的概念\",\"范式的定义会使用到主键和候选键，数据库中的键(Key)由一个或者多个属性组成。数据表中常用的几种键和\",\"属性的定义：\",\"超键:能唯一标识元组的属性集叫做超键。\",\"候选键:如果超键不包括多余的属性，那么这个超键就是候选键。\",\"主键:用户可以从候选键中选择一个作为主键。\",\"外键: 如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。\",\"主属性:包含在任一候选键中的属性称为主属性,\",\"非主属性:与主属性相对，指的是不包含在任何一个候选键中的属性。\",\"例如，有俩个表：\",\"球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号\",\"球队表(team) ：球队编号 | 主教练 | 球队所在地\",\"其中球员编号 + 任一字段 都是超键， 单个的球员编号、身份证号 可以唯一标识一条数据，这俩个就是候选键\"]},\"737\":{\"h\":\"14.1 数据库范式\",\"t\":[\"第一范式\",\"第一范式主要是确保数据表中每个家段的值必须具有 原子性，也就是说数据表中每个字段的值为 不可再次拆分 的最小数据单元。\",\"第二范式\",\"第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。如果知道主键的所有属性的值，就可以检索到任(要求中的主键，其实可以拓展替换为候选键)。何元组(行)的任何属性的任何值。\",\"举例\",\"比赛表 player_game，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这 里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：\",\"(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分) \",\"这种就不符合第二范式，由于姓名、年龄只依赖于球员编号，比赛时间、比赛场地只依赖于比赛编号，并没有完全依赖于主键。\",\"对于非主属性来说，并非完全依赖于主键，会造成什么问题呢？\",\"数据冗余：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。\",\"插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没 法插入\",\"删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉。\",\"更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。\",\"为了避免以上这种情况，应该设计成三张表：\",\"image-20240319234219202\",\"第一范式是确定字段是原子性的，而第二范式则确定每一张表都是独立的！\",\"第三范式\",\"第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，其他非主键字段不依赖于其他非主键字段！\",\"举例\",\"部门信息表：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。\",\"员工信息表：每个员工有员工编号、姓名、部门编号、部门名称。\",\"如果在员工信息表中在增加 部门名称 字段，此时就不符合第三范式，因为 部门名称依赖于部门编号，部门编号依赖于员工编号（部门名称 --》部门编号 --》员工编号）\",\"BCNF(Bovce Codd Normal Form 巴克斯范式)\",\"属于修正的第三范式，是防止主键的某一列会依赖于主键的其他列。当3NF消除了主属性对码的部分函数依赖和传递函数依赖称为BCNF。\",\"举例：库存表(仓库名，管理员名，商品名，数量)，主键为(仓库名，管理员名，商品名)，这是满足前面三个范式的，但是仓库名和管理员名之间存在依赖关系，因此删除某一个仓库，会导致管理员也被删除，这样就不满足BCNF。\",\"​\"]},\"738\":{\"c\":[\"数据库\"]},\"739\":{\"c\":[\"数据库\",\"MySQL\"]},\"740\":{\"h\":\"十五、事务\"},\"741\":{\"h\":\"15.1 事务概述\",\"t\":[\"通过 show engines 可以查看支持事务的执行引擎\",\"image-20240323170524930\",\"事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态，要么都执行，要么都不执行\",\"ACID四个特性\",\"原子性（atomicity）： 原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。\",\"一致性（consistency）：\",\"一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态。这种状态 是语义上的而不是语法上的，跟具体的业务有关。\",\"举例1: A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须>=0。\",\"举例2: A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。\",\"隔离性\",\"事务的隔离性是指一个事务的执行 不能被其他事务干扰，即一个事务内部的操作及使用的数据对 并发的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰\",\"持久性\",\"持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的，接下来的其他操作和数据库 故障不应该对其有任何影响。\"]},\"742\":{\"h\":\"15.3 事务的状态\",\"t\":[\"我们现在知道 事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 事务大致划分成几个状态：\",\"活动的（active）\",\"事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活跃的 状态\",\"部分提交的（partially committed）\",\"当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘 时，我们就说该事务处在 部分提交的状态。\",\"失败的（failed）\",\"当事务处在 活动的或者 没有刷新到磁盘 部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的状态。\",\"中止的（aborted）\",\"如果事务执行了一部分而变为 失败的状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称 之为回滚。回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了中止的（aborted）\",\"提交的（committed）\",\"当一个处在 部分提交的状态的事务将修改过的数据都处 在了提交的状态。\",\"image-20240323172453754\"]},\"743\":{\"h\":\"15.4 如何使用事务\"},\"744\":{\"h\":\"15.4.1 显示事务\",\"t\":[\"mysql> BEGIN; #或者 mysql> START TRANSACTION; \",\"START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符：\",\"① READ ONLY：标识当前事务是一个 只读事务 。也就是属于该事务的数据库操作只能读取数据，而不能修改数据\",\"② READ WRITE标识当前事务是一个 读写事务，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据\",\"③ WITH CONSISTENT SNAPSHOT ：启动一致性读。\",\"如果不指明，默认是 读写事务\"]},\"745\":{\"h\":\"15.4.2 隐式事务\",\"t\":[\"# 使用下面语句查看自动提交是否关闭 SHOW VARIABLES LIKE 'autocommit' +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0.01 sec) \",\"当然，如果我们想关闭这种 自动提交的功能，可以使用下边两种方法之一\",\"显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回 滚前会暂时关闭掉自动提交的功能。\",\"把系统变量 autocommit 的值设置为 OFF ，就像这样：\",\" SET autocommit = OFF; \"]},\"746\":{\"h\":\"15.5 事务的隔离级别\",\"t\":[\"数据并发的问题：\",\"1、脏写（ Dirty Write ）\",\"如果事务Session A 修改了另一个 未提交事务 Session B 修改过的数据，那就意味着发生了 脏写\",\"2、脏读（ Dirty Read ）\",\"Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若是SessionB回滚， Session A 读取的内容就是 临时且无效的。\",\"3、不可重复读（ Non Repeatable Read ）\",\"Session A 读取了一个字段，然后 Session B 更新了该字段。之后， Session A 再次读取同一个字段， 值就不同了。那就意味着发生了不可重复读。\",\"4、幻读（ Phantom ）\",\"Session A 从一个表中读取了一个字段, 然后 Session B 在该表中 插入入了一些新的行。 之后, 如果 Session A 再次读取 同一个表就会多出来几行，这种现象称为幻读，多出来的记录称为: 幻影记录\",\"上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：\",\"脏写 > 脏读 > 不可重复读 > 幻读 \",\"隔离级别越低，并 发问题发生的就越多。 SQL标准 中设立了4个 隔离级别：\",\"READ UNCOMMITTED 读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。\",\"**READ COMMITTED **读已提交，一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。\",\"**REPEATABLE READ **可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。\",\"SERIALIZABLE：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读\",\"SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：\",\"image-20240323180805461\",\"查看数据库默认的隔离级别\",\"SHOW VARIABLES LIKE 'transaction_isolation'; 或者 SELECT @@transaction_isolation; \",\"设置隔离级别\",\"SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; #其中，隔离级别格式： > READ UNCOMMITTED > READ COMMITTED > REPEATABLE READ > SERIALIZABLE 或者 SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = '隔离级别' #其中，隔离级别格式： > READ-UNCOMMITTED > READ-COMMITTED > REPEATABLE-READ > SERIALIZABLE \",\"关于设置时使用GLOBAL或SESSION的影响：\",\"使用G LOBAL 关键字（在全局范围影响）： \",\"当前已经存在的会话无效\",\"只对执行完该语句之后产生的会话起作用\",\"使用S ESSION 关键字（在会话范围影响）： \",\"对当前会话的所有后续的事务有效\",\"如果在事务之间执行，则对后续的事务有效\",\"该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\"]},\"747\":{\"h\":\"15.6 事务日志\",\"t\":[\"事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？\",\"事务的隔离性由 锁机制实现。\",\"而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。\",\"REDO LOG 称为 重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。\",\"UNDO LOG 称为 回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。\",\"REDO 和 UNDO 日志都被视作一种恢复操作，UNDO 很好理解，回滚之后进行恢复。而 REDO日志是如何恢复呢？\",\"首先要知道在修改数据时，会先从磁盘读取数据保存到内存中，修改的数据是内存中的数据，事后还需要刷新回磁盘，但是假设在刷新的过程中出现了宕机等异常，导致没有刷新成功，那么就会记录在 REDO 日志中，当服务器重启时，会从REDO日志中读取数据刷新到磁盘中。\"]},\"748\":{\"h\":\"15.6.1 redo 日志\"},\"749\":{\"h\":\"（1）为什么需要 redo 日志呢？\",\"t\":[\"一方面，MySQL采用checkpoint机制保证数据最终会被刷新到磁盘上，但是由于 checkpoint 是定期刷新, 所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。\",\"另一方面，事务包含 持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩 溃，这个事务对数据库中所做的更改也不能丢失。\",\"那么如何保证持久性呢，最暴力的一个办法就是 实时更新，我只要更改内存中的数据我就刷新回磁盘, 但通常来说暴力方法都是不可取的，有俩个问题：\",\"修正量与刷新磁盘工作量严重不符\",\"磁盘与内存交互的基本单位是页，默认的页大小为 16KB，假设你只修改 1b 的数据，那么也要将这 16KB的数据刷新回磁盘\",\"随机IO刷新慢\",\"一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Bufer Pool中的页面 刷新到磁盘 时，需要进行很多的 随机I0，随机I0比顺序I0要慢，尤其对于传统的机械硬盘来说\",\"另一个解决方案就是 REDO 日志, 不用把整个页的数据都刷新回磁盘，只需要记录一下被修改数据的偏移量即可。比如：，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成2。\"]},\"750\":{\"h\":\"（2）好处、特点\",\"t\":[\"好处\",\"redo日志降低了刷盘频率\",\"redo日志占用的空间非常小\",\"特点\",\"redo日志是顺序写入磁盘的\",\"事务执行过程中，redo log不断记录\"]},\"751\":{\"h\":\"（3）redo组成\",\"t\":[\"Redo log可以简单分为以下两个部分：\",\"重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。\",\"重做日志文件 (redo log file) ，保存在硬盘中，是持久的。\",\"redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M\",\"mysql> show variables like '%innodb_log_buffer_size%'; +------------------------+----------+ | Variable_name | Value | +------------------------+----------+ | innodb_log_buffer_size | 16777216 | +------------------------+----------+ \"]},\"752\":{\"h\":\"（4）redo整体流程\",\"t\":[\"image-20240325222116848\",\"第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式 第4步：定期将内存中修改的数据刷新到磁盘中 \"]},\"753\":{\"h\":\"（5）redo 刷盘策略\",\"t\":[\"redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一定的频率刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。\",\"image-20240325222800349\",\"注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存 （page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系 统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。\",\"针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：\",\"设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）\",\"设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值）\",\"设置为2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。\",\"另外，InnoDB存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存(page cache)，然后调用刷盘操作。\",\"image-20240325223116404\"]},\"754\":{\"h\":\"15.6.2 undo 日志\",\"t\":[\"redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据的 前置操作其实是要 先写入一个 undo log 。\"]},\"755\":{\"h\":\"（1）如何理解undo日志\",\"t\":[\"事务需要保证 原子性，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半 会出现一些情况，比如：\",\"情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误， 操作系统错误，甚至是突然断电导致的错误。\",\"情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。\",\"以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 回滚，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 原子性要求。\",\"每当我们要对一条记录做改动(这里的 改动 可以指 INSERT、DELETE、UPDATE)，时。都需要“留一手\\\"-- 把回滚时所需的东西记下来,比如:\",\"·你插入一条记录 时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的 记录删掉 就好了。(对于每个INSERT，InnoDB存储引擎会完成一个DELETE)\",\"你删除了一条记录 ，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 插入到表中就好了。(对于每个DELETE，InnoDB存储引擎会执行一个INSERT)\",\"你 修改了一条记录 ，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录 更新为旧值 就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)\",\"此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。\"]},\"756\":{\"h\":\"（2）undo日志的作用\",\"t\":[\"作用1：回滚数据\",\"作用2：MVCC\",\"undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。\"]},\"757\":{\"h\":\"（3）undo 日志生命周期\",\"t\":[\"以下是undo+redo事务的简化过程假设有2个数值，分别为A=1和B=2，然后将A修改为3，B修改为4\",\"1.start transaction; 2.记录 A=1 到undo log; 3.update A= 3; 4.记录 A=3 到redo log; 5.记录 B=2 到undo log; 6.update B= 4; 7.记录B=4 到redo log: 8.将redo log刷新到磁盘 9.commit \",\"在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁上的数据做任何影响。\",\"如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化,\",\"若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。\",\"image-20240325230912020\"]},\"758\":{\"c\":[\"数据库\"]},\"759\":{\"c\":[\"数据库\",\"MySQL\"]},\"760\":{\"h\":\"十六、锁\",\"t\":[\"在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 并发操作进行控制，因此产生了锁。同时 锁机制也为实现MySQL 的各个隔离级别提供了保证。 锁冲突也是影响数据库 并发访问性能的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。\"]},\"761\":{\"h\":\"16.1 并发事务访问相同的记录\"},\"762\":{\"h\":\"16.1.1 读读的情况\",\"t\":[\"读-读 情况，即并发事务相继 读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。\"]},\"763\":{\"h\":\"16.1.2 写写的情况\",\"t\":[\"写-写 情况，即并发事务相继对相同的记录做出改动\",\"在这种情况下会发生 脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行，这个排队的过程其实是通过锁来实现的。\",\"这个所谓 的锁其实是一个 内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构,当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联：\",\"image-20240326221608906\",\"在 锁结构 里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来\",\"trx信息:代表这个锁结构是哪个事务生成的。\",\"is_waiting:代表当前事务是否在等待。\",\"当 事务T1 获取锁之后，会将 is_waiting 改为 false , 表示获取锁成功。此时若是 事务T2 也想对这条记录进行改动，但是此时 T1 在占着锁，因此会将 is_waiting 改为 true，表示获取锁失败\",\"image-20240326221907548\",\"不加锁\",\"意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。\",\"获取锁成功，或者加锁成功\",\"意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作。\",\"获取锁失败，或者加锁失败，或者没有获取到锁\",\"意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作。\"]},\"764\":{\"h\":\"16.1.3 读写或写读的情况\",\"t\":[\"读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。\",\"各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题。\"]},\"765\":{\"h\":\"16.1.4 并发问题的解决方案\",\"t\":[\"怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：\",\"方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。\",\"方案二：读、写操作都采用 加锁 的方式。\",\"所谓的 MVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本(历史版本由undo日志 构建)。查询语句只能读 到在生成Readview之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。\",\"普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。\",\"在 READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就是避免了脏读现象；\",\"在 REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。\",\"像读写都加锁的方式，显然效率比较低，除非一些特殊场景，比如银行存钱， 首先要从数据库读取金额，此时加锁，在更改完之前不允许别的事务进行操作。而大部分采用第一种方案效率会更高！\"]},\"766\":{\"h\":\"16.2 锁的不同角度的分类\",\"t\":[\"image-20240326223411829\"]},\"767\":{\"h\":\"16.2.1 读锁、写锁\",\"t\":[\"读锁 ：也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。\",\"写锁 ：也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。\",\"需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。\",\"读操作可以加读锁，也可以加写锁，但是写操作只能加写锁\",\"为读操作增加读锁\",\"SELECT LOCK IN SHARE MODE ; #或 SELECT FOR SHARE;#(8.0新增语法) \",\"为读操作增加写锁\",\"SELECT FOR UPDATE \",\"演示为读操作增加写锁被阻塞：\",\"1、首先启动俩个客户端C1，C2\",\"2、在C1中开始事务并为读操作增加 写锁\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from regions for update; +-----------+------------------------+ | region_id | region_name | +-----------+------------------------+ | 1 | Europe | | 2 | Americas | | 3 | Asia | | 4 | Middle East and Africa | +-----------+------------------------+ 4 rows in set (0.00 sec) \",\"3、可以看到C1读取成功，此时由于没有提交事务。C2也执行读操作访问相同记录，并且增加写锁，此时就可以看到C2被阻塞\",\"image-20240326225709207\"]},\"768\":{\"h\":\"16.2.2 表级锁、页锁、行级锁\",\"t\":[\"为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很 耗资源 的事情(涉及获取、检査、释放锁等动作)。因此数据库系统需要在 高并发响应和 系统性能 两方面进行平衡，这样就产生了“锁粒度(Lock granularity)”的概念。\"]},\"769\":{\"h\":\"（1）表级锁\"},\"770\":{\"h\":\"① 表级别的S锁、X锁\",\"t\":[\"由于 InnoDB 引擎中提供了 锁粒度 更细的行级锁 ，因此在 InnoDB中执行SELECT、INSERT、DELETE\",\"UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁的.\",\"但是在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。这个过程其实是通过在 server层 使用一种称之为 元数据锁 （英文名： Metadata Locks ，简称 MDL ）结构来实现的。\",\"设置S、X锁\",\"LOCK TABLES t READ ：InnoDB存储引擎会对表 t 加表级别的 S锁 。 LOCK TABLES t WRITE ：InnoDB存储引擎会对表 t 加表级别的 X锁 。 unlock tables; 释放锁 \",\"针对表级锁的操作情况\",\"image-20240326231544244\"]},\"771\":{\"h\":\"① 意向锁\",\"t\":[\"InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁与 表级锁 共存，而意向锁就是其中的一种 表锁 。\",\"作用\",\"假设有俩个事务 T1、T2，其中T2试图增加表级锁，如果没有意向锁的存在，那么T2就需要去检查每行或者每页是否存在锁，如果数据比较多，这无疑是浪费时间的。如果存在意向锁，那么此时T2就会被阻塞，避免了不要的检查！\",\"特点\",\"1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存。\",\"2、意向锁是一种 不与行级锁冲突表级锁，这一点非常重要。\",\"3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”\",\"在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了\",\"意向锁分为俩种：\",\"意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）\",\"-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE; \",\"意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）\",\"-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE; \",\"即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。\",\"意向锁是兼容的，但是他会与普通的 共享锁/排它锁互斥：\",\"image-20240326233627730\",\"演示意向锁质检互相兼容的情况：\",\"1、启动俩个客户端C1、C2\",\"2、C1中开启事务，对其中一条数据设置X锁，此时InnoDB自动生成了一个IX\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from regions where region_id = 4 for update; +-----------+------------------------+ | region_id | region_name | +-----------+------------------------+ | 4 | Middle East and Africa | +-----------+------------------------+ 1 row in set (6.34 sec) mysql> \",\"3、在C2中开启事务，对另外一条数据设置X锁，此时InnoDB自动生成了一个IX，并且成功访问到了数据\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select * from regions where region_id = 3 for update; +-----------+-------------+ | region_id | region_name | +-----------+-------------+ | 3 | Asia | +-----------+-------------+ 1 row in set (0.00 sec) mysql> \"]},\"772\":{\"h\":\"③ 自增锁\",\"t\":[\"自增锁是一种比较特殊的表级锁。并且在事务向包含了 AUTO_INCREMENT 列的表中新增数据时就会去持有自增锁，假设事务 A 正在做这个操作，如果另一个事务 B 尝试执行 INSERT语句，事务 B 会被阻塞住，直到事务 A 释放自增锁。（其实这么说是有些不准确的，因为自增锁有三种模式，每一种模式的处理方式不同）\",\"传统模式（Traditional）\",\"当我们向包含了 AUTO_INCREMENT 列的表中插入数据时，都会持有这么一个特殊的表锁——自增锁（AUTO-INC），并且当语句执行完之后就会释放。这样一来可以保证单个语句内生成的自增值是连续的。但是弊端就是 并发性能差 ,因为要一条一条执行\",\"连续模式（Consecutive）\",\"在锁模式处于连续模式下时，如果 INSERT 语句能够提前确定插入的数据量，则可以不用获取自增锁，举个例子，像 INSERT INTO 这种简单的、能提前确认数量的新增语句，就不会使用自增锁\",\"交叉模式（Interleaved）\",\"交叉模式（Interleaved）下，所有的 INSERT 语句，包含 INSERT 和 INSERT INTO ... SELECT ，都不会使用 AUTO-INC 自增锁，而是使用较为轻量的 mutex 锁。这样一来，多条 INSERT 语句可以并发的执行，这也是三种锁模式中扩展性最好的一种。\"]},\"773\":{\"h\":\"④ 元数据锁（MDL）\",\"t\":[\"MySQL5.5引入了 meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性\",\"比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一\",\"列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。\",\"因此，当对一个表做增删改查操作的时候，MYSQL会自动加上 MDL 读锁，对表结构进行修改时，会自动加上 MDL 写锁\"]},\"774\":{\"h\":\"（2）InnoDB中的行锁\",\"t\":[\"行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行(某条记录 row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现\",\"优点: 锁定力度小，发生 锁冲突概率低，可以实现的 并发度高，\",\"缺点: 对于 锁的开销比较大，加锁会比较慢，容易出现 死锁 情况。\",\"InnoDB与MyISAM的最大不同有两点: 一是支持事务(TRANSACTION);二是采用了行级锁。\"]},\"775\":{\"h\":\"① 记录锁(Record Locks)\",\"t\":[\"记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的\",\"那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。\",\"image-20240327222401309\",\"记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。\",\"当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；\",\"当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。\"]},\"776\":{\"h\":\"② 间隙锁(Gap Locks)\",\"t\":[\"gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有 共享gap锁 和 独占gap锁 这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁(不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。\",\"比如，把id值为8的那条记录加一个gap锁的示意图如下。\",\"image-20240327224623534\",\"图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。\",\"若在id值为25的记录增加间隙锁，则 id在 (20,+∞) 这个区间的记录都不允许增加！\",\"间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生 死锁\",\"image-20240327225404331\",\"由于都为5增加了间隙锁，双方都会等待对方先释放锁而导致死锁！\"]},\"777\":{\"h\":\"③ 临键锁(Next-Key Locks)\",\"t\":[\"有时候我们既想 锁住某条记录 ，又想 阻止其他事务在该记录前边的间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。\",\"select * from student where id <=8 and id > 3 for update; \"]},\"778\":{\"h\":\"④ 插入意向锁(Insert Intention Locks)\",\"t\":[\"我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁（next-key锁也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 插入意向锁 。插入意向锁是一种 Gap锁 ，不是意向锁，在insert操作时产生\"]},\"779\":{\"h\":\"16.2.3 页锁\",\"t\":[\"页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。\",\"每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。\"]},\"780\":{\"h\":\"1、悲观锁、乐观锁\",\"t\":[\"从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 设计思想 。\"]},\"781\":{\"h\":\"悲观锁\",\"t\":[\"悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中的synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现\"]},\"782\":{\"h\":\"乐观锁\",\"t\":[\"乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。\"]},\"783\":{\"h\":\"俩种锁的使用场景\",\"t\":[\"乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。\",\"悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。\"]},\"784\":{\"h\":\"16.2.4 其他锁\"},\"785\":{\"h\":\"1、全局锁\",\"t\":[\"全局锁就是对 整个数据库实例加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。\",\"Flush tables with read lock \"]},\"786\":{\"h\":\"2、死锁\",\"t\":[\"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死锁示例：\",\"image-20240331135828610\",\"死锁产生的条件：\",\"1、两个或者两个以上事务\",\"2、每个事务都已经持有锁并且申请新的锁\",\"3、锁资源同时只能被同一个事务持有或者不兼容\",\"4、事务之间因为持有锁和申请锁导致彼此循环等待\",\"解决策略：\",\"一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。\",\"另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。将参数innodb_deadlock_detect 设置为on ，表示开启这个逻辑。\",\"如何避免死锁\",\"合理设计索引，使业务 SQL尽可能通过索引定位更少的行，减少锁竞争。\",\"调整业务逻辑 SQL 执行顺序，避免 update/delete 长时间持有锁的 SQL 在事务前面。\",\"避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更\"]},\"787\":{\"c\":[\"数据库\"]},\"788\":{\"c\":[\"数据库\",\"MySQL\"]},\"789\":{\"h\":\"十七、MVCC\"},\"790\":{\"h\":\"17.1 什么是MVCC\",\"t\":[\"MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。\",\"多个版本： 指undo日志中保存的被事务修改的行信息\"]},\"791\":{\"h\":\"17.2 快照读和当前读\",\"t\":[\"MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。\",\"快照读\",\"快照读又叫一致性读，读取的是快照数据。不加锁的简单的SELECT都属于快照读，即不加锁的非阻塞读；比如这样：\",\"SELECT * FROM player WHERE ... \",\"当前读\",\"当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如\",\"SELECT * FROM student LOCK IN SHARE MODE; # 共享锁 SELECT * FROM student FOR UPDATE; # 排他锁 INSERT INTO student values ... # 排他锁 DELETE FROM student WHERE ... # 排他锁 UPDATE student SET ... # 排他锁 \"]},\"792\":{\"h\":\"17.3 复习\"},\"793\":{\"h\":\"17.3.1 再谈隔离级别\",\"t\":[\"四个隔离级别可以解决的并发问题如下：\",\"读未提交不能解决 脏读、不可重复读、幻读\",\"读已提交解决了脏读\",\"可重复读解决了脏读、不可重复读\",\"串行化解决以上三种并发问题！\",\"image-20240331143413546\",\"这仅仅是MySQL中定义的标准，但实际上在MySQL中 可重复读，已经解决了幻读, 靠的就是 MVCC。\",\"image-20240331143804882\"]},\"794\":{\"h\":\"17.3.2 隐藏字段、UNDO日志版本链\",\"t\":[\"回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：\",\"trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。\",\"roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。\",\"insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的UndoLog Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。\",\"假设之后两个事务id分别为 10 、 20 的事务对这条记录进行 UPDATE 操作，操作流程如下：\",\"image-20240331144303492\",\"每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志都连起来，串成一个链表：\",\"image-20240331144352550\"]},\"795\":{\"h\":\"17.4 MVCC实现原理之ReadView\",\"t\":[\"MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。\"]},\"796\":{\"h\":\"17.4.1 什么是ReadView\",\"t\":[\"在 MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢? 这时就需要用到 ReadView 了，它帮我们解决了行的可见性问题，\",\"Readview 就是事务A在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务 的ID(“活跃”指的就是，启动了但还没提交)。\",\"ReadView是和事务一一对应的！并且只有活跃的事务才会有 ReadView ，谨记！！！\"]},\"797\":{\"h\":\"17.4.2 设计思路\",\"t\":[\"使用 READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了(没有使用到MVCC)。\",\"使用 SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。(没有使用到MVCC)\",\"使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务，都必须保证读到 已经提交了的 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。\",\"核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。\",\"这个ReadView中主要包含4个比较重要的内容，分别如下：\",\"1、creator_trx_id ，创建这个 Read View 的事务 ID。\",\"说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。\",\"2、trx_ids ，表示在生成ReadView时当前系统中活跃的读写事务的 事务id列表\",\"3、up_limit_id ，活跃的事务中最小的事务 ID。\",\"4、low_limit_id ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。\",\"trx_ids 为活跃的事务Id列表，low_limit_id 包括系统中已经提交的事务ID，比如：活跃的事务Id有 1,2 , 提交的事务ID有 3,4。 那么low_limit_id的值就是5。\"]},\"798\":{\"h\":\"17.4.3 ReadView规则\",\"t\":[\"有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：\",\"如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。\",\"如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。\",\"如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。\",\"如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。 \",\"如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。\",\"如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。\",\"总结起来就是访问最新提交的快照！\"]},\"799\":{\"h\":\"17.4.4 MVCC整体操作流程\",\"t\":[\"1、首先获取事务自己的版本号，也就是事务 ID；\",\"2、 获取 ReadView；\",\"3、查询得到的数据，然后与 ReadView 中的事务版本号进行比较；\",\"4、如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；\",\"5、最后返回符合规则的数据。\",\"Innodb中，MVCC是通过 Undo Log+ ReadView 进行数据获取，Undo Log保存了历史快照，而ReadView帮我们判断是否可以读取！\",\"在隔离级别为**读已提交（Read Committed）**时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。\",\"image-20240331152555348\",\"读已提交: 只能读取其他事物提交过后的数据\",\"相同SQL查询也会重新获取一次 ReadView，如果俩次 ReadView 的不一样，就有可能导致幻读、不可重复读的问题！\",\"当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：\",\"image-20240331152746169\"]},\"800\":{\"h\":\"17.5 如何解决幻读\",\"t\":[\"假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。\",\"image-20240331154809923\",\"假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。\",\"事务A开始第一次查询\",\"select * from student where id >= 1; \",\"在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids=[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 。\",\"此时SQL语句查询出来id=1的一条数据，然后根据ReadView判断是否可以被访问：\",\"trx = 1，小于up_limit_id ，说明在生成ReadView之前已经被提交，因此可以被访问\",\"结果：第一次查询出 id = 1 的数据\",\"事务B执行插入操作\",\"insert into student(id,name) values(2,'李四'); insert into student(id,name) values(3,'王五'); \",\"此时student 表中有三条数据：\",\"image-20240331155312038\",\"事务A开始第二次查询\",\"select * from student where id >= 1; \",\"由于隔离级别为 可重复读，此时并不会重新生成 ReadView，三条数据都符合Where 条件，都会被查询出来，然后根据ReadView判断哪个版本可以被访问：\",\"首先 id = 3，trx_id = 30 ， 在 trx_ids=[20,30] 之间，说明此时的 trx_id = 30 为活跃状态，因此不可以被访问\",\"id = 2，trx_id = 30 和上面同理，不可以被访问\",\"id = 1，可以被访问\",\"结果：第二次查询出 id = 1 的数据，解决了幻读问题！\"]},\"801\":{\"h\":\"17.6 总结\",\"t\":[\"MVCC可以解决\",\"读写之间阻塞的问题：通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。\",\"降低了死锁的概率 ：这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。\",\"解决快照读的问题：当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。\"]},\"802\":{\"c\":[\"数据库\"]},\"803\":{\"c\":[\"数据库\",\"MySQL\"]},\"804\":{\"h\":\"十八、日志\"},\"805\":{\"h\":\"18.1 日志类型\",\"t\":[\"MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志、 和慢查 错误日志、 通用查询日志 询日志，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志和 数据定义语句日志。使 用这些日志文件，可以查看MySQL内部发生的事情。\",\"**慢查询日志：**记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。\",\"**通用查询日志：**记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。\",\"**错误日志：**记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。\",\"**二进制日志：**记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。\",\"**中继日志：**用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。\",\"**数据定义语句日志：**记录数据定义语句执行的元数据操作。\",\"日志弊端\",\"日志功能会降低MySQL数据库的性能。\",\"日志会 占用大量的磁盘空间 。\"]},\"806\":{\"h\":\"18.2 通用查询日志\",\"t\":[\"通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题\",\"查看当前状态\",\"mysql> SHOW VARIABLES LIKE '%general%'; +------------------+------------------------------+ | Variable_name | Value | +------------------+------------------------------+ | general_log | OFF | #通用查询日志处于关闭状态 | general_log_file | /var/lib/mysql/atguigu01.log | #通用查询日志文件的名称是atguigu01.log +------------------+------------------------------+ 2 rows in set (0.03 sec) \",\"启动日志\",\"永久启动\",\"修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：\",\"[mysqld] general_log=ON general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名 \",\"临时启动\",\"SET GLOBAL general_log=on; # 开启通用查询日志 SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置 \",\"关闭日志\",\"设置成 OFF 即可\"]},\"807\":{\"h\":\"18.3 错误日志\",\"t\":[\"在MySQL数据库中，错误日志功能是 默认开启 的。而且，错误日志 无法被禁止 。\",\"默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或 hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：\",\"[mysqld] log-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名 \",\"查看日志\",\"mysql> SHOW VARIABLES LIKE 'log_err%'; +----------------------------+----------------------------------------+ | Variable_name | Value | +----------------------------+----------------------------------------+ | log_error | /var/log/mysqld.log | | log_error_services | log_filter_internal; log_sink_internal | | log_error_suppression_list | | | log_error_verbosity | 2 | +----------------------------+----------------------------------------+ 4 rows in set (0.01 sec) \"]},\"808\":{\"h\":\"18.4 二进制日志(bin log)\",\"t\":[\"binlog 即 binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）\",\"binlog主要应用场景：\",\"一是用于 数据恢复\",\"二是用于 数据复制\"]},\"809\":{\"h\":\"18.4.1 使用命令\",\"t\":[\"查看当前状态\",\"mysql> show variables like '%log_bin%'; +---------------------------------+------------------------------------------------------------------+ | Variable_name | Value | +---------------------------------+------------------------------------------------------------------+ | log_bin | ON | | log_bin_basename | C:\\\\ProgramData\\\\MySQL\\\\MySQL Server 8.0\\\\Data\\\\LAPTOP-OHIMTDP2 | | log_bin_index | C:\\\\ProgramData\\\\MySQL\\\\MySQL Server 8.0\\\\Data\\\\LAPTOP-OHIMTDP2.index | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+------------------------------------------------------------------+ 6 rows in set, 1 warning (0.00 sec) \",\"日志参数设置\",\"修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数：\",\"[mysqld] #启用二进制日志 log-bin=atguigu-bin binlog_expire_logs_seconds=600 max_binlog_size=100M \",\"临时性方式\",\"如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql8中只有 会话级别 的设置，没有了global级别的设置。\",\"# global 级别 mysql> set global sql_log_bin=0; ERROR 1228 (HY000): Variable 'sql_log_bin' is a SESSION variable and can`t be used with SET GLOBAL # session级别 mysql> SET sql_log_bin=0; Query OK, 0 rows affected (0.01 秒) \",\"查看日志\",\"当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。\",\"MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。\",\"查看当前的二进制日志文件列表及大小。指令如下：\",\"mysql> SHOW BINARY LOGS; +--------------------+-----------+-----------+ | Log_name | File_size | Encrypted | +--------------------+-----------+-----------+ | atguigu-bin.000001 | 156 | No | +--------------------+-----------+-----------+ 1 行于数据集 (0.02 秒) \",\"查看日志文件内容：\",\"下面命令将行事件以 伪SQL的形式 表现出来\",\"mysqlbinlog -v \\\"文件位置\\\" # 可查看参数帮助 mysqlbinlog --no-defaults --help # 查看最后100行 mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 \",\"上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：\",\"mysql> show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]; \",\"IN 'log_name' ：指定要查询的binlog文件名（不指定就是第一个binlog文件）\",\"FROM pos ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）\",\"LIMIT [offset] ：偏移量(不指定就是0)\",\"row_count :查询总条数（不指定就是所有行）\",\"使用日志恢复数据\",\"恢复命令：\",\"mysqlbinlog [option] filename|mysql –uuser -ppass; 举例： # mysqlbinlog命令路径 /usr/bin/mysqlbinlog --start-position=起始点 -stop-position=终止点 --database= '数据库' 'log文件路径' /usr/bin/mysql -uroot -proot -v '数据库' \",\"这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。\",\"filename ：是日志文件名。\",\"option ：可选项，比较重要的两对option参数是--start-date、--stop-date 和 --start-position、--\",\"stop-position。\",\"--start-date 和 --stop-date ：可以指定恢复数据库的起始时间点和结束时间点。\",\"--start-position 和--stop-position ：可以指定恢复数据的开始位置和结束位置。\",\"可以通过 show binlog events in 'LAPTOP-OHIMTDP2.000137'; 命令查看事件的起始点和终止点，然后在执行上面的恢复命令！\",\"删除日志文件\",\"MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 PURGE MASTER LOGS 只删除指定部分的二进制日志文件， RESET MASTER 删除所有的二进制日志文件。具体如下：\",\"PURGE {MASTER | BINARY} LOGS TO ‘指定日志文件名’ PURGE {MASTER | BINARY} LOGS BEFORE ‘指定日期’ \"]},\"810\":{\"h\":\"18.4.2 写入机制\",\"t\":[\"binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。\",\"image-20240331222759467\",\"write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。如下图：\",\"image-20240331222834151\",\"为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同redo log刷盘流程一样。\",\"最后还有一种折中方式，可以设置为N(N>1)，表示每次提交事务都write，但累积N个事务后才fsync。\"]},\"811\":{\"h\":\"18.4.3 binlog 和 redolog对比\",\"t\":[\"Redo Log它是 物理日志 ，用于保证事务的持久性，即在事务提交之前将事务的修改写入磁盘，以便在数据库发生崩溃时恢复未提交的事务\",\"binlog 是 逻辑日志 ，记录了所有对数据库进行修改的操作，包括对数据的增删改等，它用于复制、恢复、以及点播恢复等操作。\",\"Redo Log 是 InnoDB 存储引擎特有的，它记录了 InnoDB 存储引擎中数据页的物理修改操作。\",\"Binlog 是 MySQL 服务器的整体功能，它记录了数据库中执行的 SQL 语句的逻辑操作\"]},\"812\":{\"h\":\"18.4.4 俩阶段提交\",\"t\":[\"在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机 不一样。\",\"image-20240331223700913\",\"redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？\",\"如果事务执行完，写完了 redo log 但是由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。\",\"image-20240331224057648\",\"为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案\",\"image-20240331224233530\",\"使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据 redolog日志恢复数据时，发现redolog还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。\",\"image-20240331224337529\"]},\"813\":{\"h\":\"18.5 中继日志(relay log)\",\"t\":[\"中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 本地的日志文件 中，这个从服务器本地的日志文件就叫 中继日志 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的 数据同步 。\",\"文件名的格式是： 从服务器名 -relay-bin.序号 。中继日志还有一个索引文件： 从服务器名 -relay-bin.index ，用来定位当前正在使用的中继日志。\",\"中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。下面是中继日志的一个片段：\"]},\"814\":{\"c\":[\"数据库\"]},\"815\":{\"c\":[\"数据库\",\"MySQL\"]},\"816\":{\"h\":\"十九、主从复制\"},\"817\":{\"h\":\"19.1 主从复制的概述\"},\"818\":{\"h\":\"19.1.1 如何提升数据库的并发能力\",\"t\":[\"在实际工作中，我们常常将 Redis 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就 提升了读取的效率，也减少了对后端数据库的 访问压力。 Redis 的缓存架构是高并发架构中非常重要的一环。\",\"image-20240401091741919\",\"此外，一般应用对数据库而言都是“ 读多写少 ”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 主从架构 、进行 读写分离 ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。\",\"如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 优化SQL和索引 ，这种方式简单有效；其次才是采用 缓存的策略 ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用 主从架构 ，进行读写分离\"]},\"819\":{\"h\":\"19.1.2 主从复制的作用\",\"t\":[\"主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用\",\"第1个作用 : 读写分离。我们可以通过主从复制的方式来 同步数据，然后通过读写分离提高数据库并发处理能\",\"image-20240401092406011\",\"其中一个是Master主库，负责写入数据，我们称之为: 写库。\",\"其它都是slave从库，负责读取数据，我们称之为: 读库。\",\"当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。面对“读多写少”的需求，采用读写分离的方式，可以实现, 更高的并发访问。同时，\",\"我们还能对从服务器进行 负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让 读取更加顺畅 。读取顺畅的另一个原因，就是 减少了锁表 的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行 SELECT 的读取。\",\"第2个作用 就是数据备份。我们通过主从复制将主库上的数据复制到了从库上，相当于是一 种 热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。\",\"第3个作用 是具有高可用性。数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现 故障 或 宕机 的情况下，可以 切换 到从服务器上，保证服务的正常运行。\"]},\"820\":{\"h\":\"19.2 主从复制的原理\",\"t\":[\"Slave 会从 Master 读取 binlog 来进行数据同步。\",\"实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程 来操作，一个主库线程，两个从库线程\",\"image-20240401093239495\",\"二进制日志转储线程 （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。\",\"从库 I/O 线程 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。\",\"从库 SQL 线程 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步\",\"image-20240401093401888\",\"三步骤：\",\"步骤1： Master 将写操作记录到二进制日志（ binlog ）。\",\"步骤2： Slave 将 Master 的 binary log events 拷贝到它的中继日志（ relay log ）；\",\"步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 接入点 开始复制。\",\"基本准则：\",\"每个 Slave 只有一个 Master\",\"每个 Slave 只能有一个唯一的服务器ID\",\"每个 Master 可以有多个 Slave\"]},\"821\":{\"h\":\"19.3 一主一从搭建\",\"t\":[\"一台 主机 用于处理所有 写请求 ，一台 从机 负责所有 读请求 ，架构图如下\",\"image-20240401093954967\"]},\"822\":{\"h\":\"19.3.1 准备工作\",\"t\":[\"1、准备 2台 CentOS 虚拟机\",\"2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )\",\"注意：克隆的方式需要修改新克隆出来主机的：① MAC地址 ② hostname ③ IP 地址 ④ UUID 。\",\"此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如： show slave status\\\\G ，报如下的错误：\",\"Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. \",\"修改方式：\",\"vim /var/lib/mysql/auto.cnf systemctl restart mysqld \"]},\"823\":{\"h\":\"19.3.2 主机配置文件\",\"t\":[\"建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 [mysqld] 节点下，且都是小写字母。\",\"必选\",\"#[必须]主服务器唯一ID server-id= #[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin log-bin=atguigu-bin \",\"可选\",\"#[可选] 0（默认）表示读写（主机），1表示只读（从机） read-only=0 #设置日志文件保留的时长，单位是秒 binlog_expire_logs_seconds=6000 #控制单个二进制日志大小。此参数的最大和默认值是1GB max_binlog_size=200M #[可选]设置不要复制的数据库 binlog-ignore-db=test #[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave binlog-do-db=需要复制的主数据库名字 #[可选]设置binlog格式 binlog_format=STATEMENT \",\"binlog格式设置：\",\"格式1：STATEMENT模式（基于SQL语句的复制(statement-based replication, SBR)）\",\"binlog_format=STATEMENT \",\"每一条会修改数据的 sql语句 会记录到binlog中。这是默认的binlog格式。\",\"SBR优点\",\"不需要记录每一行的变化，减少了binlog日志量，文件较小\",\"binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况\",\"binlog可以用于实时的还原，而不仅仅用于复制\",\"主从版本可以不一样，从服务器版本可以比主服务器版本高\",\"SBR缺点\",\"不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候\",\"格式二：ROW模式（基于行的复制(row-based replication, RBR)）\",\"binlog_format=ROW \",\"RBR 的优点：\",\"任何情况都可以被复制，这对复制来说是最 安全可靠 的。（比如：不会出现某些特定情况下\",\"的存储过程、function、trigger的调用和触发无法被正确复制的问题）\",\"多数情况下，从服务器上的表如果有主键的话，复制就会快了很多\",\"复制以下几种语句时的行锁更少：INSERT ... SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句\",\"执行 INSERT，UPDATE，DELETE 语句时锁更少\",\"从服务器上采用 多线程 来执行复制成为可能\",\"RBR 的缺点：\",\"binlog 大了很多\",\"复杂的回滚时 binlog 中会包含大量的数据\",\"主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题\",\"无法从 binlog 中看到都复制了些什么语句\",\"格式三： MIXED模式（混合模式复制(mixed-based replication, MBR)）\",\"在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。\",\"MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\"]},\"824\":{\"h\":\"19.3.3 从机配置文件\",\"t\":[\"必选\",\"#[必须]从服务器唯一ID server-id=2 \",\"可选\",\"# [可选]启用中继日志 relay-log=mysql-relay \",\"注意：主从机都关闭防火墙\",\"service iptables stop #CentOS 6\",\"systemctl stop firewalld.service #CentOS 7\"]},\"825\":{\"h\":\"19.3.4 主机：建立账户并授权\",\"t\":[\"# 在主机MySQL里执行授权主从复制的命令 GRANT REPLICATION SLAVE ON *.* TO 'slave1'@'从机器数据库IP' IDENTIFIED BY 'abc123'; #5.5,5.7 \",\"注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：\",\"CREATE USER 'slave1'@'%' IDENTIFIED BY '123456'; GRANT REPLICATION SLAVE ON *.* TO 'slave1'@'%'; #此语句必须执行。否则见下面。 ALTER USER 'slave1'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; flush privileges; \",\"查询Master的状态，并记录下File和Position的值\",\"image-20240401095229716\",\"注意：执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化。\"]},\"826\":{\"h\":\"19.3.5 从机：配置需要复制的主机\",\"t\":[\"1、从机上复制主机的命令\",\"CHANGE MASTER TO MASTER_HOST='主机的IP地址', MASTER_USER='主机用户名', MASTER_PASSWORD='主机用户名的密码', MASTER_LOG_FILE='mysql-bin.具体数字', MASTER_LOG_POS=具体值; \",\"image-20240401095449801\",\"若是之前做过主从复制，并且还仍在开着，请先停止！\",\"image-20240401095618744\",\"2、启动slave同步\",\"#启动slave同步 START SLAVE; \",\"如果报错\",\"image-20240401095701933\",\"可以执行如下操作，删除之前的 relay_log信息。然后重新执行 CHANGE MASTER TO ... 语句即可。\",\"mysql> reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件 \",\"查看同步状态\",\"SHOW SLAVE STATUS\\\\G; \",\"image-20240401095908989\",\"上面两个参数都是Yes，则说明主从配置成功！\"]},\"827\":{\"h\":\"19.3.5 停止复制\",\"t\":[\"stop slave; \",\"如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错如下：\",\"image-20240401100217220\"]},\"828\":{\"c\":[\"数据库\"]},\"829\":{\"c\":[\"数据库\",\"MySQL\"]},\"830\":{\"h\":\"二十、备份\",\"t\":[\"物理备份：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比 较大，MySQL中可以用 xtrabackup 工具来进行物理备份。\",\"逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空 间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。逻辑备份就是 时候执行备份的sql语句实现数据库数据的重现。\"]},\"831\":{\"h\":\"20.1 逻辑备份\",\"t\":[\"备份一个数据库\",\"mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]> 备份文件名称.sql \",\"说明： 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的。\",\"备份所有数据库\",\"若想用mysqldump备份整个实例，可以使用 --all-databases 或 -A参数\",\"mysqldump -uroot -pxxxxxx --all-databases > all_database.sql mysqldump -uroot -pxxxxxx -A > all_database.sql \",\"备份部分数据库\",\"使用 --databases 或 -B 参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定 databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在。语法如下：\",\"mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] > 备份文件名称.sql \",\"备份部份表\",\"mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] > 备份文件名称.sql \",\"备份单表的部分数据、\",\"有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 --where 选项了。where后面附 带需要满足的条件。\",\"mysqldump -uroot -p atguigu student --where=\\\"id < 10 \\\" > student_part_id10_low_bak.sql \",\"排除某些表的备份\",\"如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些 表，同样的，选项 --ignore-table 可以完成这个功能。\",\"mysqldump -uroot -p atguigu --ignore-table=atguigu.student > no_stu_bak.sql \",\"通过如下指定判定文件中没有student表结构：\",\"grep \\\"student\\\" no_stu_bak.sql \",\"只备份结构或只备份数据\",\"只备份结构的话可以使用 --no-data 简写为-d选项；只备份数据可以使用 --no-create-info 简写为 -t选项。\",\"只备份数据\",\"mysqldump -uroot -p atguigu --no-data > atguigu_no_data_bak.sql #使用grep命令，没有找到insert相关语句，表示没有数据备份。 [root@node1 ~]# grep \\\"INSERT\\\" atguigu_no_data_bak.sql [root@node1 ~]# \",\"只备份结构\",\"mysqldump -uroot -p atguigu --no-create-info > atguigu_no_create_info_bak.sql #使用grep命令，没有找到create相关语句，表示没有数据结构。 [root@node1 ~]# grep \\\"CREATE\\\" atguigu_no_create_info_bak.sql [root@node1 ~]# \",\"备份中包含存储过程、函数、事件\",\"mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用 --routines 或-R选项来备份存储过程及函数，使用 --events 或-E参数来备份事件。\",\"mysqldump -uroot -p -R -E --databases atguigu > fun_atguigu_bak.sql \"]},\"832\":{\"h\":\"20.2 逻辑恢复\",\"t\":[\"基本语法\",\"mysql –u root –p [dbname] < backup.sql \",\"单库备份中恢复单库\",\"如果备份文件中包含了创建数据库的语句，则恢复的时候不需要指定数据库名称，如下所示\",\"mysql -uroot -p < atguigu.sql \",\"否则就需要指定数据库：\",\"mysql -uroot -p atguigu4< atguigu.sql \",\"全量备份恢复\",\"如果我们现在有昨天的全量备份，现在想整个恢复，则可以这样操作\",\"mysql -uroot -p < all.sql \",\"从全量备份中恢复单库\",\"可能有这样的需求，比如说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以从全量备份中分离出单个库的备份。\",\"sed -n '/^-- Current Database: `atguigu`/,/^-- Current Database: `/p' all_database.sql > atguigu.sql #分离完成后我们再导入atguigu.sql即可恢复单个库 \",\"从单库备份中恢复单表\",\"cat atguigu.sql | sed -e '/./{H;$!d;}' -e 'x;/CREATE TABLE `class`/!d;q' > class_structure.sql cat atguigu.sql | grep --ignore-case 'insert into `class`' > class_data.sql #用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 use atguigu; mysql> source class_structure.sql; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> source class_data.sql; Query OK, 1 row affected (0.01 sec) \"]},\"833\":{\"c\":[\"数据库\"]},\"834\":{\"c\":[\"数据库\",\"MySQL\"]},\"835\":{\"h\":\"附录\",\"t\":[\"在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同\",\"规范下的表 连接操作是有区别的。\",\"SQL 有两个主要的标准，分别是 SQL92 和 SQL99 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年 提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、 SQL:2011 和 SQL:2016 等其他的标准。\",\"这么多标准，到底该学习哪个呢？实际上最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的 形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂， 但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满 足日常工作的需求即可。\",\"SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。也正是在这两个标准发布之 后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言， 还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使 用。\"]},\"836\":{\"h\":\"阿里巴巴字段命名规范\",\"t\":[\"【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出 现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 \",\"正例：aliyun_admin，rdc_config，level3_name\",\"反例：AliyunAdmin，rdcConfig，level_3_name\",\"【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。\",\"【强制】表必备三字段：id, gmt_create, gmt_modified。 \",\"说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被 动式更新\",\"【推荐】表的命名最好是遵循 “业务名称_表的作用”。 \",\"正例：alipay_task 、 force_project、 trade_config\",\"【推荐】库名与应用名称尽量一致\",\"【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速 度。\"]},\"837\":{\"h\":\"阿里巴巴外键规范\",\"t\":[\"【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\",\"说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发，不适合 分布式、 高并发集群；级联更新是强阻塞，存在数据库 更新风暴的风险；外键影响 数据库的 插入速度。\"]},\"838\":{\"c\":[\"数据库\"]},\"839\":{\"c\":[\"数据库\",\"MySQL\"]},\"840\":{\"h\":\"MySQL\"},\"841\":{\"c\":[\"数据库\"]},\"842\":{\"c\":[\"数据库\",\"MySQL\"]},\"843\":{\"h\":\"缓存双写一致性问题\",\"t\":[\"只要使用缓存，就可能涉及到 Redis 缓存与数据库 双存储双写，只要是双写，就一定会有数据一致性的问题！\",\"image-20240416203555111\"]},\"844\":{\"h\":\"你是如何解决数据一致性问题的？\",\"t\":[\"采用 双检加锁 策略\",\"多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。\",\"image-20240416222902670\"]},\"845\":{\"h\":\"你的更新策略是什么？\",\"t\":[\"原文\",\"如何保证数据库和缓存双写一致性？ - 知乎 (zhihu.com)\",\"目前常见的更新策略有四种：\",\"先写缓存，再写数据库\",\"先写数据库，再写缓存\",\"先删缓存，再写数据库\",\"先写数据库，再删缓存\"]},\"846\":{\"h\":\"先写缓存，再写数据库\",\"t\":[\"这种方案是最不可取的，写完缓存后，更新数据库时出现网络异常，导致数据库更新不成功！\",\"那么 Redis 中的数据不就成了 脏数据了 吗？\",\"image-20240417162206531\"]},\"847\":{\"h\":\"先写数据库，再写缓存\",\"t\":[\"这种方案貌似解决了上面脏数据 的问题，但是又带来了一个新问题，新值被覆盖的问题\",\"image-20240417162515274\",\"假设请求a先执行数据库写操作，在写入缓存是出现卡顿\",\"这时，请求b在请求a卡顿的过程中，先更新缓存的值为5\",\"在请求b更新完之后，请求a卡顿结束，更新缓存值为6\",\"这时请求a的旧值就覆盖了请求b的新值\"]},\"848\":{\"h\":\"先删缓存，再写数据库\",\"t\":[\"这种方案仍然会出现新值被覆盖的问题\",\"假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求c，还有另一个写数据请求d（一个更新操作），同时请求到业务系统。如下图所示：\",\"image-20240417164418066\",\"请求d先删除数据库，在写数据库时出现卡顿\",\"此时请求c过来查询缓存没有，查询数据库并更新缓存，但此时更新的是旧值，请求d由于卡顿还未更新数据库。\",\"在请求c更新缓存之后，请求d卡顿结束，写入数据库\",\"这就造成了数据库时请求d更新的新值，而缓存中是请求c更新的旧值，造成了数据不一致的问题！\",\"但是这个方案有一个解决方法，就是在请求d写数据库完之后，间隔一段时间再去删除缓存，也就是所谓的 延时双删 的策略！\",\"值得注意的是，一定要间隔一段时间，在请求c更新缓存之后再去删除，否则没有意义！\",\"这个间隔多长时间根据你具体的业务去考虑\"]},\"849\":{\"h\":\"先写数据库，再删缓存\",\"t\":[\"这种方案其实是比较推荐的！\",\"image-20240417165601046\",\"请求d先写数据库，由于卡顿未来得及删除缓存\",\"请求c查询缓存，由于请求d未删除，返回的是旧值\",\"请求d删除缓存\",\"这个方案，仅仅是请求c读到了一次旧值，但随之请求d就删除了，相对前面三个比较能接受一些！\"]},\"850\":{\"h\":\"删除失败怎么办\",\"t\":[\"其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致\",\"这种情况就需要使用 重试机制 ，当删除失败后，可以立即进行重试，若多次重试之后仍然失败，这是就需要记录给相关人员手工处理了！\",\"而实现重试机制有很多种方式，常见的有：定时任务、RabbitMQ、binlog日志\"]},\"851\":{\"h\":\"定时任务\",\"t\":[\"1、当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：\",\"img\",\"2、在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为0。然后重试5次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。\",\"img\"]},\"852\":{\"h\":\"RabbitMQ\",\"t\":[\"当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。\",\"mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入死信队列中。\",\"由指定的消费者监听死信队列 , 若失败5次仍然未成功可以保存到表中通知相关人员做下一步处理！\",\"img\"]},\"853\":{\"h\":\"binlog\",\"t\":[\"无论是定时任务，还是mq（消息队列），做重试机制，对业务都有一定的侵入性。\",\"其实，还有一种更优雅的实现，即监听binlog，比如使用：canal等中间件。\",\"img\",\"在业务接口中写数据库之后，就不管了，直接返回成功。\",\"mysql服务器会自动把变更的数据写入binlog中。\",\"binlog订阅者获取变更的数据，然后删除缓存。\",\"这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在binlog订阅者中做缓存删除工作。\",\"但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。\",\"如何解决这个问题呢？\",\"答：这就需要加上前面聊过的重试机制了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入mq，让mq自动重试。\",\"img\"]},\"854\":{\"c\":[\"Redis\"]},\"855\":{\"c\":[\"缓存\",\"MySQL\",\"数据一致性\"]},\"856\":{\"h\":\"主要功能与配置演示\"},\"857\":{\"c\":[\"使用指南\"]},\"858\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"859\":{\"c\":[\"使用指南\"]},\"860\":{\"c\":[\"禁用\"]},\"861\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"862\":{\"c\":[\"指南\"]},\"863\":{\"c\":[\"布局\"]},\"864\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"865\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"866\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"867\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"868\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"869\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"870\":{\"h\":\"提示容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"871\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"872\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"873\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"874\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"875\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"876\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"877\":{\"h\":\"任务列表\",\"t\":[\"[x] 计划 1\",\"[ ] 计划 2\",\"查看详情\"]},\"878\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"879\":{\"h\":\"组件\"},\"880\":{\"c\":[\"使用指南\"]},\"881\":{\"c\":[\"Markdown\"]},\"882\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"883\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 --- \"]},\"884\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"885\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"886\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"887\":{\"c\":[\"使用指南\"]},\"888\":{\"c\":[\"页面配置\",\"使用指南\"]},\"889\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"890\":{\"h\":\"Leet Code\"},\"891\":{\"h\":\"Microservices\"},\"892\":{\"h\":\"Redis\"}},\"dirtCount\":0,\"index\":[[\"脚注\",{\"0\":{\"875\":1}}],[\"详情容器\",{\"1\":{\"870\":1}}],[\"详情看compact行格式中的记录头信息\",{\"1\":{\"671\":1}}],[\"危险容器\",{\"1\":{\"870\":1}}],[\"警告容器\",{\"1\":{\"870\":1}}],[\"信息容器\",{\"1\":{\"870\":1}}],[\"展示\",{\"0\":{\"864\":1}}],[\"夜间模式按钮\",{\"1\":{\"861\":1}}],[\"布局包括\",{\"1\":{\"861\":1}}],[\"布局\",{\"0\":{\"861\":1},\"2\":{\"863\":1}}],[\"布局与功能禁用\",{\"0\":{\"858\":1}}],[\"评论\",{\"1\":{\"858\":1,\"861\":1}}],[\"评测系统内部使用整数\",{\"1\":{\"393\":1}}],[\"贡献者\",{\"1\":{\"858\":1,\"861\":1}}],[\"侧边栏\",{\"1\":{\"858\":1,\"861\":1}}],[\"导航栏\",{\"1\":{\"858\":1,\"861\":1}}],[\"导致数据库更新不成功\",{\"1\":{\"846\":1}}],[\"导致没有刷新成功\",{\"1\":{\"747\":1}}],[\"答\",{\"1\":{\"853\":1}}],[\"答案\",{\"1\":{\"595\":1}}],[\"答案及所有中间计算结果可以用\",{\"1\":{\"330\":1}}],[\"答案保证唯一\",{\"1\":{\"327\":1}}],[\"答案不应该是\",{\"1\":{\"227\":1}}],[\"答案可以按\",{\"1\":{\"192\":1}}],[\"答案中不可以包含重复的三元组\",{\"1\":{\"176\":1}}],[\"延时双删\",{\"1\":{\"848\":1}}],[\"知乎\",{\"1\":{\"845\":1}}],[\"知道了对角线的规律\",{\"1\":{\"304\":1}}],[\"知道了对角线的数量\",{\"1\":{\"304\":1}}],[\"知道了哪行和哪列要置为0\",{\"1\":{\"301\":1}}],[\"策略\",{\"1\":{\"844\":1}}],[\"缓存\",{\"2\":{\"855\":1}}],[\"缓存与数据库\",{\"1\":{\"843\":1}}],[\"缓存双写一致性问题\",{\"0\":{\"843\":1}}],[\"缓存的策略\",{\"1\":{\"818\":1}}],[\"级联更新是强阻塞\",{\"1\":{\"837\":1}}],[\"级别\",{\"1\":{\"809\":1}}],[\"学生表中的\",{\"1\":{\"837\":1}}],[\"强制\",{\"1\":{\"836\":3,\"837\":1}}],[\"强制开启\",{\"1\":{\"475\":1}}],[\"足日常工作的需求即可\",{\"1\":{\"835\":1}}],[\"形式更简单\",{\"1\":{\"835\":1}}],[\"形成主外键关系\",{\"1\":{\"513\":2}}],[\"形成前后指针或快慢指针\",{\"1\":{\"250\":1}}],[\"形成一个新的子集\",{\"1\":{\"203\":1}}],[\"形成新的子集\",{\"1\":{\"203\":1}}],[\"形成的序列称为\",{\"1\":{\"78\":1}}],[\"附录\",{\"0\":{\"835\":1}}],[\"^\",{\"1\":{\"832\":2}}],[\"带需要满足的条件\",{\"1\":{\"831\":1}}],[\"带入之后得$\",{\"1\":{\"299\":2}}],[\"带入之后得\",{\"1\":{\"299\":1}}],[\"带入关键公式\",{\"1\":{\"299\":1}}],[\"带入\",{\"1\":{\"92\":1}}],[\"待备份的数据库名称\",{\"1\":{\"831\":1}}],[\"待反转的第一个结点start\",{\"1\":{\"384\":1}}],[\"汇总入备份文件内\",{\"1\":{\"830\":1}}],[\"汇报分支事务的状态\",{\"1\":{\"426\":1}}],[\"停止复制\",{\"0\":{\"827\":1}}],[\"混合模式复制\",{\"1\":{\"823\":1}}],[\"混淆的原因主要是区间没有定义好\",{\"1\":{\"270\":1}}],[\"尤其是包含不确定操作的时候\",{\"1\":{\"823\":1}}],[\"尤其对于传统的机械硬盘来说\",{\"1\":{\"749\":1}}],[\"报如下的错误\",{\"1\":{\"822\":1}}],[\"报错\",{\"1\":{\"451\":1}}],[\"克隆的方式生成的虚拟机\",{\"1\":{\"822\":1}}],[\"克隆的方式需要修改新克隆出来主机的\",{\"1\":{\"822\":1}}],[\"准备\",{\"1\":{\"822\":1}}],[\"准备工作\",{\"0\":{\"822\":1}}],[\"宕机\",{\"1\":{\"819\":1}}],[\"热备份机制\",{\"1\":{\"819\":1}}],[\"热点参数限流\",{\"1\":{\"444\":2}}],[\"热点即经常访问的数据\",{\"1\":{\"417\":1}}],[\"热点规则配置\",{\"1\":{\"417\":1}}],[\"热点规则\",{\"0\":{\"417\":1},\"1\":{\"419\":1}}],[\"热点流量防护等多个维度来帮助开发者保障微服务的稳定性\",{\"1\":{\"406\":1}}],[\"偏移量\",{\"1\":{\"809\":1}}],[\"伪sql的形式\",{\"1\":{\"809\":1}}],[\"伪代码如下\",{\"1\":{\"185\":1}}],[\"启用中继日志\",{\"1\":{\"824\":1}}],[\"启用二进制日志\",{\"1\":{\"809\":1,\"823\":1}}],[\"启动slave同步\",{\"1\":{\"826\":2}}],[\"启动日志\",{\"1\":{\"806\":1}}],[\"启动了但还没提交\",{\"1\":{\"796\":1}}],[\"启动俩个客户端c1\",{\"1\":{\"771\":1}}],[\"启动一致性读\",{\"1\":{\"744\":1}}],[\"启动脚本\",{\"1\":{\"454\":1}}],[\"启动报错\",{\"1\":{\"450\":1}}],[\"启动类\",{\"1\":{\"433\":1,\"434\":1,\"489\":1}}],[\"启动命令\",{\"1\":{\"429\":1}}],[\"启动入口动作的微服务模块\",{\"1\":{\"426\":1}}],[\"启动\",{\"1\":{\"407\":1}}],[\"启动成功后\",{\"1\":{\"422\":1,\"459\":1}}],[\"启动成功\",{\"1\":{\"401\":1,\"454\":1}}],[\"王五\",{\"1\":{\"800\":1}}],[\"李四\",{\"1\":{\"800\":1}}],[\"谨记\",{\"1\":{\"796\":1}}],[\"靠的就是\",{\"1\":{\"793\":1}}],[\"场景\",{\"1\":{\"785\":1}}],[\"场比赛\",{\"1\":{\"737\":1}}],[\"阻塞\",{\"1\":{\"781\":1}}],[\"阻止其他事务在该记录前边的间隙插入新记录\",{\"1\":{\"777\":1}}],[\"阻止对该服务的请求\",{\"1\":{\"475\":1}}],[\"乐观锁适用于多读的应用类型\",{\"1\":{\"782\":1}}],[\"乐观锁认为对同一数据的并发操作不会总发生\",{\"1\":{\"782\":1}}],[\"乐观锁和悲观锁并不是锁\",{\"1\":{\"780\":1}}],[\"乐观锁\",{\"0\":{\"780\":1,\"782\":1},\"1\":{\"783\":1}}],[\"悲观锁总是假设最坏的情况\",{\"1\":{\"781\":1}}],[\"悲观锁\",{\"0\":{\"780\":1,\"781\":1},\"1\":{\"783\":1}}],[\"临键锁\",{\"0\":{\"777\":1}}],[\"临时启动\",{\"1\":{\"806\":1}}],[\"临时且无效的\",{\"1\":{\"746\":1}}],[\"临时性方式\",{\"1\":{\"698\":1,\"809\":1}}],[\"临时修改存储引擎\",{\"1\":{\"635\":1}}],[\"临时保存下一个即将要交换的头结点\",{\"1\":{\"387\":1}}],[\"独占gap锁\",{\"1\":{\"776\":1}}],[\"独一无二\",{\"1\":{\"65\":1,\"277\":1}}],[\"官方保留字\",{\"1\":{\"836\":1}}],[\"官方的类型名称为\",{\"1\":{\"775\":1,\"777\":1,\"778\":1}}],[\"官网地址\",{\"1\":{\"458\":1,\"462\":1}}],[\"官网明确说明使用\",{\"1\":{\"457\":1}}],[\"官网\",{\"1\":{\"442\":1}}],[\"官网文档\",{\"1\":{\"426\":1}}],[\"死锁产生的条件\",{\"1\":{\"786\":1}}],[\"死锁示例\",{\"1\":{\"786\":1}}],[\"死锁是指两个或多个事务在同一资源上相互占用\",{\"1\":{\"786\":1}}],[\"死锁\",{\"0\":{\"786\":1},\"1\":{\"774\":1,\"776\":1}}],[\"容易出现\",{\"1\":{\"774\":1}}],[\"容量一点一点尝试\",{\"1\":{\"101\":1}}],[\"容量为5的背包\",{\"1\":{\"99\":5}}],[\"容量为j的背包\",{\"1\":{\"95\":1}}],[\"容量为2时\",{\"1\":{\"92\":1}}],[\"容量为4磅\",{\"1\":{\"91\":1}}],[\"顾名思义\",{\"1\":{\"774\":1,\"790\":1}}],[\"顾客排队购买你的产品\",{\"1\":{\"357\":1}}],[\"④\",{\"0\":{\"773\":1,\"778\":1},\"1\":{\"822\":1}}],[\"释放自增锁\",{\"1\":{\"772\":1}}],[\"释放锁\",{\"1\":{\"770\":1}}],[\"释放锁等动作\",{\"1\":{\"768\":1}}],[\"元数据锁\",{\"0\":{\"773\":1},\"1\":{\"770\":1}}],[\"元素来获得\",{\"1\":{\"345\":1}}],[\"元素的\",{\"1\":{\"312\":1}}],[\"元素的顺序可以改变\",{\"1\":{\"278\":1}}],[\"元素从上往下遍历时\",{\"1\":{\"304\":1}}],[\"元素从下往上遍历时\",{\"1\":{\"304\":2}}],[\"元素遍历的元素由\",{\"1\":{\"304\":1}}],[\"元素遍历的顺序由\",{\"1\":{\"304\":1}}],[\"元素个数\",{\"1\":{\"190\":1}}],[\"元素值太小\",{\"1\":{\"177\":1}}],[\"元素值太大\",{\"1\":{\"177\":1}}],[\"元素值初始化为0\",{\"1\":{\"146\":1}}],[\"元素值的最大和为\",{\"1\":{\"95\":1}}],[\"元素4\",{\"1\":{\"141\":1}}],[\"元素\",{\"1\":{\"48\":1}}],[\"涉及获取\",{\"1\":{\"768\":1}}],[\"耗资源\",{\"1\":{\"768\":1}}],[\"耗费时间\",{\"1\":{\"642\":1}}],[\"理论上每次只锁定当前操作的数据的方案会得到最大的并发度\",{\"1\":{\"768\":1}}],[\"英文用\",{\"1\":{\"767\":2}}],[\"英文名\",{\"1\":{\"710\":1,\"770\":1}}],[\"英文名是\",{\"1\":{\"668\":1}}],[\"共享资源每次只给一个线程使用\",{\"1\":{\"781\":1}}],[\"共享gap锁\",{\"1\":{\"776\":1}}],[\"共享锁\",{\"1\":{\"767\":1,\"771\":1,\"791\":1}}],[\"共存\",{\"1\":{\"771\":1}}],[\"共63个字符\",{\"1\":{\"583\":1}}],[\"历史版本由undo日志\",{\"1\":{\"765\":1}}],[\"留一手\",{\"1\":{\"755\":1}}],[\"留给下一条边处理\",{\"1\":{\"288\":1}}],[\"己决定什么时候同步到磁盘文件\",{\"1\":{\"753\":1}}],[\"志的同步\",{\"1\":{\"753\":1}}],[\"刷盘操作\",{\"1\":{\"753\":1}}],[\"刷盘策略\",{\"0\":{\"753\":1}}],[\"刷新到磁盘\",{\"1\":{\"749\":1}}],[\"溃\",{\"1\":{\"749\":1}}],[\"刚写完缓冲池\",{\"1\":{\"749\":1}}],[\"刚开始想的是用递归\",{\"1\":{\"171\":1}}],[\"况就是事务提交后\",{\"1\":{\"749\":1}}],[\"久性\",{\"1\":{\"747\":1}}],[\"恢复\",{\"1\":{\"811\":1}}],[\"恢复命令\",{\"1\":{\"809\":1}}],[\"恢复之后可以选择回滚\",{\"1\":{\"757\":1}}],[\"恢复提交事务修改的页操作\",{\"1\":{\"747\":1}}],[\"恢复成\",{\"1\":{\"60\":1}}],[\"锁资源同时只能被同一个事务持有或者不兼容\",{\"1\":{\"786\":1}}],[\"锁升级就是用更大粒度的锁替代多个更小粒度的锁\",{\"1\":{\"779\":1}}],[\"锁升级\",{\"1\":{\"779\":1}}],[\"锁空间的大小是有限的\",{\"1\":{\"779\":1}}],[\"锁住某条记录\",{\"1\":{\"777\":1}}],[\"锁的开销比较大\",{\"1\":{\"774\":1}}],[\"锁的不同角度的分类\",{\"0\":{\"766\":1}}],[\"锁冲突概率低\",{\"1\":{\"774\":1}}],[\"锁冲突也是影响数据库\",{\"1\":{\"760\":1}}],[\"锁定粒度介于表锁和行锁之间\",{\"1\":{\"779\":1}}],[\"锁定的数据资源比行锁要多\",{\"1\":{\"779\":1}}],[\"锁定力度小\",{\"1\":{\"774\":1}}],[\"锁定时间\",{\"1\":{\"699\":1}}],[\"锁粒度\",{\"1\":{\"768\":1,\"770\":1}}],[\"锁结构与之关联\",{\"1\":{\"763\":1}}],[\"锁结构\",{\"1\":{\"763\":6}}],[\"锁机制也为实现mysql\",{\"1\":{\"760\":1}}],[\"锁机制实现\",{\"1\":{\"747\":1}}],[\"锁\",{\"0\":{\"760\":1},\"1\":{\"771\":4,\"772\":1}}],[\"免脏读\",{\"1\":{\"746\":1}}],[\"幻影记录\",{\"1\":{\"746\":1}}],[\"幻读问题仍然存在\",{\"1\":{\"746\":1}}],[\"幻读\",{\"1\":{\"746\":3,\"764\":2,\"765\":1,\"793\":1}}],[\"脏数据了\",{\"1\":{\"846\":1}}],[\"脏读\",{\"1\":{\"746\":2,\"764\":1,\"765\":1,\"793\":1}}],[\"脏写的问题\",{\"1\":{\"763\":1}}],[\"脏写\",{\"1\":{\"746\":3}}],[\"滚前会暂时关闭掉自动提交的功能\",{\"1\":{\"745\":1}}],[\"滚动数组\",{\"1\":{\"92\":1}}],[\"③\",{\"0\":{\"772\":1,\"777\":1},\"1\":{\"744\":1,\"822\":1}}],[\"读请求\",{\"1\":{\"821\":1}}],[\"读库\",{\"1\":{\"819\":1}}],[\"读多写少\",{\"1\":{\"818\":1,\"819\":1}}],[\"读操作多\",{\"1\":{\"783\":1}}],[\"读操作可以加读锁\",{\"1\":{\"767\":1}}],[\"读操作利用多版本并发控制\",{\"1\":{\"765\":1}}],[\"读锁和写锁可以加在表上\",{\"1\":{\"767\":1}}],[\"读锁\",{\"0\":{\"767\":1},\"1\":{\"767\":1,\"773\":1,\"781\":1}}],[\"读写分离\",{\"1\":{\"818\":1,\"819\":1}}],[\"读写之间阻塞的问题\",{\"1\":{\"801\":1}}],[\"读写或写读的情况\",{\"0\":{\"764\":1}}],[\"读写事务\",{\"1\":{\"744\":2}}],[\"读\",{\"1\":{\"762\":2,\"764\":2,\"765\":1,\"783\":1,\"791\":1}}],[\"读读的情况\",{\"0\":{\"762\":1}}],[\"读到的还是原来的内容\",{\"1\":{\"746\":1}}],[\"读已提交解决了脏读\",{\"1\":{\"793\":1}}],[\"读已提交\",{\"1\":{\"746\":1,\"799\":2}}],[\"读未提交不能解决\",{\"1\":{\"793\":1}}],[\"读未提交\",{\"1\":{\"746\":1}}],[\"读取完成之后\",{\"1\":{\"820\":1}}],[\"读取\",{\"1\":{\"820\":1}}],[\"读取顺畅的另一个原因\",{\"1\":{\"819\":1}}],[\"读取更加顺畅\",{\"1\":{\"819\":1}}],[\"读取数据时并不需要加锁\",{\"1\":{\"801\":1}}],[\"读取时还要保证其他并发事务不能修改当前记录\",{\"1\":{\"791\":1}}],[\"读取操作本身不会对记录有任何影响\",{\"1\":{\"762\":1}}],[\"读取相同的记录\",{\"1\":{\"762\":1}}],[\"读取了一个字段\",{\"1\":{\"746\":1}}],[\"读取了已经被\",{\"1\":{\"746\":1}}],[\"读取的是快照数据\",{\"1\":{\"791\":1}}],[\"读取的内容就是\",{\"1\":{\"746\":1}}],[\"读取的配置文件可以通过\",{\"1\":{\"452\":1}}],[\"读取行指针和\",{\"1\":{\"725\":1}}],[\"读取超时时间\",{\"1\":{\"466\":1}}],[\"务处在了中止的\",{\"1\":{\"742\":1}}],[\"败的状态\",{\"1\":{\"742\":1}}],[\"失\",{\"1\":{\"742\":1}}],[\"失败的状态\",{\"1\":{\"742\":1}}],[\"失败的\",{\"1\":{\"742\":1}}],[\"失败\",{\"1\":{\"476\":1}}],[\"活跃\",{\"1\":{\"796\":1}}],[\"活跃的事务id有\",{\"1\":{\"797\":1}}],[\"活跃的事务中最小的事务\",{\"1\":{\"797\":1}}],[\"活跃的\",{\"1\":{\"742\":1}}],[\"活动的或者\",{\"1\":{\"742\":1}}],[\"活动的\",{\"1\":{\"742\":1}}],[\"余额并没有增加\",{\"1\":{\"741\":1}}],[\"余额这列必须>=0\",{\"1\":{\"741\":1}}],[\"跟缓存双删的方案一样\",{\"1\":{\"850\":1}}],[\"跟具体的业务有关\",{\"1\":{\"741\":1}}],[\"跟在列的定义后面\",{\"1\":{\"613\":1}}],[\"商品名\",{\"1\":{\"737\":2}}],[\"商品编号采用的数据类型是\",{\"1\":{\"598\":1}}],[\"仓库名\",{\"1\":{\"737\":2}}],[\"巴克斯范式\",{\"1\":{\"737\":1}}],[\"巴斯\",{\"1\":{\"736\":1}}],[\"法插入\",{\"1\":{\"737\":1}}],[\"得分\",{\"1\":{\"737\":1}}],[\"得到按照时间排序的前10条里面含有左连接的查询语句\",{\"1\":{\"699\":1}}],[\"得到访问次数最多的10个sql\",{\"1\":{\"699\":1}}],[\"得到返回记录集最多的10个sql\",{\"1\":{\"699\":1}}],[\"得到查询时间最多的10个sql\",{\"1\":{\"699\":1}}],[\"得到长度等工作\",{\"1\":{\"604\":1}}],[\"得到输入数组\",{\"1\":{\"276\":1}}],[\"得到的字符串仍然是\",{\"1\":{\"367\":1}}],[\"得到的方法数量只有\",{\"1\":{\"103\":1}}],[\"得到的是\",{\"1\":{\"87\":1}}],[\"得到的是根结点左子树的个数\",{\"1\":{\"47\":1}}],[\"得到\",{\"1\":{\"96\":4}}],[\"→\",{\"1\":{\"737\":1}}],[\"何元组\",{\"1\":{\"737\":1}}],[\"球队所在地\",{\"1\":{\"736\":1}}],[\"球队表\",{\"1\":{\"736\":1}}],[\"球队编号\",{\"1\":{\"736\":2}}],[\"球员编号\",{\"1\":{\"736\":1,\"737\":2}}],[\"球员表\",{\"1\":{\"736\":1}}],[\"候选键\",{\"1\":{\"736\":1}}],[\"键和相关属性的概念\",{\"1\":{\"736\":1}}],[\"键值的方式来存储数据\",{\"1\":{\"510\":1}}],[\"键值型数据库通过\",{\"1\":{\"510\":1}}],[\"键值型数据库\",{\"1\":{\"510\":1}}],[\"范式的定义会使用到主键和候选键\",{\"1\":{\"736\":1}}],[\"范式\",{\"1\":{\"736\":1}}],[\"范围条件右边的列索引失效\",{\"0\":{\"718\":1}}],[\"范围查找速度非常快\",{\"1\":{\"650\":1}}],[\"范围为1～4\",{\"1\":{\"555\":1}}],[\"范围内使用4个不同的数字\",{\"1\":{\"189\":1}}],[\"范围内的回文串长度\",{\"1\":{\"157\":2}}],[\"范围内的s串的回文串的长度为\",{\"1\":{\"157\":1}}],[\"范围内的s串\",{\"1\":{\"157\":1}}],[\"范围内的字符串就是回文子串\",{\"1\":{\"155\":1}}],[\"范围内的字符串是否是回文子串\",{\"1\":{\"155\":3}}],[\"范围内\",{\"1\":{\"17\":1,\"23\":1,\"40\":1,\"53\":1,\"116\":1}}],[\"科德范式\",{\"1\":{\"736\":1}}],[\"毕竟设置架构本身是有成本的\",{\"1\":{\"818\":1}}],[\"毕竟\",{\"1\":{\"732\":1}}],[\"易主的问题\",{\"1\":{\"732\":1}}],[\"噩梦\",{\"1\":{\"731\":1}}],[\"几乎所有数据库都支持自增类型\",{\"1\":{\"731\":1}}],[\"化方式\",{\"1\":{\"728\":1}}],[\"弊端\",{\"1\":{\"727\":1}}],[\"般分页查询时\",{\"1\":{\"726\":1}}],[\"遵照索引建的最佳左前缀法则\",{\"1\":{\"726\":1}}],[\"遵循如下规则\",{\"1\":{\"216\":1}}],[\"间隔一段时间再去删除缓存\",{\"1\":{\"848\":1}}],[\"间小\",{\"1\":{\"830\":1}}],[\"间隙\",{\"1\":{\"778\":1}}],[\"间隙锁的引入\",{\"1\":{\"776\":1}}],[\"间隙锁\",{\"0\":{\"776\":1}}],[\"间\",{\"1\":{\"725\":1}}],[\"间段的日期时间\",{\"1\":{\"557\":1}}],[\"丢失b索引\",{\"1\":{\"725\":1}}],[\"丢失a索引\",{\"1\":{\"725\":1}}],[\"序号\",{\"1\":{\"813\":1}}],[\"序不一定比索引慢\",{\"1\":{\"725\":1}}],[\"序列化的输出按层序遍历排列\",{\"1\":{\"23\":1}}],[\"描\",{\"1\":{\"725\":1}}],[\"描述各种页的通用信息\",{\"1\":{\"668\":1}}],[\"描述\",{\"1\":{\"559\":1}}],[\"描述转化为包含小时\",{\"1\":{\"556\":1}}],[\"②\",{\"0\":{\"776\":1},\"1\":{\"724\":1,\"729\":1,\"744\":1,\"822\":1}}],[\"撤销这些临时表\",{\"1\":{\"724\":1}}],[\"撤销处理过的结点\",{\"1\":{\"187\":2,\"188\":1}}],[\"撤销处理结果\",{\"1\":{\"185\":2,\"222\":1}}],[\"①\",{\"0\":{\"770\":1,\"771\":1,\"775\":1},\"1\":{\"724\":1,\"729\":1,\"744\":1,\"822\":1}}],[\"扫描指定的索引idx\",{\"1\":{\"710\":1}}],[\"括号中的`\",{\"1\":{\"710\":1}}],[\"括起来\",{\"1\":{\"524\":1}}],[\"见课件说明\",{\"1\":{\"710\":1}}],[\"帮你检查是否充分的利用上了索引\",{\"1\":{\"706\":1}}],[\"帮助企业迅速搭建客户触达通道\",{\"1\":{\"399\":2}}],[\"帮助访问处理的结点\",{\"1\":{\"7\":1}}],[\"帮助我们访问结点\",{\"1\":{\"7\":1}}],[\"☆\",{\"0\":{\"706\":1,\"710\":1}}],[\"越先执行\",{\"1\":{\"702\":1}}],[\"越接近1越好\",{\"1\":{\"689\":1}}],[\"永久启动\",{\"1\":{\"806\":1}}],[\"永久性的\",{\"1\":{\"741\":1}}],[\"永久关闭\",{\"1\":{\"698\":1}}],[\"永久生效\",{\"1\":{\"635\":1}}],[\"认为是超出了我们的最大忍耐时间值\",{\"1\":{\"697\":1}}],[\"认值\",{\"1\":{\"620\":1}}],[\"意向排他锁\",{\"1\":{\"771\":1}}],[\"意向共享锁\",{\"1\":{\"771\":1}}],[\"意向锁是兼容的\",{\"1\":{\"771\":1}}],[\"意向锁是由存储引擎\",{\"1\":{\"771\":1}}],[\"意向锁是一种\",{\"1\":{\"771\":1}}],[\"意向锁分为俩种\",{\"1\":{\"771\":1}}],[\"意向锁的存在是为了协调行锁和表锁的关系\",{\"1\":{\"771\":1}}],[\"意向锁\",{\"0\":{\"771\":1}}],[\"意思就是在内存中生成了对应的\",{\"1\":{\"763\":2}}],[\"意思就是不需要在内存中生成对应的\",{\"1\":{\"763\":1}}],[\"意思是我们只要知道了某个小査询的\",{\"1\":{\"703\":1}}],[\"意思是运行10秒以上\",{\"1\":{\"697\":1}}],[\"意味着当前事务在访问它自己修改过的记录\",{\"1\":{\"798\":1}}],[\"意味着\",{\"1\":{\"776\":1}}],[\"意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据\",{\"1\":{\"680\":1}}],[\"意味着它们都不是b+树的非叶子节点中的最小记录\",{\"1\":{\"680\":1}}],[\"倍\",{\"1\":{\"696\":1}}],[\"观察\",{\"1\":{\"694\":1}}],[\"身份证号\",{\"1\":{\"690\":1,\"736\":2}}],[\"身高相同\",{\"1\":{\"362\":1}}],[\"身高排好序之后\",{\"1\":{\"362\":1}}],[\"频繁更新的字段不一定要创建索引\",{\"1\":{\"690\":1}}],[\"频繁作为\",{\"1\":{\"689\":1}}],[\"散列性高\",{\"1\":{\"689\":1}}],[\"区分度高\",{\"1\":{\"689\":1}}],[\"区间去掉就行了\",{\"1\":{\"366\":1}}],[\"区间\",{\"1\":{\"70\":1,\"294\":2}}],[\"区间之内\",{\"1\":{\"64\":1}}],[\"区间内\",{\"1\":{\"25\":1}}],[\"长时间持有锁的\",{\"1\":{\"786\":1}}],[\"长会非常快\",{\"1\":{\"689\":1}}],[\"长度\",{\"1\":{\"588\":1}}],[\"长度正确的期望答案\",{\"1\":{\"312\":1}}],[\"长度最小的子数组\",{\"0\":{\"284\":1}}],[\"长度最长的公共子数组是\",{\"1\":{\"136\":1}}],[\"长度最长的子数组的长度\",{\"1\":{\"136\":1}}],[\"长度小相同\",{\"1\":{\"165\":1}}],[\"长度相等\",{\"1\":{\"162\":1}}],[\"长度为1\",{\"1\":{\"134\":1}}],[\"长度为3\",{\"1\":{\"134\":1}}],[\"速度\",{\"1\":{\"689\":1}}],[\"速度快\",{\"1\":{\"589\":1}}],[\"隐藏的\",{\"1\":{\"800\":1}}],[\"隐藏列\",{\"1\":{\"794\":1}}],[\"隐藏字段\",{\"0\":{\"794\":1},\"1\":{\"795\":1}}],[\"隐式事务\",{\"0\":{\"745\":1}}],[\"隐式方式\",{\"1\":{\"687\":1}}],[\"隐形转换\",{\"1\":{\"527\":1}}],[\"普通的select语句在read\",{\"1\":{\"765\":1}}],[\"普通索引创建的b+树只包含当前索引的列和主键\",{\"1\":{\"727\":1}}],[\"普通索引\",{\"1\":{\"686\":1}}],[\"普通用户记录\",{\"1\":{\"650\":1}}],[\"章节中讲解\",{\"1\":{\"681\":1}}],[\"章节用贪心算法已经做过了\",{\"1\":{\"143\":1}}],[\"示意图如下\",{\"1\":{\"680\":1}}],[\"示例代码\",{\"1\":{\"497\":1}}],[\"示例2\",{\"1\":{\"21\":1}}],[\"示例1\",{\"1\":{\"21\":1}}],[\"示例\",{\"1\":{\"11\":3,\"13\":3,\"15\":3,\"17\":2,\"19\":2,\"23\":2,\"25\":2,\"27\":2,\"30\":3,\"32\":2,\"34\":3,\"36\":3,\"38\":2,\"40\":2,\"42\":2,\"44\":3,\"46\":2,\"48\":2,\"50\":2,\"52\":2,\"53\":2,\"55\":2,\"57\":2,\"59\":2,\"61\":3,\"63\":2,\"65\":3,\"67\":3,\"69\":2,\"71\":2,\"73\":4,\"78\":3,\"80\":2,\"82\":2,\"84\":4,\"86\":2,\"88\":2,\"94\":2,\"96\":2,\"98\":2,\"100\":2,\"102\":3,\"104\":2,\"106\":3,\"108\":2,\"110\":3,\"112\":2,\"114\":3,\"116\":2,\"119\":2,\"121\":3,\"123\":4,\"125\":2,\"127\":2,\"129\":2,\"132\":3,\"134\":2,\"136\":2,\"138\":3,\"140\":3,\"142\":3,\"145\":2,\"147\":2,\"149\":2,\"151\":2,\"154\":2,\"156\":2,\"161\":2,\"164\":3,\"166\":2,\"169\":2,\"172\":3,\"174\":3,\"176\":3,\"178\":2,\"186\":2,\"189\":3,\"192\":3,\"194\":3,\"196\":2,\"198\":2,\"200\":3,\"202\":2,\"204\":2,\"206\":2,\"208\":3,\"210\":2,\"212\":2,\"214\":2,\"216\":1,\"223\":2,\"225\":2,\"227\":2,\"229\":2,\"231\":2,\"233\":2,\"240\":3,\"244\":3,\"246\":2,\"249\":2,\"252\":2,\"255\":2,\"257\":2,\"260\":2,\"266\":3,\"269\":2,\"273\":3,\"274\":2,\"275\":3,\"276\":3,\"277\":3,\"278\":2,\"281\":2,\"284\":3,\"287\":2,\"290\":4,\"294\":2,\"297\":2,\"300\":2,\"303\":2,\"306\":2,\"309\":2,\"312\":2,\"315\":2,\"321\":1,\"324\":3,\"327\":1,\"330\":3,\"333\":2,\"336\":2,\"343\":2,\"345\":3,\"347\":3,\"349\":2,\"351\":2,\"353\":3,\"355\":2,\"357\":2,\"359\":2,\"361\":2,\"363\":3,\"365\":3,\"367\":2,\"369\":3,\"371\":2,\"376\":3,\"379\":2,\"380\":3,\"383\":2,\"385\":3,\"388\":3,\"390\":3,\"393\":3}}],[\"专门存储各种状态信息\",{\"1\":{\"674\":1}}],[\"专门存储各个表的约束\",{\"1\":{\"613\":1}}],[\"专门给记录做一个目录\",{\"1\":{\"673\":1}}],[\"部分提交的状态的事务将修改过的数据都处\",{\"1\":{\"742\":1}}],[\"部分提交的状态时\",{\"1\":{\"742\":1}}],[\"部分提交的状态\",{\"1\":{\"742\":1}}],[\"部分提交的\",{\"1\":{\"742\":1}}],[\"部分\",{\"1\":{\"670\":1}}],[\"部门编号依赖于员工编号\",{\"1\":{\"737\":1}}],[\"部门编号\",{\"1\":{\"737\":2}}],[\"部门简介等信息\",{\"1\":{\"737\":1}}],[\"部门信息表\",{\"1\":{\"737\":1}}],[\"部门表\",{\"1\":{\"618\":1}}],[\"部门\",{\"1\":{\"578\":2}}],[\"部门id和其最低工资\",{\"1\":{\"574\":1}}],[\"部门所在城市名称\",{\"1\":{\"533\":1}}],[\"部门名称依赖于部门编号\",{\"1\":{\"737\":1}}],[\"部门名称\",{\"1\":{\"533\":1,\"737\":4}}],[\"造成了数据不一致的问题\",{\"1\":{\"848\":1}}],[\"造成了该页传输的不完整\",{\"1\":{\"668\":1}}],[\"造出来的二分搜索树如下图所示\",{\"1\":{\"659\":1}}],[\"十九\",{\"0\":{\"816\":1}}],[\"十八\",{\"0\":{\"804\":1}}],[\"十七\",{\"0\":{\"789\":1}}],[\"十六\",{\"0\":{\"760\":1}}],[\"十五\",{\"0\":{\"740\":1}}],[\"十四\",{\"0\":{\"736\":1}}],[\"十三\",{\"0\":{\"713\":1}}],[\"十二\",{\"0\":{\"693\":1}}],[\"十一\",{\"0\":{\"684\":1}}],[\"十\",{\"0\":{\"665\":1}}],[\"十分频繁改变的column\",{\"1\":{\"604\":1}}],[\"事件\",{\"1\":{\"831\":1}}],[\"事后还需要刷新回磁盘\",{\"1\":{\"747\":1}}],[\"事实上\",{\"1\":{\"660\":1}}],[\"事务提交的时候\",{\"1\":{\"810\":1}}],[\"事务b执行插入操作\",{\"1\":{\"800\":1}}],[\"事务a开始第二次查询\",{\"1\":{\"800\":1}}],[\"事务a开始第一次查询\",{\"1\":{\"800\":1}}],[\"事务a在读到一条数据之后\",{\"1\":{\"746\":1}}],[\"事务修改过的记录\",{\"1\":{\"797\":1}}],[\"事务id列表\",{\"1\":{\"797\":1}}],[\"事务id\",{\"1\":{\"794\":1}}],[\"事务id和回滚指针在后面的\",{\"1\":{\"681\":1}}],[\"事务之间因为持有锁和申请锁导致彼此循环等待\",{\"1\":{\"786\":1}}],[\"事务级别在\",{\"1\":{\"777\":1}}],[\"事务要获取某些行的\",{\"1\":{\"771\":2}}],[\"事务有意向对表中的某些行加排他锁\",{\"1\":{\"771\":1}}],[\"事务有意向对表中的某些行加共享锁\",{\"1\":{\"771\":1}}],[\"事务有4种特性\",{\"1\":{\"747\":1}}],[\"事务不可以读取到未提交的事务所做的更改\",{\"1\":{\"765\":1}}],[\"事务t2\",{\"1\":{\"763\":1}}],[\"事务t1\",{\"1\":{\"763\":1}}],[\"事务未提交\",{\"1\":{\"757\":1}}],[\"事务需要保证\",{\"1\":{\"755\":1}}],[\"事务执行过程中可能遇到各种错误\",{\"1\":{\"755\":1}}],[\"事务执行过程中\",{\"1\":{\"750\":1,\"810\":1}}],[\"事务包含\",{\"1\":{\"749\":1}}],[\"事务日志\",{\"0\":{\"747\":1}}],[\"事务对应的数据库操作正在执行过程中时\",{\"1\":{\"742\":1}}],[\"事务大致划分成几个状态\",{\"1\":{\"742\":1}}],[\"事务是一个抽象的概念\",{\"1\":{\"742\":1}}],[\"事务的隔离性由\",{\"1\":{\"747\":1}}],[\"事务的隔离性是指一个事务的执行\",{\"1\":{\"741\":1}}],[\"事务的隔离级别\",{\"0\":{\"746\":1}}],[\"事务的状态\",{\"0\":{\"742\":1}}],[\"事务的发起者\",{\"1\":{\"435\":1}}],[\"事务概述\",{\"0\":{\"741\":1}}],[\"事务数据页\",{\"1\":{\"667\":1}}],[\"事务\",{\"0\":{\"740\":1},\"1\":{\"636\":1,\"741\":1,\"763\":1,\"772\":1,\"800\":2}}],[\"事务且不触发\",{\"1\":{\"589\":1}}],[\"事务控制语\",{\"1\":{\"517\":1}}],[\"事务组与tc服务集群的映射关系\",{\"1\":{\"432\":1}}],[\"事务组\",{\"1\":{\"432\":1}}],[\"事务模式\",{\"1\":{\"426\":1}}],[\"伸展树\",{\"1\":{\"660\":1}}],[\"红黑树\",{\"1\":{\"660\":1}}],[\"红色都是从\",{\"1\":{\"304\":1}}],[\"人们提出了平衡二叉搜索树\",{\"1\":{\"660\":1}}],[\"人们把\",{\"1\":{\"635\":1}}],[\"创\",{\"1\":{\"659\":1}}],[\"创建这个\",{\"1\":{\"797\":1}}],[\"创建联合索引\",{\"1\":{\"718\":1}}],[\"创建索引注意事项\",{\"1\":{\"689\":1}}],[\"创建索引和维护索引要\",{\"1\":{\"642\":1}}],[\"创建好语法树后\",{\"1\":{\"628\":1}}],[\"创建子表时\",{\"1\":{\"618\":1}}],[\"创建方式二\",{\"1\":{\"587\":1}}],[\"创建方式一\",{\"1\":{\"587\":1}}],[\"创建表之后增加索引\",{\"1\":{\"687\":1}}],[\"创建表格后指定\",{\"1\":{\"676\":1}}],[\"创建表格时指定\",{\"1\":{\"676\":1}}],[\"创建表\",{\"0\":{\"587\":1},\"1\":{\"608\":1}}],[\"创建数据库并指定字符集\",{\"1\":{\"585\":1}}],[\"创建数据库\",{\"0\":{\"585\":1}}],[\"创建数据表\",{\"1\":{\"582\":1}}],[\"创建和管理数据库\",{\"0\":{\"584\":1}}],[\"创建和管理表\",{\"0\":{\"582\":1}}],[\"创建\",{\"1\":{\"504\":1,\"618\":1}}],[\"创建网关服务模块\",{\"1\":{\"489\":1}}],[\"创建ordercircuitcontroller\",{\"1\":{\"477\":1}}],[\"创建配置文件\",{\"1\":{\"442\":1}}],[\"创建一个表\",{\"1\":{\"643\":1}}],[\"创建一个字段\",{\"1\":{\"513\":1}}],[\"创建一个\",{\"1\":{\"454\":1,\"497\":1}}],[\"创建一个名称为\",{\"1\":{\"442\":1}}],[\"创建一个根节点\",{\"1\":{\"50\":1}}],[\"创建时间\",{\"1\":{\"440\":1}}],[\"创建订单\",{\"1\":{\"432\":2}}],[\"创建中\",{\"1\":{\"431\":1,\"432\":2}}],[\"创建三个数据库\",{\"1\":{\"431\":1}}],[\"创建的是大顶堆\",{\"1\":{\"338\":1}}],[\"冲突时\",{\"1\":{\"658\":1}}],[\"冲突则换下一列\",{\"1\":{\"215\":1}}],[\"拉链法来解决\",{\"1\":{\"658\":1}}],[\"碰撞\",{\"1\":{\"658\":1}}],[\"磁盘取其他字段\",{\"1\":{\"725\":1}}],[\"磁盘与内存交互的基本单位是页\",{\"1\":{\"749\":1}}],[\"磁盘与内存交互的基本单位\",{\"0\":{\"666\":1}}],[\"磁盘的i\",{\"1\":{\"657\":1}}],[\"磁盘空间\",{\"1\":{\"642\":1}}],[\"页脚\",{\"1\":{\"858\":1,\"861\":1}}],[\"页锁的开销介于表锁和行锁之间\",{\"1\":{\"779\":1}}],[\"页锁就是在页的粒度上进行锁定\",{\"1\":{\"779\":1}}],[\"页锁\",{\"0\":{\"768\":1,\"779\":1}}],[\"页结构的示意图如下所示\",{\"1\":{\"667\":1}}],[\"页头\",{\"1\":{\"667\":1}}],[\"页和\",{\"1\":{\"667\":1}}],[\"页如果按类型划分的话\",{\"1\":{\"667\":1}}],[\"页\",{\"0\":{\"666\":1},\"1\":{\"666\":1,\"835\":2}}],[\"页面都会被转换为一个\",{\"1\":{\"886\":1}}],[\"页面内容\",{\"0\":{\"885\":1}}],[\"页面标题\",{\"0\":{\"883\":1},\"1\":{\"883\":1}}],[\"页面配置\",{\"0\":{\"882\":1},\"1\":{\"884\":1},\"2\":{\"888\":1}}],[\"页面引入配置\",{\"1\":{\"866\":1}}],[\"页面信息\",{\"0\":{\"884\":1},\"1\":{\"858\":1}}],[\"页面中偏移量为\",{\"1\":{\"749\":1}}],[\"页面头部\",{\"0\":{\"674\":1}}],[\"页面被最后修改时对应的日志序列位置\",{\"1\":{\"668\":1}}],[\"页面回收等操作来维护好节点和记录的排序\",{\"1\":{\"656\":1}}],[\"页面分裂\",{\"1\":{\"656\":1}}],[\"页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录\",{\"1\":{\"680\":1}}],[\"页目录中存储了多少个槽等等\",{\"1\":{\"674\":1}}],[\"页目录\",{\"0\":{\"673\":1},\"1\":{\"645\":1}}],[\"占用大量的磁盘空间\",{\"1\":{\"805\":1}}],[\"占用\",{\"1\":{\"725\":1}}],[\"占用1个二进制位\",{\"1\":{\"680\":1}}],[\"占用16kb的存储空间\",{\"1\":{\"656\":1}}],[\"占用内存高\",{\"1\":{\"655\":1}}],[\"占用字节多\",{\"1\":{\"599\":1}}],[\"占用字节少\",{\"1\":{\"599\":1}}],[\"照c2\",{\"1\":{\"652\":1}}],[\"太浪费空间\",{\"1\":{\"651\":1}}],[\"太平洋同时可以到达的地点\",{\"1\":{\"234\":1}}],[\"太平洋\",{\"1\":{\"233\":2}}],[\"据c2列的值查找到完整的用户记录的话\",{\"1\":{\"651\":1}}],[\"辅助索引\",{\"0\":{\"651\":1}}],[\"辅助矩阵\",{\"1\":{\"298\":1}}],[\"响性能\",{\"1\":{\"650\":1}}],[\"响应时间超过阀值\",{\"1\":{\"697\":1}}],[\"响应时间超过200ms\",{\"1\":{\"413\":1}}],[\"响应状态码及执行时间\",{\"1\":{\"470\":1}}],[\"响应压缩\",{\"0\":{\"469\":1},\"1\":{\"469\":2}}],[\"响应体\",{\"1\":{\"422\":1}}],[\"响应的状态\",{\"1\":{\"422\":1}}],[\"响应内容\",{\"1\":{\"422\":2}}],[\"聚集\",{\"1\":{\"649\":1}}],[\"聚簇索引和非聚簇索引\",{\"1\":{\"686\":1}}],[\"聚簇索引中再查一遍\",{\"1\":{\"651\":1}}],[\"聚簇索引对于主键的\",{\"1\":{\"650\":1}}],[\"聚簇索引更快\",{\"1\":{\"650\":1}}],[\"聚簇索引并不是一种单独的索引类型\",{\"1\":{\"650\":1}}],[\"聚簇索引\",{\"0\":{\"650\":1},\"1\":{\"655\":1}}],[\"聚簇\",{\"1\":{\"649\":1,\"728\":1}}],[\"聚合\",{\"1\":{\"561\":1}}],[\"聚合函数不能嵌套\",{\"1\":{\"578\":1}}],[\"聚合函数\",{\"0\":{\"561\":1}}],[\"称之为\",{\"1\":{\"654\":1,\"775\":1}}],[\"称为\",{\"1\":{\"643\":1,\"747\":2}}],[\"称作\",{\"1\":{\"145\":1}}],[\"立一个目录\",{\"1\":{\"643\":1}}],[\"箭头来表明下一条记录是谁\",{\"1\":{\"643\":1}}],[\"件更快达到最大文件尺寸\",{\"1\":{\"642\":1}}],[\"件进行执行\",{\"1\":{\"570\":1}}],[\"便可快速定位到需要的文章\",{\"1\":{\"641\":1}}],[\"便可以凑成dp\",{\"1\":{\"109\":1}}],[\"九\",{\"0\":{\"640\":1}}],[\"压缩\",{\"1\":{\"637\":1}}],[\"査询数据字典\",{\"1\":{\"729\":1}}],[\"査询优化\",{\"1\":{\"635\":1}}],[\"査询缓存\",{\"1\":{\"635\":1}}],[\"物理备份恢复速度比较快\",{\"1\":{\"830\":1}}],[\"物理备份\",{\"1\":{\"830\":1}}],[\"物理日志\",{\"1\":{\"811\":1}}],[\"物理实现\",{\"1\":{\"686\":1}}],[\"物理查询优化阶段\",{\"1\":{\"634\":1}}],[\"物品为每一个完全平方数\",{\"1\":{\"109\":1}}],[\"物品一个一个尝试\",{\"1\":{\"101\":1}}],[\"物品的价值\",{\"1\":{\"95\":1}}],[\"物品i的价值\",{\"1\":{\"91\":1}}],[\"物品i的重量\",{\"1\":{\"91\":1}}],[\"物品2\",{\"1\":{\"91\":1}}],[\"物品1\",{\"1\":{\"91\":1}}],[\"物品0\",{\"1\":{\"91\":1}}],[\"识别成\",{\"1\":{\"634\":2}}],[\"句\",{\"1\":{\"634\":1}}],[\"词法分析\",{\"1\":{\"634\":1}}],[\"备份中包含存储过程\",{\"1\":{\"831\":1}}],[\"备份单表的部分数据\",{\"1\":{\"831\":1}}],[\"备份部份表\",{\"1\":{\"831\":1}}],[\"备份部分数据库\",{\"1\":{\"831\":1}}],[\"备份文件中会存在创建数据库的语句\",{\"1\":{\"831\":1}}],[\"备份文件名称\",{\"1\":{\"831\":3}}],[\"备份所有数据库\",{\"1\":{\"831\":1}}],[\"备份的文件并非一定要求后缀名为\",{\"1\":{\"831\":1}}],[\"备份一个数据库\",{\"1\":{\"831\":1}}],[\"备份数据文件\",{\"1\":{\"830\":1}}],[\"备份\",{\"0\":{\"830\":1}}],[\"备\",{\"1\":{\"632\":1}}],[\"插件来实现\",{\"1\":{\"867\":1}}],[\"插件式存储引擎层\",{\"1\":{\"631\":1}}],[\"插入速度\",{\"1\":{\"837\":1}}],[\"插入速度严重依赖于插入顺序\",{\"1\":{\"650\":1}}],[\"插入操作需要等待\",{\"1\":{\"778\":1}}],[\"插入意向锁是一种\",{\"1\":{\"778\":1}}],[\"插入意向锁\",{\"0\":{\"778\":1},\"1\":{\"778\":1}}],[\"插入入了一些新的行\",{\"1\":{\"746\":1}}],[\"插入异常\",{\"1\":{\"737\":1}}],[\"插入重复的set类型成员时\",{\"1\":{\"607\":1}}],[\"插入null也是有效的\",{\"1\":{\"606\":1}}],[\"插入多条数据\",{\"1\":{\"542\":1}}],[\"插入数据\",{\"1\":{\"542\":1,\"582\":1,\"608\":1,\"680\":1}}],[\"插入订单成功后获得插入mysql的实体对象\",{\"1\":{\"432\":1}}],[\"插入订单\",{\"1\":{\"432\":1}}],[\"插入到表中就好了\",{\"1\":{\"755\":1}}],[\"插入到\",{\"1\":{\"384\":1}}],[\"插入的过程\",{\"1\":{\"362\":1}}],[\"插入等等等\",{\"1\":{\"337\":1}}],[\"插入\",{\"1\":{\"151\":1,\"362\":6,\"658\":2,\"778\":2}}],[\"插入一个字符\",{\"1\":{\"151\":1}}],[\"权限缓存等\",{\"1\":{\"630\":1}}],[\"权限获取\",{\"1\":{\"625\":1}}],[\"验证该客户端是否具有执行该查询的权限\",{\"1\":{\"628\":1}}],[\"典丰富查询语法树\",{\"1\":{\"628\":1}}],[\"典型产品\",{\"1\":{\"510\":1}}],[\"典型的键值型数据库使用场景是作为缓存\",{\"1\":{\"510\":1}}],[\"误\",{\"1\":{\"628\":1}}],[\"传统模式\",{\"1\":{\"772\":1}}],[\"传递到后续步骤\",{\"1\":{\"628\":1}}],[\"传输过来的账号密码做身份认证\",{\"1\":{\"625\":1}}],[\"义函数等多种sql语言接口\",{\"1\":{\"627\":1}}],[\"省去了创建和销毁线程的开销\",{\"1\":{\"625\":1}}],[\"省略多个表的连接条件\",{\"1\":{\"533\":1}}],[\"省略sql操作\",{\"1\":{\"464\":1}}],[\"省略了~\",{\"1\":{\"433\":1,\"434\":1}}],[\"赖于此时读到的权限\",{\"1\":{\"625\":1}}],[\"段文本\",{\"1\":{\"624\":1}}],[\"八\",{\"0\":{\"623\":1}}],[\"告诉其他人这个数据页或数据表已经有人上过排它锁了\",{\"1\":{\"771\":1}}],[\"告\",{\"1\":{\"619\":1}}],[\"允\",{\"1\":{\"618\":1}}],[\"允许按照角标的方式获取指定索引位置的枚举值\",{\"1\":{\"606\":1}}],[\"允许执行的最大请求数\",{\"1\":{\"482\":1}}],[\"允许一些请求通过以测试服务是否恢复正常\",{\"1\":{\"477\":1}}],[\"手动删除后\",{\"1\":{\"698\":1}}],[\"手动删除对应的索引\",{\"1\":{\"618\":1}}],[\"手动在控制台增加流控规则\",{\"1\":{\"422\":1}}],[\"员工编号\",{\"1\":{\"737\":1}}],[\"员工信息表\",{\"1\":{\"737\":1}}],[\"员工表\",{\"1\":{\"618\":1}}],[\"员工表的员工所在部门的选择\",{\"1\":{\"618\":1}}],[\"员工所在部门\",{\"1\":{\"612\":1}}],[\"型不一样\",{\"1\":{\"618\":1}}],[\"型\",{\"1\":{\"617\":1}}],[\"配合来使用\",{\"1\":{\"818\":1}}],[\"配合唯一列\",{\"1\":{\"617\":1}}],[\"配置需要复制的主机\",{\"0\":{\"826\":1}}],[\"配置consul地址\",{\"1\":{\"489\":1}}],[\"配置参数\",{\"1\":{\"480\":1}}],[\"配置了降级\",{\"1\":{\"478\":1}}],[\"配置time\",{\"1\":{\"477\":1,\"478\":1}}],[\"配置在客户端\",{\"1\":{\"477\":1}}],[\"配置断路器计算错误率或者慢调用率的最小调用数\",{\"1\":{\"476\":1}}],[\"配置调用时间的峰值\",{\"1\":{\"476\":1}}],[\"配置开启\",{\"1\":{\"468\":1}}],[\"配置不会丢失\",{\"1\":{\"454\":1}}],[\"配置持久化\",{\"0\":{\"454\":1}}],[\"配置规则\",{\"1\":{\"452\":1}}],[\"配置中心\",{\"1\":{\"449\":1}}],[\"配置中的\",{\"1\":{\"424\":1}}],[\"配置管理系统\",{\"1\":{\"449\":1}}],[\"配置管理和服务管理平台\",{\"1\":{\"399\":1,\"400\":1}}],[\"配置限流之后\",{\"1\":{\"422\":2}}],[\"配置简单\",{\"1\":{\"422\":1}}],[\"配置格式一定要选择\",{\"1\":{\"419\":1}}],[\"配置授权规则\",{\"1\":{\"418\":1}}],[\"配置流控规则\",{\"1\":{\"416\":1}}],[\"配置sentinel控制台的地址\",{\"1\":{\"422\":2}}],[\"配置sentinel\",{\"1\":{\"408\":1,\"420\":1}}],[\"配置\",{\"0\":{\"429\":1,\"866\":1},\"1\":{\"404\":1,\"450\":1,\"452\":1,\"478\":1,\"481\":1,\"482\":1,\"486\":1,\"504\":1}}],[\"配置文件中配置的路由条目\",{\"1\":{\"421\":1}}],[\"配置文件动态刷新功能\",{\"1\":{\"403\":1}}],[\"配置文件来配置\",{\"1\":{\"403\":1}}],[\"配置文件\",{\"1\":{\"403\":1,\"429\":1,\"452\":2}}],[\"配置类方式\",{\"0\":{\"423\":1},\"1\":{\"422\":1,\"423\":1}}],[\"配置类\",{\"1\":{\"402\":1,\"423\":1,\"446\":1,\"497\":1}}],[\"配置nacos地址\",{\"1\":{\"402\":1,\"420\":1}}],[\"配置更改时自动刷新\",{\"1\":{\"399\":1}}],[\"赋值给trx\",{\"1\":{\"794\":1}}],[\"赋值为具体值\",{\"1\":{\"617\":1}}],[\"赋予resttemplate负载均衡的能力\",{\"1\":{\"402\":1}}],[\"建立账户并授权\",{\"0\":{\"825\":1}}],[\"建立一个临时表\",{\"1\":{\"724\":1}}],[\"建立索引以后\",{\"1\":{\"686\":1}}],[\"建立主键约束可以在列级别创建\",{\"1\":{\"616\":1}}],[\"建这个目录必须完成下边这些事\",{\"1\":{\"643\":1}}],[\"建\",{\"1\":{\"643\":1}}],[\"建表后\",{\"1\":{\"615\":1,\"616\":1,\"618\":1}}],[\"建表之后\",{\"1\":{\"614\":1}}],[\"建表时\",{\"1\":{\"614\":1,\"615\":1,\"616\":1,\"618\":1}}],[\"建议mysql版本一致且后台以服务运行\",{\"1\":{\"823\":1}}],[\"建议尽量不要用跟业务有关的字段做主键\",{\"1\":{\"732\":1}}],[\"建议明确字段\",{\"1\":{\"729\":1}}],[\"建议单独分出去\",{\"1\":{\"605\":1}}],[\"建议使用char\",{\"1\":{\"605\":1}}],[\"建议使用varchar类型\",{\"1\":{\"604\":1}}],[\"建议每个字段前都指明其所在的表\",{\"1\":{\"533\":1}}],[\"建议每次使用都打印出来\",{\"1\":{\"432\":1}}],[\"建议遵守\",{\"1\":{\"518\":1}}],[\"建议配合服务名\",{\"1\":{\"422\":1,\"489\":1}}],[\"建议看看\",{\"1\":{\"72\":1}}],[\"限制该索引的值必须是唯一的\",{\"1\":{\"686\":1}}],[\"限制\",{\"1\":{\"650\":1}}],[\"限定某个表的某个字段的引用完整性\",{\"1\":{\"618\":1}}],[\"限定某个字段\",{\"1\":{\"614\":1}}],[\"限流器每隔limitrefreshperiod刷新一次\",{\"1\":{\"482\":1}}],[\"限流的例子\",{\"1\":{\"482\":1}}],[\"限流\",{\"0\":{\"482\":1},\"1\":{\"472\":1,\"474\":1}}],[\"限流啦\",{\"1\":{\"422\":1}}],[\"限流阈值\",{\"1\":{\"419\":1}}],[\"限流降级功能的接入\",{\"1\":{\"399\":1}}],[\"密码不能为空等\",{\"1\":{\"612\":1}}],[\"密码更新均遵循以下步骤\",{\"1\":{\"255\":1}}],[\"女\",{\"1\":{\"612\":1,\"690\":1}}],[\"男\",{\"1\":{\"612\":1,\"690\":1}}],[\"性别\",{\"1\":{\"690\":1}}],[\"性别范围\",{\"1\":{\"612\":1}}],[\"性能差\",{\"1\":{\"731\":1}}],[\"性能就会更好\",{\"1\":{\"724\":1}}],[\"性能参数如下\",{\"1\":{\"695\":1}}],[\"性能参数\",{\"1\":{\"695\":1}}],[\"性能分析工具的使用\",{\"0\":{\"693\":1}}],[\"性能非常高\",{\"1\":{\"510\":1}}],[\"性能和效率比较低\",{\"1\":{\"468\":1}}],[\"域完整性\",{\"1\":{\"612\":1}}],[\"七\",{\"0\":{\"611\":1}}],[\"七种join的使用\",{\"0\":{\"541\":1}}],[\"松地传递这个字符串\",{\"1\":{\"608\":1}}],[\"忽略大小写\",{\"1\":{\"606\":1}}],[\"忽略元素顺序\",{\"1\":{\"257\":1}}],[\"冬\",{\"1\":{\"606\":1}}],[\"秋\",{\"1\":{\"606\":2}}],[\"夏\",{\"1\":{\"606\":1}}],[\"春\",{\"1\":{\"606\":2}}],[\"哪些索引被实际使用\",{\"1\":{\"700\":1}}],[\"哪些索引可以使用\",{\"1\":{\"700\":1}}],[\"哪些情况不适合创建索引\",{\"0\":{\"690\":1}}],[\"哪些情况适合创建索引\",{\"0\":{\"689\":1}}],[\"哪些情况用\",{\"1\":{\"604\":1}}],[\"哪些情况用char\",{\"1\":{\"604\":1}}],[\"哪个业务字段会因为项目的业务需求而有重复\",{\"1\":{\"732\":1}}],[\"哪个效率更高\",{\"1\":{\"729\":1}}],[\"哪个服务需要监控就配置哪个服务\",{\"1\":{\"486\":1}}],[\"哪个加油站开始走\",{\"1\":{\"356\":1}}],[\"声明的字段长度即为char类型字段所占的存储空间的字节数\",{\"1\":{\"604\":1}}],[\"及金额计算的场景\",{\"1\":{\"600\":1}}],[\"力学等\",{\"1\":{\"600\":1}}],[\"于是就进入了\",{\"1\":{\"634\":1}}],[\"于是代码如下\",{\"1\":{\"177\":1}}],[\"于需要取值范围大\",{\"1\":{\"600\":1}}],[\"果\",{\"1\":{\"630\":1,\"746\":1}}],[\"果错误\",{\"1\":{\"599\":1}}],[\"果m=n\",{\"1\":{\"552\":1}}],[\"千万不要使用浮点数\",{\"1\":{\"599\":1}}],[\"零的部分\",{\"1\":{\"599\":1}}],[\"点数都会存储表示符号的部分\",{\"1\":{\"599\":1}}],[\"点击源码分析\",{\"1\":{\"432\":1}}],[\"么\",{\"1\":{\"599\":1}}],[\"浮点数相对于定点数的优点是在长度一定的情况下\",{\"1\":{\"600\":1}}],[\"浮点数\",{\"1\":{\"600\":1}}],[\"浮点数和定点\",{\"1\":{\"599\":1}}],[\"浮点数和定点数类型的特点是可以\",{\"1\":{\"599\":1}}],[\"浮点类型取值范围大\",{\"1\":{\"600\":1}}],[\"浮点类型\",{\"0\":{\"599\":1}}],[\"客户门店中流通的商品种类较多\",{\"1\":{\"598\":1}}],[\"客户端发送\",{\"1\":{\"633\":1}}],[\"客户端和服务器端建立连接\",{\"1\":{\"633\":1}}],[\"客户端程序结束执行\",{\"1\":{\"625\":1}}],[\"客户端进程向服务器进程发送一段文本\",{\"1\":{\"624\":1}}],[\"客户端向\",{\"1\":{\"488\":1}}],[\"客户端就相当于家里的电器\",{\"1\":{\"477\":1}}],[\"客户端order80服务\",{\"1\":{\"464\":1}}],[\"客户端所有请求都会交给nginx\",{\"1\":{\"457\":1}}],[\"客户端无法做到实时更新\",{\"1\":{\"453\":1}}],[\"客户端消费者\",{\"1\":{\"446\":1}}],[\"客户端认证失败\",{\"1\":{\"444\":1}}],[\"客户端\",{\"1\":{\"407\":1,\"625\":1}}],[\"影响力越来越大\",{\"1\":{\"835\":1}}],[\"影响效率\",{\"1\":{\"728\":1}}],[\"影响可靠性\",{\"1\":{\"598\":1}}],[\"影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统\",{\"1\":{\"112\":1}}],[\"旦遇到超出取值范围的情况\",{\"1\":{\"598\":1}}],[\"面对\",{\"1\":{\"819\":1}}],[\"面的流程\",{\"1\":{\"625\":1}}],[\"面\",{\"1\":{\"598\":1}}],[\"面向云原生微服务的高可用流控防护组件\",{\"1\":{\"405\":1}}],[\"券公司衍生产品持仓等\",{\"1\":{\"598\":1}}],[\"证\",{\"1\":{\"598\":1}}],[\"定时任务\",{\"0\":{\"851\":1},\"1\":{\"850\":1}}],[\"定期将内存中修改的数据刷新到磁盘中\",{\"1\":{\"752\":1}}],[\"定位了查询慢的\",{\"1\":{\"700\":1}}],[\"定位执行慢的sql\",{\"0\":{\"697\":1}}],[\"定点数\",{\"1\":{\"600\":1}}],[\"定点数在mysql内部是以\",{\"1\":{\"600\":1}}],[\"定点数类型取值范围相对小\",{\"1\":{\"600\":1}}],[\"定点数类型\",{\"0\":{\"600\":1}}],[\"定了zerofill只是表示不够m位时\",{\"1\":{\"597\":1}}],[\"定义时\",{\"1\":{\"604\":1}}],[\"定义char类型字段时\",{\"1\":{\"604\":1}}],[\"定义流控规则\",{\"1\":{\"423\":1}}],[\"定义虚拟结点\",{\"1\":{\"384\":1}}],[\"定义填充数字\",{\"1\":{\"289\":1}}],[\"定义区间\",{\"1\":{\"271\":2}}],[\"定义双指针\",{\"1\":{\"251\":1,\"280\":1,\"283\":1,\"317\":1,\"392\":1}}],[\"定义变量\",{\"1\":{\"209\":1,\"213\":1}}],[\"定义集合变量\",{\"1\":{\"207\":1}}],[\"定义俩个变量\",{\"1\":{\"201\":1}}],[\"定义俩个集合\",{\"1\":{\"187\":1}}],[\"定义如下\",{\"1\":{\"193\":1}}],[\"定义为\",{\"1\":{\"169\":1}}],[\"定义dp数组及含义\",{\"1\":{\"130\":1,\"157\":1}}],[\"定义dp数组及下标含义\",{\"1\":{\"105\":1,\"261\":1}}],[\"定义dp数组含义\",{\"1\":{\"120\":1,\"122\":1,\"124\":1,\"126\":1}}],[\"定义dp数组的含义\",{\"1\":{\"103\":1}}],[\"定义dp数组以及下标的含义\",{\"1\":{\"89\":1}}],[\"定义dp数组\",{\"1\":{\"79\":1,\"81\":1,\"83\":1,\"87\":1,\"89\":1,\"91\":1,\"99\":1,\"124\":1,\"137\":1,\"139\":1}}],[\"定义结点\",{\"1\":{\"2\":1}}],[\"置为无符号类型\",{\"1\":{\"596\":1}}],[\"置0\",{\"1\":{\"356\":1}}],[\"填满宽度\",{\"1\":{\"595\":1}}],[\"填充\",{\"1\":{\"231\":1}}],[\"填充数组\",{\"1\":{\"92\":1}}],[\"填充dp数组\",{\"1\":{\"91\":1}}],[\"填充它的每个\",{\"1\":{\"23\":1}}],[\"故而\",{\"1\":{\"637\":1}}],[\"故不建议在开发代码中使用此语句\",{\"1\":{\"589\":1}}],[\"故障不应该对其有任何影响\",{\"1\":{\"741\":1}}],[\"故障\",{\"1\":{\"420\":1,\"819\":1}}],[\"清空表\",{\"1\":{\"588\":1}}],[\"约束等级\",{\"1\":{\"618\":1}}],[\"约束关系是针对双方的\",{\"1\":{\"618\":1}}],[\"约束名\",{\"1\":{\"615\":1,\"616\":1,\"618\":1}}],[\"约束可分为\",{\"1\":{\"613\":3}}],[\"约束的分类\",{\"0\":{\"613\":1}}],[\"约束是表级的强制规定\",{\"1\":{\"612\":1}}],[\"约束概念\",{\"0\":{\"612\":1}}],[\"约束\",{\"0\":{\"611\":1,\"620\":1},\"1\":{\"612\":1,\"613\":1}}],[\"约束条件\",{\"1\":{\"587\":3}}],[\"约等于3\",{\"1\":{\"411\":1}}],[\"管理员名\",{\"1\":{\"737\":2}}],[\"管理数据库\",{\"0\":{\"586\":1}}],[\"管理界面\",{\"1\":{\"449\":1}}],[\"查找\",{\"1\":{\"699\":1}}],[\"查看详情\",{\"1\":{\"870\":1,\"871\":1,\"872\":1,\"873\":1,\"874\":1,\"875\":1,\"876\":1,\"877\":1,\"878\":1}}],[\"查看同步状态\",{\"1\":{\"826\":1}}],[\"查看最后100行\",{\"1\":{\"809\":1}}],[\"查看日志文件内容\",{\"1\":{\"809\":1}}],[\"查看日志\",{\"1\":{\"807\":1,\"809\":1}}],[\"查看当前的二进制日志文件列表及大小\",{\"1\":{\"809\":1}}],[\"查看当前状态\",{\"1\":{\"806\":1,\"809\":1}}],[\"查看当前数据库中有哪些表\",{\"1\":{\"586\":1}}],[\"查看通用查询日志\",{\"1\":{\"806\":1}}],[\"查看数据库默认的隔离级别\",{\"1\":{\"746\":1}}],[\"查看数据库的创建信息\",{\"1\":{\"586\":1}}],[\"查看mysqldumpslow帮助信息\",{\"1\":{\"699\":1}}],[\"查看mysql的存储引擎\",{\"1\":{\"635\":1}}],[\"查看慢查询的时间阈值设置\",{\"1\":{\"698\":1}}],[\"查看慢查询日志是否开启\",{\"1\":{\"698\":1}}],[\"查看系统性能参数\",{\"0\":{\"695\":1}}],[\"查看系统内使用的字符集\",{\"1\":{\"585\":1}}],[\"查看索引\",{\"1\":{\"687\":1}}],[\"查看默认的存储引擎\",{\"1\":{\"635\":1}}],[\"查看某个表的索引名\",{\"1\":{\"618\":1}}],[\"查看某张表的约束\",{\"1\":{\"613\":1}}],[\"查看表的索引\",{\"1\":{\"615\":1}}],[\"查看都有哪些约束\",{\"1\":{\"615\":1}}],[\"查看所有的数据库\",{\"1\":{\"586\":1}}],[\"查询数据库并更新缓存\",{\"1\":{\"848\":1}}],[\"查询master的状态\",{\"1\":{\"825\":1}}],[\"查询总条数\",{\"1\":{\"809\":1}}],[\"查询都会重新获取一次\",{\"1\":{\"799\":1}}],[\"查询得到的数据\",{\"1\":{\"799\":1}}],[\"查询转换成某个位置的查询\",{\"1\":{\"726\":1}}],[\"查询排序的代价非常大\",{\"1\":{\"726\":1}}],[\"查询来替代子查询\",{\"1\":{\"724\":1}}],[\"查询完毕后\",{\"1\":{\"724\":1}}],[\"查询语句只能读\",{\"1\":{\"765\":1}}],[\"查询语句的`where`子句永远为`false`时将会提示该额外信息\",{\"1\":{\"710\":1}}],[\"查询语句中不包含union或者子查询的查询都算作是simple类型\",{\"1\":{\"703\":1}}],[\"查询语句中每出现一个\",{\"1\":{\"702\":1}}],[\"查询时间\",{\"1\":{\"699\":1}}],[\"查询的列放在左边\",{\"1\":{\"718\":1}}],[\"查询的时间\",{\"1\":{\"696\":1}}],[\"查询的能力\",{\"1\":{\"568\":1}}],[\"查询条件的字段\",{\"1\":{\"689\":1}}],[\"查询\",{\"1\":{\"658\":3,\"710\":1}}],[\"查询显示一定范围数据的时候\",{\"1\":{\"650\":1}}],[\"查询并返回结果\",{\"1\":{\"634\":1}}],[\"查询缓存\",{\"1\":{\"634\":1}}],[\"查询缓存组件\",{\"0\":{\"630\":1}}],[\"查询结果返回给用户\",{\"1\":{\"629\":1}}],[\"查询结果都能当做一张新表使用\",{\"1\":{\"579\":1}}],[\"查询之前会使用查询优化器确定\",{\"1\":{\"629\":1}}],[\"查询优化器\",{\"0\":{\"629\":1}}],[\"查询本部门的平均工资\",{\"1\":{\"579\":1}}],[\"查询员工的id\",{\"1\":{\"579\":1}}],[\"查询员工的姓名以及所在部门名称\",{\"1\":{\"541\":3}}],[\"查询员工中工资大于本部门平均工资的员工的last\",{\"1\":{\"579\":1}}],[\"查询平均工资等于这个最低的平均工资的部门id\",{\"1\":{\"578\":1}}],[\"查询平均工资最低的部门id\",{\"1\":{\"578\":1}}],[\"查询最低工资大于50号部门最低工资的\",{\"1\":{\"574\":1}}],[\"查询与141号员工的manager\",{\"1\":{\"573\":1}}],[\"查询各个部门中最高工资比10000高的部门信息\",{\"1\":{\"564\":1}}],[\"查询出这个新表中最低的平均工资\",{\"1\":{\"578\":1}}],[\"查询出所有部门的平均工资\",{\"1\":{\"578\":1}}],[\"查询出b表也就是departments表中不符合条件的行\",{\"1\":{\"541\":1}}],[\"查询出a表也就是employees表中不符合条件的行\",{\"1\":{\"541\":1}}],[\"查询出每个员工的管理者名称\",{\"1\":{\"536\":1}}],[\"查询出每一个员工的工资等级\",{\"1\":{\"534\":1}}],[\"查询出来的\",{\"1\":{\"522\":1}}],[\"查询每一个员工的\",{\"1\":{\"533\":1}}],[\"查询部门编号为90的员工\",{\"1\":{\"525\":1}}],[\"确保事务可以从一个表中读取相同的行\",{\"1\":{\"746\":1}}],[\"确保数据表中的每一个非主键字段都和主键字段直接相关\",{\"1\":{\"737\":1}}],[\"确保数据的一致性\",{\"1\":{\"618\":1}}],[\"确实不用回表\",{\"1\":{\"651\":1}}],[\"确认字段\",{\"1\":{\"582\":1}}],[\"确定当前孩子\",{\"1\":{\"362\":1}}],[\"确定好循环次数\",{\"1\":{\"288\":1}}],[\"确定好规则\",{\"1\":{\"288\":1}}],[\"确定好了左闭右闭区间\",{\"1\":{\"271\":1}}],[\"确定滑动窗口的范围\",{\"1\":{\"285\":1}}],[\"确定返回值及参数\",{\"1\":{\"224\":1}}],[\"确定终止条件\",{\"1\":{\"187\":1}}],[\"确定\",{\"1\":{\"134\":1,\"155\":1,\"362\":1}}],[\"确定dp含义及下标\",{\"1\":{\"113\":1}}],[\"确定dp含义\",{\"1\":{\"109\":1,\"111\":1}}],[\"确定dp数组及含义\",{\"1\":{\"128\":1}}],[\"确定dp数组及其下标含义\",{\"1\":{\"107\":1}}],[\"确定dp数组及下标含义\",{\"1\":{\"95\":1,\"143\":1,\"146\":1,\"148\":1,\"152\":1,\"155\":1}}],[\"确定dp数组及下标的含义\",{\"1\":{\"91\":1}}],[\"确定dp数组含义\",{\"1\":{\"101\":1}}],[\"确定dp数组下标含义\",{\"1\":{\"85\":1}}],[\"确定dp数组\",{\"1\":{\"77\":1,\"79\":1,\"81\":1,\"83\":1,\"85\":1}}],[\"确定关系式\",{\"1\":{\"91\":1}}],[\"确定递推关系式\",{\"1\":{\"89\":1,\"91\":1,\"99\":1,\"101\":1,\"111\":1,\"113\":1,\"143\":1,\"146\":1,\"148\":1,\"152\":1,\"155\":1}}],[\"确定递推公式\",{\"1\":{\"77\":1,\"79\":2,\"81\":1,\"83\":1,\"85\":1,\"87\":1,\"107\":1,\"261\":1}}],[\"确定遍历顺序\",{\"1\":{\"77\":1,\"79\":1,\"81\":1,\"85\":1}}],[\"确定根结点\",{\"1\":{\"72\":1}}],[\"确定根结点右子树的起始范围\",{\"1\":{\"49\":1}}],[\"确定根结点左子树的起始范围\",{\"1\":{\"49\":1}}],[\"确定根节点的右子树的起始范围\",{\"1\":{\"47\":1}}],[\"确定根节点的左子树的起始范围\",{\"1\":{\"47\":1}}],[\"确定根节点在inorder\",{\"1\":{\"47\":1}}],[\"显然效率比较低\",{\"1\":{\"765\":1}}],[\"显然是不合理的\",{\"1\":{\"732\":1}}],[\"显然是个体力活\",{\"1\":{\"699\":1}}],[\"显然是更方便的选择\",{\"1\":{\"12\":1}}],[\"显式的的使用\",{\"1\":{\"745\":1}}],[\"显式员工的employee\",{\"1\":{\"575\":1}}],[\"显示事务\",{\"0\":{\"744\":1}}],[\"显示的创建索引\",{\"1\":{\"687\":1}}],[\"显示宽度与类型可以存储的\",{\"1\":{\"595\":1}}],[\"询日志\",{\"1\":{\"805\":1}}],[\"询\",{\"1\":{\"570\":1}}],[\"骤中作为输入\",{\"1\":{\"565\":1}}],[\"虚拟机\",{\"1\":{\"822\":1}}],[\"虚拟表\",{\"1\":{\"565\":1}}],[\"虚拟结点\",{\"1\":{\"389\":2}}],[\"谁好呢\",{\"1\":{\"562\":1}}],[\"草根\",{\"1\":{\"559\":1}}],[\"屌丝\",{\"1\":{\"559\":1}}],[\"潜力股\",{\"1\":{\"559\":1}}],[\"错误日志存储在mysql数据库的数据文件夹下\",{\"1\":{\"807\":1}}],[\"错误日志功能是\",{\"1\":{\"807\":1}}],[\"错误日志\",{\"0\":{\"807\":1},\"1\":{\"805\":2,\"807\":1}}],[\"错误或者直接断电等\",{\"1\":{\"742\":1}}],[\"错误演示\",{\"1\":{\"617\":1}}],[\"错误写法\",{\"1\":{\"564\":1}}],[\"错误\",{\"1\":{\"559\":1}}],[\"错误的\",{\"1\":{\"578\":1}}],[\"错误的使用\",{\"1\":{\"522\":1}}],[\"错误的请求占\",{\"1\":{\"477\":1}}],[\"错误的请求\",{\"1\":{\"477\":1}}],[\"常见的有\",{\"1\":{\"850\":1}}],[\"常见的有数据页\",{\"1\":{\"667\":1}}],[\"常见的有两类\",{\"1\":{\"658\":1}}],[\"常见的平衡二叉树有很多种\",{\"1\":{\"660\":1}}],[\"常见的负载均衡有软件nginx\",{\"1\":{\"457\":1}}],[\"常见索引概念\",{\"0\":{\"649\":1}}],[\"常见数据类型的属性\",{\"1\":{\"592\":1}}],[\"常用的聚合函数\",{\"0\":{\"562\":1}}],[\"常量值1\",{\"1\":{\"559\":2}}],[\"否\",{\"1\":{\"559\":1}}],[\"否则没有意义\",{\"1\":{\"848\":1}}],[\"否则会报错如下\",{\"1\":{\"827\":1}}],[\"否则会出现\",{\"1\":{\"579\":1}}],[\"否则见下面\",{\"1\":{\"825\":1}}],[\"否则在有些场景会报错\",{\"1\":{\"822\":1}}],[\"否则在一个只读事务中的事务id值都默认为0\",{\"1\":{\"797\":1}}],[\"否则在进行比较时dp\",{\"1\":{\"107\":1}}],[\"否则sql会很慢\",{\"1\":{\"726\":1}}],[\"否则有可能出现爆屏情况\",{\"1\":{\"699\":1}}],[\"否则认为页的传输已经完成\",{\"1\":{\"668\":1}}],[\"否则将会出现页分裂\",{\"1\":{\"650\":1}}],[\"否则应该优先考虑innodb引擎\",{\"1\":{\"636\":1}}],[\"否则报错\",{\"1\":{\"604\":1}}],[\"否则指定显示宽度无效\",{\"1\":{\"595\":1}}],[\"否则变为关闭状态\",{\"1\":{\"475\":1}}],[\"否则一重启服务\",{\"1\":{\"424\":1}}],[\"否则一直累加\",{\"1\":{\"307\":1}}],[\"否则继续熔断\",{\"1\":{\"412\":1}}],[\"否则去前半部分找\",{\"1\":{\"277\":1}}],[\"否则去后半部分找\",{\"1\":{\"277\":1}}],[\"否则抛弃左区间\",{\"1\":{\"276\":1}}],[\"否则返回value2\",{\"1\":{\"559\":1}}],[\"否则返回\",{\"1\":{\"269\":1,\"277\":1,\"355\":1,\"357\":1,\"552\":1}}],[\"否则返回高度\",{\"1\":{\"37\":1}}],[\"否则翻转前k个字符\",{\"1\":{\"254\":1}}],[\"否则就需要指定数据库\",{\"1\":{\"832\":1}}],[\"否则就移动到headb的下一个结点\",{\"1\":{\"391\":1}}],[\"否则就移动到heada的下一个结点\",{\"1\":{\"391\":1}}],[\"否则就反转全部字符串\",{\"1\":{\"254\":1}}],[\"否则就不是\",{\"1\":{\"155\":1}}],[\"否则就会出现一场比赛时间不同的情况\",{\"1\":{\"737\":1}}],[\"否则就会报错\",{\"1\":{\"564\":1}}],[\"否则就会触发警报\",{\"1\":{\"115\":1}}],[\"否则就会在dp\",{\"1\":{\"107\":1}}],[\"否则不会被覆盖\",{\"1\":{\"107\":1}}],[\"否则\",{\"1\":{\"44\":1,\"52\":1,\"172\":1,\"173\":1,\"296\":1,\"321\":1,\"349\":1}}],[\"否则则不是\",{\"1\":{\"33\":1}}],[\"针对表级锁的操作情况\",{\"1\":{\"770\":1}}],[\"针对同一份数据\",{\"1\":{\"767\":1}}],[\"针对同样的数据\",{\"1\":{\"660\":1}}],[\"针对这种情况\",{\"1\":{\"753\":1}}],[\"针对不同的隔离级别\",{\"1\":{\"746\":1}}],[\"针对的是会扫描全表的\",{\"1\":{\"729\":1}}],[\"针对数据页做的简易目录就搞定了\",{\"1\":{\"643\":1}}],[\"针对数据统计有额外的常数存储\",{\"1\":{\"637\":1}}],[\"针对给定年份与所在年份中的天数返回一个日期\",{\"1\":{\"557\":1}}],[\"针对来源\",{\"1\":{\"409\":1}}],[\"返\",{\"1\":{\"557\":1}}],[\"返回顶部按钮\",{\"1\":{\"858\":1,\"861\":1}}],[\"返回记录\",{\"1\":{\"699\":1}}],[\"返回公司工资最少的员工的last\",{\"1\":{\"573\":1}}],[\"返回expr不为空的记录总数\",{\"1\":{\"562\":1}}],[\"返回e的x次方\",{\"1\":{\"550\":1}}],[\"返回value1\",{\"1\":{\"559\":2}}],[\"返回date所在月份的最后一天的日期\",{\"1\":{\"557\":1}}],[\"返回date1\",{\"1\":{\"557\":1}}],[\"返回time加上n后的时间\",{\"1\":{\"557\":1}}],[\"返回time1减去time2后的时间\",{\"1\":{\"557\":1}}],[\"返回time1加上time2的时间\",{\"1\":{\"557\":1}}],[\"返回true\",{\"1\":{\"33\":1}}],[\"返回与date相差interval时间间隔的\",{\"1\":{\"557\":1}}],[\"返回与给定日期时间相差interval时\",{\"1\":{\"557\":1}}],[\"返回指定日期中特定的部分\",{\"1\":{\"555\":1}}],[\"返回指定位置的字符串\",{\"1\":{\"552\":1}}],[\"返回日期字符串的显示格式\",{\"1\":{\"558\":1}}],[\"返回日期date距离0000年1月1日的天数\",{\"1\":{\"557\":1}}],[\"返回日期位于所在月份的第几天\",{\"1\":{\"555\":1}}],[\"返回日期是一年中的第几天\",{\"1\":{\"555\":1}}],[\"返回日期对应的季度\",{\"1\":{\"555\":1}}],[\"返回一年中的第几周\",{\"1\":{\"555\":1}}],[\"返回一个对x的值进行四舍五入后最接近x的值\",{\"1\":{\"548\":1}}],[\"返回一个对x的值进行四舍五入后\",{\"1\":{\"548\":1}}],[\"返回一个表示每个字符串片段的长度的列表\",{\"1\":{\"367\":1}}],[\"返回一个表示表达式值的整数\",{\"1\":{\"330\":1}}],[\"返回周几\",{\"1\":{\"555\":2}}],[\"返回星期几\",{\"1\":{\"555\":1}}],[\"返回月份\",{\"1\":{\"555\":1}}],[\"返回utc\",{\"1\":{\"554\":2}}],[\"返回当前系统日期和时间\",{\"1\":{\"554\":1}}],[\"返回当前时间\",{\"1\":{\"554\":1}}],[\"返回当前日期\",{\"1\":{\"554\":1}}],[\"返回当前层数\",{\"1\":{\"28\":1}}],[\"返回s反转后的字符串\",{\"1\":{\"552\":1}}],[\"返回str重复n次的结果\",{\"1\":{\"552\":1}}],[\"返回0\",{\"1\":{\"552\":1}}],[\"返回0~1的随机值\",{\"1\":{\"548\":2}}],[\"返回从0000年1月1日起\",{\"1\":{\"557\":1}}],[\"返回从字符串s的index位置其len个字符\",{\"1\":{\"552\":1}}],[\"返回从右侧所能看到的节点值\",{\"1\":{\"15\":1}}],[\"返回n个空格\",{\"1\":{\"552\":1}}],[\"返回null\",{\"1\":{\"62\":1,\"548\":1,\"550\":1}}],[\"返回字符串s1在字符串s2中出现的位置\",{\"1\":{\"552\":1}}],[\"返回字符串s在字符串列表中第一次出现的位置\",{\"1\":{\"552\":1}}],[\"返回字符串substr在字符串str中首次出现的位置\",{\"1\":{\"552\":1}}],[\"返回字符串str最右边的n个字符\",{\"1\":{\"552\":1}}],[\"返回字符串str最左边的n个字符\",{\"1\":{\"552\":1}}],[\"返回字符串s的字节数\",{\"1\":{\"552\":1}}],[\"返回字符串s的字符数\",{\"1\":{\"552\":1}}],[\"返回字符串s中的第一个字符的ascii码值\",{\"1\":{\"552\":1}}],[\"返回f1进制数变成f2进制数\",{\"1\":{\"551\":1}}],[\"返回false\",{\"1\":{\"33\":1}}],[\"返回以2为底的x的对数\",{\"1\":{\"550\":1}}],[\"返回以10为底的x的对数\",{\"1\":{\"550\":1}}],[\"返回以e为底的x的对数\",{\"1\":{\"550\":1}}],[\"返回以该节点为根的子树\",{\"1\":{\"53\":1}}],[\"返回两个参数的反正切值\",{\"1\":{\"549\":1}}],[\"返回数字x截断为y位小数的结果\",{\"1\":{\"548\":1}}],[\"返回数组\",{\"1\":{\"353\":1}}],[\"返回x除以y后的余数\",{\"1\":{\"548\":1}}],[\"返回x的八进制编码\",{\"1\":{\"551\":1}}],[\"返回x的十六进制编码\",{\"1\":{\"551\":1}}],[\"返回x的二进制编码\",{\"1\":{\"551\":1}}],[\"返回x的y次方\",{\"1\":{\"550\":1}}],[\"返回x的余切值\",{\"1\":{\"549\":1}}],[\"返回x的余弦值\",{\"1\":{\"549\":1}}],[\"返回x的正切值\",{\"1\":{\"549\":1}}],[\"返回x的正弦值\",{\"1\":{\"549\":1}}],[\"返回x的反正切值\",{\"1\":{\"549\":1}}],[\"返回x的反正弦值\",{\"1\":{\"549\":1}}],[\"返回x的反余弦值\",{\"1\":{\"549\":1}}],[\"返回x的平方根\",{\"1\":{\"548\":1}}],[\"返回x的符号\",{\"1\":{\"548\":1}}],[\"返回x的绝对值\",{\"1\":{\"548\":1}}],[\"返回列表中的最大值\",{\"1\":{\"548\":1}}],[\"返回列表中的最小值\",{\"1\":{\"548\":1}}],[\"返回小于或等于某个值的最大整数\",{\"1\":{\"548\":1}}],[\"返回大于或等于某个值的最小整数\",{\"1\":{\"548\":1}}],[\"返回圆周率的值\",{\"1\":{\"548\":1}}],[\"返回符合条件的结果记录\",{\"1\":{\"528\":1}}],[\"返回备用结果\",{\"1\":{\"477\":1}}],[\"返回给用户一个友好提示\",{\"1\":{\"472\":1}}],[\"返回类型与原方法一致\",{\"1\":{\"416\":2}}],[\"返回类型\",{\"1\":{\"416\":1}}],[\"返回索引为\",{\"1\":{\"393\":2}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"393\":1}}],[\"返回新的头结点\",{\"1\":{\"387\":1}}],[\"返回头结点\",{\"1\":{\"378\":1}}],[\"返回引爆所有气球所必须射出的\",{\"1\":{\"363\":1}}],[\"返回到达\",{\"1\":{\"351\":1}}],[\"返回队列开头的元素\",{\"1\":{\"321\":1}}],[\"返回删除后数组的新长度\",{\"1\":{\"312\":1}}],[\"返回它将会被按顺序插入的位置\",{\"1\":{\"273\":1}}],[\"返回该\",{\"1\":{\"257\":1}}],[\"返回该数组所有可能的子集\",{\"1\":{\"202\":1}}],[\"返回的是旧值\",{\"1\":{\"849\":1}}],[\"返回的结果为null\",{\"1\":{\"550\":2}}],[\"返回的结果字符串中\",{\"1\":{\"244\":1}}],[\"返回的队列应该格式化为数组\",{\"1\":{\"361\":1}}],[\"返回的解集中\",{\"1\":{\"204\":1}}],[\"返回时不要忘记将\",{\"1\":{\"241\":1}}],[\"返回网格坐标\",{\"1\":{\"233\":1}}],[\"返回网格中\",{\"1\":{\"229\":1}}],[\"返回解集\",{\"1\":{\"202\":1}}],[\"返回这些组合\",{\"1\":{\"194\":1}}],[\"返回这两个字符串的最长\",{\"1\":{\"138\":1}}],[\"返回范围\",{\"1\":{\"186\":1}}],[\"返回答案\",{\"1\":{\"178\":1,\"186\":1,\"206\":1,\"208\":1,\"336\":1}}],[\"返回使得\",{\"1\":{\"149\":1}}],[\"返回获得利润的最大值\",{\"1\":{\"129\":1}}],[\"返回你可以从这笔交易中获取的最大利润\",{\"1\":{\"119\":1}}],[\"返回可以通过上述方法构造的\",{\"1\":{\"98\":1}}],[\"返回此石头\",{\"1\":{\"96\":1}}],[\"返回满足题意的二叉搜索树的种数\",{\"1\":{\"88\":1}}],[\"返回右子树为新的子树\",{\"1\":{\"68\":1,\"70\":1}}],[\"返回右子树代替删除节点root\",{\"1\":{\"68\":1}}],[\"返回左子树为新的子树\",{\"1\":{\"68\":1,\"70\":1}}],[\"返回左子树代替删除结点root\",{\"1\":{\"68\":1}}],[\"返回二叉搜索树\",{\"1\":{\"67\":1}}],[\"返回插入后二叉搜索树的根节点\",{\"1\":{\"65\":1}}],[\"返回right\",{\"1\":{\"62\":1}}],[\"返回合并后的二叉树\",{\"1\":{\"52\":1}}],[\"返回所有不同的\",{\"1\":{\"214\":1}}],[\"返回所有不重复的全排列\",{\"1\":{\"210\":1}}],[\"返回所有可能的有效\",{\"1\":{\"200\":1}}],[\"返回所有它能表示的字母组合\",{\"1\":{\"192\":1}}],[\"返回所有左叶子之和\",{\"1\":{\"40\":1}}],[\"返回所有从根节点到叶子节点的路径\",{\"1\":{\"38\":1}}],[\"返回\",{\"1\":{\"33\":1,\"44\":2,\"50\":1,\"57\":1,\"59\":1,\"62\":3,\"68\":1,\"86\":1,\"102\":1,\"106\":1,\"108\":1,\"110\":2,\"116\":1,\"119\":1,\"121\":1,\"136\":1,\"138\":2,\"166\":1,\"172\":2,\"174\":1,\"189\":1,\"192\":1,\"198\":1,\"240\":3,\"244\":1,\"266\":2,\"275\":1,\"281\":1,\"284\":1,\"312\":1,\"321\":2,\"333\":1,\"345\":1,\"349\":2,\"357\":1,\"365\":1,\"369\":1,\"383\":1,\"390\":1,\"393\":1,\"555\":2}}],[\"返回其它job\",{\"1\":{\"578\":2}}],[\"返回其\",{\"1\":{\"208\":1}}],[\"返回其最大和\",{\"1\":{\"142\":1,\"347\":1}}],[\"返回其最大深度\",{\"1\":{\"25\":1}}],[\"返回其节点值\",{\"1\":{\"13\":1}}],[\"返回其节点值的层序遍历\",{\"1\":{\"19\":1}}],[\"返回其节点值的\",{\"1\":{\"11\":1}}],[\"返回地址存放在栈中\",{\"1\":{\"5\":1}}],[\"返回值为交换完链表新的\",{\"1\":{\"386\":1}}],[\"返回值值\",{\"1\":{\"292\":1}}],[\"返回值有俩种写法\",{\"1\":{\"276\":1}}],[\"返回值仍然为boolean类型\",{\"1\":{\"217\":1}}],[\"返回值及条件\",{\"1\":{\"190\":1}}],[\"返回值及参数\",{\"1\":{\"187\":1,\"193\":1,\"195\":1,\"199\":1,\"201\":1,\"203\":1,\"207\":1,\"209\":1,\"213\":1,\"215\":1,\"217\":1}}],[\"返回值\",{\"1\":{\"5\":1,\"62\":1,\"68\":1,\"386\":2,\"443\":2}}],[\"周六是\",{\"1\":{\"555\":1}}],[\"周一是2\",{\"1\":{\"555\":1}}],[\"周日是1\",{\"1\":{\"555\":1}}],[\"周日是6\",{\"1\":{\"555\":1}}],[\"周2是1\",{\"1\":{\"555\":1}}],[\"周1是0\",{\"1\":{\"555\":1}}],[\"星期数\",{\"0\":{\"555\":1}}],[\"星期\",{\"0\":{\"555\":1}}],[\"世界标准时间\",{\"1\":{\"554\":2}}],[\"秒\",{\"1\":{\"554\":1,\"555\":1,\"557\":2,\"602\":3,\"753\":1,\"809\":2}}],[\"秒杀高并发等操作\",{\"1\":{\"472\":1}}],[\"月份\",{\"1\":{\"555\":1}}],[\"月\",{\"1\":{\"554\":1,\"602\":3,\"884\":1}}],[\"月工资\",{\"1\":{\"523\":1}}],[\"日积月累\",{\"1\":{\"598\":1}}],[\"日期和时间类型\",{\"0\":{\"602\":1}}],[\"日期类型\",{\"1\":{\"562\":1}}],[\"日期的格式化与解析\",{\"0\":{\"558\":1}}],[\"日期与时间戳的转换\",{\"1\":{\"554\":1}}],[\"日期\",{\"1\":{\"554\":1,\"557\":1}}],[\"日期函数\",{\"0\":{\"553\":1}}],[\"日\",{\"1\":{\"554\":1,\"602\":3,\"884\":1}}],[\"日志参数设置\",{\"1\":{\"809\":1}}],[\"日志文件所在目录路径\",{\"1\":{\"806\":1}}],[\"日志会\",{\"1\":{\"805\":1}}],[\"日志功能会降低mysql数据库的性能\",{\"1\":{\"805\":1}}],[\"日志弊端\",{\"1\":{\"805\":1}}],[\"日志类型\",{\"0\":{\"805\":1}}],[\"日志生命周期\",{\"0\":{\"757\":1}}],[\"日志呢\",{\"0\":{\"749\":1}}],[\"日志中\",{\"1\":{\"747\":1}}],[\"日志都被视作一种恢复操作\",{\"1\":{\"747\":1}}],[\"日志来保证\",{\"1\":{\"747\":1}}],[\"日志和undo\",{\"1\":{\"747\":1}}],[\"日志\",{\"0\":{\"748\":1,\"754\":1,\"804\":1},\"1\":{\"733\":1,\"749\":1}}],[\"日志级别\",{\"1\":{\"470\":1}}],[\"日志打印功能\",{\"0\":{\"470\":1}}],[\"未提交事务\",{\"1\":{\"746\":1}}],[\"未找到\",{\"1\":{\"552\":1}}],[\"未来的某一个不同的日子\",{\"1\":{\"119\":1}}],[\"截止到现在\",{\"1\":{\"634\":1}}],[\"截断\",{\"1\":{\"548\":1}}],[\"截取移动的字符串\",{\"1\":{\"256\":1}}],[\"截取移动后边的字符串\",{\"1\":{\"256\":1}}],[\"截取单词并加入到集合中\",{\"1\":{\"245\":1}}],[\"截取\",{\"1\":{\"12\":1}}],[\"随机i0比顺序i0要慢\",{\"1\":{\"749\":1}}],[\"随机i0\",{\"1\":{\"749\":1}}],[\"随机io刷新慢\",{\"1\":{\"749\":1}}],[\"随机数\",{\"1\":{\"548\":1}}],[\"随后\",{\"1\":{\"121\":1,\"123\":1,\"125\":1}}],[\"随后又仔细想了一下\",{\"1\":{\"43\":1}}],[\"效率较低\",{\"1\":{\"725\":1}}],[\"效率就会降低\",{\"1\":{\"658\":1}}],[\"效率更高\",{\"1\":{\"542\":1,\"616\":1,\"725\":1}}],[\"效果\",{\"1\":{\"410\":1,\"411\":1,\"416\":1}}],[\"效果图来源于代码随想录\",{\"1\":{\"282\":1}}],[\"源表名\",{\"1\":{\"542\":1}}],[\"慢\",{\"1\":{\"725\":1}}],[\"慢查询日志分析工具\",{\"0\":{\"699\":1}}],[\"慢查询日志\",{\"0\":{\"697\":1,\"698\":1},\"1\":{\"805\":1}}],[\"慢外连接\",{\"1\":{\"541\":1}}],[\"慢调用百分比峰值\",{\"1\":{\"478\":1}}],[\"慢调用时间阈值\",{\"1\":{\"478\":1}}],[\"慢调用占有实际的比例＝慢调用次数➗总调用次数\",{\"1\":{\"412\":1}}],[\"慢调用比例阈值\",{\"1\":{\"419\":1}}],[\"慢调用比例模式下为慢调用临界\",{\"1\":{\"419\":1}}],[\"慢调用比例\",{\"0\":{\"413\":1},\"1\":{\"412\":1,\"413\":1,\"419\":2}}],[\"慢调用\",{\"1\":{\"412\":1}}],[\"率\",{\"1\":{\"540\":1,\"608\":1}}],[\"姓名\",{\"1\":{\"533\":1,\"578\":2,\"736\":1,\"737\":3}}],[\"产生一条mq消息\",{\"1\":{\"852\":1}}],[\"产生一个\",{\"1\":{\"800\":1}}],[\"产生数据的混乱\",{\"1\":{\"732\":1}}],[\"产生大量的慢查询\",{\"1\":{\"724\":1}}],[\"产生的笛卡尔积得原因\",{\"1\":{\"533\":1}}],[\"产品id\",{\"1\":{\"431\":2}}],[\"笛卡尔乘积是一个数学运算\",{\"1\":{\"532\":1}}],[\"笛卡尔积\",{\"1\":{\"532\":1,\"533\":1,\"579\":1}}],[\"符合则\",{\"1\":{\"641\":1}}],[\"符合条件\",{\"1\":{\"276\":1,\"286\":1}}],[\"符号\",{\"1\":{\"599\":1,\"608\":1}}],[\"符号整数类型的最小取值为0\",{\"1\":{\"596\":1}}],[\"符号运算符\",{\"0\":{\"529\":1}}],[\"算数运算符\",{\"0\":{\"527\":1}}],[\"算法是通过某种确定性的算法\",{\"1\":{\"658\":1}}],[\"算法\",{\"1\":{\"725\":1},\"2\":{\"75\":1,\"158\":1,\"180\":1,\"219\":1,\"235\":1,\"263\":1,\"318\":1,\"340\":1,\"373\":1,\"396\":1}}],[\"着重号\",{\"0\":{\"524\":1},\"1\":{\"524\":1,\"583\":1}}],[\"年\",{\"1\":{\"835\":1,\"884\":1}}],[\"年龄只依赖于球员编号\",{\"1\":{\"737\":1}}],[\"年龄\",{\"1\":{\"736\":1,\"737\":2}}],[\"年龄的情况等\",{\"1\":{\"658\":1}}],[\"年龄范围0\",{\"1\":{\"612\":1}}],[\"年份\",{\"1\":{\"555\":1}}],[\"年工资\",{\"1\":{\"523\":1}}],[\"年的双十一大促流量的核心场景\",{\"1\":{\"406\":1}}],[\"绑定变量等都大写\",{\"1\":{\"518\":1}}],[\"言显得尤其重要\",{\"1\":{\"760\":1}}],[\"言\",{\"1\":{\"517\":1}}],[\"录\",{\"1\":{\"517\":1,\"643\":1}}],[\"视图\",{\"1\":{\"517\":1,\"627\":1}}],[\"视为慢调用\",{\"1\":{\"478\":1}}],[\"系\",{\"1\":{\"513\":1}}],[\"系统性能\",{\"1\":{\"768\":1}}],[\"系统默认master\",{\"1\":{\"753\":1}}],[\"系统默认会在所在的列或列组合上建立对应的主键索引\",{\"1\":{\"616\":1}}],[\"系统页\",{\"1\":{\"667\":1}}],[\"系统\",{\"1\":{\"625\":1}}],[\"系统库\",{\"1\":{\"613\":1}}],[\"系统自动按照实际长度存储\",{\"1\":{\"605\":1}}],[\"系统自适应过载保护\",{\"1\":{\"406\":1}}],[\"系统故障产生的成本远远超过增加几个字段存储空间所产生的成本\",{\"1\":{\"598\":1}}],[\"系统错误\",{\"1\":{\"598\":1}}],[\"系统繁忙\",{\"1\":{\"477\":1,\"480\":1,\"481\":1}}],[\"系统异常\",{\"1\":{\"444\":1}}],[\"系统规则不满足要求\",{\"1\":{\"444\":1}}],[\"系统规则不满足\",{\"1\":{\"444\":1}}],[\"系统忙不过来\",{\"1\":{\"423\":1}}],[\"系统初始化的阀值为10\",{\"1\":{\"411\":1}}],[\"系统负载保护等多个维度保护服务的稳定性\",{\"1\":{\"399\":1}}],[\"系统会用下面的代码来测试你的题解\",{\"1\":{\"312\":1}}],[\"系统会自动报警\",{\"1\":{\"112\":1,\"114\":1}}],[\"联合\",{\"1\":{\"686\":1}}],[\"联合索引优于单值索引\",{\"1\":{\"689\":1}}],[\"联合索引其实就是非聚簇索引的一种\",{\"1\":{\"652\":1}}],[\"联合索引\",{\"0\":{\"652\":1}}],[\"联接表\",{\"1\":{\"513\":1}}],[\"联系集\",{\"1\":{\"512\":1}}],[\"联系\",{\"1\":{\"512\":1}}],[\"索\",{\"1\":{\"517\":1}}],[\"索的时候才能保证性能最优\",{\"1\":{\"510\":1}}],[\"索引中找到记录\",{\"1\":{\"728\":1}}],[\"索引下推\",{\"0\":{\"728\":1}}],[\"索引字段的维护总是有代价的\",{\"1\":{\"727\":1}}],[\"索引列名称\",{\"1\":{\"727\":1}}],[\"索引可以保证数据的有序性\",{\"1\":{\"725\":1}}],[\"索引可以分为\",{\"1\":{\"649\":1,\"686\":1}}],[\"索引则不会失效\",{\"1\":{\"719\":1}}],[\"索引失效\",{\"0\":{\"719\":1,\"722\":1}}],[\"索引失效的11种情况\",{\"0\":{\"714\":1}}],[\"索引优化与查询优化\",{\"0\":{\"713\":1}}],[\"索引就是让数据按照某种顺序进行存储或检索\",{\"1\":{\"689\":1}}],[\"索引主要有\",{\"1\":{\"686\":1}}],[\"索引通常不会用到重复值多的列上\",{\"1\":{\"658\":1}}],[\"索引还需要对数据重新排序\",{\"1\":{\"658\":1}}],[\"索引还有一个缺陷\",{\"1\":{\"658\":1}}],[\"索引仅能满足\",{\"1\":{\"658\":1}}],[\"索引文件具有\",{\"1\":{\"716\":1}}],[\"索引文件\",{\"1\":{\"654\":1}}],[\"索引文件就可能比数据文\",{\"1\":{\"642\":1}}],[\"索引即数据\",{\"1\":{\"650\":1}}],[\"索引称为二级索引或者辅助索引\",{\"1\":{\"649\":1}}],[\"索引按照物理实现方式\",{\"1\":{\"649\":1}}],[\"索引也要动态地维护\",{\"1\":{\"642\":1}}],[\"索引需要占\",{\"1\":{\"642\":1}}],[\"索引是在存储引擎中实现的\",{\"1\":{\"642\":1}}],[\"索引是数据结构\",{\"1\":{\"642\":1}}],[\"索引是存储引擎用于快速找到数据记录的一种数据结构\",{\"1\":{\"641\":1}}],[\"索引的设计原则\",{\"0\":{\"688\":1}}],[\"索引的分类\",{\"0\":{\"686\":1}}],[\"索引的声明与使用\",{\"0\":{\"685\":1}}],[\"索引的创建与设计原则\",{\"0\":{\"684\":1}}],[\"索引的效率更高\",{\"1\":{\"658\":1}}],[\"索引的代价\",{\"0\":{\"656\":1}}],[\"索引的叶子节点包含实际的数据行\",{\"1\":{\"650\":1}}],[\"索引的本质\",{\"1\":{\"642\":1}}],[\"索引的特点及优缺点\",{\"0\":{\"642\":1}}],[\"索引\",{\"0\":{\"640\":1},\"1\":{\"632\":1,\"636\":1,\"642\":1,\"643\":1,\"649\":1,\"655\":1,\"686\":1,\"715\":1}}],[\"索引名\",{\"1\":{\"618\":1}}],[\"索引从\",{\"1\":{\"393\":1}}],[\"索引为\",{\"1\":{\"355\":1}}],[\"索引整数数组\",{\"1\":{\"351\":1}}],[\"阉割版本\",{\"1\":{\"510\":1}}],[\"概念解释\",{\"1\":{\"837\":1}}],[\"概念介绍\",{\"0\":{\"472\":1}}],[\"概述\",{\"0\":{\"507\":1}}],[\"继承\",{\"1\":{\"497\":1,\"504\":1}}],[\"继续允许请求通过\",{\"1\":{\"475\":1}}],[\"继续遍历下一个孩子\",{\"1\":{\"344\":1}}],[\"继续为下一个孩子分配饼干\",{\"1\":{\"344\":1}}],[\"继续计算下一个连续的1的个数\",{\"1\":{\"308\":1}}],[\"继续使用\",{\"1\":{\"299\":3}}],[\"继续找下一个子数组的起始点\",{\"1\":{\"348\":1}}],[\"继续找下一条路径\",{\"1\":{\"39\":1}}],[\"继续找与graph\",{\"1\":{\"224\":2}}],[\"继续看一下张图\",{\"1\":{\"211\":1}}],[\"继续处理\",{\"1\":{\"193\":2}}],[\"继续匹配\",{\"1\":{\"153\":1}}],[\"继续向下一个加油站走\",{\"1\":{\"356\":1}}],[\"继续向下访问\",{\"1\":{\"7\":1}}],[\"继续向后边匹配\",{\"1\":{\"146\":1}}],[\"继续与其他元素求差值\",{\"1\":{\"97\":1}}],[\"继续往下遍历\",{\"1\":{\"66\":1}}],[\"希望用一个\",{\"1\":{\"497\":1}}],[\"希望大家能有画图的习惯\",{\"1\":{\"211\":1}}],[\"外\",{\"1\":{\"642\":1,\"710\":1}}],[\"外查询\",{\"1\":{\"569\":1}}],[\"外连接可以将不符合条件的行也都查询出来\",{\"1\":{\"539\":1}}],[\"外连接\",{\"0\":{\"537\":1,\"539\":1},\"1\":{\"537\":2}}],[\"外键影响\",{\"1\":{\"837\":1}}],[\"外键与级联更新适用于\",{\"1\":{\"837\":1}}],[\"外键\",{\"1\":{\"637\":1,\"736\":1}}],[\"外键约束是有成本的\",{\"1\":{\"618\":1}}],[\"外键约束名\",{\"1\":{\"618\":1}}],[\"外键约束\",{\"0\":{\"618\":1},\"1\":{\"613\":1,\"687\":1}}],[\"外键是主键\",{\"1\":{\"513\":1}}],[\"外键唯一\",{\"1\":{\"513\":2}}],[\"外部访问我的ip限制\",{\"1\":{\"495\":1}}],[\"外层循环计算由\",{\"1\":{\"89\":1}}],[\"匹配和才可以访问\",{\"1\":{\"504\":1}}],[\"匹配\",{\"1\":{\"493\":1}}],[\"匹配具有给定名称且其值符合正则表达式的cookie\",{\"1\":{\"493\":1}}],[\"匹配后提供服务的路由地址\",{\"1\":{\"422\":1}}],[\"格式三\",{\"1\":{\"823\":1}}],[\"格式二\",{\"1\":{\"823\":1}}],[\"格式1\",{\"1\":{\"823\":1}}],[\"格式如下\",{\"1\":{\"806\":1}}],[\"格式\",{\"1\":{\"492\":1}}],[\"端口\",{\"1\":{\"489\":2}}],[\"谓词\",{\"1\":{\"488\":1}}],[\"架构图如下\",{\"1\":{\"821\":1}}],[\"架构\",{\"1\":{\"487\":1,\"624\":2}}],[\"网络地址是\",{\"1\":{\"495\":1}}],[\"网络地址和广播地址分别是每个子网的第一个和最后一个地址\",{\"1\":{\"495\":1}}],[\"网关就能够替我们转发到\",{\"1\":{\"489\":1}}],[\"网关是响应式编程删除掉spring\",{\"1\":{\"489\":1}}],[\"网关也要注册进服务注册中心统一管控\",{\"1\":{\"489\":1}}],[\"网关也是一个单独的服务模块\",{\"1\":{\"489\":1}}],[\"网关模块\",{\"1\":{\"489\":1}}],[\"网关聚合服务\",{\"1\":{\"487\":1}}],[\"网关的负载均衡\",{\"1\":{\"487\":1}}],[\"网关的角色是作为一个\",{\"1\":{\"487\":1}}],[\"网关前\",{\"1\":{\"487\":1}}],[\"网关\",{\"0\":{\"487\":1}}],[\"网格任务支持海量子任务均匀分配到所有\",{\"1\":{\"399\":1}}],[\"网格的左上角\",{\"1\":{\"84\":1}}],[\"六\",{\"0\":{\"487\":1,\"592\":1}}],[\"六数之和都是这个逻辑\",{\"1\":{\"179\":1}}],[\"各个数据库厂商对\",{\"1\":{\"764\":1}}],[\"各个存放\",{\"1\":{\"650\":1}}],[\"各个列的值\",{\"1\":{\"643\":1}}],[\"各个select语句之间使用union或union\",{\"1\":{\"540\":1}}],[\"各子句分行写\",{\"1\":{\"518\":1}}],[\"各种统计\",{\"1\":{\"503\":1}}],[\"各span通过parent\",{\"1\":{\"484\":1}}],[\"各元素之间的差值为\",{\"1\":{\"345\":2}}],[\"五\",{\"0\":{\"483\":1,\"582\":1}}],[\"五数\",{\"1\":{\"179\":1}}],[\"禁止两个下划线中间只出\",{\"1\":{\"836\":1}}],[\"禁止出现数字开头\",{\"1\":{\"836\":1}}],[\"禁止\",{\"1\":{\"746\":1}}],[\"禁止访问\",{\"1\":{\"482\":1}}],[\"禁用了如下功能\",{\"1\":{\"858\":1}}],[\"禁用保留字\",{\"1\":{\"836\":1}}],[\"禁用\",{\"1\":{\"475\":1},\"2\":{\"860\":1}}],[\"舱壁\",{\"1\":{\"480\":1,\"481\":1}}],[\"船的\",{\"1\":{\"480\":1,\"481\":1}}],[\"过滤器where\",{\"0\":{\"525\":1}}],[\"过滤器名称\",{\"1\":{\"491\":1}}],[\"过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前\",{\"1\":{\"488\":1}}],[\"过滤器链\",{\"1\":{\"488\":1}}],[\"过滤器\",{\"1\":{\"488\":1}}],[\"过时不候进舱壁兜底fallback\",{\"1\":{\"480\":1}}],[\"过程二\",{\"1\":{\"175\":1}}],[\"过程一\",{\"1\":{\"175\":1}}],[\"神坑的位置\",{\"1\":{\"478\":1}}],[\"ㄒoㄒ\",{\"1\":{\"477\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"滑动窗⼝的⼤⼩配置count\",{\"1\":{\"477\":1}}],[\"滑动窗口的大小配置\",{\"1\":{\"478\":1}}],[\"滑动窗口的类型\",{\"1\":{\"477\":1,\"478\":1}}],[\"滑动窗口的位置\",{\"1\":{\"333\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"333\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"333\":1}}],[\"滑动窗口\",{\"1\":{\"285\":1,\"286\":1,\"339\":1},\"2\":{\"264\":1}}],[\"拒绝所有请求\",{\"1\":{\"477\":1}}],[\"精度范围时\",{\"1\":{\"600\":1}}],[\"精确优先\",{\"1\":{\"477\":1}}],[\"精准\",{\"1\":{\"399\":2}}],[\"暴露出去\",{\"1\":{\"477\":1}}],[\"暴力法\",{\"1\":{\"175\":1,\"282\":1,\"283\":1,\"285\":1}}],[\"国家电网\",{\"1\":{\"477\":1}}],[\"始终拒绝访问\",{\"1\":{\"475\":1}}],[\"始终允许访问\",{\"1\":{\"475\":1}}],[\"始终记录子数组的最小长度\",{\"1\":{\"286\":1}}],[\"尝试执行\",{\"1\":{\"772\":1}}],[\"尝试重新计算失败率\",{\"1\":{\"475\":1}}],[\"尝试使用更为精妙的\",{\"1\":{\"347\":1}}],[\"半开状态允许的最大请求数\",{\"1\":{\"477\":1,\"478\":1}}],[\"半开\",{\"1\":{\"475\":2}}],[\"属于小概率事件\",{\"1\":{\"782\":1}}],[\"属于表锁范畴\",{\"1\":{\"773\":1}}],[\"属于修正的第三范式\",{\"1\":{\"737\":1}}],[\"属于\",{\"1\":{\"589\":2}}],[\"属于正常状态\",{\"1\":{\"475\":1}}],[\"属性为\",{\"1\":{\"763\":2}}],[\"属性的定义\",{\"1\":{\"736\":1}}],[\"属性\",{\"1\":{\"512\":2,\"794\":1}}],[\"属性指明调用出错时的返回逻辑\",{\"1\":{\"420\":1}}],[\"关于这些扩展\",{\"1\":{\"868\":1}}],[\"关于设置时使用global或session的影响\",{\"1\":{\"746\":1}}],[\"关于数据表设计的基本原则\",{\"1\":{\"736\":1}}],[\"关于select\",{\"1\":{\"729\":1}}],[\"关于标点符号\",{\"1\":{\"518\":1}}],[\"关注点\",{\"1\":{\"702\":1}}],[\"关键字不能被缩写也不能分行\",{\"1\":{\"518\":1}}],[\"关键字\",{\"1\":{\"518\":2,\"614\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":1,\"702\":1,\"746\":2}}],[\"关系型数据库的设计规则\",{\"0\":{\"511\":1}}],[\"关系型数据库以\",{\"1\":{\"509\":1}}],[\"关系型数据库模型是把复杂的数据结构归结为简单的\",{\"1\":{\"509\":1}}],[\"关系型数据库\",{\"0\":{\"509\":1}}],[\"关系型数据库绝对是\",{\"1\":{\"508\":1}}],[\"关闭日志\",{\"1\":{\"806\":1}}],[\"关闭慢查询日志\",{\"1\":{\"698\":1}}],[\"关闭转换为开启状态\",{\"1\":{\"475\":1}}],[\"关闭\",{\"0\":{\"698\":1},\"1\":{\"475\":1}}],[\"关联查询的优化\",{\"0\":{\"723\":1}}],[\"关联子查询\",{\"1\":{\"579\":1}}],[\"关联起来\",{\"1\":{\"484\":1}}],[\"关联\",{\"1\":{\"410\":1,\"579\":1}}],[\"断路开启经过一段时间后\",{\"1\":{\"475\":1}}],[\"断路器打开\",{\"1\":{\"478\":1}}],[\"断路器把调用时间⼤于slowcalldurationthreshold\",{\"1\":{\"478\":1}}],[\"断路器把调用时间大于slowcalldurationthreshold的调用视为慢调用\",{\"1\":{\"476\":1}}],[\"断路器也不会开启\",{\"1\":{\"477\":1}}],[\"断路器也不会进入到打开状态\",{\"1\":{\"476\":1}}],[\"断路器计算失败率或慢调用率之前所需的最小样本\",{\"1\":{\"477\":1,\"478\":1}}],[\"断路器相当于家庭的保险丝\",{\"1\":{\"477\":1}}],[\"断路器应该配置在哪个模块\",{\"1\":{\"477\":1}}],[\"断路器再次进入打开状态\",{\"1\":{\"476\":1}}],[\"断路器开启\",{\"1\":{\"476\":1}}],[\"断路器的滑动窗口期类型\",{\"1\":{\"476\":1}}],[\"断路器的状态\",{\"1\":{\"475\":1}}],[\"断路器配置参数\",{\"0\":{\"476\":1}}],[\"断路器使用滑动窗口来统计调用结果\",{\"1\":{\"475\":1}}],[\"断路器就会由\",{\"1\":{\"475\":1}}],[\"断路器关闭时\",{\"1\":{\"475\":1}}],[\"断路器会恢复到关闭状态\",{\"1\":{\"475\":1}}],[\"断路器会暂时拒绝所有请求\",{\"1\":{\"475\":1}}],[\"断路器会切换到开启状态\",{\"1\":{\"475\":1}}],[\"断路器\",{\"1\":{\"475\":1}}],[\"断路\",{\"1\":{\"474\":1}}],[\"断言\",{\"1\":{\"422\":1,\"489\":1}}],[\"供您在应用程序中使用\",{\"1\":{\"474\":1}}],[\"严重影响查询的效率\",{\"1\":{\"689\":1}}],[\"严重影\",{\"1\":{\"650\":1}}],[\"严禁一窝蜂的过来拥挤\",{\"1\":{\"472\":1}}],[\"严格递增\",{\"1\":{\"71\":1}}],[\"紧接着\",{\"1\":{\"472\":1}}],[\"紧接着继续带入\",{\"1\":{\"299\":2}}],[\"积压了大量请求\",{\"1\":{\"472\":1}}],[\"线程就可以读取到主库的二进制日志转储线程发送的\",{\"1\":{\"820\":1}}],[\"线程\",{\"1\":{\"820\":2}}],[\"线程等待权限的默认等待时间\",{\"1\":{\"482\":1}}],[\"线程资源逐渐耗尽\",{\"1\":{\"472\":1}}],[\"线程池打满\",{\"1\":{\"472\":1}}],[\"线索二叉树\",{\"1\":{\"0\":1}}],[\"程序实现\",{\"1\":{\"783\":1}}],[\"程序员可以在事务执行过程中手动输入rollback语句结束当前事务的执行\",{\"1\":{\"755\":1}}],[\"程序运行异常\",{\"1\":{\"472\":1}}],[\"程序逻辑异常了\",{\"1\":{\"416\":2}}],[\"雪崩效应\",{\"1\":{\"471\":1}}],[\"扇出\",{\"1\":{\"471\":1}}],[\"复制以下几种语句时的行锁更少\",{\"1\":{\"823\":1}}],[\"复制就会快了很多\",{\"1\":{\"823\":1}}],[\"复制会原矩阵\",{\"1\":{\"298\":1}}],[\"复习\",{\"0\":{\"792\":1}}],[\"复用\",{\"1\":{\"765\":1}}],[\"复杂的回滚时\",{\"1\":{\"823\":1}}],[\"复杂度是o\",{\"1\":{\"562\":1}}],[\"复杂分布式体系结构中的应用程序有数十个依赖关系\",{\"1\":{\"471\":1}}],[\"含有\",{\"1\":{\"470\":1}}],[\"含义为\",{\"1\":{\"476\":1}}],[\"含义\",{\"1\":{\"81\":1,\"83\":1,\"91\":1}}],[\"触发器\",{\"1\":{\"627\":1}}],[\"触发压缩数据类型\",{\"1\":{\"469\":1}}],[\"触发限流\",{\"1\":{\"423\":1}}],[\"触发限流规则会执行\",{\"1\":{\"416\":1}}],[\"局部唯一性\",{\"1\":{\"731\":1}}],[\"局部配置\",{\"1\":{\"466\":1}}],[\"局部最优解\",{\"1\":{\"346\":1}}],[\"局部最优\",{\"1\":{\"122\":1,\"342\":1,\"354\":1}}],[\"较大\",{\"1\":{\"830\":1}}],[\"较大元素和较大元素组合\",{\"1\":{\"258\":1}}],[\"较多\",{\"1\":{\"725\":1}}],[\"较与\",{\"1\":{\"462\":1}}],[\"拷贝到它的中继日志\",{\"1\":{\"820\":1}}],[\"拷贝\",{\"1\":{\"459\":1}}],[\"硬件\",{\"1\":{\"457\":1}}],[\"硬编码订单微服务则后续的维护会变得异常复杂\",{\"1\":{\"447\":1}}],[\"硬编码\",{\"1\":{\"446\":1}}],[\"环境下是大小写敏感的\",{\"1\":{\"518\":1}}],[\"环境下是大小写不敏感的\",{\"1\":{\"518\":1}}],[\"环境\",{\"1\":{\"452\":2}}],[\"环境搭建\",{\"0\":{\"441\":1}}],[\"替代具体的\",{\"1\":{\"451\":1}}],[\"替换默认的httpurlconnection\",{\"1\":{\"468\":1}}],[\"替换成\",{\"1\":{\"188\":1}}],[\"替换\",{\"1\":{\"152\":1,\"564\":1}}],[\"替换操作\",{\"1\":{\"152\":1,\"153\":1}}],[\"替换为\",{\"1\":{\"151\":4,\"353\":1}}],[\"替换一个字符\",{\"1\":{\"151\":1}}],[\"命令查看事件的起始点和终止点\",{\"1\":{\"809\":1}}],[\"命令行查看\",{\"1\":{\"449\":1}}],[\"命名空间id\",{\"1\":{\"404\":1}}],[\"文章标题列表\",{\"1\":{\"861\":1}}],[\"文本字符串总体上分为\",{\"1\":{\"603\":1}}],[\"文本字符串类型\",{\"0\":{\"603\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"885\":1}}],[\"文件生成页面\",{\"1\":{\"864\":1}}],[\"文件较小\",{\"1\":{\"823\":1}}],[\"文件名的格式是\",{\"1\":{\"813\":1}}],[\"文件中\",{\"1\":{\"810\":1}}],[\"文件位置\",{\"1\":{\"809\":1}}],[\"文件可以设置二进制日志的相关参数\",{\"1\":{\"809\":1}}],[\"文件系统缓存\",{\"1\":{\"753\":1}}],[\"文件系统上\",{\"1\":{\"632\":1}}],[\"文件尾\",{\"0\":{\"669\":1}}],[\"文件头部和文件尾部都有属性\",{\"1\":{\"668\":1}}],[\"文件头内部组成\",{\"1\":{\"668\":1}}],[\"文件的方式存\",{\"1\":{\"632\":1}}],[\"文件夹的图片\",{\"1\":{\"885\":1}}],[\"文件夹\",{\"1\":{\"454\":1}}],[\"文件\",{\"1\":{\"449\":1,\"635\":1,\"864\":1}}],[\"文档数据库所存放的文档\",{\"1\":{\"510\":1}}],[\"文档型数据库\",{\"1\":{\"510\":1}}],[\"文档\",{\"1\":{\"399\":1,\"405\":1,\"479\":1,\"482\":1}}],[\"界面\",{\"1\":{\"449\":1}}],[\"健康检测\",{\"1\":{\"449\":1}}],[\"功能\",{\"1\":{\"449\":1}}],[\"语言的使\",{\"1\":{\"835\":1}}],[\"语言开发\",{\"1\":{\"449\":1}}],[\"语句会比较长\",{\"1\":{\"835\":1}}],[\"语句即可\",{\"1\":{\"826\":1}}],[\"语句可以并发的执行\",{\"1\":{\"772\":1}}],[\"语句能够提前确定插入的数据量\",{\"1\":{\"772\":1}}],[\"语句时锁更少\",{\"1\":{\"823\":1}}],[\"语句时\",{\"1\":{\"770\":1,\"823\":1}}],[\"语句开启一个事务\",{\"1\":{\"745\":1}}],[\"语句相较于\",{\"1\":{\"744\":1}}],[\"语句输出的各个列的作用如下\",{\"1\":{\"700\":1}}],[\"语句的逻辑操作\",{\"1\":{\"811\":1}}],[\"语句的使用方法与explain语句是一样的\",{\"1\":{\"700\":1}}],[\"语句的执行路径\",{\"1\":{\"629\":1,\"634\":1}}],[\"语句在\",{\"1\":{\"634\":1}}],[\"语句进行查询处理\",{\"1\":{\"633\":1}}],[\"语句进行语法分析\",{\"1\":{\"628\":1,\"634\":1}}],[\"语句规定\",{\"1\":{\"612\":1}}],[\"语句实现比较复杂的查询\",{\"1\":{\"724\":1}}],[\"语句实现\",{\"1\":{\"599\":1}}],[\"语句\",{\"1\":{\"589\":2,\"612\":1,\"634\":2,\"651\":1,\"729\":1,\"772\":1,\"823\":1}}],[\"语句执行这些步骤的时候\",{\"1\":{\"565\":1}}],[\"语句将删除表中的所有记录\",{\"1\":{\"542\":1}}],[\"语句组合多个routepredicatefactory\",{\"1\":{\"491\":1}}],[\"语法进行了扩展\",{\"1\":{\"868\":1}}],[\"语法扩展\",{\"1\":{\"867\":1}}],[\"语法更加复杂\",{\"1\":{\"835\":1}}],[\"语法如下\",{\"1\":{\"831\":1}}],[\"语法解析\",{\"1\":{\"635\":1}}],[\"语法树\",{\"1\":{\"628\":1}}],[\"语法格式\",{\"1\":{\"540\":1}}],[\"语法\",{\"1\":{\"538\":1,\"869\":1,\"886\":1}}],[\"语义分析\",{\"1\":{\"628\":1,\"634\":1}}],[\"语义\",{\"1\":{\"436\":1}}],[\"安装\",{\"0\":{\"449\":1}}],[\"安全的在\",{\"1\":{\"870\":1}}],[\"安全可靠\",{\"1\":{\"823\":1}}],[\"安全等于运算符\",{\"1\":{\"528\":1}}],[\"安全级别\",{\"1\":{\"517\":1}}],[\"安全\",{\"1\":{\"399\":2}}],[\"项目中有大量重复的代码\",{\"1\":{\"447\":1}}],[\"项的和\",{\"1\":{\"79\":1}}],[\"∩\",{\"1\":{\"446\":2}}],[\"暂时通过\",{\"1\":{\"446\":1}}],[\"暂存\",{\"1\":{\"299\":1}}],[\"匿名用户访问无权限资源时的异常\",{\"1\":{\"444\":1}}],[\"枚举类\",{\"1\":{\"444\":1}}],[\"成一个默认的值\",{\"1\":{\"618\":1}}],[\"成\",{\"1\":{\"608\":1}}],[\"成功修改记录\",{\"1\":{\"443\":1}}],[\"成功插入记录\",{\"1\":{\"443\":1}}],[\"成为了确保订单业务稳定运行的核心诉求之一\",{\"1\":{\"425\":1}}],[\"真正的写入会交给系\",{\"1\":{\"753\":1}}],[\"真正的负责了mysql中数据的存储和提取\",{\"1\":{\"631\":1}}],[\"真正引入\",{\"1\":{\"441\":1}}],[\"真是有点\",{\"1\":{\"342\":1}}],[\"搭建链路监控\",{\"0\":{\"486\":1}}],[\"搭建maven父工程\",{\"1\":{\"441\":1}}],[\"搭建示例项目\",{\"0\":{\"440\":1}}],[\"搭建cloudalibaba\",{\"1\":{\"403\":1}}],[\"业务名称\",{\"1\":{\"836\":1}}],[\"业务字段做主键\",{\"0\":{\"732\":1}}],[\"业务还需要额外执行一次类似\",{\"1\":{\"731\":1}}],[\"业务上具有唯一特性的字段\",{\"1\":{\"689\":1}}],[\"业务逻辑异常\",{\"1\":{\"444\":1}}],[\"业务图\",{\"1\":{\"440\":1}}],[\"业务\",{\"1\":{\"436\":5}}],[\"业务代码\",{\"1\":{\"418\":1}}],[\"微服务b和微服务c又调用其它的微服务\",{\"1\":{\"471\":1}}],[\"微服务\",{\"0\":{\"433\":1,\"434\":1},\"1\":{\"447\":1,\"459\":1},\"2\":{\"437\":1,\"505\":1}}],[\"订单流水号\",{\"1\":{\"440\":1,\"443\":1}}],[\"订单微服务结束调用account账号\",{\"1\":{\"432\":1}}],[\"订单微服务结束调用storage库存\",{\"1\":{\"432\":1}}],[\"订单微服务开始调用account账号\",{\"1\":{\"432\":1}}],[\"订单微服务开始调用storage库存\",{\"1\":{\"432\":1}}],[\"订单微服务通过openfeign去调用账户微服务\",{\"1\":{\"432\":1}}],[\"订单微服务通过openfeign去调用库存微服务\",{\"1\":{\"432\":1}}],[\"订单状态status\",{\"1\":{\"432\":2}}],[\"订单状态\",{\"1\":{\"431\":1}}],[\"扣减账户时\",{\"1\":{\"435\":1}}],[\"扣减账户余额成功\",{\"1\":{\"434\":1}}],[\"扣减账户余额\",{\"1\":{\"431\":2,\"434\":2}}],[\"扣减账号余额\",{\"1\":{\"432\":2}}],[\"扣减库存成功\",{\"1\":{\"433\":1}}],[\"扣减库存\",{\"1\":{\"432\":2,\"433\":3,\"434\":1}}],[\"需求\",{\"1\":{\"497\":1,\"503\":1,\"539\":1}}],[\"需求说明\",{\"1\":{\"430\":1}}],[\"需要将用户数据写入重试表中\",{\"1\":{\"851\":1}}],[\"需要将输入栈导入到输出栈\",{\"1\":{\"322\":1}}],[\"需要如下的方式建立账户\",{\"1\":{\"825\":1}}],[\"需要区别于正在活跃的事务id\",{\"1\":{\"797\":1}}],[\"需要读取哪个版本的行记录呢\",{\"1\":{\"796\":1}}],[\"需要让它们\",{\"1\":{\"763\":1}}],[\"需要对\",{\"1\":{\"725\":1,\"760\":1}}],[\"需要对map中的元素按照\",{\"1\":{\"337\":1}}],[\"需要我们手动来设置这个参数\",{\"1\":{\"697\":1}}],[\"需要重新进行传输\",{\"1\":{\"668\":1}}],[\"需要的注意的是\",{\"1\":{\"774\":1}}],[\"需要的io操作就越少\",{\"1\":{\"662\":1}}],[\"需要的箭数\",{\"1\":{\"364\":1}}],[\"需要遍历桶中的行指针来进行比较\",{\"1\":{\"658\":1}}],[\"需要识别出里面\",{\"1\":{\"634\":1}}],[\"需要说明的是\",{\"1\":{\"634\":1}}],[\"需要消耗系统资源\",{\"1\":{\"618\":1}}],[\"需要先删除从表中依赖\",{\"1\":{\"618\":1}}],[\"需要先将输入栈导入输出栈\",{\"1\":{\"323\":2}}],[\"需要注意的一点是\",{\"1\":{\"616\":1}}],[\"需要注意的是在mysql8中只有\",{\"1\":{\"809\":1}}],[\"需要注意的是对于innodb引擎来说\",{\"1\":{\"767\":1}}],[\"需要注意的是除法和减法\",{\"1\":{\"331\":1}}],[\"需要注意的是\",{\"1\":{\"91\":1,\"313\":1,\"317\":1,\"389\":1,\"565\":1,\"579\":1,\"702\":1,\"728\":1,\"780\":1}}],[\"需要2个字节的存储空间\",{\"1\":{\"606\":1}}],[\"需要1个字节的存储空间\",{\"1\":{\"606\":1}}],[\"需要从同一个表中先计算得出一个数据结果\",{\"1\":{\"568\":1}}],[\"需要两个参数\",{\"1\":{\"502\":1}}],[\"需要一个\",{\"1\":{\"499\":2,\"500\":2,\"501\":1}}],[\"需要一维数组保存单一路径\",{\"1\":{\"222\":1}}],[\"需要服务熔断来确保整个系统的可用性\",{\"1\":{\"472\":1}}],[\"需要调用接口的\",{\"1\":{\"463\":1}}],[\"需要配置负载均衡\",{\"1\":{\"451\":1}}],[\"需要在数据库服务器端生成\",{\"1\":{\"731\":1}}],[\"需要在依赖中排除\",{\"1\":{\"450\":1}}],[\"需要在对$count\",{\"1\":{\"307\":1}}],[\"需要部署更多的订单微服务和支付微服务\",{\"1\":{\"447\":1}}],[\"需要持久化\",{\"1\":{\"424\":1}}],[\"需要同时配置redirect\",{\"1\":{\"422\":2}}],[\"需要进行很多的\",{\"1\":{\"749\":1}}],[\"需要进行持久化配置\",{\"1\":{\"422\":1}}],[\"需要进行下一个跳跃\",{\"1\":{\"352\":1}}],[\"需要根据调用接口的来源判断是否允许执行本次请求\",{\"1\":{\"418\":1}}],[\"需要trace的异常\",{\"1\":{\"416\":1}}],[\"需要请自取\",{\"1\":{\"398\":1,\"439\":1}}],[\"需要删除的节点\",{\"1\":{\"379\":1}}],[\"需要留意的是\",{\"1\":{\"378\":1}}],[\"需要至少两个摄像头来监视树的所有节点\",{\"1\":{\"371\":1}}],[\"需要移除区间的最小数量\",{\"1\":{\"365\":1}}],[\"需要手动保持队列中的元素单调性\",{\"1\":{\"339\":1}}],[\"需要找到其中的规律\",{\"1\":{\"304\":1}}],[\"需要满足以下的条件\",{\"1\":{\"295\":1}}],[\"需要舍弃左边\",{\"1\":{\"277\":1}}],[\"需要舍弃右边\",{\"1\":{\"277\":1}}],[\"需要确定起始的元素是哪个\",{\"1\":{\"187\":1}}],[\"需要用到`idx\",{\"1\":{\"710\":1}}],[\"需要用到\",{\"1\":{\"155\":1}}],[\"需要用额外的一个指针来访问\",{\"1\":{\"9\":1}}],[\"需要向题目中添加哪些限制条件\",{\"1\":{\"104\":1}}],[\"需要\",{\"1\":{\"80\":1}}],[\"案例\",{\"0\":{\"573\":1,\"578\":1}}],[\"案例2\",{\"1\":{\"533\":1}}],[\"案例搭建\",{\"0\":{\"430\":1}}],[\"案例演示\",{\"0\":{\"459\":1,\"464\":1},\"1\":{\"416\":1}}],[\"`filesort`\",{\"1\":{\"710\":1}}],[\"`表示需要进行索引合并的索引名称\",{\"1\":{\"710\":1}}],[\"`提示\",{\"1\":{\"710\":3}}],[\"`salary`\",{\"1\":{\"569\":2}}],[\"`status`\",{\"1\":{\"428\":5,\"431\":1}}],[\"``\",{\"1\":{\"524\":2}}],[\"`\",{\"1\":{\"442\":2,\"832\":1}}],[\"`department\",{\"1\":{\"579\":2}}],[\"`deleted`\",{\"1\":{\"440\":1}}],[\"`distributed\",{\"1\":{\"428\":5}}],[\"`atguigu`\",{\"1\":{\"832\":1}}],[\"`amount`\",{\"1\":{\"440\":1}}],[\"`application\",{\"1\":{\"428\":3}}],[\"`order`\",{\"1\":{\"524\":1}}],[\"`order\",{\"1\":{\"440\":1}}],[\"`int\",{\"1\":{\"595\":1}}],[\"`ix\",{\"1\":{\"431\":3}}],[\"`id`\",{\"1\":{\"431\":5,\"440\":2}}],[\"`idx\",{\"1\":{\"428\":6}}],[\"`log\",{\"1\":{\"431\":12}}],[\"`lock\",{\"1\":{\"428\":4}}],[\"`union`等子句的查询过程中\",{\"1\":{\"710\":1}}],[\"`undo\",{\"1\":{\"431\":6}}],[\"`update\",{\"1\":{\"440\":1}}],[\"`used`\",{\"1\":{\"431\":4}}],[\"`user\",{\"1\":{\"431\":3,\"440\":1}}],[\"`ux\",{\"1\":{\"431\":3}}],[\"`money`\",{\"1\":{\"431\":1}}],[\"`class`\",{\"1\":{\"832\":2}}],[\"`client\",{\"1\":{\"428\":1}}],[\"`create\",{\"1\":{\"440\":1}}],[\"`context`\",{\"1\":{\"431\":3}}],[\"`count`\",{\"1\":{\"431\":1}}],[\"`pay\",{\"1\":{\"440\":1}}],[\"`product\",{\"1\":{\"431\":3}}],[\"`pk`\",{\"1\":{\"428\":1}}],[\"`expire`\",{\"1\":{\"428\":1}}],[\"`residue`\",{\"1\":{\"431\":4}}],[\"`resource\",{\"1\":{\"428\":3}}],[\"`rollback\",{\"1\":{\"431\":3}}],[\"`row\",{\"1\":{\"428\":2}}],[\"`branch\",{\"1\":{\"428\":6,\"431\":6}}],[\"`begin\",{\"1\":{\"428\":1}}],[\"`group\",{\"1\":{\"710\":1}}],[\"`gmt\",{\"1\":{\"428\":7}}],[\"`global\",{\"1\":{\"428\":1}}],[\"`t\",{\"1\":{\"440\":2}}],[\"`total`\",{\"1\":{\"431\":4}}],[\"`table\",{\"1\":{\"428\":1}}],[\"`timeout`\",{\"1\":{\"428\":1}}],[\"`transaction\",{\"1\":{\"428\":6}}],[\"`xid`\",{\"1\":{\"428\":6,\"431\":6}}],[\"调整业务逻辑\",{\"1\":{\"786\":1}}],[\"调度\",{\"1\":{\"426\":1}}],[\"调用底层存储引擎提供的\",{\"1\":{\"635\":1}}],[\"调用父类的构造器\",{\"1\":{\"497\":2,\"504\":1}}],[\"调用方\",{\"1\":{\"477\":1}}],[\"调用方式\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"调用端\",{\"1\":{\"475\":1}}],[\"调用服务端中具体的controller\",{\"1\":{\"464\":1}}],[\"调用数>5\",{\"1\":{\"414\":1,\"415\":1}}],[\"调用被触发\",{\"1\":{\"412\":1}}],[\"调用\",{\"1\":{\"274\":3,\"312\":1,\"412\":1,\"420\":1,\"446\":1}}],[\"申请开启一个全局事务\",{\"1\":{\"426\":1}}],[\"驱动分支事务的提交或者回滚\",{\"1\":{\"426\":1}}],[\"驱动全局事务提交或者回滚\",{\"1\":{\"426\":1}}],[\"工具来进行物理备份\",{\"1\":{\"830\":1}}],[\"工具进行查看\",{\"1\":{\"813\":1}}],[\"工具做针对性的分析查询语句\",{\"1\":{\"700\":1}}],[\"工作中常用的\",{\"1\":{\"699\":1}}],[\"工作流程\",{\"1\":{\"426\":1,\"488\":1}}],[\"工资都低的员工的员工号\",{\"1\":{\"578\":2}}],[\"工程埋雷\",{\"1\":{\"420\":1}}],[\"四个隔离级别可以解决的并发问题如下\",{\"1\":{\"793\":1}}],[\"四个元素\",{\"1\":{\"97\":1}}],[\"四舍五入\",{\"1\":{\"548\":1}}],[\"四种\",{\"1\":{\"513\":1}}],[\"四\",{\"0\":{\"425\":1,\"471\":1,\"568\":1}}],[\"固定长度的\",{\"1\":{\"604\":1}}],[\"固定死的\",{\"1\":{\"424\":1}}],[\"固定为1\",{\"1\":{\"419\":1}}],[\"名称默认为\",{\"1\":{\"807\":1}}],[\"名称的\",{\"1\":{\"493\":1}}],[\"名称是你的\",{\"1\":{\"424\":1}}],[\"名词解释\",{\"1\":{\"412\":1}}],[\"稍后重试\",{\"1\":{\"422\":1}}],[\"发给\",{\"1\":{\"806\":1}}],[\"发起死锁检测\",{\"1\":{\"786\":1}}],[\"发起针对\",{\"1\":{\"426\":1}}],[\"发生锁冲突的几率也更\",{\"1\":{\"786\":1}}],[\"发生\",{\"1\":{\"774\":1}}],[\"发生重叠\",{\"1\":{\"366\":1}}],[\"发问题发生的就越多\",{\"1\":{\"746\":1}}],[\"发出请求\",{\"1\":{\"488\":1}}],[\"发送给mq服务器\",{\"1\":{\"852\":1}}],[\"发送的只能是get请求\",{\"1\":{\"446\":1}}],[\"发送请求完\",{\"1\":{\"435\":1}}],[\"发现redolog还处于prepare阶段\",{\"1\":{\"812\":1}}],[\"发现问题\",{\"1\":{\"805\":1}}],[\"发现死锁后\",{\"1\":{\"786\":1}}],[\"发现name已经使用了索引\",{\"1\":{\"718\":1}}],[\"发现订单创建了\",{\"1\":{\"435\":1}}],[\"发现报以下错误\",{\"1\":{\"422\":1}}],[\"路由谓词工厂接受一个\",{\"1\":{\"495\":1,\"496\":1}}],[\"路由谓词工厂需要两个参数\",{\"1\":{\"494\":1}}],[\"路由谓词\",{\"1\":{\"494\":1}}],[\"路由地址\",{\"1\":{\"489\":1}}],[\"路由是构建网关的基本模块\",{\"1\":{\"488\":1}}],[\"路由\",{\"1\":{\"488\":1}}],[\"路由的id\",{\"1\":{\"422\":1,\"489\":1}}],[\"路径导航\",{\"1\":{\"858\":1,\"861\":1}}],[\"路径匹配\",{\"1\":{\"493\":1}}],[\"路径错误\",{\"1\":{\"454\":1}}],[\"路径相匹配的进行路由\",{\"1\":{\"422\":1,\"489\":1}}],[\"路径\",{\"1\":{\"185\":2}}],[\"路径和结点是成双成对的\",{\"1\":{\"39\":1}}],[\"缺点是无法像关系型数据库一样使用条件过滤\",{\"1\":{\"510\":1}}],[\"缺点就是\",{\"1\":{\"423\":1}}],[\"缺点\",{\"1\":{\"422\":1,\"642\":1,\"650\":1,\"774\":1}}],[\"维度\",{\"1\":{\"421\":2}}],[\"维护的底层数据执行操作\",{\"1\":{\"631\":1}}],[\"维护的全局事务和分支事务状态\",{\"1\":{\"426\":1}}],[\"维护整个序列最长子序列长度\",{\"1\":{\"135\":1}}],[\"维护到当前元素时的最长子序列\",{\"1\":{\"135\":1}}],[\"维护一个变量\",{\"1\":{\"58\":1}}],[\"降低了死锁的概率\",{\"1\":{\"801\":1}}],[\"降低了cpu的消耗\",{\"1\":{\"642\":1}}],[\"降低更新表的速度\",{\"1\":{\"642\":1}}],[\"降低\",{\"1\":{\"642\":1}}],[\"降低版本即可\",{\"1\":{\"420\":1}}],[\"降级\",{\"1\":{\"472\":1}}],[\"降级等功能\",{\"1\":{\"462\":1}}],[\"降级等规则\",{\"1\":{\"416\":1}}],[\"激活sentinel对feign的支持\",{\"1\":{\"420\":1}}],[\"激活sentinel对openfeign的支持\",{\"1\":{\"420\":1}}],[\"╥\",{\"1\":{\"420\":2}}],[\"持久性的特性\",{\"1\":{\"749\":1}}],[\"持久性是指一个事务一旦被提交\",{\"1\":{\"741\":1}}],[\"持久性\",{\"1\":{\"741\":1}}],[\"持久化\",{\"1\":{\"454\":1}}],[\"持久化规则\",{\"0\":{\"419\":1,\"424\":1},\"1\":{\"424\":1}}],[\"持有\",{\"1\":{\"126\":1}}],[\"持有股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"黑名单\",{\"1\":{\"418\":1}}],[\"黑禁止\",{\"1\":{\"418\":1}}],[\"白名单\",{\"1\":{\"418\":1}}],[\"白名单与黑名单\",{\"1\":{\"418\":1}}],[\"白放行\",{\"1\":{\"418\":1}}],[\"授权规则不通过\",{\"1\":{\"444\":2}}],[\"授权规则\",{\"0\":{\"418\":1}}],[\"期望某个参数达到某个特殊值之后\",{\"1\":{\"417\":1}}],[\"达到一定的异常比例之后进入熔断状态\",{\"1\":{\"415\":1}}],[\"达到dp\",{\"1\":{\"124\":2,\"126\":2}}],[\"异步读取重试表中的用户数据\",{\"1\":{\"851\":1}}],[\"异常处理\",{\"1\":{\"498\":1}}],[\"异常\",{\"1\":{\"477\":1}}],[\"异常数模式下为对应的阈值\",{\"1\":{\"419\":1}}],[\"异常数策略\",{\"1\":{\"419\":1}}],[\"异常数\",{\"0\":{\"415\":1},\"1\":{\"415\":1,\"419\":1}}],[\"异常调用\",{\"1\":{\"414\":1}}],[\"异常比例\",{\"0\":{\"414\":1},\"1\":{\"414\":1,\"419\":3}}],[\"异位词变为相同的单词\",{\"1\":{\"165\":1}}],[\"异位词\",{\"1\":{\"165\":2}}],[\"异位词的特点\",{\"1\":{\"165\":1}}],[\"探路先锋\",{\"1\":{\"412\":1}}],[\"探测恢复状态\",{\"1\":{\"412\":1}}],[\"剩余可用额度\",{\"1\":{\"431\":1}}],[\"剩余库存\",{\"1\":{\"431\":1}}],[\"剩余4次全被抛弃了\",{\"1\":{\"411\":1}}],[\"剩下的2位用于主机地址\",{\"1\":{\"495\":1}}],[\"剩下的区间没有重叠\",{\"1\":{\"365\":1}}],[\"剩下的元素保持其原始顺序\",{\"1\":{\"345\":1}}],[\"剩下的就是不重复的元素\",{\"1\":{\"329\":1}}],[\"匀速排队\",{\"1\":{\"411\":1}}],[\"阀值为10\",{\"1\":{\"411\":1}}],[\"阈值\",{\"1\":{\"411\":1}}],[\"阈值类型\",{\"1\":{\"409\":1,\"419\":2}}],[\"冷启动\",{\"1\":{\"411\":1}}],[\"冷启动方式\",{\"1\":{\"411\":1}}],[\"冷冻期\",{\"1\":{\"127\":1}}],[\"预估的需要读取的记录条数值越小越好\",{\"1\":{\"708\":1}}],[\"预热时长设置5秒\",{\"1\":{\"411\":1}}],[\"预热\",{\"1\":{\"411\":1}}],[\"预先按照升序排列\",{\"1\":{\"276\":1}}],[\"快照读又叫一致性读\",{\"1\":{\"791\":1}}],[\"快照读\",{\"1\":{\"791\":2}}],[\"快照读和当前读\",{\"0\":{\"791\":1}}],[\"快\",{\"1\":{\"542\":1,\"725\":1}}],[\"快捷方式\",{\"1\":{\"491\":1,\"497\":1}}],[\"快捷方式和完全展开的参数\",{\"1\":{\"491\":1}}],[\"快速返回失败处理或者返回默认兜底数据\",{\"1\":{\"471\":1}}],[\"快速熔断\",{\"1\":{\"471\":1}}],[\"快速失败\",{\"1\":{\"411\":1}}],[\"快乐数\",{\"1\":{\"169\":2}}],[\"资源\",{\"1\":{\"760\":1}}],[\"资源分类\",{\"1\":{\"416\":1}}],[\"资源的唯一名称\",{\"1\":{\"409\":1}}],[\"资源名为对应的\",{\"1\":{\"421\":1}}],[\"资源名称\",{\"1\":{\"416\":1,\"419\":1}}],[\"资源名\",{\"1\":{\"409\":1,\"419\":2}}],[\"运行或停止mysql服务时出现的问题\",{\"1\":{\"805\":1}}],[\"运行时间为\",{\"1\":{\"696\":2}}],[\"运行时环境\",{\"1\":{\"407\":1}}],[\"运行结果\",{\"1\":{\"696\":2}}],[\"运行断路器在half\",{\"1\":{\"476\":1}}],[\"运算符\",{\"0\":{\"526\":1}}],[\"运算对象\",{\"1\":{\"330\":1}}],[\"运算结果等于\",{\"1\":{\"98\":1}}],[\"库名与应用名称尽量一致\",{\"1\":{\"836\":1}}],[\"库存表\",{\"1\":{\"737\":1}}],[\"库存扣减了\",{\"1\":{\"435\":1}}],[\"库\",{\"1\":{\"407\":1,\"474\":1}}],[\"库的整合模块\",{\"1\":{\"406\":1}}],[\"扩展\",{\"0\":{\"867\":1,\"868\":1},\"1\":{\"868\":1}}],[\"扩展接口\",{\"1\":{\"406\":1}}],[\"扩展机制\",{\"1\":{\"406\":1}}],[\"等第一个线程查询到了数据\",{\"1\":{\"844\":1}}],[\"等其他的标准\",{\"1\":{\"835\":1}}],[\"等数据库更新事件的语句\",{\"1\":{\"808\":1}}],[\"等独占锁就是悲观锁思想的实现\",{\"1\":{\"781\":1}}],[\"等值\",{\"1\":{\"718\":1}}],[\"等值连接\",{\"0\":{\"533\":1}}],[\"等多种算法智能分析出文本文字中关键词的频率和重要性\",{\"1\":{\"686\":1}}],[\"等多语言的原生实现\",{\"1\":{\"406\":1}}],[\"等类型\",{\"1\":{\"603\":1}}],[\"等号运算符\",{\"1\":{\"528\":1}}],[\"等标准\",{\"1\":{\"516\":1}}],[\"等\",{\"1\":{\"510\":1,\"517\":3,\"637\":1,\"667\":1,\"836\":1}}],[\"等待后续进一步处理\",{\"1\":{\"851\":1}}],[\"等待队列\",{\"1\":{\"481\":2}}],[\"等待5秒后\",{\"1\":{\"477\":1}}],[\"等应用容器\",{\"1\":{\"407\":1}}],[\"等框架也有较好的支持\",{\"1\":{\"407\":1}}],[\"等于\",{\"1\":{\"190\":1}}],[\"等于val的元素\",{\"1\":{\"279\":1}}],[\"等于val\",{\"1\":{\"54\":1}}],[\"等于目标和的根节点到叶节点路径如上图所示\",{\"1\":{\"44\":1}}],[\"您可以通过实现扩展接口来快速地定制逻辑\",{\"1\":{\"406\":1}}],[\"您可以在控制台中看到接入应用的单台机器秒级数据\",{\"1\":{\"406\":1}}],[\"您可以在任何应用\",{\"1\":{\"399\":1}}],[\"您只需要引入相应的依赖并进行简单的配置即可快速地接入\",{\"1\":{\"406\":1}}],[\"广播地址是\",{\"1\":{\"495\":1}}],[\"广播地址和两个可用的主机地址\",{\"1\":{\"495\":1}}],[\"广泛的开源生态\",{\"1\":{\"406\":1}}],[\"广度优先遍历\",{\"1\":{\"12\":1,\"29\":1,\"222\":1}}],[\"广度优先搜索\",{\"1\":{\"12\":1}}],[\"台以下规模的集群的汇总运行情况\",{\"1\":{\"406\":1}}],[\"甚至超越了数据库领域\",{\"1\":{\"835\":1}}],[\"甚至是对数据库操作的审计都有很大的帮助\",{\"1\":{\"805\":1}}],[\"甚至是突然断电导致的错误\",{\"1\":{\"755\":1}}],[\"甚至是造成不可挽回的损失\",{\"1\":{\"599\":1}}],[\"甚至\",{\"1\":{\"406\":1}}],[\"集群总数为2\",{\"1\":{\"460\":1}}],[\"集群流量控制\",{\"1\":{\"406\":1}}],[\"集合是不重复的\",{\"1\":{\"267\":1}}],[\"集合内不能有重复的元素\",{\"1\":{\"211\":1}}],[\"集合之前\",{\"1\":{\"209\":1}}],[\"集合前\",{\"1\":{\"207\":1}}],[\"集合的和\",{\"1\":{\"190\":1}}],[\"集合的大小和孩子的数量是相等的\",{\"1\":{\"185\":1}}],[\"集合的大小构成了树的宽度\",{\"1\":{\"185\":1}}],[\"集合的大小就构成了树的宽度\",{\"1\":{\"184\":1}}],[\"集合了\",{\"1\":{\"177\":1}}],[\"集合中可以存在重复的元素\",{\"1\":{\"197\":1}}],[\"集合中的元素\",{\"1\":{\"187\":1}}],[\"集合中的元素等于\",{\"1\":{\"187\":1}}],[\"集合中\",{\"1\":{\"170\":1,\"190\":1,\"245\":1}}],[\"集合不重复的特点\",{\"1\":{\"167\":1}}],[\"集合\",{\"1\":{\"8\":1,\"100\":1,\"170\":1,\"267\":1,\"495\":1}}],[\"承接了阿里巴巴近\",{\"1\":{\"406\":1}}],[\"丰富的应用场景\",{\"1\":{\"406\":1}}],[\"流体动\",{\"1\":{\"600\":1}}],[\"流程处理函数可以根据不同的条件\",{\"1\":{\"559\":1}}],[\"流程控制函数\",{\"0\":{\"559\":1}}],[\"流程\",{\"1\":{\"432\":1}}],[\"流控效果\",{\"0\":{\"411\":1},\"1\":{\"419\":1}}],[\"流控模式\",{\"0\":{\"410\":1},\"1\":{\"419\":1}}],[\"流控规则\",{\"0\":{\"409\":1},\"1\":{\"419\":1,\"423\":1}}],[\"流量整形\",{\"1\":{\"406\":1}}],[\"流量控制\",{\"1\":{\"406\":1}}],[\"流动\",{\"1\":{\"233\":1}}],[\"介绍\",{\"0\":{\"406\":1,\"426\":1,\"449\":1,\"457\":1,\"462\":1,\"474\":1,\"865\":1},\"1\":{\"865\":1,\"866\":1}}],[\"|tail\",{\"1\":{\"809\":1}}],[\"|\",{\"1\":{\"405\":1,\"687\":11,\"696\":12,\"699\":2,\"701\":39,\"736\":6,\"745\":6,\"751\":6,\"767\":15,\"771\":12,\"806\":9,\"807\":15,\"809\":31,\"832\":2}}],[\"||board\",{\"1\":{\"232\":1}}],[\"||\",{\"1\":{\"7\":1,\"33\":3,\"37\":2,\"45\":1,\"47\":1,\"49\":1,\"54\":2,\"62\":3,\"113\":1,\"115\":1,\"128\":1,\"155\":2,\"193\":1,\"201\":2,\"207\":2,\"226\":7,\"228\":7,\"230\":13,\"232\":14,\"234\":4,\"262\":1,\"302\":1,\"311\":1,\"317\":1,\"326\":2,\"329\":1,\"344\":1,\"346\":2,\"372\":2,\"382\":1,\"386\":1,\"387\":1,\"389\":1,\"392\":1}}],[\"熔断机制\",{\"0\":{\"475\":1}}],[\"熔断\",{\"1\":{\"472\":1}}],[\"熔断触发的最小请求数\",{\"1\":{\"419\":1}}],[\"熔断策略\",{\"1\":{\"419\":1}}],[\"熔断时长\",{\"1\":{\"419\":1}}],[\"熔断时长为5s\",{\"1\":{\"414\":1,\"415\":1}}],[\"熔断时长为\",{\"1\":{\"413\":1}}],[\"熔断时长结束后进入探测恢复状态\",{\"1\":{\"412\":1}}],[\"熔断状态\",{\"1\":{\"412\":2}}],[\"熔断规则\",{\"0\":{\"412\":1},\"1\":{\"419\":1}}],[\"熔断限流\",{\"0\":{\"405\":1}}],[\"熔断降级作为保护自身的手段\",{\"1\":{\"475\":1}}],[\"熔断降级等功能\",{\"1\":{\"416\":1}}],[\"熔断降级\",{\"0\":{\"471\":1},\"1\":{\"399\":1,\"406\":1}}],[\"生表中的\",{\"1\":{\"837\":1}}],[\"生产环境需要将配置规则进行持久化\",{\"1\":{\"419\":1}}],[\"生产环境\",{\"1\":{\"404\":1}}],[\"生成一条重做日志并写入redo\",{\"1\":{\"752\":1}}],[\"生成一个\",{\"1\":{\"629\":1}}],[\"生成一个包含\",{\"1\":{\"287\":1}}],[\"生成的测试用例可以到达\",{\"1\":{\"351\":1}}],[\"生成\",{\"1\":{\"309\":1}}],[\"测试\",{\"1\":{\"404\":1,\"410\":1,\"467\":1,\"468\":1,\"470\":1,\"477\":1,\"493\":1,\"494\":1}}],[\"隔的字符串\",{\"1\":{\"552\":1}}],[\"隔板超出最大数量限制\",{\"1\":{\"480\":1}}],[\"隔离级别的事务\",{\"1\":{\"797\":3}}],[\"隔离级别下\",{\"1\":{\"765\":2}}],[\"隔离级别上就已经解决了\",{\"1\":{\"764\":1}}],[\"隔离级别格式\",{\"1\":{\"746\":2}}],[\"隔离级别\",{\"1\":{\"746\":3}}],[\"隔离级别越低\",{\"1\":{\"746\":1}}],[\"隔离性和持久性\",{\"1\":{\"747\":1}}],[\"隔离性\",{\"1\":{\"741\":1}}],[\"隔离允许并发线程执行的最大数量\",{\"1\":{\"480\":1}}],[\"隔离\",{\"0\":{\"479\":1},\"1\":{\"474\":1,\"480\":1,\"481\":1}}],[\"隔离等\",{\"1\":{\"404\":1}}],[\"隔开\",{\"1\":{\"134\":1}}],[\"演示意向锁质检互相兼容的情况\",{\"1\":{\"771\":1}}],[\"演示为读操作增加写锁被阻塞\",{\"1\":{\"767\":1}}],[\"演示\",{\"1\":{\"403\":1,\"865\":1}}],[\"⚡⚡⚡\",{\"1\":{\"403\":2}}],[\"主题扩展了更多\",{\"1\":{\"869\":1}}],[\"主题扩展\",{\"0\":{\"869\":1}}],[\"主题也带有以下元素\",{\"1\":{\"861\":1}}],[\"主服务器上执行\",{\"1\":{\"823\":1}}],[\"主服务器唯一id\",{\"1\":{\"823\":1}}],[\"主机名称\",{\"1\":{\"831\":1}}],[\"主机用户名的密码\",{\"1\":{\"826\":1}}],[\"主机用户名\",{\"1\":{\"826\":1}}],[\"主机的ip地址\",{\"1\":{\"826\":1}}],[\"主机配置文件\",{\"0\":{\"823\":1}}],[\"主机\",{\"0\":{\"825\":1},\"1\":{\"821\":1,\"823\":1}}],[\"主库可以将二进制日志发送给从库\",{\"1\":{\"820\":1}}],[\"主从机都关闭防火墙\",{\"1\":{\"824\":1}}],[\"主从版本可以不一样\",{\"1\":{\"823\":1}}],[\"主从所有配置项都配置在\",{\"1\":{\"823\":1}}],[\"主从同步设计不仅可以提高数据库的吞吐量\",{\"1\":{\"819\":1}}],[\"主从架构\",{\"1\":{\"818\":2}}],[\"主从复制的原理\",{\"0\":{\"820\":1}}],[\"主从复制的作用\",{\"0\":{\"819\":1}}],[\"主从复制的概述\",{\"0\":{\"817\":1}}],[\"主从复制\",{\"0\":{\"816\":1}}],[\"主动回滚死锁链条中的某一个事务\",{\"1\":{\"786\":1}}],[\"主教练\",{\"1\":{\"736\":1}}],[\"主属性\",{\"1\":{\"736\":1}}],[\"主键为\",{\"1\":{\"737\":1}}],[\"主键还可以加入业务和系统属性\",{\"1\":{\"733\":1}}],[\"主键的设计\",{\"0\":{\"730\":1}}],[\"主键索引就是一种\",{\"1\":{\"686\":1}}],[\"主键索引\",{\"1\":{\"686\":3}}],[\"主键值\",{\"1\":{\"654\":1}}],[\"主键值是依次递增的\",{\"1\":{\"643\":1}}],[\"主键列使用\",{\"1\":{\"617\":1}}],[\"主键列\",{\"1\":{\"617\":1}}],[\"主键约束对应的索引就自动删除了\",{\"1\":{\"616\":1}}],[\"主键约束列不允许重复\",{\"1\":{\"616\":1}}],[\"主键约束相当于唯一约束+非空约束的组合\",{\"1\":{\"616\":1}}],[\"主键约束\",{\"0\":{\"616\":1},\"1\":{\"687\":1}}],[\"主键\",{\"1\":{\"613\":1,\"719\":1,\"727\":1,\"736\":1,\"800\":1}}],[\"主查询的每一行都执行一次子查询\",{\"1\":{\"579\":1}}],[\"主表删除时\",{\"1\":{\"618\":1}}],[\"主表名\",{\"1\":{\"618\":2}}],[\"主表名称\",{\"1\":{\"618\":1}}],[\"主表的修改和删除数据受约束\",{\"1\":{\"618\":1}}],[\"主表的记录将不允许删除\",{\"1\":{\"618\":1}}],[\"主表的主键和从表的主键\",{\"1\":{\"513\":1}}],[\"主表的主键和从表的外键\",{\"1\":{\"513\":1}}],[\"主表\",{\"1\":{\"537\":2,\"618\":3}}],[\"主启动类增加\",{\"1\":{\"450\":1}}],[\"主启动类\",{\"1\":{\"403\":1,\"432\":1,\"443\":1,\"446\":1,\"464\":1}}],[\"主要从\",{\"1\":{\"864\":1}}],[\"主要看表的大小\",{\"1\":{\"729\":1}}],[\"主要针对于联合索引\",{\"1\":{\"706\":1}}],[\"主要的语句关键字包括\",{\"1\":{\"517\":3}}],[\"主要特性\",{\"1\":{\"406\":1}}],[\"主要以流量为切入点\",{\"1\":{\"406\":1}}],[\"主要功能与配置演示\",{\"0\":{\"856\":1}}],[\"主要功能\",{\"1\":{\"399\":1}}],[\"主要是监控应用的qps流量或者并发线程数等指标\",{\"1\":{\"409\":1}}],[\"主要是对于递推关系上的考虑有一些复杂\",{\"1\":{\"153\":1}}],[\"主要是为了初始化方便\",{\"1\":{\"146\":1}}],[\"主要为了初始化的方便\",{\"1\":{\"141\":1}}],[\"主要在于如何知道买卖的次数\",{\"1\":{\"124\":1}}],[\"模型中有三个主要概念是\",{\"1\":{\"512\":1}}],[\"模块配置熔断机制\",{\"1\":{\"477\":1}}],[\"模块模块新建一个\",{\"1\":{\"477\":1}}],[\"模块\",{\"1\":{\"447\":1,\"463\":1,\"477\":1}}],[\"模块为例\",{\"1\":{\"403\":1}}],[\"模式设定为启用\",{\"1\":{\"599\":1}}],[\"模式\",{\"1\":{\"426\":1}}],[\"模拟本地addorder新增订单成功\",{\"1\":{\"464\":1}}],[\"模拟消费者发送get请求\",{\"1\":{\"446\":1}}],[\"模拟订单支付的简单业务\",{\"1\":{\"440\":1}}],[\"模拟超时异常\",{\"1\":{\"434\":1}}],[\"模拟左侧从下到上\",{\"1\":{\"289\":1}}],[\"模拟下侧从右到左\",{\"1\":{\"289\":1}}],[\"模拟右侧从上到下\",{\"1\":{\"289\":1}}],[\"模拟上侧从左到右\",{\"1\":{\"289\":1}}],[\"模拟矩阵的行和列\",{\"1\":{\"289\":1}}],[\"模拟顺时针画矩阵的过程\",{\"1\":{\"288\":1}}],[\"模拟dp数组\",{\"1\":{\"143\":1}}],[\"负数返回\",{\"1\":{\"548\":1}}],[\"负数平方后变正数\",{\"1\":{\"282\":1}}],[\"负载均衡\",{\"1\":{\"819\":1}}],[\"负载均衡原理\",{\"0\":{\"460\":1}}],[\"负载保护\",{\"1\":{\"479\":1}}],[\"负责所有\",{\"1\":{\"821\":1}}],[\"负责读取数据\",{\"1\":{\"819\":1}}],[\"负责写入数据\",{\"1\":{\"819\":1}}],[\"负责数据的存储和读取\",{\"1\":{\"633\":1}}],[\"负责对\",{\"1\":{\"487\":1}}],[\"负责管理分支事务的资源\",{\"1\":{\"426\":1}}],[\"负责定义全局事务的范围\",{\"1\":{\"426\":1}}],[\"负责维护全局事务和分支事务的状态\",{\"1\":{\"426\":1}}],[\"负责负载均衡+远程调用\",{\"1\":{\"402\":1}}],[\"消息队列\",{\"1\":{\"853\":1}}],[\"消息削峰填谷\",{\"1\":{\"406\":1}}],[\"消息驱动能力\",{\"1\":{\"399\":1}}],[\"消费者将要去访问的微服务名称\",{\"1\":{\"402\":1}}],[\"访问压力\",{\"1\":{\"818\":1}}],[\"访问类型\",{\"1\":{\"704\":1}}],[\"访问次数\",{\"1\":{\"699\":1}}],[\"访问接口时长\",{\"1\":{\"503\":1}}],[\"访问接口url参数\",{\"1\":{\"503\":1}}],[\"访问接口url\",{\"1\":{\"503\":1}}],[\"访问接口端口\",{\"1\":{\"503\":1}}],[\"访问接口主机\",{\"1\":{\"503\":1}}],[\"访问http\",{\"1\":{\"502\":1}}],[\"访问令牌不合法\",{\"1\":{\"444\":1}}],[\"访问者要有\",{\"1\":{\"420\":1}}],[\"访问失败的话\",{\"1\":{\"420\":1}}],[\"访问同一个资源common\",{\"1\":{\"410\":1}}],[\"访问\",{\"1\":{\"401\":1,\"407\":1,\"449\":1,\"459\":1,\"485\":1,\"625\":1}}],[\"执行完此步骤后不要再操作主服务器mysql\",{\"1\":{\"825\":1}}],[\"执行完毕会在数据目录下重新生成慢查询日志文件\",{\"1\":{\"698\":1}}],[\"执行insert\",{\"1\":{\"797\":1}}],[\"执行顺序\",{\"1\":{\"786\":1}}],[\"执行子査询时\",{\"1\":{\"724\":1}}],[\"执行以下sql语句\",{\"1\":{\"718\":1}}],[\"执行査询时的访问方法\",{\"1\":{\"704\":1}}],[\"执行器阶段\",{\"1\":{\"634\":1}}],[\"执行器\",{\"1\":{\"634\":1}}],[\"执行计划中出现`using\",{\"1\":{\"710\":1}}],[\"执行计划的一条记录就代表着mysql对某个表的\",{\"1\":{\"704\":1}}],[\"执行计划\",{\"1\":{\"629\":1,\"635\":1}}],[\"执行操作后不可回滚\",{\"1\":{\"589\":1}}],[\"执行操作后可以进行回滚\",{\"1\":{\"589\":1}}],[\"执行不同的处理流程\",{\"1\":{\"559\":1}}],[\"执行union\",{\"1\":{\"540\":1}}],[\"执行业务逻辑\",{\"1\":{\"488\":1}}],[\"执行fallback兜底方法\",{\"1\":{\"477\":1}}],[\"执行流程\",{\"1\":{\"464\":1}}],[\"执行步骤\",{\"1\":{\"420\":1}}],[\"执行dealhandler\",{\"1\":{\"417\":1}}],[\"执行6次是因为在最后1s请求进来了\",{\"1\":{\"411\":1}}],[\"执行\",{\"1\":{\"401\":1,\"436\":1,\"454\":1,\"485\":1,\"704\":1,\"823\":1}}],[\"版本号机制\",{\"1\":{\"782\":1}}],[\"版本信息\",{\"1\":{\"449\":1}}],[\"版本要求\",{\"1\":{\"441\":1}}],[\"版本开始\",{\"1\":{\"421\":1}}],[\"版本选择\",{\"1\":{\"401\":1}}],[\"版本对应关系\",{\"1\":{\"399\":1}}],[\"版本所支持的负载均衡组件的适配\",{\"1\":{\"399\":1}}],[\"阿里巴巴外键规范\",{\"0\":{\"837\":1}}],[\"阿里巴巴字段命名规范\",{\"0\":{\"836\":1}}],[\"阿里巴巴sentinel来提供熔断\",{\"1\":{\"462\":1}}],[\"阿里巴巴开源产品\",{\"1\":{\"399\":1}}],[\"阿里中间件团队开发的一款分布式任务调度产品\",{\"1\":{\"399\":1}}],[\"阿里云短信服务\",{\"1\":{\"399\":1}}],[\"阿里云提供的海量\",{\"1\":{\"399\":1}}],[\"阿里云对象存储服务\",{\"1\":{\"399\":1}}],[\"阿里云对象存储\",{\"1\":{\"399\":1}}],[\"智能的互联化通讯能力\",{\"1\":{\"399\":2}}],[\"友好\",{\"1\":{\"399\":2}}],[\"低成本\",{\"1\":{\"399\":2}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"882\":1}}],[\"注\",{\"1\":{\"440\":1}}],[\"注册分支事务\",{\"1\":{\"426\":1}}],[\"注解标注\",{\"1\":{\"482\":1}}],[\"注解标注的资源也能够配置限流\",{\"1\":{\"416\":1}}],[\"注解即可\",{\"1\":{\"462\":1}}],[\"注解生效\",{\"1\":{\"441\":1}}],[\"注解\",{\"1\":{\"399\":1,\"416\":1,\"420\":1,\"426\":1,\"435\":1,\"450\":1,\"451\":1,\"453\":1,\"463\":1}}],[\"注意的是\",{\"1\":{\"703\":1}}],[\"注意横杠表示这两个单词连起来的意思\",{\"1\":{\"661\":1}}],[\"注意事项\",{\"1\":{\"569\":1,\"579\":1}}],[\"注意后缀必须是\",{\"1\":{\"497\":1}}],[\"注意右上角的格式为\",{\"1\":{\"452\":1}}],[\"注意题目中这句话\",{\"1\":{\"350\":1}}],[\"注意这五个元素可为任意顺序\",{\"1\":{\"278\":1}}],[\"注意下一层搜索要从i+1开始\",{\"1\":{\"187\":2,\"188\":1}}],[\"注意图中\",{\"1\":{\"185\":1}}],[\"注意你不能在第\",{\"1\":{\"123\":1}}],[\"注意利润不能是\",{\"1\":{\"119\":1}}],[\"注意组合和排列的区别\",{\"1\":{\"103\":1}}],[\"注意\",{\"1\":{\"52\":1,\"65\":1,\"69\":1,\"73\":1,\"110\":2,\"123\":1,\"125\":1,\"127\":1,\"129\":1,\"137\":1,\"161\":1,\"176\":2,\"192\":1,\"194\":1,\"196\":1,\"207\":1,\"211\":1,\"244\":1,\"276\":1,\"330\":1,\"344\":1,\"357\":1,\"367\":1,\"379\":1,\"381\":1,\"390\":3,\"393\":1,\"403\":1,\"417\":1,\"420\":1,\"533\":1,\"540\":1,\"552\":1,\"555\":2,\"607\":1,\"615\":1,\"618\":1,\"753\":1,\"822\":1,\"824\":1,\"825\":2}}],[\"注意搜索最大值的起始范围\",{\"1\":{\"51\":1}}],[\"注意push\",{\"1\":{\"39\":1}}],[\"注意进行回溯\",{\"1\":{\"39\":1}}],[\"基础设施的一部分\",{\"1\":{\"491\":1}}],[\"基于行的复制\",{\"1\":{\"823\":1}}],[\"基于sql语句的复制\",{\"1\":{\"823\":1}}],[\"基于键值对存储数据\",{\"1\":{\"510\":1}}],[\"基于调用时间\",{\"0\":{\"478\":1}}],[\"基于调用数量统计的案例演示\",{\"0\":{\"477\":1}}],[\"基于调用数量的滑动窗口\",{\"1\":{\"475\":1}}],[\"基于时间的滑动窗口\",{\"1\":{\"475\":1}}],[\"基于高可用分布式集群技术\",{\"1\":{\"399\":1}}],[\"基于\",{\"1\":{\"399\":3,\"407\":1,\"587\":1}}],[\"基本准则\",{\"1\":{\"820\":1}}],[\"基本语法\",{\"1\":{\"700\":1,\"832\":1}}],[\"基本上一样\",{\"1\":{\"696\":1}}],[\"基本上所有的外部配置中心都需要\",{\"1\":{\"403\":1}}],[\"基本单位\",{\"1\":{\"666\":1}}],[\"基本函数\",{\"0\":{\"548\":1}}],[\"基本结构\",{\"1\":{\"520\":1}}],[\"基本select\",{\"0\":{\"520\":1}}],[\"基本可以断定本题是需要使用二分查找\",{\"1\":{\"277\":1}}],[\"基本的逻辑是这样\",{\"1\":{\"177\":1}}],[\"基本是要分析两种情况\",{\"1\":{\"148\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"878\":1}}],[\"支持多粒度\",{\"1\":{\"771\":1}}],[\"支持多种方式\",{\"1\":{\"449\":1}}],[\"支持\",{\"1\":{\"771\":1}}],[\"支持两种排序方式\",{\"1\":{\"725\":1}}],[\"支持慢调用比例\",{\"1\":{\"419\":1}}],[\"支持在任何应用\",{\"1\":{\"399\":1}}],[\"支持分布式系统中的外部化配置\",{\"1\":{\"399\":1}}],[\"支付微服务远程调用\",{\"1\":{\"464\":1}}],[\"支付接口\",{\"1\":{\"447\":1}}],[\"支付交易表\",{\"1\":{\"440\":1}}],[\"支付流水号\",{\"1\":{\"440\":1,\"443\":1}}],[\"支付的顺序\",{\"1\":{\"357\":1}}],[\"支付\",{\"1\":{\"82\":7}}],[\"适合\",{\"1\":{\"783\":2}}],[\"适合于对精度要求极高的场景\",{\"1\":{\"600\":1}}],[\"适合用栈操作运算\",{\"1\":{\"330\":1}}],[\"适用\",{\"1\":{\"600\":1}}],[\"适用场景\",{\"0\":{\"598\":1}}],[\"适配动态数据源等\",{\"1\":{\"406\":1}}],[\"适配\",{\"1\":{\"399\":1}}],[\"服务层\",{\"0\":{\"626\":1},\"1\":{\"633\":1}}],[\"服务的访问\",{\"1\":{\"487\":1}}],[\"服务端就相当于\",{\"1\":{\"477\":1}}],[\"服务端名称\",{\"1\":{\"463\":1}}],[\"服务b的请求线程也随之阻塞\",{\"1\":{\"472\":1}}],[\"服务熔断触发降级\",{\"1\":{\"472\":1}}],[\"服务器的整体功能\",{\"1\":{\"811\":1}}],[\"服务器本身的错误\",{\"1\":{\"755\":1}}],[\"服务器通过api与存储引擎进行通信\",{\"1\":{\"631\":1}}],[\"服务器对\",{\"1\":{\"625\":1}}],[\"服务器前\",{\"1\":{\"625\":1}}],[\"服务器进程处理后在向客户端进程发送一段文本\",{\"1\":{\"624\":1}}],[\"服务器端程序使用的\",{\"1\":{\"624\":1}}],[\"服务器\",{\"1\":{\"487\":1}}],[\"服务器忙\",{\"1\":{\"472\":1}}],[\"服务器集群总数量\",{\"1\":{\"460\":1}}],[\"服务器给与响应\",{\"1\":{\"412\":1}}],[\"服务已经变成俩个\",{\"1\":{\"459\":1}}],[\"服务调用\",{\"0\":{\"455\":1}}],[\"服务启动\",{\"1\":{\"454\":1}}],[\"服务名\",{\"1\":{\"450\":1,\"451\":1}}],[\"服务名称\",{\"1\":{\"419\":1}}],[\"服务发现\",{\"1\":{\"449\":1}}],[\"服务异常\",{\"1\":{\"444\":1}}],[\"服务开启降级保护\",{\"1\":{\"444\":1}}],[\"服务降级\",{\"1\":{\"444\":1,\"471\":1}}],[\"服务提供者9001\",{\"1\":{\"420\":1}}],[\"服务提供者\",{\"1\":{\"420\":1}}],[\"服务\",{\"1\":{\"404\":1,\"459\":1,\"472\":1}}],[\"服务配置\",{\"0\":{\"403\":1}}],[\"服务注册发现consul\",{\"1\":{\"489\":1}}],[\"服务注册中心上的微服务名称\",{\"1\":{\"451\":1}}],[\"服务注册和发现\",{\"1\":{\"432\":1}}],[\"服务注册\",{\"0\":{\"402\":1,\"450\":1}}],[\"服务注册+配置nacos\",{\"0\":{\"400\":1}}],[\"服务注册与发现标准\",{\"1\":{\"399\":1}}],[\"服务注册与发现\",{\"1\":{\"399\":1}}],[\"服务限流降级\",{\"1\":{\"399\":1}}],[\"监控等信息\",{\"1\":{\"733\":1}}],[\"监控的是\",{\"1\":{\"420\":1}}],[\"监控\",{\"1\":{\"399\":1,\"420\":1}}],[\"监控二叉树2\",{\"1\":{\"372\":1}}],[\"致力于提供高性能和简单易用的分布式事务服务\",{\"1\":{\"426\":1}}],[\"致力于提供微服务开发的一站式解决方案\",{\"1\":{\"399\":1}}],[\"致谢\",{\"1\":{\"145\":1}}],[\"会记录到binlog中\",{\"1\":{\"823\":1}}],[\"会记录redo\",{\"1\":{\"812\":1}}],[\"会读取从库中的中继日志\",{\"1\":{\"820\":1}}],[\"会连接到主库\",{\"1\":{\"820\":1}}],[\"会基于\",{\"1\":{\"820\":1}}],[\"会丢失\",{\"1\":{\"810\":1}}],[\"会话级别\",{\"1\":{\"809\":1}}],[\"会为事务\",{\"1\":{\"800\":1}}],[\"会生成数据库系统当前的一个快照\",{\"1\":{\"796\":1}}],[\"会对读取的记录进行加锁\",{\"1\":{\"791\":1}}],[\"会对sql查询进行语法上的优化\",{\"1\":{\"628\":1}}],[\"会出现什么问题\",{\"1\":{\"812\":1}}],[\"会出现死锁\",{\"1\":{\"779\":1}}],[\"会出现数据浪费的现象\",{\"1\":{\"779\":1}}],[\"会出现一些情况\",{\"1\":{\"755\":1}}],[\"会自动将数据复制到从库中\",{\"1\":{\"819\":1}}],[\"会自动加上\",{\"1\":{\"773\":1}}],[\"会自动进行类型转换\",{\"1\":{\"717\":1}}],[\"会被阻塞住\",{\"1\":{\"772\":1}}],[\"会先获取该数据行\",{\"1\":{\"771\":1}}],[\"会先从磁盘读取数据保存到内存中\",{\"1\":{\"747\":1}}],[\"会从\",{\"1\":{\"820\":1}}],[\"会从从库中进行读取\",{\"1\":{\"819\":1}}],[\"会从redo日志中读取数据刷新到磁盘中\",{\"1\":{\"747\":1}}],[\"会从权限表查出账号拥有的权限与连接关联\",{\"1\":{\"625\":1}}],[\"会导致管理员也被删除\",{\"1\":{\"737\":1}}],[\"会导致代码膨胀不好管理\",{\"1\":{\"420\":1}}],[\"会造成什么问题呢\",{\"1\":{\"737\":1}}],[\"会员信息表\",{\"1\":{\"732\":1}}],[\"会通过\",{\"1\":{\"729\":1}}],[\"会产生临时文件\",{\"1\":{\"725\":1}}],[\"会使用\",{\"1\":{\"867\":1}}],[\"会使\",{\"1\":{\"694\":1}}],[\"会字段创建出索引\",{\"1\":{\"687\":1}}],[\"会影响整体数据査询的效率\",{\"1\":{\"660\":1}}],[\"会单独为表的主键创建一个索引\",{\"1\":{\"654\":1}}],[\"会\",{\"1\":{\"628\":1}}],[\"会收到一个access\",{\"1\":{\"625\":1}}],[\"会保留数据尾部的空格\",{\"1\":{\"604\":1}}],[\"会报错\",{\"1\":{\"596\":1}}],[\"会不会截断或插入失败\",{\"1\":{\"595\":1}}],[\"会将部门下没有员工的部门也会查询出来\",{\"1\":{\"541\":1}}],[\"会将右表不符合条件的行查询出来\",{\"1\":{\"539\":1}}],[\"会将左表不符合条件的行查询出来\",{\"1\":{\"539\":1}}],[\"会将字符串转换为数值类型\",{\"1\":{\"527\":1}}],[\"会将\",{\"1\":{\"522\":1,\"763\":1}}],[\"会将共同的类都存放在另一个模块下\",{\"1\":{\"447\":1}}],[\"会有一个\",{\"1\":{\"491\":1}}],[\"会抛出\",{\"1\":{\"477\":1}}],[\"会转换到\",{\"1\":{\"475\":1}}],[\"会在\",{\"1\":{\"820\":1}}],[\"会在当前最大值的基础上自增\",{\"1\":{\"617\":1}}],[\"会在注册中心上获取注册信息服务列表之后缓存到jvm本地\",{\"1\":{\"457\":1}}],[\"会在订单服务中创建一个订单\",{\"1\":{\"430\":1}}],[\"会拦截\",{\"1\":{\"436\":1}}],[\"会进入到黑名单\",{\"1\":{\"418\":1}}],[\"会率先走完\",{\"1\":{\"391\":1}}],[\"会发现并不符合题意\",{\"1\":{\"362\":1}}],[\"头插法\",{\"1\":{\"384\":1}}],[\"头结点都是第二个\",{\"1\":{\"387\":1}}],[\"头结点\",{\"1\":{\"386\":1}}],[\"头结点的上一结点就是虚拟头结点\",{\"1\":{\"377\":1}}],[\"头结点无覆盖的情况\",{\"1\":{\"372\":1}}],[\"获得\",{\"1\":{\"377\":2}}],[\"获取锁失败\",{\"1\":{\"763\":1}}],[\"获取锁成功\",{\"1\":{\"763\":1}}],[\"获取锁之后\",{\"1\":{\"763\":1}}],[\"获取到数据后返回给客户端就好了\",{\"1\":{\"635\":1}}],[\"获取月份\",{\"0\":{\"555\":1}}],[\"获取日期与时间\",{\"1\":{\"554\":1}}],[\"获取日期\",{\"0\":{\"554\":1}}],[\"获取请求参数中的第一个参数\",{\"1\":{\"497\":1}}],[\"获取\",{\"1\":{\"426\":1,\"799\":1}}],[\"获取下一结点很容易\",{\"1\":{\"382\":1}}],[\"获取下一个求和的数\",{\"1\":{\"171\":1}}],[\"获取当前字母的最远距离\",{\"1\":{\"368\":1}}],[\"获取前k个元素\",{\"1\":{\"338\":1}}],[\"获取value\",{\"1\":{\"338\":1}}],[\"获取优先级队列前k个元素\",{\"1\":{\"337\":1}}],[\"获取队列最大值\",{\"1\":{\"335\":1}}],[\"获取根节点\",{\"1\":{\"49\":1}}],[\"获取二叉树的高度\",{\"1\":{\"43\":1}}],[\"链路中的任何一环出现高延时或错误都会引起整个请求最后的失败\",{\"1\":{\"483\":1}}],[\"链路\",{\"1\":{\"410\":1}}],[\"链表必须\",{\"1\":{\"390\":1}}],[\"链表中没有环\",{\"1\":{\"393\":1}}],[\"链表中有一个环\",{\"1\":{\"393\":2}}],[\"链表中结点的数目为\",{\"1\":{\"388\":1}}],[\"链表中节点的数目范围在范围\",{\"1\":{\"393\":1}}],[\"链表中节点的数目范围是\",{\"1\":{\"379\":1,\"380\":1}}],[\"链表中节点的数目在范围\",{\"1\":{\"385\":1}}],[\"链表中节点数目为\",{\"1\":{\"383\":1}}],[\"链表中的节点\",{\"1\":{\"379\":1}}],[\"链表中的节点数应该减少\",{\"1\":{\"379\":1}}],[\"链表中每个节点的值都是\",{\"1\":{\"379\":1}}],[\"链表的所有值都是\",{\"1\":{\"379\":1}}],[\"链表\",{\"0\":{\"375\":1},\"1\":{\"390\":6,\"393\":1,\"645\":1},\"2\":{\"397\":1}}],[\"链接\",{\"1\":{\"12\":1,\"858\":1,\"870\":1}}],[\"摄像头数\",{\"1\":{\"372\":1}}],[\"逻辑恢复\",{\"0\":{\"832\":1}}],[\"逻辑备份就是\",{\"1\":{\"830\":1}}],[\"逻辑备份恢复速度慢\",{\"1\":{\"830\":1}}],[\"逻辑备份\",{\"0\":{\"831\":1},\"1\":{\"830\":1}}],[\"逻辑日志\",{\"1\":{\"811\":1}}],[\"逻辑查询优化阶段和\",{\"1\":{\"634\":1}}],[\"逻辑架构剖析\",{\"0\":{\"624\":1}}],[\"逻辑意义一致\",{\"1\":{\"618\":1}}],[\"逻辑运算符\",{\"0\":{\"530\":1}}],[\"逻辑\",{\"1\":{\"416\":1}}],[\"逻辑处理\",{\"1\":{\"372\":1}}],[\"逻辑和上面的一样\",{\"1\":{\"304\":1}}],[\"划分结果为\",{\"1\":{\"367\":1}}],[\"划分结果需要满足\",{\"1\":{\"367\":1}}],[\"明显不是最少的\",{\"1\":{\"366\":1}}],[\"尾数\",{\"1\":{\"599\":1}}],[\"尾结点\",{\"1\":{\"395\":1}}],[\"尾端\",{\"1\":{\"366\":1}}],[\"尾随空格或者单词间的多个空格\",{\"1\":{\"244\":1}}],[\"射出\",{\"1\":{\"364\":2}}],[\"气球的尾端\",{\"1\":{\"364\":2}}],[\"气球可以用2支箭来爆破\",{\"1\":{\"363\":2}}],[\"好处\",{\"0\":{\"750\":1},\"1\":{\"727\":1,\"750\":1}}],[\"好几十个\",{\"1\":{\"420\":1}}],[\"好多人再看到题目时是懵逼得\",{\"1\":{\"364\":1}}],[\"好一个脱裤子放屁\",{\"1\":{\"43\":1}}],[\"击破气球\",{\"1\":{\"363\":4}}],[\"弓箭数\",{\"1\":{\"363\":1}}],[\"弓箭一旦被射出之后\",{\"1\":{\"363\":1}}],[\"引擎中提供了\",{\"1\":{\"770\":1}}],[\"引擎层\",{\"0\":{\"631\":1}}],[\"引是btree索引\",{\"1\":{\"653\":1}}],[\"引起来\",{\"1\":{\"583\":1}}],[\"引等数据库对象\",{\"1\":{\"517\":1}}],[\"引入所创建的\",{\"1\":{\"464\":1}}],[\"引入依赖\",{\"1\":{\"452\":1}}],[\"引入\",{\"1\":{\"442\":1}}],[\"引入自己定义的api通用包\",{\"1\":{\"402\":1}}],[\"引爆\",{\"1\":{\"363\":1}}],[\"引用别人的表\",{\"1\":{\"618\":1}}],[\"引用完整性\",{\"1\":{\"612\":1}}],[\"引用\",{\"1\":{\"278\":2}}],[\"≤\",{\"1\":{\"363\":2}}],[\"轴从不同点\",{\"1\":{\"363\":1}}],[\"坐标\",{\"1\":{\"363\":1}}],[\"墙面上的气球记录在整数数组\",{\"1\":{\"363\":1}}],[\"规范下的表\",{\"1\":{\"835\":1}}],[\"规定某个字段在整个表中是唯一的\",{\"1\":{\"613\":1}}],[\"规定某个字段不能为空\",{\"1\":{\"613\":1}}],[\"规则就称为范式\",{\"1\":{\"736\":1}}],[\"规则都没了\",{\"1\":{\"424\":1}}],[\"规则\",{\"1\":{\"362\":1,\"452\":1,\"799\":1}}],[\"规律三\",{\"1\":{\"304\":1}}],[\"规律二\",{\"1\":{\"304\":1}}],[\"规律一\",{\"1\":{\"304\":1}}],[\"糖果的数量\",{\"1\":{\"360\":1}}],[\"颗糖果\",{\"1\":{\"359\":3}}],[\"收下10元\",{\"1\":{\"358\":1}}],[\"收到20元\",{\"1\":{\"358\":1}}],[\"收到10元\",{\"1\":{\"358\":1}}],[\"收到5元\",{\"1\":{\"358\":1}}],[\"收集每天的正利润\",{\"1\":{\"122\":1}}],[\"张\",{\"1\":{\"357\":2,\"689\":1}}],[\"美元的钞票和一张\",{\"1\":{\"357\":1}}],[\"美元的钞票\",{\"1\":{\"357\":6}}],[\"美元或\",{\"1\":{\"357\":1}}],[\"美元\",{\"1\":{\"357\":7}}],[\"必为主键\",{\"1\":{\"836\":1}}],[\"必选\",{\"1\":{\"823\":1,\"824\":1}}],[\"必要时使用缩进\",{\"1\":{\"518\":1}}],[\"必然是\",{\"1\":{\"356\":1}}],[\"必须修改\",{\"1\":{\"822\":1}}],[\"必须先获得表的\",{\"1\":{\"771\":2}}],[\"必须要分配给一个线程专门与这个客户端的交互\",{\"1\":{\"625\":1}}],[\"必须引用\",{\"1\":{\"618\":1}}],[\"必须指定长度m\",{\"1\":{\"604\":1}}],[\"必须指明路径参数名称\",{\"1\":{\"464\":1}}],[\"必须和\",{\"1\":{\"597\":1}}],[\"必须保证你的字段没有和保留字\",{\"1\":{\"583\":1}}],[\"必须保证所有的\",{\"1\":{\"518\":1}}],[\"必须只能包含\",{\"1\":{\"583\":1}}],[\"必须遵守\",{\"1\":{\"518\":1}}],[\"必须创建第三个表\",{\"1\":{\"513\":1}}],[\"必须至少调用5次\",{\"1\":{\"476\":1}}],[\"必须是整型\",{\"1\":{\"617\":1}}],[\"必须是\",{\"1\":{\"416\":1}}],[\"必须是负数\",{\"1\":{\"354\":1}}],[\"必须使用英文状态下的半角输入方式\",{\"1\":{\"518\":1}}],[\"必须使用\",{\"1\":{\"403\":1}}],[\"必须为\",{\"1\":{\"390\":1}}],[\"必须\",{\"1\":{\"336\":1,\"618\":1,\"823\":2,\"824\":1}}],[\"必须在部门表能找到对应的部分\",{\"1\":{\"618\":1}}],[\"必须在不复制数组的情况下原地对数组进行操作\",{\"1\":{\"315\":1}}],[\"必须在\",{\"1\":{\"227\":1}}],[\"必须都用一次\",{\"1\":{\"212\":1}}],[\"油量不够\",{\"1\":{\"356\":1}}],[\"油量一定是不足的\",{\"1\":{\"356\":1}}],[\"油箱的总剩余油量一定是\",{\"1\":{\"356\":1}}],[\"油箱的剩余油量必然是\",{\"1\":{\"356\":1}}],[\"号因为它无法使用索引\",{\"1\":{\"728\":1}}],[\"号进行计算时\",{\"1\":{\"527\":1}}],[\"号或\",{\"1\":{\"355\":1}}],[\"号加油站出发\",{\"1\":{\"355\":2}}],[\"号加油站\",{\"1\":{\"355\":10}}],[\"号房屋\",{\"1\":{\"112\":5,\"114\":4}}],[\"升汽油\",{\"1\":{\"355\":13}}],[\"升\",{\"1\":{\"355\":2}}],[\"升序\",{\"1\":{\"71\":1,\"269\":1,\"273\":3,\"362\":1}}],[\"偶数次反转等于它本身\",{\"1\":{\"354\":1}}],[\"偶数为卖出\",{\"1\":{\"126\":2}}],[\"跳转的url\",{\"1\":{\"422\":1}}],[\"跳转的uri\",{\"1\":{\"422\":2}}],[\"跳跃次数\",{\"1\":{\"352\":1}}],[\"跳跃的次数\",{\"1\":{\"352\":1}}],[\"跳到下标为\",{\"1\":{\"351\":1}}],[\"跳到最后一个位置的最小跳跃数是\",{\"1\":{\"351\":1}}],[\"跳\",{\"1\":{\"349\":1,\"351\":1}}],[\"跳过平坡\",{\"1\":{\"346\":1}}],[\"跳过空格\",{\"1\":{\"245\":1}}],[\"跳过单词间的所有空格\",{\"1\":{\"245\":1}}],[\"跳过\",{\"1\":{\"226\":1}}],[\"跳过当前循环\",{\"1\":{\"217\":1}}],[\"跳过重复元素也就没有必要使用\",{\"1\":{\"177\":1}}],[\"跳过root结点及右子树\",{\"1\":{\"70\":1}}],[\"跳过root及左子树\",{\"1\":{\"70\":1}}],[\"步长为\",{\"1\":{\"836\":1}}],[\"步骤3\",{\"1\":{\"820\":1}}],[\"步骤2\",{\"1\":{\"820\":1}}],[\"步骤1\",{\"1\":{\"820\":1}}],[\"步骤\",{\"1\":{\"419\":1}}],[\"步到达数组的最后一个位置\",{\"1\":{\"351\":1}}],[\"步到达最后一个下标\",{\"1\":{\"349\":1}}],[\"步\",{\"1\":{\"349\":1,\"351\":1,\"582\":1,\"753\":1}}],[\"万一\",{\"1\":{\"348\":1}}],[\"毫无疑问负数会拉低\",{\"1\":{\"348\":1}}],[\"摆动序列\",{\"1\":{\"345\":4}}],[\"想快速的定位到需要查找的记录在哪些数据页中该咋办\",{\"1\":{\"643\":1}}],[\"想要重新维护是非常麻烦的\",{\"1\":{\"645\":1}}],[\"想要自定义响应信息就使用\",{\"1\":{\"416\":1}}],[\"想要了解深层次的原理请跳过\",{\"1\":{\"398\":1,\"439\":1}}],[\"想要使摄像头数量少\",{\"1\":{\"372\":1}}],[\"想要用最少的箭射穿最多的气球\",{\"1\":{\"364\":1}}],[\"想要求得\",{\"1\":{\"354\":1}}],[\"想要给你的孩子们一些小饼干\",{\"1\":{\"343\":1}}],[\"想象一下\",{\"1\":{\"52\":1}}],[\"想象自己站在它的右侧\",{\"1\":{\"15\":1}}],[\"鸡肋\",{\"1\":{\"342\":1}}],[\"优势是访问的速度快\",{\"1\":{\"637\":1}}],[\"优势\",{\"1\":{\"509\":1}}],[\"优点是查找速度快\",{\"1\":{\"510\":1}}],[\"优点\",{\"1\":{\"422\":1,\"642\":1,\"650\":1,\"774\":1}}],[\"优先考虑覆盖索引\",{\"0\":{\"727\":1}}],[\"优先考虑外连接\",{\"1\":{\"539\":1}}],[\"优先使用服务ip进行注册\",{\"1\":{\"464\":1}}],[\"优先使用10+5\",{\"1\":{\"358\":1}}],[\"优先级越高\",{\"1\":{\"702\":1}}],[\"优先级更加高\",{\"1\":{\"452\":1}}],[\"优先级队列通常用\",{\"1\":{\"339\":1}}],[\"优先级队列\",{\"1\":{\"337\":1,\"339\":1}}],[\"优先找\",{\"1\":{\"358\":1}}],[\"优于\",{\"1\":{\"336\":1}}],[\"优化sql和索引\",{\"1\":{\"818\":1}}],[\"优化方案二\",{\"1\":{\"726\":1}}],[\"优化方案一\",{\"1\":{\"726\":1}}],[\"优化建议\",{\"1\":{\"725\":1}}],[\"优化器\",{\"1\":{\"634\":1}}],[\"优化和执行的整个过程了\",{\"1\":{\"630\":1}}],[\"优化\",{\"0\":{\"293\":1},\"1\":{\"81\":2,\"115\":1,\"350\":1,\"578\":1}}],[\"依赖隔离\",{\"1\":{\"479\":1}}],[\"依赖的spring\",{\"1\":{\"422\":1}}],[\"依赖\",{\"1\":{\"399\":1,\"402\":1,\"403\":1,\"408\":1,\"422\":1,\"459\":1,\"464\":1,\"481\":1,\"482\":1}}],[\"依次弹出后加入\",{\"1\":{\"334\":2}}],[\"依然能够保持0\",{\"1\":{\"658\":1}}],[\"依然使用动态规划\",{\"1\":{\"115\":1}}],[\"依然利用二叉搜索树的行\",{\"1\":{\"58\":1}}],[\"队首3对应的下标为1\",{\"1\":{\"334\":1}}],[\"队尾值为6\",{\"1\":{\"334\":1}}],[\"队尾值为3\",{\"1\":{\"334\":1}}],[\"队尾值为5\",{\"1\":{\"334\":1}}],[\"队尾值为\",{\"1\":{\"334\":2}}],[\"队列为空\",{\"1\":{\"334\":2}}],[\"队列为先进先出\",{\"1\":{\"322\":1}}],[\"队列应当支持一般队列支持的所有操作\",{\"1\":{\"321\":1}}],[\"队列\",{\"1\":{\"222\":1,\"334\":6},\"2\":{\"341\":1}}],[\"遇见比当前值小的\",{\"1\":{\"334\":1}}],[\"遇到这种情况\",{\"1\":{\"605\":1}}],[\"遇到算符则取出栈顶两个数字进行计算\",{\"1\":{\"330\":1}}],[\"遇到数字则入栈\",{\"1\":{\"330\":1}}],[\"遇到相等的元素弹栈\",{\"1\":{\"328\":1}}],[\"遇到右括号弹栈\",{\"1\":{\"326\":1}}],[\"遇到左括号直接入栈\",{\"1\":{\"326\":1}}],[\"遇到不为1的元素停止\",{\"1\":{\"307\":1}}],[\"遇到此类问题\",{\"1\":{\"304\":1}}],[\"遇到空格停止\",{\"1\":{\"245\":2}}],[\"减少了binlog日志量\",{\"1\":{\"823\":1}}],[\"减少了锁表\",{\"1\":{\"819\":1}}],[\"减少锁竞争\",{\"1\":{\"786\":1}}],[\"减少使用order\",{\"1\":{\"726\":1}}],[\"减少查询中分组和排序的时间\",{\"1\":{\"642\":1}}],[\"减法也要特殊处理\",{\"1\":{\"332\":1}}],[\"减去\",{\"1\":{\"163\":1}}],[\"逆波兰表达式主要有以下两个优点\",{\"1\":{\"330\":1}}],[\"逆波兰表达式是一种后缀表达式\",{\"1\":{\"330\":1}}],[\"逆波兰表达式\",{\"1\":{\"330\":1}}],[\"逆波兰表示法\",{\"1\":{\"330\":1}}],[\"弹出队尾值后加入\",{\"1\":{\"334\":1}}],[\"弹出一个左括号\",{\"1\":{\"326\":1}}],[\"弹栈\",{\"1\":{\"325\":3}}],[\"双检加锁\",{\"1\":{\"844\":1}}],[\"双存储双写\",{\"1\":{\"843\":1}}],[\"双方都会等待对方先释放锁而导致死锁\",{\"1\":{\"776\":1}}],[\"双路排序\",{\"1\":{\"725\":1}}],[\"双向链表\",{\"1\":{\"650\":2,\"656\":1}}],[\"双引号是成对结束的\",{\"1\":{\"518\":1}}],[\"双击插件即可\",{\"1\":{\"442\":1}}],[\"双端队列\",{\"1\":{\"321\":1}}],[\"双指针法\",{\"1\":{\"279\":1,\"282\":1,\"283\":2,\"286\":1}}],[\"双指针情形二\",{\"1\":{\"250\":1}}],[\"双指针情形一\",{\"1\":{\"250\":1}}],[\"双指针系列\",{\"0\":{\"238\":1}}],[\"双指针\",{\"1\":{\"146\":1,\"245\":1,\"391\":1,\"392\":1}}],[\"众所周知\",{\"1\":{\"313\":1,\"725\":1}}],[\"众数\",{\"1\":{\"59\":1}}],[\"判题标准\",{\"1\":{\"312\":1}}],[\"判断两个数是否相等\",{\"1\":{\"599\":1}}],[\"判断数据库是否已经存在\",{\"1\":{\"585\":1}}],[\"判断请求参数中是否包含\",{\"1\":{\"504\":1}}],[\"判断是奇数还是偶数\",{\"1\":{\"354\":1}}],[\"判断是否符合\",{\"1\":{\"325\":1}}],[\"判断是否可以合并\",{\"1\":{\"295\":1}}],[\"判断是否相等\",{\"1\":{\"291\":1}}],[\"判断是否冲突\",{\"1\":{\"217\":1}}],[\"判断是否为合法的ip地址\",{\"1\":{\"201\":1}}],[\"判断是否是回文子串\",{\"1\":{\"199\":2}}],[\"判断是否存在三元组\",{\"1\":{\"176\":1}}],[\"判断你是否能够到达最后一个下标\",{\"1\":{\"349\":1}}],[\"判断队首元素是否在滑动区间内\",{\"1\":{\"335\":1}}],[\"判断队首元素是否在\",{\"1\":{\"334\":1}}],[\"判断队首元素是否在该滑动区间内\",{\"1\":{\"334\":1}}],[\"判断下一个元素\",{\"1\":{\"328\":1}}],[\"判断字符串是否有效\",{\"1\":{\"324\":1}}],[\"判断字符串是否是回文串\",{\"1\":{\"199\":2}}],[\"判断边界后\",{\"1\":{\"289\":1}}],[\"判断目标值在中间值的左边还是右边\",{\"1\":{\"277\":1}}],[\"判断3\",{\"1\":{\"217\":2}}],[\"判断列\",{\"1\":{\"217\":2}}],[\"判断行\",{\"1\":{\"217\":2}}],[\"判断当前位置\",{\"1\":{\"215\":2}}],[\"判断当前机票的标志\",{\"1\":{\"213\":1}}],[\"判断当前结点是否比上一个节点大\",{\"1\":{\"56\":1}}],[\"判断逻辑其实和\",{\"1\":{\"213\":1}}],[\"判断前一个元素被使用过\",{\"1\":{\"211\":1}}],[\"判断切割出来的序列是否符合条件\",{\"1\":{\"203\":1}}],[\"判断组成的集合是否符合条件\",{\"1\":{\"203\":1}}],[\"判断回文串\",{\"1\":{\"199\":1}}],[\"判断res数组中的值是否全为0\",{\"1\":{\"163\":1}}],[\"判断子序列\",{\"1\":{\"153\":2}}],[\"判断sindex和\",{\"1\":{\"146\":1}}],[\"判断\",{\"1\":{\"145\":1,\"364\":1}}],[\"判断集合是否有序\",{\"1\":{\"56\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"55\":1}}],[\"判断该起始点与\",{\"1\":{\"253\":1}}],[\"判断该树中是否存在\",{\"1\":{\"44\":1}}],[\"判断该结点是否为最后一层最左边的\",{\"1\":{\"43\":1}}],[\"判断它是否是高度平衡的二叉树\",{\"1\":{\"36\":1}}],[\"除非一些特殊场景\",{\"1\":{\"765\":1}}],[\"除非有非常特别的原因需要使用其他的存储引擎\",{\"1\":{\"636\":1}}],[\"除传统的计算资源\",{\"1\":{\"760\":1}}],[\"除掉\",{\"1\":{\"737\":1}}],[\"除法要特殊处理\",{\"1\":{\"332\":1}}],[\"除开首尾元素\",{\"1\":{\"310\":1}}],[\"除了上述3种信息以外的所有信息\",{\"1\":{\"643\":1}}],[\"除了上面比较笨重的方法\",{\"1\":{\"293\":1}}],[\"除了数据表占数据空间之\",{\"1\":{\"642\":1}}],[\"除了group\",{\"1\":{\"579\":1}}],[\"除了首尾元素\",{\"1\":{\"311\":1}}],[\"除了容器之外\",{\"1\":{\"222\":1}}],[\"除了需要定义\",{\"1\":{\"190\":1}}],[\"除了考虑俩个元素相等的情况\",{\"1\":{\"139\":1}}],[\"除了\",{\"1\":{\"116\":1,\"193\":1,\"416\":1,\"470\":2}}],[\"除了最底层节点可能没填满外\",{\"1\":{\"34\":1}}],[\"杨辉三角性质\",{\"1\":{\"310\":1}}],[\"杨辉三角\",{\"1\":{\"309\":2}}],[\"开头索引失\",{\"0\":{\"721\":1}}],[\"开头的\",{\"1\":{\"716\":1}}],[\"开头的两位和最后的三位都是连续\",{\"1\":{\"306\":1}}],[\"开了分组\",{\"1\":{\"477\":1}}],[\"开启通用查询日志\",{\"1\":{\"806\":1}}],[\"开启慢查询日志\",{\"1\":{\"698\":1}}],[\"开启请求\",{\"1\":{\"469\":1}}],[\"开启\",{\"0\":{\"698\":1},\"1\":{\"468\":1,\"475\":1}}],[\"开发人员可以匹配http请求中的所有内容\",{\"1\":{\"488\":1}}],[\"开发\",{\"1\":{\"404\":1,\"407\":1}}],[\"开往\",{\"1\":{\"355\":7}}],[\"开始复制\",{\"1\":{\"820\":1}}],[\"开始着手制定sql标准\",{\"1\":{\"516\":1}}],[\"开始访问时间\",{\"1\":{\"503\":1}}],[\"开始移动\",{\"1\":{\"392\":1}}],[\"开始相交\",{\"1\":{\"390\":1}}],[\"开始时油箱为空\",{\"1\":{\"355\":1}}],[\"开始则\",{\"1\":{\"304\":1}}],[\"开始的整数数组\",{\"1\":{\"240\":1,\"290\":1}}],[\"开始了\",{\"1\":{\"209\":1}}],[\"开始\",{\"1\":{\"78\":1,\"193\":1,\"212\":1,\"241\":1,\"277\":1,\"393\":1,\"411\":1,\"460\":1}}],[\"起点元素的行坐标一直是\",{\"1\":{\"304\":1}}],[\"起点元素的行坐标是和\",{\"1\":{\"304\":1}}],[\"起点元素的坐标为\",{\"1\":{\"304\":2}}],[\"起点位置又是怎么来的\",{\"1\":{\"304\":1}}],[\"起始点\",{\"1\":{\"348\":1,\"356\":1}}],[\"起始点在下图中标记为\",{\"1\":{\"84\":1}}],[\"起始列\",{\"1\":{\"217\":2}}],[\"起始行\",{\"1\":{\"217\":2}}],[\"起始的元素\",{\"1\":{\"190\":1,\"191\":1}}],[\"起始索引之外\",{\"1\":{\"190\":1}}],[\"起始元素的最大值\",{\"1\":{\"188\":1}}],[\"起始大小至少都是1\",{\"1\":{\"133\":1}}],[\"黄色从\",{\"1\":{\"304\":1}}],[\"颜色相同的对角线它的走向都是一样的\",{\"1\":{\"304\":1}}],[\"∈\",{\"1\":{\"304\":1}}],[\"覆盖索引\",{\"1\":{\"729\":1}}],[\"覆盖全球的短信服务\",{\"1\":{\"399\":2}}],[\"覆盖完\",{\"1\":{\"314\":1}}],[\"覆盖掉\",{\"1\":{\"299\":1}}],[\"覆盖删除结点\",{\"1\":{\"68\":1}}],[\"倒排索引\",{\"1\":{\"510\":1}}],[\"倒数第一列第二个元素\",{\"1\":{\"298\":1}}],[\"倒数第一列第一个元素\",{\"1\":{\"298\":1}}],[\"倒序遍历\",{\"1\":{\"97\":1}}],[\"倒序遍历都可以\",{\"1\":{\"92\":1}}],[\"倒序就不会出现这种情况\",{\"1\":{\"92\":1}}],[\"度\",{\"1\":{\"297\":1,\"604\":2,\"836\":1}}],[\"度为0的结点\",{\"1\":{\"0\":1}}],[\"末尾元素则是俩个区间较大的那个\",{\"1\":{\"295\":1}}],[\"寻找数组的中心索引\",{\"0\":{\"290\":1}}],[\"控制单个二进制日志大小\",{\"1\":{\"823\":1}}],[\"控制\",{\"1\":{\"810\":1}}],[\"控制总线等功能\",{\"1\":{\"449\":1}}],[\"控制台界面\",{\"1\":{\"429\":1}}],[\"控制台方式\",{\"0\":{\"422\":1}}],[\"控制台\",{\"1\":{\"407\":1,\"422\":1,\"424\":1}}],[\"控制循环次数\",{\"1\":{\"289\":1}}],[\"控制树的纵向遍历\",{\"1\":{\"187\":2,\"188\":1}}],[\"采样率默认为0\",{\"1\":{\"486\":1}}],[\"采取左闭右开\",{\"1\":{\"288\":1}}],[\"采用读写分离的方式\",{\"1\":{\"819\":1}}],[\"采用了乐观锁的方式\",{\"1\":{\"801\":1}}],[\"采用悲观锁的方式\",{\"1\":{\"783\":1}}],[\"采用c3列进行排序\",{\"1\":{\"652\":1}}],[\"采用两阶段提交协议的演变\",{\"1\":{\"436\":1}}],[\"采用的是懒加载\",{\"1\":{\"408\":1}}],[\"采用\",{\"1\":{\"384\":1,\"389\":1,\"844\":1}}],[\"采用双指针\",{\"1\":{\"280\":1}}],[\"采用双指针法\",{\"1\":{\"199\":1}}],[\"采用双指针的方法\",{\"1\":{\"146\":1}}],[\"采用先序遍历\",{\"1\":{\"52\":1}}],[\"统自己来决定\",{\"1\":{\"753\":1}}],[\"统一返回结果\",{\"1\":{\"444\":2}}],[\"统一放到\",{\"1\":{\"420\":1}}],[\"统一在\",{\"1\":{\"420\":1}}],[\"统一的规则\",{\"1\":{\"288\":1}}],[\"统计sql的查询成本\",{\"0\":{\"696\":1}}],[\"统计所有接口调用耗时\",{\"1\":{\"503\":1}}],[\"统计所需糖果数量\",{\"1\":{\"360\":1}}],[\"统计的案例演示\",{\"0\":{\"478\":1}}],[\"统计最近n秒的调用结果\",{\"1\":{\"475\":1}}],[\"统计最近n次的调用结果\",{\"1\":{\"475\":1}}],[\"统计窗口时长\",{\"1\":{\"419\":1}}],[\"统计时长\",{\"1\":{\"412\":1,\"413\":1,\"414\":1,\"415\":1,\"419\":1}}],[\"统计nums中每个数字出现的次数\",{\"1\":{\"338\":1}}],[\"统计nums\",{\"1\":{\"337\":1}}],[\"统计去重后数组的长度\",{\"1\":{\"268\":1}}],[\"统计陆地单元格的数量\",{\"1\":{\"230\":2}}],[\"统计并返回在\",{\"1\":{\"147\":1}}],[\"统计出现的频率\",{\"1\":{\"60\":1}}],[\"画一个找规律就知道为什么n\",{\"1\":{\"288\":1}}],[\"画矩阵\",{\"1\":{\"288\":1}}],[\"画完图已经解决一半了\",{\"1\":{\"211\":1}}],[\"底层从右到左\",{\"1\":{\"288\":1}}],[\"顶层从左到右\",{\"1\":{\"288\":1}}],[\"矩阵的创建流程分俩种情况\",{\"1\":{\"288\":1}}],[\"螺旋矩阵\",{\"0\":{\"287\":1}}],[\"≥\",{\"1\":{\"284\":1}}],[\"超键\",{\"1\":{\"736\":1}}],[\"超于1s就超时异常\",{\"1\":{\"478\":1}}],[\"超出该值计为慢调用\",{\"1\":{\"419\":1}}],[\"超过报错不好演示效果所以加上10秒\",{\"1\":{\"481\":1}}],[\"超过失败请求百分⽐circuitbreaker变为open状态\",{\"1\":{\"477\":1,\"478\":1}}],[\"超过1秒1次的时候\",{\"1\":{\"417\":1}}],[\"超过\",{\"1\":{\"283\":1,\"435\":1}}],[\"超时处理\",{\"1\":{\"474\":1}}],[\"超时控制\",{\"0\":{\"466\":1}}],[\"超时\",{\"1\":{\"95\":1,\"472\":1}}],[\"新值被覆盖的问题\",{\"1\":{\"847\":1}}],[\"新值和原始二叉搜索树中的任意节点值都不同\",{\"1\":{\"65\":1}}],[\"新记录\",{\"1\":{\"778\":1}}],[\"新商品上架\",{\"1\":{\"598\":1}}],[\"新数据类型\",{\"1\":{\"588\":1}}],[\"新数组指针\",{\"1\":{\"283\":1}}],[\"新数组\",{\"1\":{\"283\":1}}],[\"新列名\",{\"1\":{\"588\":1}}],[\"新表名\",{\"1\":{\"588\":1}}],[\"新表\",{\"1\":{\"587\":1}}],[\"新的线程的阻塞时间\",{\"1\":{\"480\":1}}],[\"新的头结点\",{\"1\":{\"387\":1}}],[\"新的头结点一直是第二个\",{\"1\":{\"386\":1}}],[\"新的头节点\",{\"1\":{\"376\":1}}],[\"新增请求参数parameter\",{\"1\":{\"500\":1}}],[\"新增一条支付相关流水记录\",{\"1\":{\"464\":1}}],[\"新增\",{\"1\":{\"452\":1,\"459\":1}}],[\"新增流控规则\",{\"1\":{\"422\":1}}],[\"新建模块\",{\"1\":{\"464\":1}}],[\"新建一个支付模块\",{\"1\":{\"443\":1}}],[\"新建支付模块\",{\"0\":{\"443\":1}}],[\"新建库存\",{\"0\":{\"433\":1,\"434\":1}}],[\"新建订单模块\",{\"0\":{\"446\":1}}],[\"新建订单成功\",{\"1\":{\"432\":1}}],[\"新建订单\",{\"1\":{\"432\":1}}],[\"新建网关模块\",{\"1\":{\"422\":1}}],[\"新创建俩个模块\",{\"1\":{\"402\":1}}],[\"平均查询次数\",{\"1\":{\"699\":1}}],[\"平均查询时间\",{\"1\":{\"699\":1}}],[\"平均返回记录数\",{\"1\":{\"699\":1}}],[\"平均锁定时间\",{\"1\":{\"699\":1}}],[\"平均工资查询出来当做一张新表\",{\"1\":{\"579\":2}}],[\"平衡二叉搜索树是最早提出来的自平衡二叉搜索树\",{\"1\":{\"660\":1}}],[\"平衡二叉搜索树\",{\"1\":{\"660\":1}}],[\"平衡二叉树的定义\",{\"1\":{\"37\":1}}],[\"平衡二叉树\",{\"1\":{\"0\":2},\"2\":{\"76\":1}}],[\"平面表示的墙面上\",{\"1\":{\"363\":1}}],[\"平常使用的算式则是一种中缀表达式\",{\"1\":{\"330\":1}}],[\"平方后最大的数不是在第一位\",{\"1\":{\"282\":1}}],[\"平方后\",{\"1\":{\"281\":1}}],[\"实时更新\",{\"1\":{\"749\":1}}],[\"实时熔断下游不可用应用等\",{\"1\":{\"406\":1}}],[\"实体完整性\",{\"1\":{\"612\":1}}],[\"实体集\",{\"1\":{\"512\":1}}],[\"实体\",{\"1\":{\"512\":1}}],[\"实际使用到的索引长度\",{\"1\":{\"706\":1}}],[\"实际上从\",{\"1\":{\"835\":1}}],[\"实际上最重要的\",{\"1\":{\"835\":1}}],[\"实际上主从同步的原理就是基于\",{\"1\":{\"820\":1}}],[\"实际上使用的索引\",{\"1\":{\"705\":1}}],[\"实际上这两个\",{\"1\":{\"696\":1}}],[\"实际上这几个列的真正名称其实是\",{\"1\":{\"681\":1}}],[\"实际上我们只需要检索一个页即可\",{\"1\":{\"696\":1}}],[\"实际调用服务器位置下标\",{\"1\":{\"460\":1}}],[\"实际慢调用比例＞比例阈值\",{\"1\":{\"413\":1}}],[\"实际请求数目＞设定的最小请求数\",{\"1\":{\"413\":1}}],[\"实际考察的是你对数据底层的一个存储原理\",{\"1\":{\"279\":1}}],[\"实施针对性的不同限流措施\",{\"1\":{\"410\":1}}],[\"实现方式二\",{\"1\":{\"573\":1}}],[\"实现方式一\",{\"1\":{\"573\":1}}],[\"实现快捷方式\",{\"1\":{\"497\":1,\"504\":1}}],[\"实现\",{\"1\":{\"321\":1,\"339\":1,\"458\":1,\"782\":1}}],[\"实现一个函数来查找第一个错误的版本\",{\"1\":{\"274\":1}}],[\"实现思路也有很多\",{\"1\":{\"267\":1}}],[\"函数中type的取值与含义\",{\"1\":{\"555\":1}}],[\"函数的分类\",{\"1\":{\"545\":1}}],[\"函数\",{\"0\":{\"545\":1,\"717\":1},\"1\":{\"548\":2,\"549\":1,\"550\":1,\"551\":1,\"552\":2,\"554\":2,\"555\":1,\"556\":1,\"557\":2,\"558\":1,\"559\":2,\"561\":1,\"831\":1},\"2\":{\"567\":1}}],[\"函数名\",{\"1\":{\"518\":2}}],[\"函数要求\",{\"1\":{\"416\":3}}],[\"函数返回结果后\",{\"1\":{\"390\":1}}],[\"函数返回的新长度为\",{\"1\":{\"278\":1}}],[\"函数应该返回新的长度\",{\"1\":{\"278\":2,\"312\":2}}],[\"函数将边界陆地都\",{\"1\":{\"230\":1}}],[\"修正量与刷新磁盘工作量严重不符\",{\"1\":{\"749\":1}}],[\"修饰符\",{\"1\":{\"744\":1}}],[\"修改方式\",{\"1\":{\"822\":1}}],[\"修改mysql的\",{\"1\":{\"809\":1}}],[\"修改my\",{\"1\":{\"806\":1}}],[\"修改了一条记录\",{\"1\":{\"755\":1}}],[\"修改了另一个\",{\"1\":{\"746\":1}}],[\"修改数据的内存拷贝\",{\"1\":{\"752\":1}}],[\"修改数据库和数据表的结构\",{\"1\":{\"517\":1}}],[\"修改的数据是内存中的数据\",{\"1\":{\"747\":1}}],[\"修改过的数据\",{\"1\":{\"746\":1}}],[\"修改索引\",{\"1\":{\"718\":1}}],[\"修改字段数据类型\",{\"1\":{\"588\":1}}],[\"修改表结构等\",{\"1\":{\"785\":1}}],[\"修改表\",{\"0\":{\"588\":1}}],[\"修改路径\",{\"1\":{\"502\":1}}],[\"修改名称为\",{\"1\":{\"501\":1}}],[\"修改controller\",{\"1\":{\"459\":1}}],[\"修改80订单服务\",{\"1\":{\"459\":1}}],[\"修改正确的路径\",{\"1\":{\"454\":1}}],[\"修改yaml\",{\"1\":{\"444\":1}}],[\"修改订单状态完成\",{\"1\":{\"432\":1}}],[\"修改订单状态\",{\"1\":{\"432\":3}}],[\"修改\",{\"1\":{\"429\":1,\"635\":1,\"658\":2}}],[\"修改规则需要改动代码\",{\"1\":{\"423\":1}}],[\"修改以下版本\",{\"1\":{\"420\":1}}],[\"修改输入数组\",{\"1\":{\"278\":1}}],[\"修剪树\",{\"1\":{\"69\":1}}],[\"额外空间并\",{\"1\":{\"278\":1}}],[\"移除\",{\"1\":{\"365\":1}}],[\"移除所有数值等于\",{\"1\":{\"278\":1}}],[\"移动结点\",{\"1\":{\"378\":1,\"382\":1}}],[\"移动窗口\",{\"1\":{\"286\":1}}],[\"移动窗口缩小\",{\"1\":{\"286\":1}}],[\"移动指针\",{\"1\":{\"251\":1}}],[\"移动方向始终相对\",{\"1\":{\"250\":1}}],[\"移动\",{\"1\":{\"229\":1}}],[\"移动到数组的末尾\",{\"1\":{\"315\":1}}],[\"移动到删除节点右子树中最小的结点\",{\"1\":{\"70\":1}}],[\"移动到要删除结点的右子树的最左边的结点\",{\"1\":{\"68\":1}}],[\"举个例子\",{\"1\":{\"277\":1,\"598\":1,\"772\":1}}],[\"举例2\",{\"1\":{\"741\":1}}],[\"举例1\",{\"1\":{\"741\":1}}],[\"举例\",{\"1\":{\"564\":1,\"618\":1,\"676\":1,\"737\":3,\"809\":1}}],[\"举例说明\",{\"1\":{\"188\":1,\"362\":1,\"424\":1}}],[\"举例推导dp数组\",{\"1\":{\"77\":1,\"79\":1,\"81\":1,\"85\":1}}],[\"怎么解决\",{\"1\":{\"765\":1}}],[\"怎么不见heap\",{\"1\":{\"680\":1}}],[\"怎么分是关键\",{\"1\":{\"277\":1}}],[\"怎么给\",{\"1\":{\"12\":1}}],[\"疑问\",{\"1\":{\"276\":1}}],[\"疑问点\",{\"1\":{\"47\":1}}],[\"舍弃右半边\",{\"1\":{\"276\":1}}],[\"舍弃左半边\",{\"1\":{\"276\":1}}],[\"旋转之后所在的位置\",{\"1\":{\"299\":3}}],[\"旋转之后的位置是什么呢\",{\"1\":{\"299\":1}}],[\"旋转图像\",{\"1\":{\"297\":1}}],[\"旋转后的位置是\",{\"1\":{\"299\":1}}],[\"旋转后\",{\"1\":{\"277\":1}}],[\"旋转一次\",{\"1\":{\"276\":1}}],[\"旋转\",{\"1\":{\"276\":4,\"277\":1}}],[\"已用余额\",{\"1\":{\"431\":1}}],[\"已用库存\",{\"1\":{\"431\":1}}],[\"已完结\",{\"1\":{\"431\":1,\"432\":2}}],[\"已按\",{\"1\":{\"312\":1}}],[\"已知\",{\"1\":{\"293\":1}}],[\"已知一个长度为\",{\"1\":{\"276\":1}}],[\"已经不仅仅是数据库领域的主流语言\",{\"1\":{\"835\":1}}],[\"已经不包含\",{\"1\":{\"271\":1}}],[\"已经提交了的\",{\"1\":{\"797\":1}}],[\"已经解决了幻读\",{\"1\":{\"793\":1}}],[\"已经用特定工厂构建\",{\"1\":{\"488\":1}}],[\"已经停更\",{\"1\":{\"457\":1}}],[\"已经注册进来了\",{\"1\":{\"422\":1}}],[\"已经练习了大量的回溯算法\",{\"1\":{\"222\":1}}],[\"已经被使用了\",{\"1\":{\"211\":1}}],[\"已经有过说明\",{\"1\":{\"205\":1}}],[\"已经有一个5\",{\"1\":{\"99\":1}}],[\"已经有一个4\",{\"1\":{\"99\":1}}],[\"已经有一个3\",{\"1\":{\"99\":1}}],[\"已经有一个2\",{\"1\":{\"99\":1}}],[\"已经有一个1\",{\"1\":{\"99\":1}}],[\"已经分析过\",{\"1\":{\"146\":1}}],[\"目标表名\",{\"1\":{\"542\":1}}],[\"目标uri\",{\"1\":{\"488\":1}}],[\"目前常见的更新策略有四种\",{\"1\":{\"845\":1}}],[\"目前常用的组件\",{\"1\":{\"439\":1}}],[\"目前关系型数据库有六种常见范式\",{\"1\":{\"736\":1}}],[\"目前基本上大部分主流的非关系型数据库都是免费的\",{\"1\":{\"510\":1}}],[\"目前是1~24它们是\",{\"1\":{\"495\":1}}],[\"目前控制台没有看到3次重试过程\",{\"1\":{\"467\":1}}],[\"目前项目存在的问题\",{\"0\":{\"447\":1}}],[\"目前只支持\",{\"1\":{\"403\":1}}],[\"目前正在带领一个团队开发新的产品\",{\"1\":{\"274\":1}}],[\"目录项\",{\"1\":{\"648\":1}}],[\"目录项记录页得目录页\",{\"0\":{\"647\":1}}],[\"目录项记录\",{\"1\":{\"646\":2,\"648\":1}}],[\"目录项记录只有主键值和页的编号两个列\",{\"1\":{\"645\":1}}],[\"目录项记录的\",{\"1\":{\"645\":1}}],[\"目录项记录的页分为不同的层次\",{\"1\":{\"650\":1}}],[\"目录项记录的页\",{\"0\":{\"645\":1}}],[\"目录下\",{\"1\":{\"454\":1}}],[\"目录\",{\"1\":{\"401\":1,\"429\":1}}],[\"目的是在\",{\"1\":{\"725\":1}}],[\"目的是随机取走俩个数\",{\"1\":{\"97\":1}}],[\"目的就是将相连的岛屿进行标记\",{\"1\":{\"226\":1}}],[\"目的就是为了防止物品重复增加\",{\"1\":{\"93\":1}}],[\"合适的字符存储长度\",{\"1\":{\"836\":1}}],[\"合适的位置\",{\"1\":{\"273\":1}}],[\"合理设计索引\",{\"1\":{\"786\":1}}],[\"合法性状态\",{\"1\":{\"741\":2}}],[\"合\",{\"1\":{\"568\":1,\"618\":1}}],[\"合并的方式执行查询\",{\"1\":{\"710\":1}}],[\"合并的规则是\",{\"1\":{\"52\":1}}],[\"合并在表名\",{\"1\":{\"636\":1}}],[\"合并\",{\"1\":{\"540\":1}}],[\"合并查询结果\",{\"1\":{\"540\":1}}],[\"合并具有同一列的两个以上的表的行\",{\"1\":{\"537\":1}}],[\"合并过程必须从两个树的根节点开始\",{\"1\":{\"52\":1}}],[\"条记录\",{\"1\":{\"696\":2}}],[\"条件下推的列必须是索引中包含的列\",{\"1\":{\"728\":1}}],[\"条件字段上加索引\",{\"1\":{\"725\":1}}],[\"条件过滤是非常可怕的\",{\"1\":{\"689\":1}}],[\"条件创建索引\",{\"1\":{\"689\":1}}],[\"条件列\",{\"1\":{\"689\":1}}],[\"条件2\",{\"1\":{\"559\":1}}],[\"条件1\",{\"1\":{\"559\":1}}],[\"条件\",{\"1\":{\"542\":1,\"800\":1}}],[\"条件以及right\",{\"1\":{\"271\":1}}],[\"条件搞混\",{\"1\":{\"270\":1}}],[\"条路径可以到达右下角\",{\"1\":{\"84\":1}}],[\"写完缓存后\",{\"1\":{\"846\":1}}],[\"写完了\",{\"1\":{\"812\":1}}],[\"写请求\",{\"1\":{\"821\":1}}],[\"写库\",{\"1\":{\"819\":1}}],[\"写入重试表\",{\"1\":{\"853\":1}}],[\"写入数据库\",{\"1\":{\"848\":1}}],[\"写入binlog时发生异常也不会有影响\",{\"1\":{\"812\":1}}],[\"写入时机\",{\"1\":{\"812\":1}}],[\"写入机制\",{\"0\":{\"810\":1}}],[\"写到\",{\"1\":{\"810\":1}}],[\"写不阻塞读\",{\"1\":{\"801\":1}}],[\"写冲突\",{\"1\":{\"791\":1}}],[\"写锁等\",{\"1\":{\"781\":1}}],[\"写锁\",{\"0\":{\"767\":1},\"1\":{\"767\":2,\"773\":1}}],[\"写操作多\",{\"1\":{\"783\":1}}],[\"写操作都采用\",{\"1\":{\"765\":1}}],[\"写操作进行\",{\"1\":{\"765\":1}}],[\"写\",{\"1\":{\"763\":2,\"764\":2,\"783\":3}}],[\"写写的情况\",{\"0\":{\"763\":1}}],[\"写一个函数搜索\",{\"1\":{\"269\":1}}],[\"写作日期为\",{\"1\":{\"884\":1}}],[\"写作\",{\"1\":{\"12\":1,\"29\":1}}],[\"挨个比对判断就行了\",{\"1\":{\"267\":1}}],[\"挨个去加\",{\"1\":{\"175\":1}}],[\"~~\",{\"1\":{\"477\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"~\",{\"1\":{\"261\":1,\"831\":4}}],[\"串成一个链表\",{\"1\":{\"794\":1}}],[\"串行化解决以上三种并发问题\",{\"1\":{\"793\":1}}],[\"串在下标\",{\"1\":{\"261\":1}}],[\"串合法\",{\"1\":{\"111\":1}}],[\"极简版\",{\"1\":{\"256\":1}}],[\"码表中的可打印字符\",{\"1\":{\"249\":1}}],[\"里有很多信息\",{\"1\":{\"763\":1}}],[\"里候选键和主键都为\",{\"1\":{\"737\":1}}],[\"里边儿\",{\"1\":{\"701\":1}}],[\"里面包含球员编号\",{\"1\":{\"737\":1}}],[\"里面的value值为\",{\"1\":{\"463\":1}}],[\"里面的方法\",{\"1\":{\"416\":1}}],[\"里面排除掉的异常类型\",{\"1\":{\"416\":1}}],[\"里\",{\"1\":{\"246\":1,\"618\":1}}],[\"单机低并发\",{\"1\":{\"837\":1}}],[\"单机阈值\",{\"1\":{\"409\":1,\"419\":2}}],[\"单表时自增\",{\"1\":{\"836\":1}}],[\"单表访问方法时在某些场景下可以使用intersection\",{\"1\":{\"704\":1}}],[\"单表访问的\",{\"1\":{\"701\":1}}],[\"单库备份中恢复单库\",{\"1\":{\"832\":1}}],[\"单位是秒\",{\"1\":{\"823\":1}}],[\"单位为\",{\"1\":{\"419\":1}}],[\"单位为秒\",{\"1\":{\"419\":1}}],[\"单个的球员编号\",{\"1\":{\"736\":1}}],[\"单路排序\",{\"1\":{\"725\":1}}],[\"单列索引可以是普通索引\",{\"1\":{\"686\":1}}],[\"单列索引只根据该字段进行索引\",{\"1\":{\"686\":1}}],[\"单列索引\",{\"1\":{\"686\":3}}],[\"单列约束\",{\"1\":{\"613\":1}}],[\"单向链表的特点就是插入\",{\"1\":{\"673\":1}}],[\"单独存储在一个文件中\",{\"1\":{\"654\":1}}],[\"单独用\",{\"1\":{\"605\":1}}],[\"单独设置它的阈值为\",{\"1\":{\"417\":1}}],[\"单行比较操作符\",{\"0\":{\"572\":1}}],[\"单行子查询返回一条记录\",{\"1\":{\"570\":1}}],[\"单行子查询\",{\"0\":{\"571\":1},\"1\":{\"570\":1}}],[\"单行操作符对应单行子查询\",{\"1\":{\"569\":1}}],[\"单行函数\",{\"0\":{\"546\":1}}],[\"单引号\",{\"1\":{\"518\":1}}],[\"单一内置过滤器gatewayfilter\",{\"1\":{\"504\":1}}],[\"单一内置的过滤器\",{\"1\":{\"498\":1}}],[\"单调递增主要是希望插入时不要影响数据库性能\",{\"1\":{\"733\":1}}],[\"单调递增\",{\"1\":{\"369\":1}}],[\"单调递增或者递减\",{\"1\":{\"339\":1}}],[\"单调队列通常用双端队列\",{\"1\":{\"339\":1}}],[\"单调队列\",{\"1\":{\"339\":1}}],[\"单词间应当仅用单个空格分隔\",{\"1\":{\"244\":1}}],[\"单词\",{\"1\":{\"244\":6,\"874\":1}}],[\"单层搜索逻辑\",{\"1\":{\"190\":1}}],[\"单层逻辑\",{\"1\":{\"187\":1}}],[\"单层递归逻辑\",{\"1\":{\"68\":1,\"193\":1,\"195\":1,\"199\":1,\"201\":1,\"203\":1,\"207\":1,\"209\":1,\"213\":1,\"215\":1,\"217\":1,\"224\":1}}],[\"首元素就是俩个区间较小的那个\",{\"1\":{\"295\":1}}],[\"首尾开始遍历\",{\"1\":{\"241\":1}}],[\"首先会从缓存中进行查找\",{\"1\":{\"818\":1}}],[\"首先会看看内存中有没有与这条记录关联的\",{\"1\":{\"763\":1}}],[\"首先获取事务自己的版本号\",{\"1\":{\"799\":1}}],[\"首先启动俩个客户端c1\",{\"1\":{\"767\":1}}],[\"首先从二级索引中筛选出\",{\"1\":{\"728\":1}}],[\"首先通过c2的值定位到\",{\"1\":{\"651\":1}}],[\"首先查看查询条件是否命中某条索引\",{\"1\":{\"641\":1}}],[\"首先先找到第一个反转结点和反转结点的前一个结点\",{\"1\":{\"384\":1}}],[\"首先想到的就是\",{\"1\":{\"370\":1}}],[\"首先最重要的就是要确定\",{\"1\":{\"288\":1}}],[\"首先需要确定是双指针的含义\",{\"1\":{\"279\":1}}],[\"首先定义俩个集合\",{\"1\":{\"224\":1}}],[\"首先在同一层的遍历当中\",{\"1\":{\"209\":1}}],[\"首先全排列问题是给定一个序列\",{\"1\":{\"209\":1}}],[\"首先看第一个问题\",{\"1\":{\"199\":1}}],[\"首先\",{\"1\":{\"187\":1,\"624\":1,\"689\":1,\"800\":1}}],[\"首先第一想法肯定也是暴力法\",{\"1\":{\"177\":1}}],[\"首先第一间房屋和最后一间房屋不能同时被偷\",{\"1\":{\"115\":1}}],[\"首先俩个字符串中的字符出现次数若是一样\",{\"1\":{\"162\":1}}],[\"首先要从数据库读取金额\",{\"1\":{\"765\":1}}],[\"首先要知道在修改数据时\",{\"1\":{\"747\":1}}],[\"首先要知道相交的结点并不是根据结点的值相等而来的\",{\"1\":{\"391\":1}}],[\"首先要知道如何旋转\",{\"1\":{\"298\":1}}],[\"首先要清楚该题能不能用贪心算法来实现\",{\"1\":{\"344\":1}}],[\"首先要按照每个区间的首元素进行升序\",{\"1\":{\"295\":1}}],[\"首先要将其抽象成一个二叉树\",{\"1\":{\"193\":1}}],[\"首先要想清楚\",{\"1\":{\"152\":1}}],[\"首先要思考一颗对称的二叉树他有什么特点\",{\"1\":{\"33\":1}}],[\"首先我们要知道\",{\"1\":{\"356\":1}}],[\"首先我们对数组按照绝对值进行升序\",{\"1\":{\"354\":1}}],[\"首先我们看如果俩个区间合并的话\",{\"1\":{\"295\":1}}],[\"首先我们看题目描述\",{\"1\":{\"97\":1}}],[\"首先我们考虑替换的目的就是让俩个字符串相等\",{\"1\":{\"152\":1,\"153\":1}}],[\"首先找到需要删除的节点\",{\"1\":{\"67\":1}}],[\"边界条件\",{\"1\":{\"234\":1}}],[\"地射出\",{\"1\":{\"363\":1}}],[\"地点已被标记\",{\"1\":{\"234\":1}}],[\"地址和一个后缀表示\",{\"1\":{\"495\":1}}],[\"地址和子网掩码\",{\"1\":{\"495\":1}}],[\"地址由\",{\"1\":{\"495\":1}}],[\"地址\",{\"1\":{\"200\":5,\"401\":1,\"403\":1,\"822\":1}}],[\"既然如此\",{\"1\":{\"350\":1}}],[\"既然我们要遍历对角线上的元素\",{\"1\":{\"304\":1}}],[\"既然每个节点有俩种情况\",{\"1\":{\"117\":1}}],[\"既可流向太平洋也可流向大西洋\",{\"1\":{\"233\":1}}],[\"西流向相邻单元格\",{\"1\":{\"233\":1}}],[\"东\",{\"1\":{\"233\":1}}],[\"南\",{\"1\":{\"233\":1}}],[\"雨水可以直接向北\",{\"1\":{\"233\":1}}],[\"岛上雨水较多\",{\"1\":{\"233\":1}}],[\"岛屿的面积是岛上值为\",{\"1\":{\"227\":1}}],[\"岛屿\",{\"1\":{\"227\":1}}],[\"岛屿数量一样\",{\"1\":{\"228\":1}}],[\"岛屿数量\",{\"1\":{\"226\":2}}],[\"岛屿总是被水包围\",{\"1\":{\"225\":1}}],[\"高并发集群\",{\"1\":{\"837\":1}}],[\"高并发响应和\",{\"1\":{\"768\":1}}],[\"高级查找算法\",{\"1\":{\"642\":1}}],[\"高级特性\",{\"0\":{\"465\":1,\"490\":1}}],[\"高\",{\"1\":{\"636\":1}}],[\"高薪\",{\"1\":{\"559\":1}}],[\"高于这个阈值的视为慢调用并增加慢调用比例\",{\"1\":{\"478\":1}}],[\"高于该峰值的视为慢调用\",{\"1\":{\"476\":1}}],[\"高于海平面的高度\",{\"1\":{\"233\":1}}],[\"高效\",{\"1\":{\"399\":2}}],[\"高效并且对业务零侵入地解决分布式事务问题\",{\"1\":{\"399\":1}}],[\"高可用的应用程序\",{\"1\":{\"474\":1}}],[\"高可用的定时\",{\"1\":{\"399\":2}}],[\"高可用\",{\"1\":{\"457\":1}}],[\"高可靠的消息发布与订阅服务\",{\"1\":{\"399\":1}}],[\"高可靠的云存储服务\",{\"1\":{\"399\":2}}],[\"高可靠\",{\"1\":{\"399\":2}}],[\"高的元素\",{\"1\":{\"336\":1}}],[\"高度平衡\",{\"1\":{\"71\":2}}],[\"高度\",{\"1\":{\"37\":1}}],[\"处的那个字节的值\",{\"1\":{\"749\":1}}],[\"处的值一定不是\",{\"1\":{\"271\":1}}],[\"处处生效\",{\"1\":{\"452\":1}}],[\"处射出一支箭\",{\"1\":{\"363\":1}}],[\"处\",{\"1\":{\"351\":2,\"355\":1}}],[\"处经旋转后可能变为\",{\"1\":{\"277\":1}}],[\"处于大陆的右边界和下边界\",{\"1\":{\"233\":1}}],[\"处于大陆的左边界和上边界\",{\"1\":{\"233\":1}}],[\"处理结果\",{\"1\":{\"624\":1}}],[\"处理结点\",{\"1\":{\"187\":2,\"188\":1}}],[\"处理小数\",{\"1\":{\"599\":1}}],[\"处理\",{\"1\":{\"423\":1}}],[\"处理方法\",{\"1\":{\"420\":1}}],[\"处理blockexception的函数名称\",{\"1\":{\"416\":1}}],[\"处理业务逻辑的实际时间\",{\"1\":{\"412\":1}}],[\"处理节点\",{\"1\":{\"185\":2,\"222\":1}}],[\"处理特殊情况\",{\"1\":{\"177\":2,\"382\":1,\"389\":1,\"392\":1}}],[\"大了很多\",{\"1\":{\"823\":1}}],[\"大小写不敏感的\",{\"1\":{\"699\":1}}],[\"大小顺序排成一个\",{\"1\":{\"650\":1}}],[\"大小\",{\"1\":{\"646\":1,\"751\":1}}],[\"大小进行排序\",{\"1\":{\"337\":1}}],[\"大型门户网站点击量\",{\"1\":{\"598\":1}}],[\"大家排队\",{\"1\":{\"472\":1}}],[\"大家不要和动态的状态转移公式混到一起\",{\"1\":{\"372\":1}}],[\"大大简化和降低了调用客户端的开发量\",{\"1\":{\"462\":1}}],[\"大尺寸的饼干分发给胃口大的孩子\",{\"1\":{\"344\":1}}],[\"大顶堆来实现\",{\"1\":{\"339\":1}}],[\"大顶堆\",{\"1\":{\"337\":2}}],[\"大西洋和太平洋都能够到达的坐标\",{\"1\":{\"234\":1}}],[\"大西洋\",{\"1\":{\"233\":2,\"234\":1}}],[\"大于我们配置的5个了\",{\"1\":{\"412\":1}}],[\"大于或等于\",{\"1\":{\"74\":1}}],[\"大于等于5\",{\"1\":{\"636\":1}}],[\"大于等于\",{\"1\":{\"59\":1}}],[\"大于\",{\"1\":{\"55\":1,\"73\":1,\"100\":1,\"273\":1}}],[\"大于val\",{\"1\":{\"54\":1}}],[\"飞地的数量\",{\"1\":{\"232\":1}}],[\"围绕的区域\",{\"1\":{\"231\":1}}],[\"围成一圈\",{\"1\":{\"114\":1}}],[\"被引用\",{\"1\":{\"618\":1}}],[\"被引用的表\",{\"1\":{\"618\":1}}],[\"被参考字段\",{\"1\":{\"618\":1}}],[\"被参考的值必须是唯一的\",{\"1\":{\"618\":1}}],[\"被参考的表\",{\"1\":{\"618\":1}}],[\"被调用方\",{\"1\":{\"477\":1}}],[\"被调用者\",{\"1\":{\"420\":1}}],[\"被删除结点\",{\"1\":{\"389\":1}}],[\"被围绕的区间不会存在于边界上\",{\"1\":{\"231\":1}}],[\"被\",{\"1\":{\"229\":1,\"416\":1}}],[\"被使用过\",{\"1\":{\"211\":2}}],[\"感染\",{\"1\":{\"228\":2,\"230\":2}}],[\"感染函数\",{\"1\":{\"226\":3,\"228\":1,\"230\":1,\"232\":1,\"234\":1}}],[\"感染函数里\",{\"1\":{\"226\":1}}],[\"构成的组合\",{\"1\":{\"227\":1}}],[\"构建\",{\"1\":{\"765\":1}}],[\"构建的\",{\"1\":{\"50\":1}}],[\"构建右子树\",{\"1\":{\"50\":1}}],[\"构建左子树\",{\"1\":{\"50\":1}}],[\"水可以从海洋附近的任何单元格流入海洋\",{\"1\":{\"233\":1}}],[\"水平或者竖直的四个方向上\",{\"1\":{\"227\":1}}],[\"水\",{\"1\":{\"225\":1}}],[\"陆地时\",{\"1\":{\"228\":1}}],[\"陆地\",{\"1\":{\"225\":1}}],[\"标签为\",{\"1\":{\"884\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"883\":1}}],[\"标题和页面信息\",{\"1\":{\"861\":1}}],[\"标准\",{\"1\":{\"835\":2}}],[\"标准超过了\",{\"1\":{\"835\":1}}],[\"标准就是\",{\"1\":{\"835\":1}}],[\"标识当前事务是一个\",{\"1\":{\"744\":1}}],[\"标识符命名规则\",{\"0\":{\"583\":1}}],[\"标志位\",{\"1\":{\"504\":1}}],[\"标志着每一层的结束\",{\"1\":{\"23\":1}}],[\"标注\",{\"1\":{\"480\":1,\"481\":1}}],[\"标注全局\",{\"1\":{\"426\":1}}],[\"标记流量的方向\",{\"1\":{\"416\":1}}],[\"标记是否被访问\",{\"1\":{\"226\":1}}],[\"标记当前陆地\",{\"1\":{\"226\":1}}],[\"标记\",{\"0\":{\"876\":1},\"1\":{\"222\":2,\"226\":1}}],[\"避免大事务\",{\"1\":{\"786\":1}}],[\"避免\",{\"1\":{\"786\":1}}],[\"避免了不要的检查\",{\"1\":{\"771\":1}}],[\"避免了第二次读取数据\",{\"1\":{\"725\":1}}],[\"避免innodb表进行索引的二次查询\",{\"1\":{\"727\":1}}],[\"避免使用\",{\"1\":{\"725\":1}}],[\"避免全表扫\",{\"1\":{\"725\":1}}],[\"避免对经常更新的表创建过多的索引\",{\"1\":{\"690\":2}}],[\"避免局部不稳定因素导致整体的雪崩\",{\"1\":{\"475\":1}}],[\"避免冷系统被压垮\",{\"1\":{\"411\":1}}],[\"避免耽误时间\",{\"1\":{\"398\":1,\"439\":1}}],[\"避免被覆盖\",{\"1\":{\"382\":1,\"384\":1}}],[\"避免在叶子节点上放摄像头\",{\"1\":{\"372\":1}}],[\"避免重复计算\",{\"1\":{\"226\":1,\"228\":1}}],[\"避免让我们的函数参数过多\",{\"1\":{\"222\":1}}],[\"避免由于值太大而覆盖原本计算出来的值\",{\"1\":{\"92\":1}}],[\"深搜需要\",{\"1\":{\"222\":1}}],[\"深度优先遍历\",{\"1\":{\"29\":1,\"222\":1}}],[\"深度优先搜索混在一起\",{\"1\":{\"218\":1}}],[\"深度优先搜索\",{\"1\":{\"12\":1}}],[\"体会一下dfs和bfs的区别\",{\"1\":{\"222\":1}}],[\"顺着一个方向遍历\",{\"1\":{\"222\":1}}],[\"顺序\",{\"1\":{\"565\":7}}],[\"顺序颠倒且\",{\"1\":{\"244\":1}}],[\"顺序返回答案\",{\"1\":{\"200\":1}}],[\"顺序不同的序列被视作不同的组合\",{\"1\":{\"104\":1}}],[\"顺序排列\",{\"1\":{\"71\":1}}],[\"图片引入\",{\"1\":{\"885\":1}}],[\"图片增强\",{\"0\":{\"878\":1}}],[\"图片来自\",{\"1\":{\"117\":1}}],[\"图像检索以及语音检索中都能看到\",{\"1\":{\"835\":1}}],[\"图形化界面\",{\"1\":{\"422\":1}}],[\"图中id值为8的记录加了gap锁\",{\"1\":{\"776\":1}}],[\"图中所示\",{\"1\":{\"411\":1}}],[\"图中的每一个矩形都代表一个气球\",{\"1\":{\"364\":1}}],[\"图示两个链表在节点\",{\"1\":{\"390\":1}}],[\"图\",{\"1\":{\"222\":1}}],[\"图论\",{\"0\":{\"221\":1},\"2\":{\"236\":1}}],[\"能提前确认数量的新增语句\",{\"1\":{\"772\":1}}],[\"能避\",{\"1\":{\"746\":1}}],[\"能唯一标识元组的属性集叫做超键\",{\"1\":{\"736\":1}}],[\"能写在where限定的条件就不要写在having中了\",{\"1\":{\"726\":1}}],[\"能做什么\",{\"1\":{\"700\":1}}],[\"能存放的\",{\"1\":{\"646\":1}}],[\"能干嘛\",{\"1\":{\"498\":1}}],[\"能先排序就先排序\",{\"1\":{\"218\":1}}],[\"能够根据主键查询\",{\"1\":{\"616\":1}}],[\"能够运行于所有\",{\"1\":{\"407\":1}}],[\"能够达到的最大利润\",{\"1\":{\"129\":1}}],[\"能够偷到的最高金额为dp\",{\"1\":{\"113\":1}}],[\"经常\",{\"1\":{\"689\":1}}],[\"经常遇到的去重问题\",{\"1\":{\"218\":1}}],[\"经理的工资不得高于本部门职工的平均工资的5倍\",{\"1\":{\"612\":1}}],[\"经预热时长逐渐升至设定的\",{\"1\":{\"411\":1}}],[\"经过三次握手建立连接成功后\",{\"1\":{\"625\":1}}],[\"经过当前加油站时\",{\"1\":{\"356\":1}}],[\"经过旋转之后出现在倒数第\",{\"1\":{\"298\":1}}],[\"经由\",{\"1\":{\"276\":1}}],[\"经历的机场数\",{\"1\":{\"213\":1}}],[\"宫内只能出现一次\",{\"1\":{\"216\":1}}],[\"检査\",{\"1\":{\"768\":1}}],[\"检索varchar类型的字段数据时\",{\"1\":{\"604\":1}}],[\"检验冲突\",{\"1\":{\"215\":1}}],[\"检查某个字段的值是否符号xx要求\",{\"1\":{\"619\":1}}],[\"检查约束\",{\"1\":{\"613\":1}}],[\"检查发现其下的sentinel\",{\"1\":{\"422\":1}}],[\"检查135度方向是否有冲突\",{\"1\":{\"215\":2}}],[\"检查45度是否有冲突\",{\"1\":{\"215\":2}}],[\"检查同一列是否冲突\",{\"1\":{\"215\":2}}],[\"检查放入的位置是否冲突\",{\"1\":{\"215\":2}}],[\"检查它是否轴对称\",{\"1\":{\"32\":1}}],[\"决定了for循环的长度\",{\"1\":{\"215\":1}}],[\"决定了递归的深度\",{\"1\":{\"215\":1}}],[\"列就表明了这个访问方法是啥\",{\"1\":{\"704\":1}}],[\"列级模式\",{\"1\":{\"616\":1}}],[\"列级约束\",{\"1\":{\"613\":1}}],[\"列名\",{\"1\":{\"518\":1,\"562\":2,\"588\":1}}],[\"列坐标一直都是最后一列\",{\"1\":{\"304\":1}}],[\"列坐标等于\",{\"1\":{\"304\":1}}],[\"列是逐渐递减的\",{\"1\":{\"304\":1}}],[\"列是逐渐递加的\",{\"1\":{\"304\":1}}],[\"列的表中插入数据时\",{\"1\":{\"772\":1}}],[\"列的表中新增数据时就会去持有自增锁\",{\"1\":{\"772\":1}}],[\"列的值就是unique\",{\"1\":{\"704\":1}}],[\"列的基数越小\",{\"1\":{\"689\":1}}],[\"列的基数越大\",{\"1\":{\"689\":1}}],[\"列的基数指的是某一列中不重复数据的个数\",{\"1\":{\"689\":1}}],[\"列的别名\",{\"0\":{\"521\":1},\"1\":{\"518\":2}}],[\"列的变化\",{\"1\":{\"304\":2}}],[\"列的元素作为起点\",{\"1\":{\"299\":1}}],[\"列第j个位置$\",{\"1\":{\"298\":1}}],[\"列表中\",{\"1\":{\"798\":1}}],[\"列表中的节点数目在范围\",{\"1\":{\"376\":1}}],[\"列表\",{\"1\":{\"233\":1,\"493\":1}}],[\"列\",{\"1\":{\"215\":1,\"217\":1,\"509\":1,\"634\":1,\"773\":1}}],[\"行于数据集\",{\"1\":{\"809\":1}}],[\"行锁\",{\"1\":{\"774\":1}}],[\"行前的状态\",{\"1\":{\"742\":1}}],[\"行的不同阶段把\",{\"1\":{\"742\":1}}],[\"行的变化\",{\"1\":{\"304\":2}}],[\"行动\",{\"1\":{\"694\":1}}],[\"行格式\",{\"0\":{\"675\":1}}],[\"行格式来实际存储记录的\",{\"1\":{\"643\":1}}],[\"行级锁只在存储引擎层实现\",{\"1\":{\"774\":1}}],[\"行级锁与\",{\"1\":{\"771\":1}}],[\"行级锁\",{\"0\":{\"768\":1},\"1\":{\"637\":1}}],[\"行处理\",{\"1\":{\"416\":1}}],[\"行数与元素个数相等\",{\"1\":{\"310\":1}}],[\"行坐标\",{\"1\":{\"304\":1}}],[\"行坐标一直是0\",{\"1\":{\"304\":1}}],[\"行和列的长度\",{\"1\":{\"302\":1}}],[\"行\",{\"1\":{\"215\":1,\"298\":1,\"309\":1,\"509\":1,\"537\":1,\"737\":1}}],[\"行程\",{\"1\":{\"212\":1}}],[\"棋盘\",{\"1\":{\"215\":1}}],[\"棋盘的深度\",{\"1\":{\"215\":1}}],[\"棋盘问题\",{\"1\":{\"183\":1,\"218\":1}}],[\"研究的是如何将\",{\"1\":{\"214\":1}}],[\"皇后数量\",{\"1\":{\"215\":1}}],[\"皇后问题存在两个不同的解法\",{\"1\":{\"214\":1}}],[\"皇后问题\",{\"1\":{\"214\":3}}],[\"皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子\",{\"1\":{\"214\":1}}],[\"例\",{\"1\":{\"334\":1}}],[\"例子\",{\"1\":{\"213\":1}}],[\"例如后缀名为\",{\"1\":{\"831\":1}}],[\"例如hashmap\",{\"1\":{\"658\":1}}],[\"例如请求头或请求参数\",{\"1\":{\"488\":1}}],[\"例如上面的代码中\",{\"1\":{\"417\":1}}],[\"例如下面\",{\"1\":{\"410\":1,\"417\":1}}],[\"例如定制规则管理\",{\"1\":{\"406\":1}}],[\"例如与\",{\"1\":{\"406\":1}}],[\"例如秒杀\",{\"1\":{\"406\":1}}],[\"例如开发测试环境和生产环境的资源\",{\"1\":{\"404\":1}}],[\"例如到底是\",{\"1\":{\"270\":1}}],[\"例如\",{\"1\":{\"63\":1,\"98\":1,\"99\":1,\"108\":1,\"132\":1,\"138\":1,\"145\":1,\"148\":1,\"152\":1,\"153\":2,\"155\":1,\"170\":1,\"183\":1,\"200\":1,\"201\":2,\"212\":1,\"257\":1,\"261\":2,\"276\":1,\"277\":1,\"278\":1,\"295\":1,\"304\":2,\"321\":1,\"327\":1,\"342\":1,\"345\":1,\"346\":1,\"460\":1,\"472\":1,\"495\":2,\"595\":1,\"612\":4,\"618\":1,\"686\":1,\"690\":1,\"704\":1,\"736\":1}}],[\"机房的信息等\",{\"1\":{\"733\":1}}],[\"机票数\",{\"1\":{\"213\":1}}],[\"机票中可能含有重复的机票\",{\"1\":{\"213\":1}}],[\"机器人试图达到网格的右下角\",{\"1\":{\"84\":1}}],[\"机器人每次只能向下或者向右移动一步\",{\"1\":{\"84\":1}}],[\"肯尼迪国际机场\",{\"1\":{\"212\":1}}],[\"肯定是不行的\",{\"1\":{\"773\":1}}],[\"肯定是不满足条件\",{\"1\":{\"188\":1}}],[\"肯定是有一部分是有序的\",{\"1\":{\"276\":1}}],[\"肯定是回文子串\",{\"1\":{\"155\":1}}],[\"肯定是false\",{\"1\":{\"155\":1}}],[\"才会为事务分配事务id\",{\"1\":{\"797\":1}}],[\"才会生成一个readview\",{\"1\":{\"765\":1}}],[\"才是对数据条件的过滤\",{\"1\":{\"689\":1}}],[\"才是对\",{\"1\":{\"211\":1}}],[\"才能表示\",{\"1\":{\"211\":1}}],[\"才有必要进行替换\",{\"1\":{\"107\":1}}],[\"吗\",{\"1\":{\"211\":1,\"846\":1}}],[\"难道我们也要配\",{\"1\":{\"420\":1}}],[\"难道不是\",{\"1\":{\"211\":1}}],[\"难了不少\",{\"1\":{\"153\":1}}],[\"哈希型的索引\",{\"1\":{\"658\":1}}],[\"哈希\",{\"1\":{\"658\":1}}],[\"哈希表的方法比较容易理解\",{\"1\":{\"391\":1}}],[\"哈希表\",{\"0\":{\"160\":1},\"1\":{\"391\":1,\"392\":2},\"2\":{\"181\":1}}],[\"哈哈哈\",{\"1\":{\"211\":1}}],[\"哈哈\",{\"1\":{\"211\":1}}],[\"方案二\",{\"1\":{\"765\":1}}],[\"方案一\",{\"1\":{\"765\":1}}],[\"方式进行调优\",{\"1\":{\"725\":1}}],[\"方式2\",{\"1\":{\"615\":1}}],[\"方式1\",{\"1\":{\"615\":1}}],[\"方式三\",{\"1\":{\"569\":1}}],[\"方式二\",{\"1\":{\"569\":1}}],[\"方式一\",{\"1\":{\"569\":1}}],[\"方式会严格控制请求通过的间隔时间\",{\"1\":{\"411\":1}}],[\"方式\",{\"1\":{\"411\":1,\"421\":1,\"686\":1}}],[\"方式传递的\",{\"1\":{\"278\":2}}],[\"方便我们了解服务器的状态\",{\"1\":{\"805\":1}}],[\"方便我们对查询进行优化\",{\"1\":{\"805\":1}}],[\"方便检查\",{\"1\":{\"432\":1}}],[\"方便开发者通过\",{\"1\":{\"399\":1}}],[\"方便跳过重复元素\",{\"1\":{\"211\":1}}],[\"方法上增加\",{\"1\":{\"451\":1}}],[\"方法\",{\"1\":{\"417\":1,\"419\":1,\"420\":1,\"464\":1}}],[\"方法参数列表为空\",{\"1\":{\"416\":1}}],[\"方法和198\",{\"1\":{\"115\":1}}],[\"方法二\",{\"1\":{\"6\":1,\"8\":1,\"37\":1,\"146\":1}}],[\"方法一\",{\"1\":{\"2\":1,\"37\":1,\"146\":1}}],[\"类中包含4部分\",{\"1\":{\"497\":1,\"504\":1}}],[\"类型为bigint\",{\"1\":{\"836\":1}}],[\"类型转换\",{\"1\":{\"717\":1}}],[\"类型转换导致索引失效\",{\"0\":{\"717\":1}}],[\"类型大小\",{\"1\":{\"689\":1}}],[\"类型必须一致\",{\"1\":{\"689\":1}}],[\"类型只允许从成员中选取单个值\",{\"1\":{\"606\":1}}],[\"类型一般需要预先定义字符串长度\",{\"1\":{\"604\":1}}],[\"类型通常用来表示带时区的年\",{\"1\":{\"602\":1}}],[\"类型通常用来表示时\",{\"1\":{\"602\":1}}],[\"类型通常用来表示年\",{\"1\":{\"602\":3}}],[\"类型主要有\",{\"1\":{\"602\":1}}],[\"类型在一个表里是整数\",{\"1\":{\"583\":1}}],[\"类型的列\",{\"1\":{\"643\":1}}],[\"类型的字段做主键\",{\"1\":{\"605\":1}}],[\"类型的整数少\",{\"1\":{\"598\":1}}],[\"类型的参数\",{\"1\":{\"416\":1}}],[\"类型的数组来表示当前元素是否使用过\",{\"1\":{\"211\":1}}],[\"类型\",{\"0\":{\"605\":1,\"606\":1,\"607\":1,\"608\":1},\"1\":{\"403\":1,\"498\":1,\"598\":1,\"599\":1,\"605\":1,\"689\":2,\"728\":1,\"836\":1}}],[\"类的问题\",{\"1\":{\"339\":1}}],[\"类\",{\"1\":{\"321\":1,\"447\":1,\"497\":1,\"511\":1}}],[\"类似大学图书馆建书目索引\",{\"1\":{\"642\":1}}],[\"类似010110\",{\"1\":{\"601\":1}}],[\"类似上面的\",{\"1\":{\"579\":1}}],[\"类似\",{\"1\":{\"528\":1,\"645\":1}}],[\"类似java和python中\",{\"1\":{\"511\":1}}],[\"类似java里面的package名和类名\",{\"1\":{\"404\":1}}],[\"类似于电路中的断路器\",{\"1\":{\"475\":1}}],[\"类似于后序遍历\",{\"1\":{\"37\":1}}],[\"类似mysql主键id\",{\"1\":{\"422\":1,\"489\":1}}],[\"类似这种统计\",{\"1\":{\"337\":1}}],[\"类似的\",{\"1\":{\"290\":1}}],[\"防止主服务器状态值变化\",{\"1\":{\"825\":1}}],[\"防止\",{\"1\":{\"783\":1}}],[\"防止根节点是无覆盖状态\",{\"1\":{\"372\":1}}],[\"防止连续的1在数组的末尾\",{\"1\":{\"307\":1}}],[\"防止重复增加到集合中\",{\"1\":{\"209\":2}}],[\"防止多次放入同一个石头\",{\"1\":{\"97\":1}}],[\"添加数据时\",{\"1\":{\"619\":1}}],[\"添加了外键约束后\",{\"1\":{\"618\":2}}],[\"添加约束\",{\"1\":{\"617\":1,\"618\":1,\"619\":1,\"620\":1}}],[\"添加主键约束\",{\"1\":{\"616\":1}}],[\"添加唯一性约束的列上也会自动创建唯一索引\",{\"1\":{\"615\":1}}],[\"添加到\",{\"1\":{\"207\":1}}],[\"添加此问题并且创建所有测试用例\",{\"1\":{\"145\":1}}],[\"下章讲解\",{\"1\":{\"765\":1}}],[\"下管辖的全部分支事务完成提交或回滚请求\",{\"1\":{\"426\":1}}],[\"下面是中继日志的一个片段\",{\"1\":{\"813\":1}}],[\"下面介绍一种更为方便的查询命令\",{\"1\":{\"809\":1}}],[\"下面命令将行事件以\",{\"1\":{\"809\":1}}],[\"下面的例子会产生\",{\"1\":{\"776\":1}}],[\"下面的例子配置了一个\",{\"1\":{\"494\":1}}],[\"下面定义单一内置过滤器\",{\"1\":{\"504\":1}}],[\"下面这个例子把\",{\"1\":{\"502\":1}}],[\"下面看看如何使用\",{\"1\":{\"452\":1}}],[\"下面规则的意思是\",{\"1\":{\"417\":1}}],[\"下面通过俩张动图\",{\"1\":{\"222\":1}}],[\"下载后只有一个\",{\"1\":{\"449\":1}}],[\"下载解压后\",{\"1\":{\"429\":1}}],[\"下载\",{\"0\":{\"427\":1,\"485\":1},\"1\":{\"407\":1,\"449\":1,\"485\":1}}],[\"下载安装\",{\"0\":{\"407\":1}}],[\"下载启动\",{\"0\":{\"401\":1}}],[\"下图中演示的是cur先移动\",{\"1\":{\"381\":1}}],[\"下一篇\",{\"1\":{\"858\":1}}],[\"下一页是谁等\",{\"1\":{\"668\":1}}],[\"下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值\",{\"1\":{\"643\":1}}],[\"下一步覆盖的最大范围\",{\"1\":{\"352\":1}}],[\"下一次都会向里缩一圈\",{\"1\":{\"289\":1}}],[\"下边界\",{\"1\":{\"234\":1}}],[\"下\",{\"1\":{\"229\":1,\"304\":4,\"441\":1,\"772\":1}}],[\"下的所有元素\",{\"1\":{\"207\":2}}],[\"下标去进行插入了\",{\"1\":{\"362\":1}}],[\"下标为\",{\"1\":{\"348\":1}}],[\"下标从\",{\"1\":{\"241\":1}}],[\"下标越界\",{\"1\":{\"226\":1}}],[\"下标代表数字\",{\"1\":{\"193\":2}}],[\"下标j\",{\"1\":{\"152\":1}}],[\"下标\",{\"1\":{\"146\":1,\"277\":1,\"290\":6}}],[\"差不多\",{\"1\":{\"207\":1}}],[\"差值最小\",{\"1\":{\"97\":1}}],[\"差值是一个正数\",{\"1\":{\"57\":1}}],[\"幂集\",{\"1\":{\"202\":1,\"204\":1}}],[\"校验\",{\"1\":{\"326\":1}}],[\"校验冲突\",{\"1\":{\"217\":1}}],[\"校验该段ip地址是否合法\",{\"1\":{\"201\":2}}],[\"校验当前区间是否合法\",{\"1\":{\"201\":2}}],[\"抽象类或者实现\",{\"1\":{\"497\":1,\"504\":1}}],[\"抽象成二叉树如下图所示\",{\"1\":{\"207\":1,\"209\":1}}],[\"抽象成二叉树为\",{\"1\":{\"201\":1,\"213\":1}}],[\"抽象为二叉树为\",{\"1\":{\"203\":1}}],[\"抽象为二叉树如下图所示\",{\"1\":{\"190\":1}}],[\"至于record\",{\"1\":{\"680\":1}}],[\"至于为什么不从0开始遍历\",{\"1\":{\"146\":1}}],[\"至此\",{\"1\":{\"643\":1}}],[\"至服务器端\",{\"1\":{\"633\":1}}],[\"至\",{\"1\":{\"276\":1}}],[\"至少保证全局唯一性且单调递增\",{\"1\":{\"733\":1}}],[\"至少要把修改这条记录前的旧值都记录下来\",{\"1\":{\"755\":1}}],[\"至少要把这条记录中的内容都记下来\",{\"1\":{\"755\":1}}],[\"至少要把这条记录的主键值记下来\",{\"1\":{\"755\":1}}],[\"至少要有一个连接条件\",{\"1\":{\"579\":1}}],[\"至少要知道\",{\"1\":{\"199\":1}}],[\"至少我们能够确定身高一定是从大到小\",{\"1\":{\"362\":1}}],[\"至少我是有的\",{\"1\":{\"211\":1}}],[\"至少两次\",{\"1\":{\"266\":1}}],[\"至少\",{\"1\":{\"246\":1,\"276\":1}}],[\"至少存在一个\",{\"1\":{\"244\":1}}],[\"至少有两个元素\",{\"1\":{\"206\":1}}],[\"像读写都加锁的方式\",{\"1\":{\"765\":1}}],[\"像上面这种\",{\"1\":{\"732\":1}}],[\"像135\",{\"1\":{\"362\":1}}],[\"像这种题\",{\"1\":{\"362\":1}}],[\"像这种求最值问题基本都可以利用\",{\"1\":{\"261\":1}}],[\"像这种dp问题\",{\"1\":{\"81\":1}}],[\"像\",{\"1\":{\"195\":2,\"197\":1,\"367\":1,\"772\":1}}],[\"zoneddatetime\",{\"1\":{\"492\":1}}],[\"zipkin\",{\"0\":{\"484\":1,\"485\":1},\"1\":{\"485\":4,\"486\":7},\"2\":{\"506\":1}}],[\"zzyy\",{\"1\":{\"432\":1}}],[\"zhihu\",{\"1\":{\"845\":1}}],[\"zhan\",{\"1\":{\"680\":1}}],[\"zhangsan\",{\"1\":{\"676\":1}}],[\"zh\",{\"1\":{\"399\":1,\"426\":1,\"427\":1}}],[\"z\",{\"1\":{\"193\":2,\"583\":2,\"705\":1,\"708\":1,\"710\":1}}],[\"zerofill\",{\"0\":{\"597\":1},\"1\":{\"595\":3,\"597\":2}}],[\"zero++\",{\"1\":{\"101\":1}}],[\"zero\",{\"1\":{\"101\":4}}],[\"值相同\",{\"1\":{\"798\":1}}],[\"值就不同了\",{\"1\":{\"746\":1}}],[\"值越大越好\",{\"1\":{\"706\":1}}],[\"值越大收集越及时\",{\"1\":{\"486\":1}}],[\"值的sql\",{\"1\":{\"697\":1}}],[\"值为1\",{\"1\":{\"680\":1}}],[\"值为0\",{\"1\":{\"680\":1}}],[\"值为字母\",{\"1\":{\"193\":2}}],[\"值进行查找时可以使用\",{\"1\":{\"645\":1}}],[\"值是将联合索引键合并后一起来计算的\",{\"1\":{\"658\":1}}],[\"值是0\",{\"1\":{\"645\":1}}],[\"值是1\",{\"1\":{\"645\":1}}],[\"值范围无关\",{\"1\":{\"595\":1}}],[\"值n\",{\"1\":{\"559\":1}}],[\"值1\",{\"1\":{\"559\":2}}],[\"值得注意的是\",{\"1\":{\"527\":1,\"848\":1}}],[\"值\",{\"1\":{\"510\":1,\"616\":1,\"668\":1,\"797\":1,\"798\":2}}],[\"值对\",{\"1\":{\"491\":1}}],[\"值分隔\",{\"1\":{\"19\":1}}],[\"电话号码的字母组合\",{\"1\":{\"193\":1}}],[\"记住\",{\"1\":{\"190\":2,\"191\":1}}],[\"记录了所有对数据库进行修改的操作\",{\"1\":{\"811\":1}}],[\"记录用户的所有操作\",{\"1\":{\"806\":1}}],[\"记录数据定义语句执行的元数据操作\",{\"1\":{\"805\":1}}],[\"记录mysql服务的启动\",{\"1\":{\"805\":1}}],[\"记录所有更改数据的语句\",{\"1\":{\"805\":1}}],[\"记录所有连接的起始时间和终止时间\",{\"1\":{\"805\":1}}],[\"记录所有执行时间超过long\",{\"1\":{\"805\":1}}],[\"记录锁是有s锁和x锁之分的\",{\"1\":{\"775\":1}}],[\"记录锁也就是仅仅把一条记录锁上\",{\"1\":{\"775\":1}}],[\"记录锁\",{\"0\":{\"775\":1}}],[\"记录b=4\",{\"1\":{\"757\":1}}],[\"记录删掉\",{\"1\":{\"755\":1}}],[\"记录的是数据被修改后的值\",{\"1\":{\"752\":1}}],[\"记录的真实数据除了我们自己定义的列的数据以外\",{\"1\":{\"681\":1}}],[\"记录的真实数据\",{\"0\":{\"681\":1}}],[\"记录较多的时候\",{\"1\":{\"710\":1}}],[\"记录较少的时候\",{\"1\":{\"710\":1}}],[\"记录表中的总记录数\",{\"1\":{\"704\":1}}],[\"记录头信息里该属性非常重要\",{\"1\":{\"680\":1}}],[\"记录头信息中各个属性如下\",{\"1\":{\"680\":1}}],[\"记录头信息的一项属性\",{\"1\":{\"643\":2}}],[\"记录头像信息\",{\"0\":{\"680\":1}}],[\"记录是以单向链表的形式进行存储的\",{\"1\":{\"673\":1}}],[\"记录是上坡还是下坡\",{\"1\":{\"346\":1}}],[\"记录可以比大小\",{\"1\":{\"672\":1}}],[\"记录移位\",{\"1\":{\"656\":1}}],[\"记录移除的区间\",{\"1\":{\"366\":1}}],[\"记录缓存\",{\"1\":{\"630\":1}}],[\"记录\",{\"0\":{\"512\":1},\"1\":{\"726\":1,\"757\":3}}],[\"记录接口调用时长统计\",{\"1\":{\"498\":1}}],[\"记录链表的个数\",{\"1\":{\"389\":1}}],[\"记录需要变成9的起始位置\",{\"1\":{\"370\":1}}],[\"记录上一个区间的结束索引\",{\"1\":{\"368\":1}}],[\"记录上一次是上坡还是下坡\",{\"1\":{\"346\":1}}],[\"记录当前遍历时\",{\"1\":{\"368\":1}}],[\"记录其尾端的值\",{\"1\":{\"366\":1}}],[\"记录10元的张数\",{\"1\":{\"358\":1}}],[\"记录5元的张数\",{\"1\":{\"358\":1}}],[\"记录总的剩余油量\",{\"1\":{\"356\":1}}],[\"记录经过每个加油站时所剩余的油量\",{\"1\":{\"356\":1}}],[\"记录子数组和\",{\"1\":{\"348\":1}}],[\"记录波峰和波谷的数量\",{\"1\":{\"346\":1}}],[\"记录孩子满足的个数\",{\"1\":{\"344\":1}}],[\"记录元素为0的位置\",{\"1\":{\"302\":1}}],[\"记录0元素的行和列\",{\"1\":{\"302\":1}}],[\"记录每一箭的开始位置\",{\"1\":{\"364\":1}}],[\"记录每一箭的end值\",{\"1\":{\"364\":1}}],[\"记录每一天的与历史最低价格的利润\",{\"1\":{\"120\":1}}],[\"记录每个学生所需要的糖果数\",{\"1\":{\"360\":1}}],[\"记录每块陆地的面积\",{\"1\":{\"228\":1}}],[\"记录一下陆地的数量\",{\"1\":{\"228\":1}}],[\"记录遍历的元素\",{\"1\":{\"203\":1}}],[\"记录遍历时出现的最大频率\",{\"1\":{\"60\":1}}],[\"记录增加到item中元素的和\",{\"1\":{\"190\":1,\"191\":1}}],[\"记录s串中每个字符出现的次数\",{\"1\":{\"162\":1}}],[\"记录回文子串的数量\",{\"1\":{\"155\":1}}],[\"记录最终结果\",{\"1\":{\"348\":1}}],[\"记录最大面积\",{\"1\":{\"228\":2}}],[\"记录最大深度\",{\"1\":{\"26\":1}}],[\"记录最长的递增子序列\",{\"1\":{\"133\":1}}],[\"记录历史最低价格\",{\"1\":{\"120\":1}}],[\"记录结点出现的频率\",{\"1\":{\"60\":1}}],[\"记录出现的最大频率\",{\"1\":{\"60\":1}}],[\"剪枝\",{\"1\":{\"188\":1,\"191\":1,\"197\":1,\"213\":1}}],[\"剪枝的过程就是把\",{\"1\":{\"188\":1}}],[\"剪枝优化\",{\"0\":{\"188\":1,\"191\":1}}],[\"纵向递归遍历\",{\"1\":{\"187\":2,\"188\":1}}],[\"很少有人能掌握全部内容一样\",{\"1\":{\"835\":1}}],[\"很少有人能掌握所有内容\",{\"1\":{\"835\":1}}],[\"很好理解\",{\"1\":{\"747\":1}}],[\"很多情况下排序操作无法使用到索引\",{\"1\":{\"710\":1}}],[\"很多列\",{\"1\":{\"645\":1}}],[\"很多时候我们希望统计或者限制某个热点数据中访问频次最高的topn数据\",{\"1\":{\"417\":1}}],[\"很多人\",{\"1\":{\"279\":1}}],[\"很难去按照这四步去思考\",{\"1\":{\"342\":1}}],[\"很明显也是\",{\"1\":{\"261\":1}}],[\"很明显暴力法是不行\",{\"1\":{\"187\":1}}],[\"很容易造成重复添加\",{\"1\":{\"211\":1}}],[\"很遗憾~~\",{\"1\":{\"171\":1}}],[\"孩子的数量就是集合的大小\",{\"1\":{\"185\":1}}],[\"存储在磁盘上\",{\"1\":{\"642\":1}}],[\"存储索引\",{\"1\":{\"637\":1}}],[\"存储数据\",{\"1\":{\"637\":1}}],[\"存储数据和索引\",{\"1\":{\"636\":1}}],[\"存储表结构\",{\"1\":{\"636\":1,\"637\":1}}],[\"存储层\",{\"0\":{\"632\":1}}],[\"存储过程\",{\"1\":{\"627\":1}}],[\"存储引擎中数据页的物理修改操作\",{\"1\":{\"811\":1}}],[\"存储引擎特有的\",{\"1\":{\"811\":1}}],[\"存储引擎的表来说\",{\"1\":{\"794\":1}}],[\"存储引擎的表会把索引信息另外存储到一个称为\",{\"1\":{\"654\":1}}],[\"存储引擎的功能\",{\"1\":{\"635\":1}}],[\"存储引擎可以定义每个表的\",{\"1\":{\"642\":1}}],[\"存储引擎就是指表的类型\",{\"1\":{\"635\":1}}],[\"存储引擎层\",{\"1\":{\"633\":1}}],[\"存储引擎\",{\"0\":{\"635\":1},\"1\":{\"604\":1,\"635\":1}}],[\"存储引擎和数据列\",{\"1\":{\"604\":1}}],[\"存储很短的信息\",{\"1\":{\"604\":1}}],[\"存储浮点数的格式为\",{\"1\":{\"599\":1}}],[\"存储空间和\",{\"1\":{\"598\":1}}],[\"存储\",{\"1\":{\"299\":1,\"449\":1}}],[\"存放\",{\"1\":{\"650\":1}}],[\"存放fallback的类\",{\"1\":{\"416\":1}}],[\"存放blockhandler的类\",{\"1\":{\"416\":1}}],[\"存放矩阵\",{\"1\":{\"289\":1}}],[\"存放集合中的元素\",{\"1\":{\"187\":1}}],[\"存放结果\",{\"1\":{\"185\":2,\"222\":1}}],[\"存在数据库\",{\"1\":{\"837\":1}}],[\"存在不同版本的标准规范\",{\"1\":{\"835\":1}}],[\"存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的\",{\"1\":{\"612\":1}}],[\"存在自增id回溯的问题\",{\"1\":{\"731\":1}}],[\"存在一个标记为null值列表中\",{\"1\":{\"679\":1}}],[\"存在一条有向边\",{\"1\":{\"223\":1}}],[\"存在说明该结点为起始点\",{\"1\":{\"395\":1}}],[\"存在重复元素\",{\"0\":{\"266\":1}}],[\"存在\",{\"1\":{\"69\":1}}],[\"把id值为8的那条记录加一个gap锁的示意图如下\",{\"1\":{\"776\":1}}],[\"把回滚时所需的东西记下来\",{\"1\":{\"755\":1}}],[\"把系统变量\",{\"1\":{\"745\":1}}],[\"把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位\",{\"1\":{\"678\":1}}],[\"把一些记录放到页里示意图如下\",{\"1\":{\"643\":1}}],[\"把真实存取数据的功能划分为\",{\"1\":{\"635\":1}}],[\"把字符串\",{\"1\":{\"634\":1}}],[\"把流量作为切入点\",{\"1\":{\"399\":1}}],[\"把每一个位置都做为起跳点试一下\",{\"1\":{\"350\":2}}],[\"把每一个字符串看做放入背包的物品\",{\"1\":{\"101\":1}}],[\"把这个答案存放起来\",{\"1\":{\"185\":1}}],[\"参考\",{\"1\":{\"836\":1}}],[\"参考完整性方面\",{\"1\":{\"642\":1}}],[\"参考主表的主键或唯一约束的列\",{\"1\":{\"618\":1}}],[\"参考别人的表\",{\"1\":{\"618\":1}}],[\"参考的是java8的\",{\"1\":{\"488\":1}}],[\"参考文档\",{\"1\":{\"399\":1}}],[\"参数了\",{\"1\":{\"831\":1}}],[\"参数x为弧度值\",{\"1\":{\"549\":4}}],[\"参数x为角度值\",{\"1\":{\"549\":1}}],[\"参数可以是一列或一个值\",{\"1\":{\"545\":1}}],[\"参数可以不添加\",{\"1\":{\"446\":1}}],[\"参数应该是一个有效的url\",{\"1\":{\"502\":1}}],[\"参数应该是一个300系列的重定向\",{\"1\":{\"502\":1}}],[\"参数中必须带有username且值是整数\",{\"1\":{\"494\":1}}],[\"参数中带有\",{\"1\":{\"493\":1}}],[\"参数也一样\",{\"1\":{\"424\":1}}],[\"参数值\",{\"1\":{\"419\":1}}],[\"参数索引\",{\"1\":{\"419\":1}}],[\"参数索引从0开始\",{\"1\":{\"417\":1}}],[\"参数配置说明\",{\"1\":{\"419\":1}}],[\"参数名称等于\",{\"1\":{\"418\":1}}],[\"参数类型\",{\"1\":{\"419\":1}}],[\"参数类型必须为八个基本类型之一\",{\"1\":{\"417\":1}}],[\"参数类型需要和原方法相匹配\",{\"1\":{\"416\":1}}],[\"参数例外项\",{\"1\":{\"417\":1,\"419\":1}}],[\"参数与原方法一致\",{\"1\":{\"416\":1}}],[\"参数说明\",{\"1\":{\"416\":1}}],[\"参数见最下方\",{\"1\":{\"409\":1}}],[\"参数\",{\"1\":{\"185\":2,\"222\":1,\"496\":1,\"499\":3,\"500\":2,\"501\":2,\"695\":1,\"753\":1}}],[\"参见示例\",{\"1\":{\"19\":1}}],[\"做重试机制\",{\"1\":{\"853\":1}}],[\"做到即使有读写冲突时\",{\"1\":{\"791\":1}}],[\"做\",{\"1\":{\"785\":1,\"818\":1}}],[\"做的第一件事就是建立tcp\",{\"1\":{\"625\":1}}],[\"做扣减money\",{\"1\":{\"432\":1}}],[\"做扣减完成\",{\"1\":{\"432\":2}}],[\"做扣减count\",{\"1\":{\"432\":1}}],[\"做出开始事务\",{\"1\":{\"426\":1}}],[\"做题的时候\",{\"1\":{\"342\":1}}],[\"做过\",{\"1\":{\"190\":1}}],[\"做了几道题就清晰了\",{\"1\":{\"184\":1}}],[\"做不到的\",{\"1\":{\"12\":1}}],[\"懵\",{\"1\":{\"184\":1}}],[\"解决快照读的问题\",{\"1\":{\"801\":1}}],[\"解决了幻读问题\",{\"1\":{\"800\":1}}],[\"解决策略\",{\"1\":{\"786\":1}}],[\"解决方法\",{\"1\":{\"471\":1,\"503\":1}}],[\"解决时间格式\",{\"0\":{\"444\":1}}],[\"解决该题\",{\"1\":{\"199\":1}}],[\"解析器\",{\"0\":{\"628\":1},\"1\":{\"634\":1}}],[\"解析为一个日期\",{\"1\":{\"558\":1}}],[\"解析\",{\"1\":{\"436\":1}}],[\"解压之后\",{\"1\":{\"401\":1}}],[\"解集\",{\"1\":{\"202\":1,\"204\":1}}],[\"解集不能包含重复的组合\",{\"1\":{\"196\":1}}],[\"解数独等等\",{\"1\":{\"183\":1,\"218\":1}}],[\"解释\",{\"1\":{\"17\":1,\"23\":1,\"40\":1,\"44\":3,\"50\":1,\"55\":1,\"61\":2,\"63\":2,\"65\":1,\"67\":2,\"71\":2,\"78\":3,\"80\":2,\"82\":2,\"84\":1,\"86\":2,\"94\":2,\"96\":1,\"98\":1,\"100\":2,\"102\":2,\"104\":1,\"106\":1,\"108\":2,\"110\":2,\"112\":2,\"114\":2,\"116\":2,\"119\":2,\"121\":3,\"123\":3,\"125\":2,\"127\":1,\"129\":1,\"132\":1,\"134\":2,\"136\":1,\"138\":3,\"140\":1,\"142\":1,\"147\":2,\"149\":1,\"151\":2,\"154\":2,\"156\":2,\"166\":1,\"169\":1,\"172\":3,\"174\":1,\"176\":3,\"189\":3,\"194\":1,\"212\":1,\"214\":1,\"216\":1,\"223\":1,\"227\":1,\"229\":2,\"231\":1,\"240\":3,\"244\":2,\"257\":2,\"260\":1,\"269\":2,\"274\":1,\"276\":3,\"278\":2,\"281\":1,\"284\":1,\"290\":4,\"294\":2,\"306\":1,\"312\":2,\"321\":1,\"327\":1,\"330\":3,\"333\":1,\"343\":2,\"345\":2,\"347\":1,\"349\":2,\"351\":1,\"353\":3,\"355\":2,\"357\":2,\"359\":2,\"361\":1,\"363\":3,\"365\":3,\"367\":1,\"371\":2,\"379\":2,\"390\":3,\"393\":3,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"554\":2,\"556\":1,\"557\":2,\"558\":1,\"559\":1}}],[\"切换\",{\"1\":{\"819\":1}}],[\"切换数据库\",{\"1\":{\"586\":1}}],[\"切割\",{\"1\":{\"199\":1,\"203\":1}}],[\"切割问题通常对给定的字符串进行切割\",{\"1\":{\"203\":1}}],[\"切割问题\",{\"1\":{\"183\":1,\"218\":1}}],[\"切记\",{\"1\":{\"6\":1,\"8\":1}}],[\"特别之处在于\",{\"1\":{\"744\":1}}],[\"特别是我们有好几种查询方式可选的时候\",{\"1\":{\"696\":1}}],[\"特别感谢\",{\"1\":{\"145\":1}}],[\"特殊的唯一性索引\",{\"1\":{\"686\":1}}],[\"特殊情况\",{\"1\":{\"292\":1}}],[\"特殊情况判断\",{\"1\":{\"179\":1}}],[\"特意在页中定义了一个叫page\",{\"1\":{\"674\":1}}],[\"特性\",{\"1\":{\"658\":1}}],[\"特点\",{\"0\":{\"750\":1},\"1\":{\"614\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"650\":1,\"750\":1,\"771\":1}}],[\"更重要的是提升检索速\",{\"1\":{\"836\":1}}],[\"更灵活\",{\"1\":{\"830\":1}}],[\"更高的并发访问\",{\"1\":{\"819\":1}}],[\"更细的行级锁\",{\"1\":{\"770\":1}}],[\"更推荐类似有序uuid的全局\",{\"1\":{\"733\":1}}],[\"更准确的理解mysql到底将如何执行给定的查询语句\",{\"1\":{\"710\":1}}],[\"更容易进行快速的全表扫描\",{\"1\":{\"637\":1}}],[\"更新缓存值为6\",{\"1\":{\"847\":1}}],[\"更新风暴的风险\",{\"1\":{\"837\":1}}],[\"更新\",{\"1\":{\"837\":1}}],[\"更新部分\",{\"1\":{\"820\":1}}],[\"更新和删除操作\",{\"1\":{\"746\":1}}],[\"更新和查询数据库记\",{\"1\":{\"517\":1}}],[\"更新了该字段\",{\"1\":{\"746\":1}}],[\"更新但还没有被提交的字段\",{\"1\":{\"746\":1}}],[\"更新异常\",{\"1\":{\"737\":1}}],[\"更新主键的代价很高\",{\"1\":{\"650\":1}}],[\"更新数据库时出现网络异常\",{\"1\":{\"846\":1}}],[\"更新数据的\",{\"1\":{\"754\":1}}],[\"更新数据\",{\"1\":{\"542\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"861\":1}}],[\"更新时间\",{\"1\":{\"440\":1,\"858\":1}}],[\"更新业务数据\",{\"1\":{\"436\":1}}],[\"更新方法如下\",{\"1\":{\"391\":1}}],[\"更新开始位置\",{\"1\":{\"364\":1}}],[\"更新end\",{\"1\":{\"364\":1}}],[\"更新为旧值\",{\"1\":{\"755\":1}}],[\"更新为当前区间的\",{\"1\":{\"366\":1}}],[\"更新为\",{\"1\":{\"352\":1,\"366\":1}}],[\"更新在cover范围内每个元素能够到达的最远距离\",{\"1\":{\"350\":1}}],[\"更新回文子串\",{\"1\":{\"261\":1}}],[\"更改数据库字符集\",{\"1\":{\"586\":1}}],[\"更改数组\",{\"1\":{\"312\":1}}],[\"更改条件为\",{\"1\":{\"179\":1}}],[\"更简单\",{\"1\":{\"29\":1}}],[\"三步骤\",{\"1\":{\"820\":1}}],[\"三条数据都符合where\",{\"1\":{\"800\":1}}],[\"三者的效率差不多\",{\"1\":{\"729\":1}}],[\"三者之间的关系\",{\"1\":{\"404\":1}}],[\"三角函数\",{\"0\":{\"549\":1}}],[\"三大核心\",{\"0\":{\"488\":1}}],[\"三段\",{\"1\":{\"470\":1}}],[\"三个模块都一样\",{\"1\":{\"433\":1,\"434\":1}}],[\"三个回文子串\",{\"1\":{\"154\":1}}],[\"三张表\",{\"1\":{\"431\":1}}],[\"三\",{\"0\":{\"405\":1,\"455\":1,\"545\":1}}],[\"三数之和\",{\"1\":{\"177\":1}}],[\"三元组不能重复\",{\"1\":{\"177\":1}}],[\"逐渐增加到board中\",{\"1\":{\"217\":2}}],[\"逐个将它加到path集合中\",{\"1\":{\"224\":1}}],[\"逐个对\",{\"1\":{\"217\":1}}],[\"逐个遍历\",{\"1\":{\"177\":1}}],[\"逐层遍历\",{\"1\":{\"19\":1}}],[\"逐层从左向右遍历\",{\"1\":{\"13\":1}}],[\"反例\",{\"1\":{\"836\":1}}],[\"反而会严重降低数据更新速度\",{\"1\":{\"690\":1}}],[\"反之\",{\"1\":{\"563\":1}}],[\"反之则只记录上坡\",{\"1\":{\"346\":1}}],[\"反之则没有\",{\"1\":{\"268\":1}}],[\"反正2021不行~~\",{\"1\":{\"441\":1}}],[\"反复除以\",{\"1\":{\"173\":1}}],[\"反转后的头结点\",{\"1\":{\"387\":1}}],[\"反转后的链表\",{\"1\":{\"383\":1}}],[\"反转后的字符串需要将单词间的空格减少到仅有一个\",{\"1\":{\"244\":1}}],[\"反转后的字符串中不能存在前导空格和尾随空格\",{\"1\":{\"244\":1}}],[\"反转链表无非就是更改指针的方向\",{\"1\":{\"382\":1}}],[\"反转完\",{\"1\":{\"354\":1}}],[\"反转的条件就是\",{\"1\":{\"354\":1}}],[\"反转函数\",{\"1\":{\"256\":1}}],[\"反转字符串系列\",{\"0\":{\"243\":1}}],[\"反转\",{\"1\":{\"8\":1,\"381\":1,\"382\":2}}],[\"习惯上将其视作第一个丑数\",{\"1\":{\"172\":1}}],[\"丑数\",{\"1\":{\"172\":2}}],[\"字面意思就是两次扫描磁盘\",{\"1\":{\"725\":1}}],[\"字节数\",{\"1\":{\"706\":1}}],[\"字段上还要加索引呢\",{\"1\":{\"725\":1}}],[\"字段上只有\",{\"1\":{\"690\":1}}],[\"字段需要创建索引\",{\"1\":{\"689\":1}}],[\"字段的\",{\"1\":{\"823\":1}}],[\"字段的数值有唯一性的限制\",{\"1\":{\"689\":1}}],[\"字段的别名\",{\"1\":{\"518\":1}}],[\"字段信息\",{\"1\":{\"687\":1}}],[\"字段列表可以是一个字段\",{\"1\":{\"616\":1}}],[\"字段列表\",{\"1\":{\"615\":1,\"616\":2}}],[\"字段列表中如果是一个字段\",{\"1\":{\"615\":1}}],[\"字段类型\",{\"1\":{\"588\":2,\"615\":1}}],[\"字段3\",{\"1\":{\"587\":1}}],[\"字段不能重名\",{\"1\":{\"583\":1}}],[\"字段2\",{\"1\":{\"520\":1,\"587\":1,\"618\":2}}],[\"字段1\",{\"1\":{\"520\":1,\"587\":1,\"618\":2}}],[\"字段别名等都小写\",{\"1\":{\"518\":1}}],[\"字段名必须使用小写字母或数字\",{\"1\":{\"836\":1}}],[\"字段名等对象名中间不要包含空格\",{\"1\":{\"583\":1}}],[\"字段名2\",{\"1\":{\"542\":1}}],[\"字段名1\",{\"1\":{\"542\":1}}],[\"字段名与mysql中的关键字重复\",{\"1\":{\"524\":1}}],[\"字段名\",{\"1\":{\"518\":1,\"588\":1,\"614\":4,\"615\":9,\"616\":6,\"617\":11,\"620\":5}}],[\"字段作为外键指向主表\",{\"1\":{\"513\":1}}],[\"字段\",{\"0\":{\"512\":1},\"1\":{\"517\":1,\"587\":1,\"618\":1,\"680\":1,\"737\":1}}],[\"字段来描述用户的会员等级\",{\"1\":{\"497\":1}}],[\"字段值为\",{\"1\":{\"404\":1}}],[\"字母\",{\"1\":{\"694\":2}}],[\"字母代表值\",{\"1\":{\"193\":1}}],[\"字母要如何进行映射\",{\"1\":{\"193\":1}}],[\"字母相同\",{\"1\":{\"165\":1}}],[\"字母异位词\",{\"1\":{\"164\":2}}],[\"字符填满宽度\",{\"1\":{\"595\":1}}],[\"字符集\",{\"1\":{\"585\":1}}],[\"字符编码\",{\"1\":{\"441\":1}}],[\"字符中的前\",{\"1\":{\"252\":1}}],[\"字符\",{\"1\":{\"246\":1}}],[\"字符串抽象成s\",{\"1\":{\"699\":1}}],[\"字符串列作为主键无法保证数据的顺序增长\",{\"1\":{\"650\":1}}],[\"字符串s2是一个以逗号分\",{\"1\":{\"552\":1}}],[\"字符串的形式进行存储\",{\"1\":{\"600\":1}}],[\"字符串的位置是从1开始的\",{\"1\":{\"552\":1}}],[\"字符串的一个子序列是原始字符串删除一些\",{\"1\":{\"145\":1}}],[\"字符串函数\",{\"0\":{\"552\":1}}],[\"字符串或表达式中有一个为null\",{\"1\":{\"528\":1}}],[\"字符串或表达式都为字符串\",{\"1\":{\"528\":1}}],[\"字符串型和日期时间类型的数据可以使用单引号\",{\"1\":{\"518\":1}}],[\"字符串\",{\"0\":{\"237\":1},\"1\":{\"495\":1},\"2\":{\"264\":1}}],[\"字符而不改变剩余字符相对位置形成的新字符串\",{\"1\":{\"145\":1}}],[\"正例\",{\"1\":{\"836\":2}}],[\"正在做这个操作\",{\"1\":{\"772\":1}}],[\"正数返回1\",{\"1\":{\"548\":1}}],[\"正数反转没有意义\",{\"1\":{\"354\":1}}],[\"正确使用\",{\"1\":{\"606\":1,\"617\":1}}],[\"正确\",{\"1\":{\"559\":1}}],[\"正确写法\",{\"1\":{\"533\":1,\"564\":1}}],[\"正确的\",{\"1\":{\"467\":1}}],[\"正是circuit\",{\"1\":{\"474\":1}}],[\"正常的请求\",{\"1\":{\"477\":1}}],[\"正常的\",{\"1\":{\"467\":1}}],[\"正方形矩阵\",{\"1\":{\"287\":1}}],[\"正好\",{\"1\":{\"361\":1}}],[\"正好足够你返回到\",{\"1\":{\"355\":1}}],[\"正好由四个整数\",{\"1\":{\"200\":1}}],[\"正好得该字符在数组中的位置\",{\"1\":{\"163\":1}}],[\"正整数\",{\"1\":{\"86\":1}}],[\"排除某些表的备份\",{\"1\":{\"831\":1}}],[\"排除的异常不会计入异常统计\",{\"1\":{\"416\":1}}],[\"排它性\",{\"1\":{\"783\":1}}],[\"排它锁互斥\",{\"1\":{\"771\":1}}],[\"排他锁之前\",{\"1\":{\"771\":1}}],[\"排他锁\",{\"1\":{\"767\":1,\"791\":4}}],[\"排队执行\",{\"1\":{\"763\":1}}],[\"排队等待\",{\"1\":{\"411\":1}}],[\"排\",{\"1\":{\"725\":1}}],[\"排成一个单向链表\",{\"1\":{\"650\":1}}],[\"排好序的快速查找数据结构\",{\"1\":{\"642\":1}}],[\"排完序之后\",{\"1\":{\"165\":1}}],[\"排序不一致\",{\"1\":{\"725\":1}}],[\"排序则一般在内存中进行排序\",{\"1\":{\"725\":1}}],[\"排序优化\",{\"0\":{\"725\":1}}],[\"排序之类的\",{\"1\":{\"710\":1}}],[\"排序查找和\",{\"1\":{\"650\":1}}],[\"排序呢\",{\"1\":{\"364\":1}}],[\"排序完之后\",{\"1\":{\"362\":1}}],[\"排序完的people\",{\"1\":{\"362\":1}}],[\"排序\",{\"1\":{\"281\":1,\"579\":1,\"725\":3}}],[\"排序的整数数组\",{\"1\":{\"281\":1}}],[\"排序更靠前\",{\"1\":{\"212\":1}}],[\"排序过后的\",{\"1\":{\"165\":1}}],[\"排序后肯定是相等的\",{\"1\":{\"163\":1}}],[\"排序后\",{\"1\":{\"162\":1,\"281\":1}}],[\"排列数组\",{\"1\":{\"273\":1}}],[\"排列问题\",{\"1\":{\"183\":1,\"218\":1}}],[\"排列强调元素的顺序\",{\"1\":{\"103\":1}}],[\"排列\",{\"1\":{\"71\":1,\"204\":1,\"240\":1,\"312\":1}}],[\"具有以下性质\",{\"1\":{\"660\":1}}],[\"具有不同开始位置或结束位置的子串\",{\"1\":{\"154\":1}}],[\"具备权限\",{\"1\":{\"634\":1}}],[\"具备以下特点\",{\"1\":{\"162\":1}}],[\"具体数字\",{\"1\":{\"826\":1}}],[\"具体情况如下\",{\"1\":{\"746\":1}}],[\"具体命令如下\",{\"1\":{\"698\":1}}],[\"具体指运行时间超过long\",{\"1\":{\"697\":1}}],[\"具体如下\",{\"1\":{\"607\":1,\"809\":1}}],[\"具体存储引擎的情况\",{\"1\":{\"604\":1}}],[\"具体的字段\",{\"1\":{\"729\":1}}],[\"具体的校验规则\",{\"1\":{\"497\":1}}],[\"具体的校验过程\",{\"1\":{\"497\":1,\"504\":1}}],[\"具体的通过\",{\"1\":{\"458\":1}}],[\"具体的流程\",{\"1\":{\"279\":1}}],[\"具体状态码参见枚举类returncodeenum\",{\"1\":{\"444\":1}}],[\"具体针对某个微服务进行限流\",{\"1\":{\"409\":1}}],[\"具体旋转咱也不知道\",{\"1\":{\"276\":1}}],[\"仅记录请求方法\",{\"1\":{\"470\":1}}],[\"仅慢调用比例模式有效\",{\"1\":{\"419\":1}}],[\"仅仅是请求c读到了一次旧值\",{\"1\":{\"849\":1}}],[\"仅仅是锁住了id值为8的记录\",{\"1\":{\"775\":1}}],[\"仅仅是为了标识链表的实际情况\",{\"1\":{\"393\":1}}],[\"仅仅返回2000000\",{\"1\":{\"726\":1}}],[\"仅仅只是产出了一个执行计划\",{\"1\":{\"634\":1}}],[\"仅仅多了一个去重的步骤\",{\"1\":{\"205\":1}}],[\"仅有一个元素或者含两个不等元素的序列也视作摆动序列\",{\"1\":{\"345\":1}}],[\"仅有一个有效答案\",{\"1\":{\"241\":1}}],[\"仅有这两种组合\",{\"1\":{\"194\":1}}],[\"仅存在一个有效答案\",{\"1\":{\"240\":1}}],[\"仅包含小写字母\",{\"1\":{\"161\":1,\"164\":1}}],[\"仅由括号\",{\"1\":{\"324\":1}}],[\"仅由数字和英文字母组成\",{\"1\":{\"260\":1}}],[\"仅由数字组成\",{\"1\":{\"200\":1}}],[\"仅由小写英文字符组成\",{\"1\":{\"138\":1}}],[\"仅由小写英文字母组成\",{\"1\":{\"110\":1,\"156\":1,\"198\":1,\"327\":1,\"367\":1}}],[\"仅由\",{\"1\":{\"100\":1}}],[\"互斥锁来锁住它\",{\"1\":{\"844\":1}}],[\"互为字母异位词\",{\"1\":{\"161\":1}}],[\"互不相同的\",{\"1\":{\"88\":1}}],[\"互不相同\",{\"1\":{\"50\":1,\"73\":1,\"102\":1,\"104\":1,\"110\":1,\"194\":1,\"202\":2,\"208\":1,\"223\":1,\"276\":2,\"277\":1}}],[\"编辑此页链接\",{\"1\":{\"858\":1}}],[\"编辑距离\",{\"1\":{\"153\":1}}],[\"编辑距离问题\",{\"0\":{\"144\":1}}],[\"编程模型轻松使用这些组件来开发分布式应用服务\",{\"1\":{\"399\":1}}],[\"编号为\",{\"1\":{\"361\":6}}],[\"编写一种算法\",{\"1\":{\"300\":1}}],[\"编写一个函数将所有\",{\"1\":{\"315\":1}}],[\"编写一个函数\",{\"1\":{\"249\":1}}],[\"编写一个函数来判断\",{\"1\":{\"161\":1}}],[\"编写一个程序\",{\"1\":{\"216\":1}}],[\"编写一个算法来判断一个数\",{\"1\":{\"169\":1}}],[\"指南\",{\"2\":{\"862\":1}}],[\"指名路径\",{\"1\":{\"823\":1}}],[\"指令如下\",{\"1\":{\"809\":1}}],[\"指令等\",{\"1\":{\"806\":1}}],[\"指undo日志中保存的被事务修改的行信息\",{\"1\":{\"790\":1}}],[\"指的就是\",{\"1\":{\"796\":1}}],[\"指的就是该类型表示的数据范围的大小\",{\"1\":{\"689\":1}}],[\"指的是不包含在任何一个候选键中的属性\",{\"1\":{\"736\":1}}],[\"指的是20字符\",{\"1\":{\"604\":1}}],[\"指的是20字节\",{\"1\":{\"604\":1}}],[\"指数和对数\",{\"0\":{\"550\":1}}],[\"指标监控健康检查的actuator\",{\"1\":{\"489\":1}}],[\"指系统对请求作出响应的业务处理时间\",{\"1\":{\"412\":1}}],[\"指明隔离类型为\",{\"1\":{\"480\":1,\"481\":1}}],[\"指明服务端的服务名\",{\"1\":{\"464\":1}}],[\"指明服务端名称\",{\"1\":{\"464\":1}}],[\"指明等待多少时间同步更新\",{\"1\":{\"453\":1}}],[\"指明\",{\"1\":{\"404\":2,\"416\":1,\"419\":1}}],[\"指定日期\",{\"1\":{\"809\":1}}],[\"指定日志文件名\",{\"1\":{\"809\":1}}],[\"指定从哪个pos起始点开始查起\",{\"1\":{\"809\":1}}],[\"指定要查询的binlog文件名\",{\"1\":{\"809\":1}}],[\"指定升序或者降序的索引值存储\",{\"1\":{\"687\":1}}],[\"指定索引的名称\",{\"1\":{\"687\":1}}],[\"指定行格式的语法\",{\"0\":{\"676\":1}}],[\"指定删除条件\",{\"1\":{\"542\":1}}],[\"指定字段的顺序及插入数据的顺序\",{\"1\":{\"542\":1}}],[\"指定字段上使用注解\",{\"1\":{\"444\":1}}],[\"指定cookie\",{\"1\":{\"493\":1}}],[\"指定哪个服务的超时时间\",{\"1\":{\"466\":1}}],[\"指定排除忽略掉哪些异常\",{\"1\":{\"416\":1}}],[\"指定yaml格式的配置\",{\"1\":{\"403\":1,\"404\":2}}],[\"指定链表中值为\",{\"1\":{\"379\":2}}],[\"指定每次拿最大的\",{\"1\":{\"342\":1}}],[\"指向第一个待反转结点\",{\"1\":{\"384\":1}}],[\"指向带反转结点的前一个结点\",{\"1\":{\"384\":1}}],[\"指向当前结点\",{\"1\":{\"382\":1}}],[\"指向当前结点的上一结点\",{\"1\":{\"382\":1}}],[\"指向当前遍历的元素\",{\"1\":{\"195\":1}}],[\"指向头结点\",{\"1\":{\"378\":1}}],[\"指向重复的元素\",{\"1\":{\"313\":1}}],[\"指向下一个元素\",{\"1\":{\"291\":1}}],[\"指向滑动窗口起始位置\",{\"1\":{\"286\":1}}],[\"指向数组首端\",{\"1\":{\"282\":1}}],[\"指向数组第一个元素\",{\"1\":{\"177\":1}}],[\"指向输出元素\",{\"1\":{\"280\":1}}],[\"指向的元素相等时\",{\"1\":{\"313\":1}}],[\"指向的元素覆盖\",{\"1\":{\"313\":2}}],[\"指向的元素\",{\"1\":{\"279\":1}}],[\"指向的元素替换掉\",{\"1\":{\"279\":1}}],[\"指向被替换的元素\",{\"1\":{\"280\":1}}],[\"指向被替换\",{\"1\":{\"279\":1}}],[\"指向可以输出的元素\",{\"1\":{\"279\":1}}],[\"指向\",{\"1\":{\"177\":1,\"199\":1,\"391\":1}}],[\"指向一个字符时\",{\"1\":{\"157\":1}}],[\"指针再次到达\",{\"1\":{\"393\":1}}],[\"指针初始指向\",{\"1\":{\"391\":1}}],[\"指针应该为4\",{\"1\":{\"313\":1}}],[\"指针就停止\",{\"1\":{\"313\":1}}],[\"指针移动到滑动窗口终止的位置\",{\"1\":{\"286\":1}}],[\"指针继续向右移动\",{\"1\":{\"279\":1}}],[\"指针不动\",{\"1\":{\"279\":1}}],[\"指针指向\",{\"1\":{\"352\":1}}],[\"指针指向的是重复元素的第一个\",{\"1\":{\"313\":1}}],[\"指针指向等于val的元素\",{\"1\":{\"279\":1}}],[\"指针指向不等于\",{\"1\":{\"279\":1}}],[\"指针指向最后一个元素时表示遍历完成\",{\"1\":{\"203\":1}}],[\"指针向右移动\",{\"1\":{\"279\":1}}],[\"指针向同侧移动\",{\"1\":{\"250\":1}}],[\"指针向中间或两端移动\",{\"1\":{\"250\":1}}],[\"指针跳出循环\",{\"1\":{\"245\":1}}],[\"指针连接\",{\"1\":{\"23\":1}}],[\"指针都被设置为\",{\"1\":{\"23\":1}}],[\"指针设置为\",{\"1\":{\"23\":1}}],[\"指针\",{\"1\":{\"23\":2,\"187\":1,\"193\":1,\"195\":1,\"201\":1,\"211\":1,\"279\":1,\"313\":1}}],[\"加表级别的\",{\"1\":{\"770\":2}}],[\"加锁的\",{\"1\":{\"791\":1}}],[\"加锁会比较慢\",{\"1\":{\"774\":1}}],[\"加锁\",{\"1\":{\"765\":2,\"820\":1}}],[\"加速查找速度的数据结构\",{\"1\":{\"658\":1}}],[\"加速表和表之间的连接\",{\"1\":{\"642\":1}}],[\"加快查询效率\",{\"1\":{\"641\":1}}],[\"加了也没用\",{\"1\":{\"605\":1}}],[\"加载\",{\"1\":{\"436\":1}}],[\"加\",{\"1\":{\"241\":1}}],[\"加到集合中即可\",{\"1\":{\"177\":1}}],[\"加入\",{\"1\":{\"157\":2}}],[\"加上当前元素的值\",{\"1\":{\"143\":1}}],[\"仍需要执行一遍\",{\"1\":{\"276\":1}}],[\"仍然为开启状态\",{\"1\":{\"475\":1}}],[\"仍然可以使用\",{\"1\":{\"402\":1}}],[\"仍然使用快慢指针\",{\"1\":{\"316\":1}}],[\"仍然没有填充结果\",{\"1\":{\"217\":1}}],[\"仍然需要到\",{\"1\":{\"651\":1}}],[\"仍然需要使用\",{\"1\":{\"201\":1}}],[\"仍然需要俩个集合\",{\"1\":{\"199\":1,\"203\":1}}],[\"仍然需要\",{\"1\":{\"195\":1}}],[\"仍然需要定义俩个集合\",{\"1\":{\"190\":1}}],[\"仍然通过\",{\"1\":{\"190\":1}}],[\"仍然有俩种情况\",{\"1\":{\"157\":1}}],[\"仍然要采取倒序遍历\",{\"1\":{\"95\":1}}],[\"仍要利用回文串的特性\",{\"1\":{\"157\":1}}],[\"了这个功能\",{\"1\":{\"634\":1}}],[\"了解了sql的执行顺序\",{\"1\":{\"565\":1}}],[\"了解以上问题\",{\"1\":{\"95\":1}}],[\"了\",{\"1\":{\"155\":1,\"796\":1}}],[\"默认全部记录\",{\"1\":{\"823\":1}}],[\"默认全局异常处理\",{\"1\":{\"445\":1}}],[\"默认开启\",{\"1\":{\"807\":1}}],[\"默认\",{\"1\":{\"751\":1,\"823\":1}}],[\"默认方式\",{\"1\":{\"699\":1}}],[\"默认设置为compact行格式\",{\"1\":{\"677\":1}}],[\"默认事务型引擎\",{\"1\":{\"636\":1}}],[\"默认采用innodb引擎\",{\"1\":{\"636\":1}}],[\"默认名不是列名\",{\"1\":{\"618\":1}}],[\"默认所有的类型的值都可以是null\",{\"1\":{\"614\":1}}],[\"默认值约束\",{\"1\":{\"613\":1}}],[\"默认值\",{\"1\":{\"587\":3,\"588\":2,\"617\":3,\"620\":2,\"753\":1}}],[\"默认值为10\",{\"1\":{\"477\":1,\"478\":1}}],[\"默认值为true\",{\"1\":{\"477\":1}}],[\"默认值为default\",{\"1\":{\"409\":1}}],[\"默认限制远程1s\",{\"1\":{\"478\":1}}],[\"默认最后\",{\"1\":{\"477\":1}}],[\"默认的页大小为\",{\"1\":{\"749\":1}}],[\"默认的\",{\"1\":{\"470\":1}}],[\"默认httpclient修改\",{\"0\":{\"468\":1}}],[\"默认关闭\",{\"1\":{\"467\":1}}],[\"默认读取data\",{\"1\":{\"452\":1}}],[\"默认是1gb\",{\"1\":{\"809\":1}}],[\"默认是1位\",{\"1\":{\"601\":1}}],[\"默认是count\",{\"1\":{\"476\":1}}],[\"默认是\",{\"1\":{\"452\":1,\"453\":1,\"744\":1,\"810\":1}}],[\"默认是out\",{\"1\":{\"416\":1}}],[\"默认有多个cloud\",{\"1\":{\"451\":1}}],[\"默认0不删除\",{\"1\":{\"440\":1}}],[\"默认讲解的模式为\",{\"1\":{\"436\":1}}],[\"默认超时\",{\"1\":{\"435\":1}}],[\"默认false\",{\"1\":{\"419\":1}}],[\"默认fallback函数可以针对所有类型的异常进\",{\"1\":{\"416\":1}}],[\"默认需要和原方法在同一个类中\",{\"1\":{\"416\":1}}],[\"默认需和原方法在同一个类中\",{\"1\":{\"416\":2}}],[\"默认coldfactor为\",{\"1\":{\"411\":1}}],[\"默认就是请求的接口路径\",{\"1\":{\"409\":1}}],[\"默认8719端口\",{\"1\":{\"408\":1,\"420\":1}}],[\"默认账号密码\",{\"1\":{\"407\":1}}],[\"默认情况下\",{\"1\":{\"697\":1,\"807\":1}}],[\"默认情况\",{\"1\":{\"404\":1}}],[\"默认为\",{\"1\":{\"403\":1,\"419\":3}}],[\"默认集成对应\",{\"1\":{\"399\":1}}],[\"默认支持\",{\"1\":{\"399\":1}}],[\"默认肯定都不是回文子串\",{\"1\":{\"155\":1}}],[\"默认左右子树已经有结果\",{\"1\":{\"62\":1}}],[\"又想\",{\"1\":{\"777\":1}}],[\"又称完美\",{\"1\":{\"736\":1}}],[\"又称\",{\"1\":{\"704\":1}}],[\"又称为avl树\",{\"1\":{\"660\":1}}],[\"又称avl\",{\"1\":{\"0\":1}}],[\"又被称为散列函数\",{\"1\":{\"658\":1}}],[\"又可以容忍微小误差的科学计算场景\",{\"1\":{\"600\":1}}],[\"又分为几种情况\",{\"1\":{\"155\":1}}],[\"整\",{\"1\":{\"737\":1}}],[\"整型数据类型可以在定义表结构时指定所需要的显示宽度\",{\"1\":{\"595\":1}}],[\"整型数组\",{\"1\":{\"269\":1}}],[\"整型\",{\"0\":{\"593\":1}}],[\"整合sentinel\",{\"1\":{\"422\":2}}],[\"整合\",{\"1\":{\"421\":1}}],[\"整合openfeign\",{\"0\":{\"420\":1}}],[\"整个数据库实例加锁\",{\"1\":{\"785\":1}}],[\"整个流程划分成了\",{\"1\":{\"694\":1}}],[\"整个调用链路被拖垮\",{\"1\":{\"472\":1}}],[\"整个链式结构中不存在环\",{\"1\":{\"390\":1}}],[\"整个nums数组波峰和波谷的数量\",{\"1\":{\"346\":1}}],[\"整个序列均为摆动序列\",{\"1\":{\"345\":1}}],[\"整个字符串\",{\"1\":{\"256\":1}}],[\"整体代码\",{\"1\":{\"193\":1}}],[\"整体上有俩种情况\",{\"1\":{\"155\":1}}],[\"整数数据类型不推荐使用显示宽度属性\",{\"1\":{\"595\":1}}],[\"整数数组\",{\"1\":{\"277\":1}}],[\"整数类型一共有\",{\"1\":{\"593\":1}}],[\"整数表示\",{\"1\":{\"330\":1}}],[\"整数之间用\",{\"1\":{\"200\":1}}],[\"整数组成的数组\",{\"1\":{\"104\":1}}],[\"整数为i时\",{\"1\":{\"89\":1}}],[\"整数为2\",{\"1\":{\"87\":1}}],[\"整数\",{\"1\":{\"87\":1,\"129\":1,\"174\":1}}],[\"觉着dp数组的定义是\",{\"1\":{\"155\":1}}],[\"回顾一下undo日志的版本链\",{\"1\":{\"794\":1}}],[\"回表\",{\"1\":{\"651\":3,\"727\":1,\"728\":2}}],[\"回应头相关\",{\"0\":{\"501\":1}}],[\"回退到\",{\"1\":{\"440\":1}}],[\"回滚数据\",{\"1\":{\"756\":1}}],[\"回滚之后进行恢复\",{\"1\":{\"747\":1}}],[\"回滚行记录到某个特定版本\",{\"1\":{\"747\":1}}],[\"回滚日志\",{\"1\":{\"747\":1}}],[\"回滚操作执行完毕时\",{\"1\":{\"742\":1}}],[\"回滚方式便是用\",{\"1\":{\"436\":1}}],[\"回滚\",{\"1\":{\"436\":1,\"755\":1}}],[\"回滚事务的决议\",{\"1\":{\"426\":1}}],[\"回文串\",{\"1\":{\"198\":2}}],[\"回文串的长度为\",{\"1\":{\"157\":1}}],[\"回文字符串\",{\"1\":{\"154\":1}}],[\"回文子串\",{\"1\":{\"154\":1}}],[\"回溯是递归的副产品\",{\"1\":{\"218\":1}}],[\"回溯找到每个皇后的位置\",{\"1\":{\"215\":1}}],[\"回溯一般没有返回值\",{\"1\":{\"213\":1}}],[\"回溯而来\",{\"1\":{\"211\":1}}],[\"回溯法一般是在集合中递归搜索\",{\"1\":{\"185\":1}}],[\"回溯的终止条件\",{\"1\":{\"185\":1}}],[\"回溯的参数\",{\"1\":{\"185\":1}}],[\"回溯返回值及参数\",{\"1\":{\"185\":1}}],[\"回溯模板\",{\"0\":{\"185\":1}}],[\"回溯算法并不是什么高效的算法\",{\"1\":{\"218\":1}}],[\"回溯算法模板如下\",{\"1\":{\"185\":1}}],[\"回溯算法的搜索过程\",{\"1\":{\"185\":1}}],[\"回溯算法的效率其实并不高\",{\"1\":{\"183\":1}}],[\"回溯算法理论基础\",{\"1\":{\"184\":1,\"185\":1}}],[\"回溯算法解决的基本都是在集合中递归查找子集\",{\"1\":{\"184\":1}}],[\"回溯基本上都是通过递归来解决问题\",{\"1\":{\"184\":1}}],[\"回溯就是一种搜索的方式\",{\"1\":{\"183\":1}}],[\"回溯\",{\"0\":{\"182\":1},\"1\":{\"185\":2,\"187\":3,\"188\":1,\"193\":2,\"197\":1,\"213\":2,\"215\":2,\"217\":2,\"222\":1,\"224\":2},\"2\":{\"220\":1}}],[\"回溯隐藏在递归中\",{\"1\":{\"45\":1}}],[\"回溯隐藏在在每次递归的时候\",{\"1\":{\"39\":1}}],[\"回溯方法\",{\"1\":{\"39\":1}}],[\"那条记录加一个记录锁的示意图如图所示\",{\"1\":{\"775\":1}}],[\"那除了最左边的那个小查询之外\",{\"1\":{\"703\":1}}],[\"那为什么索引结构要设计成树型呢\",{\"1\":{\"658\":1}}],[\"那就需要判断一下trx\",{\"1\":{\"798\":1}}],[\"那就意味着发生了不可重复读\",{\"1\":{\"746\":1}}],[\"那就意味着发生了\",{\"1\":{\"746\":1}}],[\"那就是很大的一片存储空间\",{\"1\":{\"656\":1}}],[\"那就要有很多的精力用于计算\",{\"1\":{\"604\":1}}],[\"那如果表中的数据太多\",{\"1\":{\"646\":1}}],[\"那用char应该更合适\",{\"1\":{\"604\":1}}],[\"那在另一个表里可就别变成字符型了\",{\"1\":{\"583\":1}}],[\"那它和手动的配置\",{\"1\":{\"416\":1}}],[\"那\",{\"1\":{\"372\":1,\"599\":1}}],[\"那叶子结点的父节点就没有必要放置摄像头了\",{\"1\":{\"372\":1}}],[\"那我们尽可能反转较小的数\",{\"1\":{\"354\":1}}],[\"那我们尽可能的去反转绝对值较大的负数\",{\"1\":{\"354\":1}}],[\"那肯定是回文子串\",{\"1\":{\"261\":1}}],[\"那最后当然是取最小值\",{\"1\":{\"153\":1}}],[\"那么成绩表中的\",{\"1\":{\"837\":1}}],[\"那么首先考虑的是如何\",{\"1\":{\"818\":1}}],[\"那么low\",{\"1\":{\"797\":1}}],[\"那么查询线程拿到的结果跟表结构对不上\",{\"1\":{\"773\":1}}],[\"那么t2就需要去检查每行或者每页是否存在锁\",{\"1\":{\"771\":1}}],[\"那么系统恢复之后\",{\"1\":{\"757\":1}}],[\"那么数据也丢失了\",{\"1\":{\"753\":1}}],[\"那么数据表中所有这个比赛的时间都需要进行调\",{\"1\":{\"737\":1}}],[\"那么也要将这\",{\"1\":{\"749\":1}}],[\"那么事务的四种特性到底是基于什么机制实现呢\",{\"1\":{\"747\":1}}],[\"那么事务a再读该数据\",{\"1\":{\"746\":1}}],[\"那么球员的姓名和年龄就重复了\",{\"1\":{\"737\":1}}],[\"那么之前张三购买的东西\",{\"1\":{\"732\":1}}],[\"那么加上\",{\"1\":{\"729\":1}}],[\"那么无法使用此索引\",{\"1\":{\"716\":1}}],[\"那么该子查询执行计划的type\",{\"1\":{\"704\":1}}],[\"那么该如何维护呢\",{\"1\":{\"334\":1}}],[\"那么可以通过索引进行查询\",{\"1\":{\"729\":1}}],[\"那么可以在这些列上建立\",{\"1\":{\"689\":1}}],[\"那么可以得出\",{\"1\":{\"293\":1}}],[\"那么mysql优化器就会认为\",{\"1\":{\"719\":1}}],[\"那么mysql默认col\",{\"1\":{\"687\":1}}],[\"那么mysql会自动为当前列添加unsigned属性\",{\"1\":{\"597\":1}}],[\"那么默认和\",{\"1\":{\"615\":1}}],[\"那么复合唯一\",{\"1\":{\"615\":1}}],[\"那么插入的数据宽度超过显示宽度限制\",{\"1\":{\"595\":1}}],[\"那么获取的随机数也是一样的\",{\"1\":{\"548\":1}}],[\"那么结果也一定是\",{\"1\":{\"523\":1}}],[\"那么执行间隔为\",{\"1\":{\"467\":1}}],[\"那么如何保证持久性呢\",{\"1\":{\"749\":1}}],[\"那么如何让头结点和其他结点保持一样的处理方式呢\",{\"1\":{\"378\":1}}],[\"那么如何让头结点和其他结点保持一样的操作呢\",{\"1\":{\"377\":1}}],[\"那么如何转化为动态规划呢\",{\"1\":{\"99\":1}}],[\"那么和其他结点是不一样\",{\"1\":{\"377\":1}}],[\"那么本节点就是处于被覆盖状态\",{\"1\":{\"372\":1}}],[\"那么本节点的状态就应该是无覆盖\",{\"1\":{\"372\":1}}],[\"那么本题就很容易了\",{\"1\":{\"122\":1}}],[\"那么头结点也应该放置一个摄像头\",{\"1\":{\"372\":1}}],[\"那么此时t2就会被阻塞\",{\"1\":{\"771\":1}}],[\"那么此时父节点就应该放置一个摄像头\",{\"1\":{\"372\":1}}],[\"那么此时中间节点应该就是无覆盖的状态了\",{\"1\":{\"372\":1}}],[\"那么此时我们在加上一个替换操作就能够满足要求\",{\"1\":{\"152\":1,\"153\":1}}],[\"那么叶子结点就应该放置一个摄像头\",{\"1\":{\"372\":1}}],[\"那么应该是什么状态\",{\"1\":{\"372\":1}}],[\"那么应该初始化成多少呢\",{\"1\":{\"152\":1}}],[\"那么循环到\",{\"1\":{\"366\":1}}],[\"那么这段数据就是丢失的\",{\"1\":{\"749\":1}}],[\"那么这个属性集就是数据表\",{\"1\":{\"736\":1}}],[\"那么这个超键就是候选键\",{\"1\":{\"736\":1}}],[\"那么这个数就是快乐数\",{\"1\":{\"169\":1}}],[\"那么这些列都不允许为空值\",{\"1\":{\"616\":1}}],[\"那么这样的子查询叫做不相关子查询\",{\"1\":{\"570\":1}}],[\"那么这道题是根据start\",{\"1\":{\"364\":1}}],[\"那么起始点就是我们记录的\",{\"1\":{\"356\":1}}],[\"那么不管经过哪个加油站\",{\"1\":{\"356\":1}}],[\"那么不断的累加平方和\",{\"1\":{\"170\":1}}],[\"那么到最后一个操作时一定是弹栈\",{\"1\":{\"325\":1}}],[\"那么您的题解将被\",{\"1\":{\"312\":1}}],[\"那么它一定满足以下的条件\",{\"1\":{\"273\":1}}],[\"那么它相较于普通二叉树的搜索来说多了一层判断\",{\"1\":{\"54\":1}}],[\"那么接下来要查找的左区间结束下标位置就是\",{\"1\":{\"271\":1}}],[\"那么接下来考虑怎么存储\",{\"1\":{\"175\":1}}],[\"那么要找到与node相连接的下一个节点\",{\"1\":{\"224\":1}}],[\"那么每一种组合他的字母长度就为多少\",{\"1\":{\"193\":1}}],[\"那么每一天就只有俩种状态\",{\"1\":{\"122\":1}}],[\"那么最大的起始元素为\",{\"1\":{\"188\":2}}],[\"那么将该题抽象成二叉树为\",{\"1\":{\"187\":1}}],[\"那么将这两个节点的值相加作为合并后节点的新值\",{\"1\":{\"52\":1}}],[\"那么k=50呢\",{\"1\":{\"187\":1}}],[\"那么所有的异位词都是相同的\",{\"1\":{\"165\":1}}],[\"那么会先使用\",{\"1\":{\"155\":1}}],[\"那么个数为dp\",{\"1\":{\"148\":1,\"153\":1}}],[\"那么子序列\",{\"1\":{\"134\":1}}],[\"那么根据\",{\"1\":{\"122\":1}}],[\"那么利润为\",{\"1\":{\"122\":1}}],[\"那么s串就会被分成俩个子串s1为\",{\"1\":{\"111\":1}}],[\"那么只需要加上一个钱币coins\",{\"1\":{\"107\":1}}],[\"那么凑整dp\",{\"1\":{\"99\":1}}],[\"那么对该表的访问方法就可能是ref\",{\"1\":{\"704\":2}}],[\"那么对该表的访\",{\"1\":{\"704\":1}}],[\"那么对于innodb来说就存在一个问题\",{\"1\":{\"753\":1}}],[\"那么对于这道题来说\",{\"1\":{\"362\":1}}],[\"那么对于\",{\"1\":{\"356\":1}}],[\"那么对于有效的ip地址\",{\"1\":{\"201\":1}}],[\"那么对于可以偷的房屋我们可以分成俩个线性队列\",{\"1\":{\"115\":1}}],[\"那么对于重量为\",{\"1\":{\"91\":1}}],[\"那么对应的减法总和为\",{\"1\":{\"99\":1}}],[\"那么重量为\",{\"1\":{\"96\":1}}],[\"那么两块石头都会被完全粉碎\",{\"1\":{\"96\":1}}],[\"那么粉碎的可能结果如下\",{\"1\":{\"96\":1}}],[\"那么他有俩种可能得到最大乘积\",{\"1\":{\"87\":1}}],[\"那么求节点4的新值\",{\"1\":{\"74\":1}}],[\"那么在该表的执行计划的extra列就会提示`not\",{\"1\":{\"710\":1}}],[\"那么在修改后的某个时间需要把数据同步到磁盘中\",{\"1\":{\"668\":1}}],[\"那么在调用了你的函数之后\",{\"1\":{\"379\":2}}],[\"那么在push\",{\"1\":{\"334\":1}}],[\"那么在第一次\",{\"1\":{\"188\":1}}],[\"那么在\",{\"1\":{\"72\":1,\"141\":1,\"152\":1,\"153\":1}}],[\"那么我们可以在第一个查询数据的请求上使用一个\",{\"1\":{\"844\":1}}],[\"那么我们是从前往后遍历\",{\"1\":{\"370\":1}}],[\"那么我们应该利用\",{\"1\":{\"230\":1}}],[\"那么我们的目的\",{\"1\":{\"170\":1}}],[\"那么我们将\",{\"1\":{\"165\":1}}],[\"那么我们只需要在判断\",{\"1\":{\"111\":1}}],[\"那么我们只需要调整一下先序遍历的代码顺序\",{\"1\":{\"8\":1}}],[\"那么我们就可以证明\",{\"1\":{\"111\":1}}],[\"那么我们就可以直接遍历二叉搜索树\",{\"1\":{\"66\":1}}],[\"那么我们需要知道以下问题\",{\"1\":{\"95\":1}}],[\"那么一共有以下几种情况\",{\"1\":{\"62\":1}}],[\"那么一定是对称的\",{\"1\":{\"33\":1}}],[\"那么好了\",{\"1\":{\"60\":1}}],[\"那么中序遍历\",{\"1\":{\"58\":1}}],[\"那么说明所有的结点都比较完了\",{\"1\":{\"33\":1}}],[\"那么就会记录在\",{\"1\":{\"747\":1}}],[\"那么就需要把已经修改的事务中的操作还原到事务执\",{\"1\":{\"742\":1}}],[\"那么就需要以c2在创建一颗b+树\",{\"1\":{\"651\":1}}],[\"那么就没\",{\"1\":{\"737\":1}}],[\"那么就浪费了很多的cpu资源\",{\"1\":{\"728\":1}}],[\"那么就可能使用到range访问方法\",{\"1\":{\"704\":1}}],[\"那么就不必再进行查询解析\",{\"1\":{\"630\":1}}],[\"那么就不是对称的\",{\"1\":{\"33\":3}}],[\"那么就说明这个sql语句是不合理的\",{\"1\":{\"628\":1}}],[\"那么就抛弃右区间\",{\"1\":{\"276\":1}}],[\"那么就尽可能的让俩个元素的最小值较大\",{\"1\":{\"258\":1}}],[\"那么就得使用俩层\",{\"1\":{\"187\":1}}],[\"那么就应该保证a+d\",{\"1\":{\"97\":1}}],[\"那么就有\",{\"1\":{\"54\":1,\"193\":1,\"304\":1,\"356\":2}}],[\"那么就是先把1加入计算\",{\"1\":{\"103\":1}}],[\"那么就是对称的\",{\"1\":{\"33\":1}}],[\"那么就是不对称的\",{\"1\":{\"33\":1}}],[\"那么就对称的\",{\"1\":{\"33\":1}}],[\"那么\",{\"1\":{\"12\":4,\"70\":1,\"155\":2,\"199\":1,\"211\":1,\"261\":3,\"273\":2,\"299\":1,\"356\":1,\"532\":1,\"599\":1,\"648\":1,\"651\":1,\"846\":1}}],[\"那么有\",{\"1\":{\"0\":1}}],[\"情况\",{\"1\":{\"762\":1,\"763\":1,\"774\":1}}],[\"情况4\",{\"1\":{\"604\":1}}],[\"情况3\",{\"1\":{\"604\":1}}],[\"情况2\",{\"1\":{\"604\":2}}],[\"情况四\",{\"1\":{\"372\":1}}],[\"情况1\",{\"1\":{\"372\":1,\"604\":1}}],[\"情况三\",{\"1\":{\"153\":1,\"372\":1}}],[\"情况二\",{\"1\":{\"153\":1,\"273\":1,\"372\":1,\"755\":1}}],[\"情况一\",{\"1\":{\"153\":1,\"273\":1,\"755\":1}}],[\"情况虽说复杂一些\",{\"1\":{\"153\":1}}],[\"考虑先将\",{\"1\":{\"718\":1}}],[\"考虑\",{\"1\":{\"312\":1}}],[\"考虑删除\",{\"1\":{\"152\":2,\"153\":2}}],[\"考虑coins\",{\"1\":{\"107\":1}}],[\"换到了\",{\"1\":{\"222\":1}}],[\"换方向\",{\"1\":{\"222\":1}}],[\"换成公式则为\",{\"1\":{\"173\":1}}],[\"换\",{\"1\":{\"152\":1}}],[\"换句话说\",{\"1\":{\"108\":1,\"231\":1,\"336\":1,\"351\":1,\"386\":1,\"642\":1,\"742\":1}}],[\"删表时\",{\"1\":{\"618\":1}}],[\"删word2\",{\"1\":{\"153\":1}}],[\"删word1\",{\"1\":{\"153\":1}}],[\"删\",{\"1\":{\"152\":1,\"656\":2}}],[\"删除失败怎么办\",{\"0\":{\"850\":1}}],[\"删除slave数据库的relaylog日志文件\",{\"1\":{\"826\":1}}],[\"删除之前的\",{\"1\":{\"826\":1}}],[\"删除所有的二进制日志文件\",{\"1\":{\"809\":1}}],[\"删除日志文件\",{\"1\":{\"809\":1}}],[\"删除异常\",{\"1\":{\"737\":1}}],[\"删除慢查询日志\",{\"1\":{\"698\":1}}],[\"删除不再使用或者很少使用的索引\",{\"1\":{\"690\":1}}],[\"删除非常方便\",{\"1\":{\"673\":1}}],[\"删除的平均时间复杂度都是0\",{\"1\":{\"658\":2}}],[\"删除的结点\",{\"1\":{\"378\":1}}],[\"删除和修改的时候\",{\"1\":{\"642\":1}}],[\"删除外键约束\",{\"1\":{\"618\":1}}],[\"删除外键约束后\",{\"1\":{\"618\":1}}],[\"删除主表时\",{\"1\":{\"618\":1}}],[\"删除主键\",{\"1\":{\"616\":1}}],[\"删除约束\",{\"1\":{\"617\":1}}],[\"删除索引\",{\"0\":{\"687\":1},\"1\":{\"615\":1,\"687\":1}}],[\"删除时需要指定唯一索引名\",{\"1\":{\"615\":1}}],[\"删除唯一约束只能通过删除唯一索引的方式删除\",{\"1\":{\"615\":1}}],[\"删除唯一约束\",{\"1\":{\"615\":1}}],[\"删除表\",{\"1\":{\"588\":1}}],[\"删除某个字段的语法格式\",{\"1\":{\"588\":1}}],[\"删除某些字符或者不删除任何字符形成的一个序列\",{\"1\":{\"156\":1}}],[\"删除数据\",{\"1\":{\"542\":1}}],[\"删除url请求参数customername\",{\"1\":{\"500\":1}}],[\"删除请求头sec\",{\"1\":{\"499\":1}}],[\"删除+修改操作作为家庭作业\",{\"1\":{\"446\":1}}],[\"删除标志\",{\"1\":{\"440\":1}}],[\"删除链表的倒数第\",{\"1\":{\"388\":1}}],[\"删除节点并不是指从内存中删除它\",{\"1\":{\"379\":1}}],[\"删除节点可分为两个步骤\",{\"1\":{\"67\":1}}],[\"删除给定的节点\",{\"1\":{\"379\":1}}],[\"删除后不能2跑到3后面去\",{\"1\":{\"313\":1}}],[\"删除重复出现的元素\",{\"1\":{\"312\":1}}],[\"删除上一个处理的字母\",{\"1\":{\"193\":2}}],[\"删除上一个增加到item\",{\"1\":{\"187\":1}}],[\"删除元素\",{\"1\":{\"187\":1}}],[\"删除word2\",{\"1\":{\"152\":1}}],[\"删除word1\",{\"1\":{\"152\":1}}],[\"删除一个字符\",{\"1\":{\"151\":1}}],[\"删除t中的第i个元素\",{\"1\":{\"146\":1}}],[\"删除\",{\"0\":{\"698\":1},\"1\":{\"132\":1,\"151\":3,\"279\":2,\"517\":2}}],[\"删除结点\",{\"1\":{\"378\":1,\"389\":1}}],[\"删除结点即可\",{\"1\":{\"377\":1}}],[\"删除结点的左子树\",{\"1\":{\"70\":1}}],[\"删除结点的右子树中最小结点的左子树上\",{\"1\":{\"68\":1}}],[\"删除结点右子树的最小值\",{\"1\":{\"68\":1}}],[\"删除操作\",{\"1\":{\"68\":1}}],[\"删除它\",{\"1\":{\"67\":1}}],[\"删除二叉搜索树中的\",{\"1\":{\"67\":1}}],[\"增强和控制对于\",{\"1\":{\"487\":1}}],[\"增\",{\"1\":{\"152\":1,\"656\":1}}],[\"增加了一\",{\"1\":{\"773\":1}}],[\"增加了不少\",{\"1\":{\"696\":1}}],[\"增加了对\",{\"1\":{\"528\":1}}],[\"增加外键\",{\"1\":{\"618\":1}}],[\"增加约束\",{\"1\":{\"615\":1}}],[\"增加字段\",{\"1\":{\"588\":1}}],[\"增加请求参数\",{\"1\":{\"500\":1}}],[\"增加到请求头中\",{\"1\":{\"499\":1}}],[\"增加配置类开启重试机制\",{\"1\":{\"467\":1}}],[\"增加配置类\",{\"1\":{\"424\":1}}],[\"增加\",{\"0\":{\"687\":1},\"1\":{\"422\":1,\"431\":1,\"435\":1,\"463\":1,\"614\":1}}],[\"增加依赖\",{\"1\":{\"419\":1,\"463\":1,\"468\":1,\"477\":1,\"480\":1}}],[\"增加虚拟头结点\",{\"1\":{\"378\":1}}],[\"增加一个虚拟头结点\",{\"1\":{\"378\":1}}],[\"增加一层元素\",{\"1\":{\"12\":1}}],[\"增加元素到队尾\",{\"1\":{\"335\":1}}],[\"增加元素\",{\"1\":{\"187\":1}}],[\"增加利润\",{\"1\":{\"120\":1}}],[\"增加当前结点\",{\"1\":{\"12\":1}}],[\"操作对应的undo日志没有该属性\",{\"1\":{\"794\":1}}],[\"操作流程如下\",{\"1\":{\"794\":1}}],[\"操作有了保证\",{\"1\":{\"790\":1}}],[\"操作系统错误\",{\"1\":{\"755\":1}}],[\"操作系统\",{\"1\":{\"742\":1}}],[\"操作步骤\",{\"1\":{\"728\":2}}],[\"操作的最小单位是页\",{\"1\":{\"666\":1}}],[\"操作的最少次数为dp\",{\"1\":{\"153\":1}}],[\"操作次数多\",{\"1\":{\"660\":1}}],[\"操作次数\",{\"1\":{\"657\":1}}],[\"操作数据对象\",{\"1\":{\"545\":1}}],[\"操作符返回两个查询的结果集的并集\",{\"1\":{\"540\":1}}],[\"操作成功\",{\"1\":{\"444\":1}}],[\"操作xxx失败\",{\"1\":{\"444\":1}}],[\"操作失败\",{\"1\":{\"444\":1}}],[\"操作方便\",{\"1\":{\"422\":1}}],[\"操作是合法的\",{\"1\":{\"321\":1}}],[\"操作\",{\"1\":{\"152\":1,\"279\":1,\"321\":1,\"618\":1,\"657\":1,\"660\":2,\"794\":1}}],[\"uuser\",{\"1\":{\"809\":1}}],[\"uuids\",{\"1\":{\"822\":2}}],[\"uuid\",{\"1\":{\"690\":1,\"822\":1}}],[\"uk\",{\"1\":{\"615\":1}}],[\"usr\",{\"1\":{\"809\":2}}],[\"using\",{\"1\":{\"701\":1}}],[\"usa\",{\"1\":{\"575\":2}}],[\"usessl=false\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"use\",{\"1\":{\"428\":1,\"429\":1,\"431\":3,\"586\":1,\"809\":1,\"832\":1}}],[\"user=\",{\"1\":{\"826\":1}}],[\"user错误\",{\"1\":{\"625\":1}}],[\"usertype\",{\"1\":{\"497\":8}}],[\"userid=\",{\"1\":{\"442\":1}}],[\"userid=1\",{\"1\":{\"435\":1}}],[\"userid\",{\"1\":{\"431\":4,\"432\":1,\"434\":8,\"443\":1}}],[\"username\",{\"1\":{\"429\":3,\"432\":1,\"443\":1,\"444\":1,\"452\":1}}],[\"user\",{\"0\":{\"671\":1},\"1\":{\"402\":2,\"429\":3,\"431\":3,\"434\":1,\"442\":2,\"612\":1,\"615\":1,\"667\":1,\"670\":1,\"671\":1,\"825\":2,\"831\":2}}],[\"used数组\",{\"1\":{\"218\":1}}],[\"used\",{\"1\":{\"211\":19,\"213\":14,\"428\":1,\"433\":2,\"434\":2,\"809\":1}}],[\"ucase\",{\"1\":{\"552\":1}}],[\"utc\",{\"1\":{\"554\":2}}],[\"util\",{\"1\":{\"488\":1,\"782\":1}}],[\"utf\",{\"1\":{\"441\":1,\"442\":1}}],[\"utf8mb4\",{\"1\":{\"428\":4,\"431\":3}}],[\"utf8\",{\"1\":{\"422\":1,\"586\":1}}],[\"ui<\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"ui\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1,\"454\":1}}],[\"unlock\",{\"1\":{\"770\":1}}],[\"unless\",{\"1\":{\"429\":1}}],[\"uncommitted\",{\"1\":{\"746\":3,\"797\":1}}],[\"unknow\",{\"1\":{\"606\":2}}],[\"unsigend\",{\"0\":{\"596\":1},\"1\":{\"596\":1}}],[\"unsigned\",{\"1\":{\"440\":2,\"595\":1,\"596\":1,\"597\":1,\"836\":1}}],[\"unsupported\",{\"1\":{\"444\":1}}],[\"undo只在事务回滚时起作用\",{\"1\":{\"794\":1}}],[\"undo日志都连起来\",{\"1\":{\"794\":1}}],[\"undo日志\",{\"1\":{\"794\":1}}],[\"undo日志版本链\",{\"0\":{\"794\":1}}],[\"undo日志的作用\",{\"0\":{\"756\":1}}],[\"undo的另一个作用是mvcc\",{\"1\":{\"756\":1}}],[\"undo\",{\"0\":{\"754\":1,\"757\":1},\"1\":{\"431\":10,\"667\":1,\"747\":3,\"754\":2,\"755\":1,\"795\":1,\"796\":1,\"799\":3,\"800\":1}}],[\"underscore\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"under\",{\"1\":{\"429\":3}}],[\"unversioned\",{\"1\":{\"427\":1}}],[\"unixtime\",{\"1\":{\"554\":2}}],[\"unix\",{\"1\":{\"554\":6}}],[\"union`索引合并的方式执行查询\",{\"1\":{\"710\":1}}],[\"union这三种索引合并的方式来执行查询\",{\"1\":{\"704\":1}}],[\"union\",{\"0\":{\"540\":1},\"1\":{\"539\":1,\"540\":4,\"541\":2,\"702\":2,\"703\":2,\"704\":1,\"710\":2}}],[\"unique参数\",{\"1\":{\"686\":1}}],[\"unique\",{\"1\":{\"431\":3,\"613\":1,\"615\":6,\"617\":4,\"620\":2,\"687\":5,\"704\":4}}],[\"uniquepaths\",{\"1\":{\"85\":1}}],[\"unify\",{\"1\":{\"410\":1}}],[\"uroot\",{\"1\":{\"698\":1,\"809\":1,\"831\":7,\"832\":3}}],[\"uri\",{\"1\":{\"422\":1,\"489\":2,\"491\":2,\"492\":3,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":3,\"504\":1}}],[\"url=\",{\"1\":{\"442\":1}}],[\"urls\",{\"1\":{\"429\":1}}],[\"url\",{\"1\":{\"402\":2,\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"446\":3,\"451\":1,\"452\":1,\"459\":1,\"470\":1,\"502\":2}}],[\"upper\",{\"1\":{\"552\":1}}],[\"update这些语句时\",{\"1\":{\"797\":1}}],[\"update的语句会发生阻塞\",{\"1\":{\"770\":1}}],[\"update语句时\",{\"1\":{\"770\":1}}],[\"updatetime\",{\"1\":{\"444\":1}}],[\"updatepay\",{\"1\":{\"443\":1}}],[\"updatebyzzyy\",{\"1\":{\"499\":2}}],[\"updatebyprimarykeyselective\",{\"1\":{\"443\":1}}],[\"updatebyexampleselective\",{\"1\":{\"432\":1}}],[\"update>\",{\"1\":{\"433\":1,\"434\":1}}],[\"update\",{\"1\":{\"433\":1,\"434\":1,\"440\":1,\"443\":4,\"444\":1,\"452\":1,\"463\":1,\"517\":1,\"542\":1,\"618\":3,\"689\":1,\"755\":1,\"757\":2,\"767\":2,\"771\":3,\"777\":1,\"786\":1,\"791\":2,\"794\":1,\"808\":1,\"823\":3}}],[\"updateresult\",{\"1\":{\"432\":1}}],[\"up\",{\"1\":{\"411\":3,\"419\":1,\"797\":1,\"798\":2,\"800\":1}}],[\"umghlrlose\",{\"1\":{\"255\":1}}],[\"u\",{\"1\":{\"151\":1,\"193\":2,\"831\":3,\"832\":1}}],[\"转储数据库物理文件到某一目录\",{\"1\":{\"830\":1}}],[\"转账50元给b账户\",{\"1\":{\"741\":1}}],[\"转账300元出去\",{\"1\":{\"741\":1}}],[\"转换为exists子查询\",{\"1\":{\"704\":1}}],[\"转换成代码为\",{\"1\":{\"298\":1}}],[\"转换成\",{\"1\":{\"151\":1}}],[\"转变为多表查询的操作\",{\"1\":{\"702\":1}}],[\"转化的公式为\",{\"1\":{\"556\":1}}],[\"转化为秒并返回结果值\",{\"1\":{\"556\":1}}],[\"转义字符的使用\",{\"1\":{\"529\":1}}],[\"转移过来\",{\"1\":{\"117\":1}}],[\"拿上图的例子来说\",{\"1\":{\"413\":1}}],[\"拿332举例\",{\"1\":{\"370\":1}}],[\"拿第一个例子来说\",{\"1\":{\"364\":1}}],[\"拿图中来说\",{\"1\":{\"222\":1}}],[\"拿\",{\"1\":{\"150\":1}}],[\"变换到另外一个\",{\"1\":{\"741\":1}}],[\"变长字段中存储多少字节的数据不是固定的\",{\"1\":{\"678\":1}}],[\"变长字段长度列表\",{\"0\":{\"678\":1}}],[\"变成\",{\"1\":{\"370\":3}}],[\"变成了矩阵的倒数第二列\",{\"1\":{\"298\":1}}],[\"变成了矩阵的最后一列\",{\"1\":{\"298\":1}}],[\"变为\",{\"1\":{\"149\":2,\"299\":1,\"353\":3}}],[\"变量名限制为29个\",{\"1\":{\"583\":1}}],[\"变量名是严格区分大小写的\",{\"1\":{\"518\":1}}],[\"变量累加连续1的个数\",{\"1\":{\"307\":1}}],[\"变量则表示\",{\"1\":{\"199\":1}}],[\"变量\",{\"1\":{\"12\":1,\"199\":1,\"203\":1}}],[\"来解析\",{\"1\":{\"867\":1}}],[\"来执行复制成为可能\",{\"1\":{\"823\":1}}],[\"来操作\",{\"1\":{\"820\":1}}],[\"来进行数据同步\",{\"1\":{\"820\":1}}],[\"来同步主服务器上的操作\",{\"1\":{\"805\":1}}],[\"来设置\",{\"1\":{\"786\":1}}],[\"来决定如下的关系\",{\"1\":{\"737\":1}}],[\"来重新生成查询日志文件\",{\"1\":{\"698\":1}}],[\"来源\",{\"1\":{\"689\":1}}],[\"来源应用\",{\"1\":{\"419\":1}}],[\"来\",{\"1\":{\"599\":1}}],[\"来将请求发送到我们实际的服务执行业务逻辑\",{\"1\":{\"488\":1}}],[\"来实现外键约束的功能\",{\"1\":{\"618\":1}}],[\"来实现阻塞和通行\",{\"1\":{\"480\":1}}],[\"来实现\",{\"1\":{\"459\":1}}],[\"来自定义一些\",{\"1\":{\"421\":1}}],[\"来自不同链路的请求对同一个目标访问时\",{\"1\":{\"410\":1}}],[\"来配置\",{\"1\":{\"403\":2}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"393\":1}}],[\"来判断相交的结点\",{\"1\":{\"391\":1}}],[\"来判读\",{\"1\":{\"372\":1}}],[\"来看看这个状态应该如何转移\",{\"1\":{\"372\":1}}],[\"来使剩下的区间没有重叠\",{\"1\":{\"365\":1}}],[\"来记录最大子数组的和\",{\"1\":{\"348\":1}}],[\"来模拟一个栈\",{\"1\":{\"321\":1}}],[\"来求解\",{\"1\":{\"261\":1}}],[\"来形成\",{\"1\":{\"200\":1}}],[\"来指向即将遍历的字符\",{\"1\":{\"199\":1}}],[\"来确定遍历的数字\",{\"1\":{\"193\":1}}],[\"来匹配\",{\"1\":{\"148\":6,\"153\":6}}],[\"来说\",{\"1\":{\"87\":1,\"150\":1,\"835\":1}}],[\"取一批数据\",{\"1\":{\"725\":1}}],[\"取值范围大\",{\"1\":{\"599\":1}}],[\"取值范围小\",{\"1\":{\"599\":1}}],[\"取值范围足够大\",{\"1\":{\"598\":1}}],[\"取值in\",{\"1\":{\"416\":1}}],[\"取前\",{\"1\":{\"299\":2}}],[\"取模\",{\"1\":{\"147\":1}}],[\"取出json中的数据\",{\"1\":{\"608\":1}}],[\"取出来称为tcl\",{\"1\":{\"517\":1}}],[\"取出俩个数计算\",{\"1\":{\"332\":1}}],[\"取出俩个结点\",{\"1\":{\"33\":1}}],[\"取出\",{\"1\":{\"97\":1}}],[\"包下的原子变量类就是使用了乐观锁的一种实现方式\",{\"1\":{\"782\":1}}],[\"包冲突\",{\"1\":{\"450\":1}}],[\"包名\",{\"1\":{\"442\":1}}],[\"包\",{\"1\":{\"441\":2,\"485\":1}}],[\"包括对数据的增删改等\",{\"1\":{\"811\":1}}],[\"包括启动和关闭mysql服务\",{\"1\":{\"806\":1}}],[\"包括系统中已经提交的事务id\",{\"1\":{\"797\":1}}],[\"包括建表\",{\"1\":{\"785\":1}}],[\"包括了\",{\"1\":{\"660\":1}}],[\"包括c1\",{\"1\":{\"651\":1}}],[\"包括隐藏列\",{\"1\":{\"650\":1}}],[\"包括其他隐藏列的值以及记录的额外信息\",{\"1\":{\"643\":1}}],[\"包括全文索引\",{\"1\":{\"637\":1}}],[\"包括\",{\"1\":{\"593\":1}}],[\"包括我自己\",{\"1\":{\"279\":1}}],[\"包括int\",{\"1\":{\"614\":1}}],[\"包括i\",{\"1\":{\"143\":2}}],[\"包围\",{\"1\":{\"229\":1}}],[\"包围着\",{\"1\":{\"227\":1}}],[\"包含mysql\",{\"1\":{\"822\":1}}],[\"包含\",{\"1\":{\"772\":1,\"823\":1,\"870\":1}}],[\"包含在任一候选键中的属性称为主属性\",{\"1\":{\"736\":1}}],[\"包含组函数的过滤条件\",{\"1\":{\"565\":1}}],[\"包含可打印的\",{\"1\":{\"246\":1}}],[\"包含英文大小写字母\",{\"1\":{\"244\":1}}],[\"包含重复的子集\",{\"1\":{\"202\":1,\"204\":1}}],[\"包含其他质因数\",{\"1\":{\"173\":1}}],[\"包含了order\",{\"1\":{\"726\":1}}],[\"包含了多少个表\",{\"1\":{\"701\":1}}],[\"包含了\",{\"1\":{\"103\":1}}],[\"连接操作是有区别的\",{\"1\":{\"835\":1}}],[\"连接操作时\",{\"1\":{\"689\":1}}],[\"连接查询\",{\"1\":{\"724\":1}}],[\"连接查询也算是simple类型\",{\"1\":{\"703\":1}}],[\"连接时\",{\"1\":{\"710\":1}}],[\"连接表的数量尽量不要超过\",{\"1\":{\"689\":1}}],[\"连接管理\",{\"1\":{\"635\":1}}],[\"连接收到请求后\",{\"1\":{\"625\":1}}],[\"连接层\",{\"0\":{\"625\":1},\"1\":{\"633\":1}}],[\"连接s1\",{\"1\":{\"552\":1}}],[\"连接多张表可使用多次join\",{\"1\":{\"538\":1}}],[\"连接条件\",{\"1\":{\"533\":1,\"538\":1,\"539\":2}}],[\"连接超时时间\",{\"1\":{\"466\":1}}],[\"连接\",{\"1\":{\"386\":1,\"625\":1}}],[\"连接后面交换完成的子链表\",{\"1\":{\"386\":1}}],[\"连续模式\",{\"1\":{\"772\":1}}],[\"连续子数组\",{\"1\":{\"142\":1,\"284\":1,\"347\":1}}],[\"连续递增的子序列\",{\"1\":{\"134\":2}}],[\"连线即使在端点也不能相交\",{\"1\":{\"140\":1}}],[\"现数字\",{\"1\":{\"836\":1}}],[\"现如今\",{\"1\":{\"835\":1}}],[\"现在想整个恢复\",{\"1\":{\"832\":1}}],[\"现在到了王五的名下\",{\"1\":{\"732\":1}}],[\"现在转移给了王五\",{\"1\":{\"732\":1}}],[\"现在用动态规划在实现一遍\",{\"1\":{\"143\":1}}],[\"现在\",{\"1\":{\"140\":1}}],[\"现有如下物品\",{\"1\":{\"91\":1}}],[\"它记录了数据库中执行的\",{\"1\":{\"811\":1}}],[\"它记录了数据库所有执行的ddl\",{\"1\":{\"808\":1}}],[\"它记录了\",{\"1\":{\"811\":1}}],[\"它用于复制\",{\"1\":{\"811\":1}}],[\"它帮我们解决了行的可见性问题\",{\"1\":{\"796\":1}}],[\"它占用的undolog\",{\"1\":{\"794\":1}}],[\"它允许\",{\"1\":{\"771\":1}}],[\"它支持三种策略\",{\"1\":{\"753\":1}}],[\"它其实对应着一个或多个数据库操作\",{\"1\":{\"742\":1}}],[\"它对数据库中数据的改变就是\",{\"1\":{\"741\":1}}],[\"它对于比较开销是非常有用的\",{\"1\":{\"696\":1}}],[\"它决定了被驱动表要执行的次数\",{\"1\":{\"709\":1}}],[\"它能够利用\",{\"1\":{\"686\":1}}],[\"它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量\",{\"1\":{\"680\":1}}],[\"它在二叉搜索树的基础上增加了约束\",{\"1\":{\"660\":1}}],[\"它可以帮助我们大幅提升检索数据的效率\",{\"1\":{\"658\":1}}],[\"它被设计用来处理大量的短期\",{\"1\":{\"636\":1}}],[\"它也要把字符串\",{\"1\":{\"634\":1}}],[\"它易于人阅读和编写\",{\"1\":{\"608\":1}}],[\"它不是固定的\",{\"1\":{\"579\":1}}],[\"它将多对多关系划分为两个一对多关\",{\"1\":{\"513\":1}}],[\"它等于多少\",{\"1\":{\"504\":1}}],[\"它由id\",{\"1\":{\"488\":1}}],[\"它提供了一种简单的方法\",{\"1\":{\"502\":1}}],[\"它提供了一组工具和模式\",{\"1\":{\"474\":1}}],[\"它提供了一致的\",{\"1\":{\"474\":1}}],[\"它们的id值是相同的\",{\"1\":{\"703\":1}}],[\"它们的record\",{\"1\":{\"680\":1}}],[\"它们的区别如下表所示\",{\"1\":{\"593\":1}}],[\"它们的交集\",{\"1\":{\"166\":1}}],[\"它们共计2台机器\",{\"1\":{\"460\":1}}],[\"它是由几个小查询组成的\",{\"1\":{\"703\":2}}],[\"它是由原字符串在不改变字符的相对顺序的情况下删除某些字符\",{\"1\":{\"138\":1}}],[\"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1\",{\"1\":{\"660\":1}}],[\"它是一个或多个参数\",{\"1\":{\"496\":1}}],[\"它是防止数据库中\",{\"1\":{\"612\":1}}],[\"它是对\",{\"1\":{\"561\":1}}],[\"它是要被移除的\",{\"1\":{\"501\":1}}],[\"它是要被删除的header的名称\",{\"1\":{\"499\":1}}],[\"它是要删除的查询参数的名称\",{\"1\":{\"500\":1}}],[\"它是cidr注解\",{\"1\":{\"495\":1}}],[\"它是熔断机制的具体实现\",{\"1\":{\"475\":1}}],[\"它是\",{\"1\":{\"355\":1}}],[\"它会阻断其他写锁和读锁\",{\"1\":{\"767\":1}}],[\"它会在回表前就会过滤掉所有不满足条件的行\",{\"1\":{\"728\":1}}],[\"它会打印出数组中\",{\"1\":{\"278\":1}}],[\"它会将所有相连的1都标注成2\",{\"1\":{\"226\":1}}],[\"它原来是一个升序排列的数组\",{\"1\":{\"276\":1}}],[\"它通常用于在搜索过程中撤销或回退一些步骤\",{\"1\":{\"183\":1}}],[\"它的\",{\"1\":{\"800\":1}}],[\"它的聚簇索引记录中都包含两个必要的隐藏列\",{\"1\":{\"794\":1}}],[\"它的优点在于\",{\"1\":{\"783\":1}}],[\"它的效率更快一些\",{\"1\":{\"725\":1}}],[\"它的用处比较小\",{\"1\":{\"686\":1}}],[\"它的高度远小于平衡二又树的高度\",{\"1\":{\"661\":1}}],[\"它的功能就是接收上层传下来的指令\",{\"1\":{\"635\":1}}],[\"它的阈值也会不同\",{\"1\":{\"417\":1}}],[\"它的旋转路径为\",{\"1\":{\"299\":1}}],[\"它的回文子串的长度为\",{\"1\":{\"157\":1}}],[\"它的最长公共子序列为\",{\"1\":{\"141\":1}}],[\"它的长度为\",{\"1\":{\"138\":2}}],[\"它的第\",{\"1\":{\"119\":1,\"123\":1}}],[\"它的左右子树结点个数肯定是不会变的\",{\"1\":{\"47\":1}}],[\"代表了标准提出的时间\",{\"1\":{\"835\":1}}],[\"代表了交易股票的手续费用\",{\"1\":{\"129\":1}}],[\"代表当前事务是否在等待\",{\"1\":{\"763\":1}}],[\"代表当前页面的校验和\",{\"1\":{\"668\":1}}],[\"代表这个锁结构是哪个事务生成的\",{\"1\":{\"763\":1}}],[\"代表记录被删除掉了\",{\"1\":{\"680\":1}}],[\"代表记录并没有被删除\",{\"1\":{\"680\":1}}],[\"代表什么\",{\"1\":{\"634\":1}}],[\"代表的部分是行动\",{\"1\":{\"694\":1}}],[\"代表的\",{\"1\":{\"557\":1}}],[\"代表的是\",{\"1\":{\"557\":1}}],[\"代表的是什么\",{\"1\":{\"152\":1}}],[\"代表分钟级\",{\"1\":{\"419\":1}}],[\"代表水\",{\"1\":{\"227\":1}}],[\"代表土地\",{\"1\":{\"227\":1}}],[\"代码块\",{\"0\":{\"871\":1}}],[\"代码随想录\",{\"1\":{\"279\":1,\"282\":1}}],[\"代码\",{\"1\":{\"273\":1,\"417\":1,\"504\":1,\"870\":1}}],[\"代码如下\",{\"1\":{\"39\":1,\"43\":1,\"60\":1,\"177\":1,\"179\":1,\"273\":1}}],[\"代码都一样\",{\"1\":{\"7\":1}}],[\"代码实现\",{\"0\":{\"163\":1,\"168\":1,\"171\":1,\"242\":1,\"248\":1,\"251\":1,\"254\":1,\"259\":1,\"262\":1,\"268\":1,\"271\":1,\"280\":1,\"283\":1,\"286\":1,\"289\":1,\"292\":1,\"296\":1,\"302\":1,\"305\":1,\"308\":1,\"311\":1,\"314\":1,\"317\":1,\"323\":1,\"326\":1,\"329\":1,\"332\":1,\"338\":1,\"378\":1,\"382\":1,\"387\":1,\"392\":1,\"395\":1},\"1\":{\"2\":1,\"276\":1,\"293\":1,\"298\":1,\"299\":1,\"389\":1}}],[\"多线程\",{\"1\":{\"823\":1}}],[\"多数情况下\",{\"1\":{\"823\":1}}],[\"多数据中心\",{\"1\":{\"449\":1}}],[\"多版本并发控制\",{\"1\":{\"790\":1}}],[\"多条\",{\"1\":{\"772\":1}}],[\"多粒度锁\",{\"1\":{\"771\":1}}],[\"多出来的记录称为\",{\"1\":{\"746\":1}}],[\"多1条sql\",{\"1\":{\"731\":1}}],[\"多列索引是在表的\",{\"1\":{\"686\":1}}],[\"多列索引和空间索引等\",{\"1\":{\"686\":1}}],[\"多列\",{\"1\":{\"686\":1}}],[\"多列约束\",{\"1\":{\"613\":1}}],[\"多路平衡査找树\",{\"1\":{\"661\":1}}],[\"多个线程同时去查询数据库的这条数据\",{\"1\":{\"844\":1}}],[\"多个数据库间用空格隔开\",{\"1\":{\"831\":1}}],[\"多个事务对同一个行记录进行更新会产生多个历史快照\",{\"1\":{\"796\":1}}],[\"多个事务的读操作可以同时进行而不会互相影响\",{\"1\":{\"767\":1}}],[\"多个版本\",{\"1\":{\"790\":1}}],[\"多个相等条件也是范围查询\",{\"1\":{\"725\":1}}],[\"多个字段组合\",{\"1\":{\"686\":1}}],[\"多个目录项记录的页\",{\"0\":{\"646\":1}}],[\"多个微服务之间调用的时候\",{\"1\":{\"471\":1}}],[\"多行比较操作符\",{\"0\":{\"577\":1}}],[\"多行子查询返回多条记录\",{\"1\":{\"570\":1}}],[\"多行子查询\",{\"0\":{\"576\":1},\"1\":{\"570\":1}}],[\"多行操作符对应多行子查询\",{\"1\":{\"569\":1}}],[\"多行函数\",{\"0\":{\"560\":1}}],[\"多表\",{\"1\":{\"689\":1}}],[\"多表的连接条件\",{\"1\":{\"565\":1}}],[\"多表查询时\",{\"1\":{\"533\":1}}],[\"多表查询\",{\"0\":{\"532\":1}}],[\"多对多关系\",{\"1\":{\"513\":1}}],[\"多对多关联\",{\"1\":{\"513\":1}}],[\"多方\",{\"1\":{\"513\":1}}],[\"多语言异构化服务架构的流量治理组件\",{\"1\":{\"406\":1}}],[\"多一层for循环\",{\"1\":{\"179\":1}}],[\"多了一层for循环\",{\"1\":{\"179\":1}}],[\"多次买卖一支股票\",{\"1\":{\"127\":1}}],[\"多重背包\",{\"1\":{\"90\":2}}],[\"奇数为买入\",{\"1\":{\"126\":2}}],[\"卖出操作\",{\"1\":{\"128\":1}}],[\"卖出股票后\",{\"1\":{\"127\":1}}],[\"卖出\",{\"1\":{\"126\":2,\"127\":2,\"130\":1}}],[\"卖出该股票\",{\"1\":{\"119\":1}}],[\"卖\",{\"1\":{\"125\":1}}],[\"笔交易\",{\"1\":{\"125\":1}}],[\"沿用前一天不持有股票的状态\",{\"1\":{\"124\":1,\"126\":1}}],[\"沿用前一天持有股票的状态\",{\"1\":{\"124\":1,\"126\":1}}],[\"状态码\",{\"1\":{\"502\":1}}],[\"状态\",{\"1\":{\"475\":1,\"742\":1}}],[\"状态值为\",{\"1\":{\"372\":1}}],[\"状态为\",{\"1\":{\"126\":1,\"372\":1}}],[\"状态由俩种操作转移而来\",{\"1\":{\"124\":2,\"126\":2}}],[\"状态下所获得的最大利润\",{\"1\":{\"124\":1}}],[\"全量备份恢复\",{\"1\":{\"832\":1}}],[\"全库逻辑备份\",{\"1\":{\"785\":1}}],[\"全性不高\",{\"1\":{\"731\":1}}],[\"全值匹配\",{\"0\":{\"715\":1}}],[\"全文索引和空间索引\",{\"1\":{\"687\":1}}],[\"全文索引非常适合大型数据集\",{\"1\":{\"686\":1}}],[\"全文索引\",{\"1\":{\"686\":4}}],[\"全表扫描\",{\"1\":{\"641\":1,\"704\":1}}],[\"全表检索\",{\"1\":{\"634\":1}}],[\"全表检索还是使用索引检索\",{\"1\":{\"629\":1}}],[\"全部查询getall作为家庭作业\",{\"1\":{\"443\":1}}],[\"全部限流\",{\"1\":{\"409\":1}}],[\"全局锁的典型使用\",{\"1\":{\"785\":1}}],[\"全局锁就是对\",{\"1\":{\"785\":1}}],[\"全局锁\",{\"0\":{\"785\":1}}],[\"全局过滤器\",{\"1\":{\"498\":1}}],[\"全局配置\",{\"1\":{\"466\":1}}],[\"全局异常信息exception\",{\"1\":{\"445\":1}}],[\"全局异常处理\",{\"0\":{\"445\":1}}],[\"全局事务回滚\",{\"1\":{\"434\":1}}],[\"全局事务创建成功并生成一个全局唯一的\",{\"1\":{\"426\":1}}],[\"全局唯一的事务id\",{\"1\":{\"426\":1}}],[\"全局最优解\",{\"1\":{\"346\":1}}],[\"全局最优\",{\"1\":{\"122\":1}}],[\"全为0说明s和t字符出现次数相同\",{\"1\":{\"163\":1}}],[\"全排列二\",{\"1\":{\"213\":1}}],[\"全排列多了一个去重的步骤\",{\"1\":{\"211\":1}}],[\"全排列问题无需在使用\",{\"1\":{\"209\":1}}],[\"全排列问题\",{\"1\":{\"105\":2,\"107\":1}}],[\"全排列\",{\"1\":{\"105\":1}}],[\"循环结束\",{\"1\":{\"283\":1}}],[\"循环结束仍然没有位置\",{\"1\":{\"273\":1}}],[\"循环比较俩个数的值\",{\"1\":{\"282\":1}}],[\"循环遍历所有的行和列\",{\"1\":{\"217\":1}}],[\"循环遍历所有的行\",{\"1\":{\"217\":1}}],[\"循环不用在\",{\"1\":{\"209\":1}}],[\"循环中的\",{\"1\":{\"199\":1}}],[\"循环的过程中\",{\"1\":{\"188\":1}}],[\"循环的每一轮中\",{\"1\":{\"12\":1}}],[\"循环\",{\"1\":{\"177\":1,\"187\":2,\"273\":1,\"285\":1}}],[\"循环反复\",{\"1\":{\"122\":1}}],[\"贪心的本质是选择每一阶段的局部最优\",{\"1\":{\"342\":1}}],[\"贪心\",{\"1\":{\"143\":1},\"2\":{\"374\":1}}],[\"贪心算法一般分为如下四步\",{\"1\":{\"342\":1}}],[\"贪心算法\",{\"0\":{\"342\":1},\"1\":{\"122\":1,\"346\":1,\"348\":1}}],[\"贪心则是每一步尽量选择最优解\",{\"1\":{\"77\":1}}],[\"股票\",{\"1\":{\"121\":1,\"126\":2}}],[\"股票价格\",{\"1\":{\"119\":2,\"121\":6,\"123\":6,\"125\":6}}],[\"利润减少\",{\"1\":{\"122\":1}}],[\"利润\",{\"1\":{\"121\":1}}],[\"利润为第一天的负数\",{\"1\":{\"120\":1,\"122\":1}}],[\"利润为0\",{\"1\":{\"120\":1,\"122\":1}}],[\"利用union关键字\",{\"1\":{\"540\":1}}],[\"利用jdk8的新特性\",{\"1\":{\"268\":1}}],[\"利用java中的api\",{\"1\":{\"247\":1}}],[\"利用上面那三个约束条件\",{\"1\":{\"215\":1}}],[\"利用上一层的数据拷贝到当前层\",{\"1\":{\"92\":1}}],[\"利用set进行去重\",{\"1\":{\"207\":2}}],[\"利用\",{\"1\":{\"167\":1}}],[\"利用hash表\",{\"1\":{\"162\":1}}],[\"利用滚动数组的思想\",{\"1\":{\"81\":1}}],[\"利用二叉搜索树的性质\",{\"1\":{\"64\":1}}],[\"前者现在时表示主动式创建\",{\"1\":{\"836\":1}}],[\"前置操作其实是要\",{\"1\":{\"754\":1}}],[\"前后存在非索引的列\",{\"0\":{\"722\":1}}],[\"前4个字节代表页的校验和\",{\"1\":{\"669\":1}}],[\"前提是提交前设置\",{\"1\":{\"589\":1}}],[\"前天\",{\"1\":{\"557\":1}}],[\"前缀和路径相关\",{\"0\":{\"502\":1}}],[\"前面无所谓\",{\"1\":{\"497\":1,\"504\":1}}],[\"前面在使用\",{\"1\":{\"462\":1}}],[\"前面的所有值顺序相同\",{\"1\":{\"379\":1}}],[\"前面\",{\"1\":{\"361\":1}}],[\"前一条对角线起点元素行坐标\",{\"1\":{\"304\":1}}],[\"前一天持有股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"前一天没有股票\",{\"1\":{\"120\":1,\"122\":1,\"124\":1,\"126\":1}}],[\"前一天可能也有股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"前半部分有序\",{\"1\":{\"277\":1}}],[\"前\",{\"1\":{\"255\":1,\"357\":2}}],[\"前k个字符\",{\"1\":{\"253\":1}}],[\"前序遍历顺序\",{\"1\":{\"2\":1}}],[\"前序遍历\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"今天有股票dp\",{\"1\":{\"120\":1,\"122\":1}}],[\"今天没有股票dp\",{\"1\":{\"120\":1,\"122\":1}}],[\"今晚能够偷窃到的最高金额\",{\"1\":{\"114\":1}}],[\"天都有旧商品下架\",{\"1\":{\"598\":1}}],[\"天数等函数\",{\"0\":{\"555\":1}}],[\"天生支持负载均衡\",{\"1\":{\"451\":1}}],[\"天为卖出操作\",{\"1\":{\"128\":1}}],[\"天为冷冻期\",{\"1\":{\"128\":1}}],[\"天的股票价格\",{\"1\":{\"127\":1,\"129\":1}}],[\"天的价格\",{\"1\":{\"119\":1,\"121\":1,\"123\":1,\"125\":1}}],[\"天接连购买股票\",{\"1\":{\"123\":1}}],[\"天和第\",{\"1\":{\"123\":1}}],[\"天整体去考虑\",{\"1\":{\"122\":1}}],[\"天到第\",{\"1\":{\"122\":1}}],[\"天卖出\",{\"1\":{\"122\":1}}],[\"天买入\",{\"1\":{\"122\":1}}],[\"天\",{\"1\":{\"119\":2,\"121\":6,\"123\":6,\"125\":6,\"126\":1,\"127\":1,\"555\":1}}],[\"设定一个状态值\",{\"1\":{\"504\":1}}],[\"设定一个正整数目标值\",{\"1\":{\"255\":1}}],[\"设置binlog格式\",{\"1\":{\"823\":1}}],[\"设置需要复制的数据库\",{\"1\":{\"823\":1}}],[\"设置不要复制的数据库\",{\"1\":{\"823\":1}}],[\"设置日志文件保留的时长\",{\"1\":{\"823\":1}}],[\"设置日志文件保存位置\",{\"1\":{\"806\":1}}],[\"设置成\",{\"1\":{\"806\":1}}],[\"设置s\",{\"1\":{\"770\":1}}],[\"设置为on\",{\"1\":{\"786\":1}}],[\"设置为2\",{\"1\":{\"753\":1}}],[\"设置为1\",{\"1\":{\"753\":1}}],[\"设置为0\",{\"1\":{\"753\":1}}],[\"设置隔离级别\",{\"1\":{\"746\":1}}],[\"设置慢查询时间阈值\",{\"1\":{\"698\":1}}],[\"设置字段值时\",{\"1\":{\"606\":1}}],[\"设置50\",{\"1\":{\"477\":1,\"478\":1}}],[\"设置出发压缩大小\",{\"1\":{\"469\":1}}],[\"设置超时\",{\"1\":{\"435\":1}}],[\"设置针对哪一个参数名设置\",{\"1\":{\"418\":1}}],[\"设置有什么不一样呢\",{\"1\":{\"416\":1}}],[\"设置的调用最小请求数\",{\"1\":{\"412\":1}}],[\"设置的最大rt时间\",{\"1\":{\"412\":1}}],[\"设置\",{\"1\":{\"411\":1,\"452\":1}}],[\"设需要交换的两个点为\",{\"1\":{\"386\":1}}],[\"设计思路\",{\"0\":{\"797\":1}}],[\"设计思想\",{\"1\":{\"780\":1}}],[\"设计到查找某个元素首先肯定要遍历\",{\"1\":{\"301\":1}}],[\"设计一个算法计算出最大利润\",{\"1\":{\"127\":1}}],[\"设计一个算法来计算你所能获取的最大利润\",{\"1\":{\"119\":1,\"123\":1,\"125\":1}}],[\"设当前节点为node\",{\"1\":{\"117\":1}}],[\"买入\",{\"1\":{\"126\":2,\"127\":2,\"130\":1}}],[\"买入这只股票\",{\"1\":{\"119\":1}}],[\"买卖股票的最佳时机\",{\"1\":{\"122\":1}}],[\"买卖股票的最佳时机ii\",{\"1\":{\"122\":1}}],[\"买卖股票的最佳时机二\",{\"1\":{\"120\":1}}],[\"买卖股票全系列\",{\"0\":{\"118\":1}}],[\"某条记录\",{\"1\":{\"774\":1}}],[\"某些情况下全表扫描\",{\"1\":{\"725\":1}}],[\"某些使用场景是\",{\"1\":{\"12\":1}}],[\"某个事务正在某些行持有了锁或该事务准备去持有锁\",{\"1\":{\"771\":1}}],[\"某个事务将系统表空间中\",{\"1\":{\"749\":1}}],[\"某个表经过搜索条件过滤后剩余记录条数的百分比\",{\"1\":{\"709\":1}}],[\"某个字段的值自增\",{\"1\":{\"617\":1}}],[\"某列指定默认值\",{\"1\":{\"620\":1}}],[\"某列的值不能重复\",{\"1\":{\"615\":1}}],[\"某列的值不允许为空\",{\"1\":{\"614\":1}}],[\"某公司门禁密码使用动态口令技术\",{\"1\":{\"255\":1}}],[\"某一天\",{\"1\":{\"119\":1}}],[\"灵茶山艾府\",{\"1\":{\"117\":1}}],[\"儿子节点选不选都可以\",{\"1\":{\"117\":1}}],[\"儿子节点选或不选的最大值\",{\"1\":{\"117\":1}}],[\"儿子节点都不能选\",{\"1\":{\"117\":1}}],[\"房屋将自动报警\",{\"1\":{\"116\":1}}],[\"房子与之相连\",{\"1\":{\"116\":1}}],[\"聪明的小偷意识到\",{\"1\":{\"116\":1}}],[\"父表有变更时\",{\"1\":{\"618\":1}}],[\"父表\",{\"1\":{\"618\":2}}],[\"父工程引入\",{\"1\":{\"486\":1}}],[\"父\",{\"1\":{\"116\":1}}],[\"父节点\",{\"1\":{\"58\":2}}],[\"小事务缩短锁定资源的时间\",{\"1\":{\"786\":1}}],[\"小表驱动大表\",{\"1\":{\"729\":1}}],[\"小査询在整个大査询中扮演了一个什么角色\",{\"1\":{\"703\":1}}],[\"小时\",{\"1\":{\"556\":1}}],[\"小问题\",{\"0\":{\"451\":1}}],[\"小顶堆\",{\"1\":{\"337\":2,\"339\":1}}],[\"小偷一晚能够盗取的最高金额\",{\"1\":{\"116\":2}}],[\"小偷能够盗取的最高金额\",{\"1\":{\"116\":1}}],[\"小偷又发现了一个新的可行窃的地区\",{\"1\":{\"116\":1}}],[\"小于up\",{\"1\":{\"800\":1}}],[\"小于或等于\",{\"1\":{\"233\":1,\"369\":1}}],[\"小于等于\",{\"1\":{\"59\":1}}],[\"小于\",{\"1\":{\"55\":1,\"73\":1,\"273\":1}}],[\"小于val\",{\"1\":{\"54\":1}}],[\"​\",{\"1\":{\"115\":2,\"552\":1,\"737\":1}}],[\"交叉模式\",{\"1\":{\"772\":2}}],[\"交\",{\"1\":{\"746\":1}}],[\"交互多\",{\"1\":{\"731\":1}}],[\"交易金额\",{\"1\":{\"440\":1,\"443\":1}}],[\"交易中心会调用订单中心的服务把订单状态更新\",{\"1\":{\"425\":1}}],[\"交易完卖出股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"交易完买入股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"交易\",{\"1\":{\"123\":1}}],[\"交易无法获得正利润\",{\"1\":{\"121\":1}}],[\"交替记录\",{\"1\":{\"115\":1}}],[\"交换左右孩子结点\",{\"1\":{\"31\":1}}],[\"交换\",{\"1\":{\"31\":1,\"317\":1}}],[\"核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的\",{\"1\":{\"797\":1}}],[\"核心业务\",{\"1\":{\"733\":1}}],[\"核心原理是\",{\"1\":{\"510\":1}}],[\"核心就是\",{\"1\":{\"488\":1}}],[\"核心线程数\",{\"1\":{\"481\":1}}],[\"核心库\",{\"1\":{\"407\":1}}],[\"核心\",{\"1\":{\"115\":1}}],[\"打印按钮\",{\"1\":{\"861\":1}}],[\"打印dp数组\",{\"1\":{\"91\":1}}],[\"打开断路器\",{\"1\":{\"476\":1}}],[\"打开熔断断路器\",{\"1\":{\"476\":1}}],[\"打开cmd命令行\",{\"1\":{\"401\":1}}],[\"打包后可以直接运行\",{\"1\":{\"407\":1}}],[\"打家劫舍二\",{\"1\":{\"117\":1}}],[\"打家劫舍\",{\"1\":{\"115\":2,\"117\":1}}],[\"偷当前房屋最大金额\",{\"1\":{\"115\":2}}],[\"偷当前屋\",{\"1\":{\"115\":1}}],[\"偷最后一间房屋\",{\"1\":{\"115\":2}}],[\"偷第一间房屋\",{\"1\":{\"115\":2}}],[\"偷\",{\"1\":{\"113\":1}}],[\"偷窃到的最高金额\",{\"1\":{\"112\":2,\"114\":1}}],[\"偷窃\",{\"1\":{\"112\":3}}],[\"接入点\",{\"1\":{\"820\":1}}],[\"接下来的其他操作和数据库\",{\"1\":{\"741\":1}}],[\"接下来就可以配置使用了\",{\"1\":{\"497\":1}}],[\"接下来就是对每一边进行处理\",{\"1\":{\"288\":1}}],[\"接下来就需要确定我们的循环的次数为\",{\"1\":{\"288\":1}}],[\"接顺序如何\",{\"1\":{\"629\":1}}],[\"接收用户的sql命令\",{\"1\":{\"627\":1}}],[\"接打交道\",{\"1\":{\"516\":1}}],[\"接受参数返回一个结果\",{\"1\":{\"545\":1}}],[\"接受一个路径模板参数\",{\"1\":{\"502\":1}}],[\"接受\",{\"1\":{\"499\":1,\"501\":1}}],[\"接口清单\",{\"1\":{\"464\":1}}],[\"接口\",{\"1\":{\"420\":1,\"497\":1,\"504\":1}}],[\"接口中定义\",{\"1\":{\"420\":1}}],[\"接口来判断版本号\",{\"1\":{\"274\":1}}],[\"接着将\",{\"1\":{\"299\":1}}],[\"接着偷窃\",{\"1\":{\"112\":1}}],[\"接近总和\",{\"1\":{\"97\":1}}],[\"金额\",{\"1\":{\"112\":5,\"114\":4,\"431\":1}}],[\"金额为j时\",{\"1\":{\"103\":1}}],[\"计划\",{\"1\":{\"877\":2}}],[\"计划的`extra`列将会显示`using\",{\"1\":{\"710\":1}}],[\"计划偷窃沿街的房屋\",{\"1\":{\"112\":1,\"114\":1}}],[\"计入失败的异常\",{\"1\":{\"477\":1}}],[\"计数\",{\"1\":{\"277\":1}}],[\"计算区分度\",{\"1\":{\"689\":1}}],[\"计算日期和时间的函数\",{\"0\":{\"557\":1}}],[\"计算监控树的所有节点所需的最小摄像头数量\",{\"1\":{\"371\":1}}],[\"计算1的个数\",{\"1\":{\"308\":1}}],[\"计算其中最大连续\",{\"1\":{\"306\":1}}],[\"计算其差值\",{\"1\":{\"97\":1}}],[\"计算右边的和\",{\"1\":{\"292\":1}}],[\"计算左边的和\",{\"1\":{\"292\":1}}],[\"计算并返回需要准备的\",{\"1\":{\"359\":1}}],[\"计算并返回\",{\"1\":{\"227\":1}}],[\"计算并返回可以凑成总金额所需的\",{\"1\":{\"106\":1}}],[\"计算\",{\"0\":{\"717\":1},\"1\":{\"157\":2}}],[\"计算从0~i\",{\"1\":{\"133\":1}}],[\"计算你\",{\"1\":{\"112\":1,\"114\":1}}],[\"计算石头的总重量\",{\"1\":{\"97\":1}}],[\"计算表达式\",{\"1\":{\"97\":2}}],[\"计算根节点左子树的结点数量\",{\"1\":{\"49\":1}}],[\"计算出中序遍历中根结点的左子树结点的个数\",{\"1\":{\"47\":1}}],[\"拼接成\",{\"1\":{\"110\":2}}],[\"作用2\",{\"1\":{\"756\":1}}],[\"作用1\",{\"1\":{\"756\":1}}],[\"作用字段个数进行划分\",{\"1\":{\"686\":1}}],[\"作用于position\",{\"1\":{\"552\":1}}],[\"作用与substring\",{\"1\":{\"552\":1}}],[\"作用与character\",{\"1\":{\"552\":1}}],[\"作用\",{\"1\":{\"474\":1,\"564\":1,\"668\":1,\"771\":1}}],[\"作为缓存与\",{\"1\":{\"818\":1}}],[\"作为项目设计的技术人员\",{\"1\":{\"732\":1}}],[\"作为查询的字段列表\",{\"1\":{\"729\":1}}],[\"作为磁盘和内存之间交豆的\",{\"1\":{\"666\":1}}],[\"作为索引结构\",{\"1\":{\"653\":1}}],[\"作为唯一的标识符\",{\"1\":{\"510\":1}}],[\"作为所有匹配请求的路径的前缀\",{\"1\":{\"502\":1}}],[\"作为慢指针\",{\"1\":{\"313\":1}}],[\"作为结束索引\",{\"1\":{\"271\":1}}],[\"作为key用来查找\",{\"1\":{\"175\":1}}],[\"作为\",{\"1\":{\"165\":1,\"360\":1,\"362\":1,\"680\":1}}],[\"作为俩种状态\",{\"1\":{\"117\":1}}],[\"作为字典\",{\"1\":{\"110\":1}}],[\"作者设置为\",{\"1\":{\"884\":1}}],[\"作者\",{\"1\":{\"12\":1}}],[\"推荐\",{\"1\":{\"836\":2}}],[\"推荐的主键设计\",{\"0\":{\"733\":1}}],[\"推荐使用select<字段列表>查询\",{\"1\":{\"729\":1}}],[\"推荐采用统一的书写规范\",{\"1\":{\"518\":1}}],[\"推到队列的末尾\",{\"1\":{\"321\":1}}],[\"推出\",{\"1\":{\"109\":1}}],[\"推导的结果依赖于dp\",{\"1\":{\"113\":1}}],[\"推导dp数组\",{\"1\":{\"95\":1}}],[\"推导结果\",{\"1\":{\"85\":1}}],[\"应用场景\",{\"1\":{\"637\":1}}],[\"应用层面完成检查数据一致性的逻辑\",{\"1\":{\"618\":1}}],[\"应用名\",{\"1\":{\"452\":2}}],[\"应该设计成三张表\",{\"1\":{\"737\":1}}],[\"应该增加where条件\",{\"1\":{\"533\":1}}],[\"应该在\",{\"1\":{\"441\":1}}],[\"应该保持\",{\"1\":{\"312\":1}}],[\"应该满足以下三个条件\",{\"1\":{\"201\":1}}],[\"应尽量初始化为一个较大值\",{\"1\":{\"107\":1}}],[\"应在以上俩种方式中选择一个花费最少的\",{\"1\":{\"83\":1}}],[\"要从主服务器读取二进制日志的内容\",{\"1\":{\"813\":1}}],[\"要从下标1开始遍历\",{\"1\":{\"137\":1}}],[\"要对这条记录做改动\",{\"1\":{\"763\":1}}],[\"要对磁盘进行两次扫描\",{\"1\":{\"725\":1}}],[\"要快\",{\"1\":{\"724\":1}}],[\"要由字段本身的完整性约束条件决定\",{\"1\":{\"686\":1}}],[\"要额外的时间进行一些\",{\"1\":{\"656\":1}}],[\"要的原因\",{\"1\":{\"642\":1}}],[\"要特别注意误差问题\",{\"1\":{\"599\":1}}],[\"要是为了节省存储空间\",{\"1\":{\"598\":1}}],[\"要表示多对多关系\",{\"1\":{\"513\":1}}],[\"要匹配的http方法\",{\"1\":{\"496\":1}}],[\"要给用户一个友好的反馈\",{\"1\":{\"477\":1}}],[\"要和你配置的format\",{\"1\":{\"452\":1}}],[\"要更新的业务数据\",{\"1\":{\"436\":1}}],[\"要实现openfeign\",{\"1\":{\"420\":1}}],[\"要想环绕走一圈\",{\"1\":{\"356\":1}}],[\"要么被释放\",{\"1\":{\"794\":1}}],[\"要么什么也不做\",{\"1\":{\"755\":1}}],[\"要么全部失败回滚\",{\"1\":{\"741\":1}}],[\"要么全部提交\",{\"1\":{\"741\":1}}],[\"要么都不执行\",{\"1\":{\"741\":1}}],[\"要么都执行\",{\"1\":{\"741\":1}}],[\"要么跳过下降的波谷的那些结点\",{\"1\":{\"346\":1}}],[\"要么就跳过上升到波峰的那些结点\",{\"1\":{\"346\":1}}],[\"要遵循以下原则\",{\"1\":{\"334\":1}}],[\"要使用\",{\"1\":{\"271\":1}}],[\"要不断更新回文子串的长度\",{\"1\":{\"261\":1}}],[\"要原地修改\",{\"1\":{\"250\":1}}],[\"要与其他皇后校验是否冲突\",{\"1\":{\"215\":1}}],[\"要进行去重\",{\"1\":{\"207\":1}}],[\"要遍历当前\",{\"1\":{\"207\":2}}],[\"要一直递归到叶子结点\",{\"1\":{\"207\":1}}],[\"要保持相对的顺序\",{\"1\":{\"141\":1}}],[\"要取所有\",{\"1\":{\"107\":1}}],[\"要求a+b的总余额必须不变\",{\"1\":{\"741\":1}}],[\"要求中的主键\",{\"1\":{\"737\":1}}],[\"要求从表从表先删除\",{\"1\":{\"618\":1}}],[\"要求主表必须存在\",{\"1\":{\"618\":1}}],[\"要求3\",{\"1\":{\"564\":1}}],[\"要求2\",{\"1\":{\"564\":1}}],[\"要求1\",{\"1\":{\"564\":1}}],[\"要求的返回类型为\",{\"1\":{\"481\":1}}],[\"要求也按\",{\"1\":{\"281\":1}}],[\"要求返回第一个大于等于\",{\"1\":{\"273\":1}}],[\"要求时间复杂度为\",{\"1\":{\"256\":1}}],[\"要求两个\",{\"1\":{\"227\":1}}],[\"要求装入的物品不能重复\",{\"1\":{\"91\":1}}],[\"要求达到的目标为装入的背包的总价值最大\",{\"1\":{\"91\":1}}],[\"要求算法时间复杂度为\",{\"1\":{\"67\":1}}],[\"凑足总额为\",{\"1\":{\"107\":1}}],[\"凑成\",{\"1\":{\"99\":5}}],[\"凑成dp\",{\"1\":{\"99\":1}}],[\"问方法就是\",{\"1\":{\"704\":1}}],[\"问题3\",{\"1\":{\"599\":1}}],[\"问题2\",{\"1\":{\"599\":1}}],[\"问题1\",{\"1\":{\"599\":1}}],[\"问题自然解决\",{\"1\":{\"386\":1}}],[\"问题说明\",{\"1\":{\"304\":1}}],[\"问题一样\",{\"1\":{\"199\":1}}],[\"问题其实和\",{\"1\":{\"199\":1}}],[\"问题\",{\"1\":{\"105\":1,\"562\":1,\"725\":1,\"762\":1,\"764\":1}}],[\"问题会产生何种变化\",{\"1\":{\"104\":1}}],[\"问总共有多少条不同的路径\",{\"1\":{\"84\":1}}],[\"位数最小值为1\",{\"1\":{\"601\":1}}],[\"位数\",{\"1\":{\"601\":1}}],[\"位类型\",{\"0\":{\"601\":1}}],[\"位置的语法格式如下\",{\"1\":{\"588\":1}}],[\"位置i的最长升序子序列等于j从0到i\",{\"1\":{\"133\":1}}],[\"位运算符\",{\"0\":{\"531\":1}}],[\"位子网掩码的网络\",{\"1\":{\"495\":1}}],[\"位顾客\",{\"1\":{\"357\":1}}],[\"位顾客那里\",{\"1\":{\"357\":4}}],[\"位顾客付的账\",{\"1\":{\"357\":1}}],[\"位\",{\"1\":{\"330\":1}}],[\"位整数范围\",{\"1\":{\"104\":1}}],[\"位带符号整数\",{\"1\":{\"102\":1}}],[\"两方面进行平衡\",{\"1\":{\"768\":1}}],[\"两者的作用相同\",{\"1\":{\"687\":1}}],[\"两者用的是一样的数据页\",{\"1\":{\"645\":1}}],[\"两者都是作为char类型处理的\",{\"1\":{\"604\":1}}],[\"两种建表原则\",{\"1\":{\"513\":1}}],[\"两种模式\",{\"1\":{\"422\":2}}],[\"两种授权类型\",{\"1\":{\"418\":1}}],[\"两种情况\",{\"1\":{\"103\":1}}],[\"两两交换其中相邻的节点\",{\"1\":{\"385\":1}}],[\"两个从库线程\",{\"1\":{\"820\":1}}],[\"两个或者两个以上事务\",{\"1\":{\"786\":1}}],[\"两个部分\",{\"1\":{\"694\":1}}],[\"两个不同值\",{\"1\":{\"690\":1}}],[\"两个表对应的列数和数据类型必须相同\",{\"1\":{\"540\":1}}],[\"两个表在连接过程中除了返回满足连接条件的行以外还返回左\",{\"1\":{\"537\":1}}],[\"两个整数之间的除法总是\",{\"1\":{\"330\":1}}],[\"两个\",{\"1\":{\"174\":1}}],[\"两个字符串都只由小写字符组成\",{\"1\":{\"145\":1}}],[\"两个字符串没有公共子序列\",{\"1\":{\"138\":1}}],[\"两个字符串的\",{\"1\":{\"138\":1}}],[\"两个数组中\",{\"1\":{\"136\":1}}],[\"两个直接相连的房子在同一天晚上被打劫\",{\"1\":{\"116\":1}}],[\"两笔\",{\"1\":{\"123\":1}}],[\"两棵树中的节点数目在范围\",{\"1\":{\"52\":1}}],[\"两棵树上的一些节点将会重叠\",{\"1\":{\"52\":1}}],[\"公司用\",{\"1\":{\"449\":1}}],[\"公式\",{\"1\":{\"470\":1}}],[\"公式推导过程\",{\"1\":{\"299\":1}}],[\"公式通用\",{\"1\":{\"103\":1}}],[\"公共模块中增加\",{\"1\":{\"464\":1}}],[\"公共子序列\",{\"1\":{\"138\":3}}],[\"公共前缀长度+1\",{\"1\":{\"137\":1}}],[\"公共的\",{\"1\":{\"136\":1}}],[\"公共祖先\",{\"1\":{\"62\":1}}],[\"另外\",{\"1\":{\"753\":1}}],[\"另外在真实的业务系统中\",{\"1\":{\"733\":1}}],[\"另外建议在使用这些命令时结合\",{\"1\":{\"699\":1}}],[\"另外还有innodb自己添加的隐藏列\",{\"1\":{\"645\":1}}],[\"另给一个整数\",{\"1\":{\"102\":1}}],[\"另一方面\",{\"1\":{\"598\":1,\"749\":1}}],[\"另一种策略是\",{\"1\":{\"786\":1}}],[\"另一种思想\",{\"1\":{\"350\":1}}],[\"另一种有效的行程是\",{\"1\":{\"212\":1}}],[\"另一种是自下而上\",{\"1\":{\"37\":1}}],[\"另一变量\",{\"1\":{\"135\":1}}],[\"另一个进行改动操作\",{\"1\":{\"764\":1}}],[\"另一个解决方案就是\",{\"1\":{\"749\":1}}],[\"另一个为\",{\"1\":{\"689\":1}}],[\"另一个是字符串\",{\"1\":{\"528\":1}}],[\"另一个正确答案是\",{\"1\":{\"67\":1}}],[\"另一个满足题目要求可以通过的树是\",{\"1\":{\"65\":1}}],[\"另一个不为空\",{\"1\":{\"33\":1}}],[\"选项\",{\"1\":{\"831\":1}}],[\"选项了\",{\"1\":{\"831\":1}}],[\"选用有序的顺序id\",{\"1\":{\"650\":1}}],[\"选中则表示集群环境\",{\"1\":{\"409\":1}}],[\"选取元素的集合可能有重复元素\",{\"1\":{\"197\":1}}],[\"选一个低的买入\",{\"1\":{\"122\":1}}],[\"选则当前节点\",{\"1\":{\"117\":1}}],[\"选当前节点子树最大和\",{\"1\":{\"117\":1}}],[\"选\",{\"1\":{\"117\":4}}],[\"选择与否\",{\"1\":{\"729\":1}}],[\"选择多个成员\",{\"1\":{\"607\":1}}],[\"选择将子查询物化之后与外层查询进行连接查询时\",{\"1\":{\"703\":1}}],[\"选择将当前孩子的糖果\",{\"1\":{\"360\":2}}],[\"选择将右孩子的糖果+1\",{\"1\":{\"360\":2}}],[\"选择下标\",{\"1\":{\"353\":3}}],[\"选择某个下标\",{\"1\":{\"353\":1}}],[\"选择的节点\",{\"1\":{\"222\":1}}],[\"选择列表\",{\"1\":{\"185\":2}}],[\"选择右孩子\",{\"1\":{\"117\":1}}],[\"选择\",{\"1\":{\"117\":1,\"185\":2,\"222\":1,\"337\":1}}],[\"选择节点2\",{\"1\":{\"117\":1}}],[\"选择节点3最大和为3\",{\"1\":{\"117\":1}}],[\"选择node节点\",{\"1\":{\"117\":1}}],[\"选择最少的花费开始爬\",{\"1\":{\"83\":1}}],[\"选或者不选\",{\"1\":{\"117\":1}}],[\"选与不选\",{\"1\":{\"101\":1}}],[\"组下加入log选项\",{\"1\":{\"806\":1}}],[\"组件\",{\"0\":{\"879\":1,\"886\":1},\"1\":{\"399\":1,\"886\":1}}],[\"组成的新数组\",{\"1\":{\"281\":1}}],[\"组成的的二维网格\",{\"1\":{\"225\":1}}],[\"组成的组合为\",{\"1\":{\"188\":2}}],[\"组成的bag\",{\"1\":{\"148\":2,\"153\":2}}],[\"组成\",{\"1\":{\"100\":1,\"324\":1}}],[\"组合索引\",{\"1\":{\"689\":1}}],[\"组合的个数即为两个集合中元素\",{\"1\":{\"532\":1}}],[\"组合起来进行去重\",{\"1\":{\"522\":1}}],[\"组合成为集群\",{\"1\":{\"460\":1}}],[\"组合ii\",{\"1\":{\"218\":1}}],[\"组合总和\",{\"1\":{\"205\":1}}],[\"组合总和ii\",{\"1\":{\"197\":1}}],[\"组合即从一组元素中\",{\"1\":{\"203\":1}}],[\"组合可以以任何顺序返回\",{\"1\":{\"189\":1}}],[\"组合4\",{\"1\":{\"188\":1}}],[\"组合和排列的区别\",{\"1\":{\"183\":1}}],[\"组合在一起看是否一样\",{\"1\":{\"522\":1}}],[\"组合在一起\",{\"1\":{\"164\":1}}],[\"组合问题\",{\"1\":{\"105\":1,\"183\":1,\"211\":1,\"218\":1}}],[\"组合不强调元素的顺序\",{\"1\":{\"103\":1,\"183\":1}}],[\"组合\",{\"1\":{\"96\":4,\"187\":1,\"190\":1,\"199\":1,\"203\":1,\"532\":1,\"686\":1}}],[\"子句\",{\"1\":{\"725\":1}}],[\"子句中\",{\"1\":{\"725\":1}}],[\"子句中使用索引\",{\"1\":{\"725\":1}}],[\"子句中有针对该表的搜索条件时\",{\"1\":{\"710\":1}}],[\"子句和\",{\"1\":{\"725\":1}}],[\"子表跟着更新\",{\"1\":{\"618\":1}}],[\"子表将外键列设置\",{\"1\":{\"618\":1}}],[\"子表\",{\"1\":{\"618\":2}}],[\"子查询是\",{\"1\":{\"724\":1}}],[\"子查询优化\",{\"0\":{\"724\":1}}],[\"子查询中使用到了主查询中的列\",{\"1\":{\"579\":1}}],[\"子查询中使用主查询的列\",{\"1\":{\"579\":1}}],[\"子查询都要重新计算一次\",{\"1\":{\"579\":1}}],[\"子查询从数据表中查询了数据结果\",{\"1\":{\"570\":1}}],[\"子查询的结果集存储的临时表\",{\"1\":{\"724\":1}}],[\"子查询的结果被主查询\",{\"1\":{\"569\":1}}],[\"子查询的执行效率不高\",{\"1\":{\"724\":1}}],[\"子查询的分类\",{\"0\":{\"570\":1}}],[\"子查询要包含在括号内\",{\"1\":{\"569\":1}}],[\"子查询其实就相当于变成语言中的嵌套for循环\",{\"1\":{\"568\":1}}],[\"子查询指一个查询语句嵌套在另一个查询语句内部的查询\",{\"1\":{\"568\":1}}],[\"子查询\",{\"0\":{\"568\":1},\"1\":{\"569\":2,\"570\":2}}],[\"子工程引入以下五个即可\",{\"1\":{\"486\":1}}],[\"子工程的\",{\"1\":{\"441\":1}}],[\"子串\",{\"1\":{\"261\":1}}],[\"子字符串\",{\"1\":{\"154\":1}}],[\"子序列定义为\",{\"1\":{\"156\":1}}],[\"子序列长度+1\",{\"1\":{\"150\":1}}],[\"子序列长度为\",{\"1\":{\"150\":1}}],[\"子序列\",{\"1\":{\"132\":1,\"138\":1,\"147\":1,\"345\":1}}],[\"子序列问题通常要求出下标为\",{\"1\":{\"133\":1}}],[\"子序列问题\",{\"0\":{\"131\":1}}],[\"子集ii\",{\"1\":{\"218\":1}}],[\"子集的不同之处\",{\"1\":{\"209\":1}}],[\"子集二可以对序列排序\",{\"1\":{\"207\":1}}],[\"子集二\",{\"1\":{\"207\":3}}],[\"子集可以按\",{\"1\":{\"204\":1}}],[\"子集问题已经遇见过了\",{\"1\":{\"211\":1}}],[\"子集问题通常要扫描所有元素\",{\"1\":{\"203\":1}}],[\"子集问题要遍历所有元素\",{\"1\":{\"203\":1}}],[\"子集问题则是要遍历所有的元素\",{\"1\":{\"203\":1}}],[\"子集问题\",{\"1\":{\"183\":1,\"218\":1}}],[\"子集\",{\"1\":{\"100\":1,\"203\":1,\"205\":1}}],[\"子数组\",{\"1\":{\"142\":1,\"284\":1,\"347\":1}}],[\"子数组最少包含一个元素\",{\"1\":{\"142\":1,\"347\":1}}],[\"子数组后缀上\",{\"1\":{\"50\":1}}],[\"子数组前缀上\",{\"1\":{\"50\":1}}],[\"呢\",{\"1\":{\"99\":1,\"211\":1,\"276\":1,\"313\":1,\"362\":1,\"660\":1}}],[\"还不会编写\",{\"1\":{\"865\":1}}],[\"还存在\",{\"1\":{\"835\":1}}],[\"还原操作时的具体场景\",{\"1\":{\"806\":1}}],[\"还原业务数据\",{\"1\":{\"436\":2}}],[\"还可以使用如下指令\",{\"1\":{\"809\":1}}],[\"还可以是全文索引\",{\"1\":{\"686\":1}}],[\"还可以用来创建\",{\"1\":{\"517\":1}}],[\"还会有三个隐藏列\",{\"1\":{\"681\":1}}],[\"还会将其值复制过去\",{\"1\":{\"587\":1}}],[\"还没有真正去读写真实的表\",{\"1\":{\"634\":1}}],[\"还支持查看限流降级\",{\"1\":{\"399\":1}}],[\"还有一种更优雅的实现\",{\"1\":{\"853\":1}}],[\"还有一个问题就是如果节点为空\",{\"1\":{\"372\":1}}],[\"还有另一个写数据请求d\",{\"1\":{\"848\":1}}],[\"还有以下\",{\"1\":{\"819\":1}}],[\"还有text类型不用加默认值\",{\"1\":{\"605\":1}}],[\"还有单独将\",{\"1\":{\"517\":1}}],[\"还有couchdb等\",{\"1\":{\"510\":1}}],[\"还有请求和响应的正文及元数据\",{\"1\":{\"470\":1}}],[\"还有请求和响应的头信息\",{\"1\":{\"470\":1}}],[\"还有剩余\",{\"1\":{\"354\":2}}],[\"还要满足数据表里的每一条数据记录\",{\"1\":{\"737\":1}}],[\"还要判断头结点的覆盖状态\",{\"1\":{\"372\":1}}],[\"还要比较孩子的右边\",{\"1\":{\"360\":1}}],[\"还要执行一遍循环\",{\"1\":{\"276\":1}}],[\"还要考虑不相等的情况\",{\"1\":{\"139\":1}}],[\"还想等\",{\"1\":{\"261\":1}}],[\"还需要了解一个关键字\",{\"1\":{\"539\":1}}],[\"还需要一个\",{\"1\":{\"222\":1}}],[\"还需要定义一个\",{\"1\":{\"190\":1}}],[\"还需要选择的元素个数\",{\"1\":{\"188\":1}}],[\"还需要选择\",{\"1\":{\"188\":2}}],[\"还需要注意一点\",{\"1\":{\"99\":1}}],[\"还是mq\",{\"1\":{\"853\":1}}],[\"还是失败\",{\"1\":{\"851\":1,\"852\":1}}],[\"还是信息领域中信息处理的主流语言\",{\"1\":{\"835\":1}}],[\"还是读多行\",{\"1\":{\"666\":1}}],[\"还是存放\",{\"1\":{\"648\":1}}],[\"还是根据索引检索等\",{\"1\":{\"634\":1}}],[\"还是按照类型的实际宽度进行保存\",{\"1\":{\"595\":1}}],[\"还是从后往前遍历\",{\"1\":{\"370\":1}}],[\"还是要读取整表的记录\",{\"1\":{\"728\":1}}],[\"还是要right\",{\"1\":{\"270\":1}}],[\"还是要强调一点\",{\"1\":{\"51\":1}}],[\"还是\",{\"1\":{\"270\":1,\"362\":1,\"364\":1}}],[\"还是false\",{\"1\":{\"155\":1}}],[\"还是分俩种情况\",{\"1\":{\"146\":1}}],[\"表必备三字段\",{\"1\":{\"836\":1}}],[\"表现出来\",{\"1\":{\"809\":1}}],[\"表结构做变更\",{\"1\":{\"773\":1}}],[\"表明生成该版本的事务在当前事务生成readview后才开启\",{\"1\":{\"798\":1}}],[\"表明生成该版本的事务在当前事务生成readview前已经提交\",{\"1\":{\"798\":1}}],[\"表明有事务想在某个\",{\"1\":{\"778\":1}}],[\"表明\",{\"1\":{\"771\":1}}],[\"表明mysql\",{\"1\":{\"704\":1}}],[\"表锁等\",{\"1\":{\"781\":1}}],[\"表锁与行锁\",{\"1\":{\"771\":1}}],[\"表锁\",{\"1\":{\"771\":1}}],[\"表进行去重的时候\",{\"1\":{\"702\":1}}],[\"表之间的引用\",{\"1\":{\"700\":1}}],[\"表之间的连\",{\"1\":{\"629\":1}}],[\"表和\",{\"1\":{\"689\":1}}],[\"表数据和索引保存在俩个文件中\",{\"1\":{\"655\":1}}],[\"表数据和索引都保存到一个表中\",{\"1\":{\"655\":1}}],[\"表只能有一个聚簇索引\",{\"1\":{\"650\":1}}],[\"表以什么文件格式存储\",{\"1\":{\"635\":1}}],[\"表时就指定外键约束的话\",{\"1\":{\"618\":1}}],[\"表级别的s锁\",{\"0\":{\"770\":1}}],[\"表级锁\",{\"0\":{\"768\":1,\"769\":1},\"1\":{\"771\":1}}],[\"表级模式\",{\"1\":{\"616\":1}}],[\"表级约束\",{\"1\":{\"613\":1}}],[\"表创建\",{\"1\":{\"587\":1}}],[\"表约束条件\",{\"1\":{\"587\":1}}],[\"表不能重名\",{\"1\":{\"583\":1}}],[\"表中有三条数据\",{\"1\":{\"800\":1}}],[\"表中有2个int类型的列\",{\"1\":{\"643\":1}}],[\"表中都为\",{\"1\":{\"689\":1}}],[\"表中的三个列\",{\"1\":{\"643\":1}}],[\"表中的对应字符的次数递减\",{\"1\":{\"162\":1}}],[\"表中不满足条件的\",{\"1\":{\"537\":1}}],[\"表中\",{\"1\":{\"534\":1,\"536\":1}}],[\"表别名\",{\"1\":{\"518\":1}}],[\"表的作用\",{\"1\":{\"836\":1}}],[\"表的命名最好是遵循\",{\"1\":{\"836\":1}}],[\"表的查询\",{\"1\":{\"704\":1}}],[\"表的表名\",{\"1\":{\"701\":1}}],[\"表的读取顺序\",{\"1\":{\"700\":1}}],[\"表的每一行的内容\",{\"1\":{\"632\":1}}],[\"表的定义\",{\"1\":{\"632\":1}}],[\"表的外键列不能为not\",{\"1\":{\"618\":1}}],[\"表的字段名保持一致\",{\"1\":{\"542\":1}}],[\"表的别名\",{\"1\":{\"518\":1}}],[\"表的关联关系\",{\"0\":{\"513\":1}}],[\"表具有一些特性\",{\"1\":{\"511\":1}}],[\"表名2\",{\"1\":{\"831\":1}}],[\"表名1\",{\"1\":{\"831\":1}}],[\"表名称\",{\"1\":{\"613\":1,\"614\":2,\"615\":5,\"616\":4,\"617\":5,\"618\":2,\"620\":2}}],[\"表名不得超过30个字符\",{\"1\":{\"583\":1}}],[\"表名\",{\"1\":{\"518\":2,\"520\":1,\"538\":1,\"539\":2,\"542\":3,\"583\":1,\"587\":1,\"588\":6,\"615\":1,\"634\":1,\"636\":2,\"637\":3,\"676\":2,\"836\":1}}],[\"表名具有唯一性\",{\"1\":{\"511\":1}}],[\"表名以及对应的实体类\",{\"1\":{\"442\":1}}],[\"表\",{\"0\":{\"512\":1},\"1\":{\"431\":1,\"517\":2,\"704\":1,\"831\":1}}],[\"表达式中不含除零运算\",{\"1\":{\"330\":1}}],[\"表达式\",{\"1\":{\"98\":2,\"399\":2}}],[\"表示没有数据结构\",{\"1\":{\"831\":1}}],[\"表示没有数据备份\",{\"1\":{\"831\":1}}],[\"表示读写\",{\"1\":{\"823\":1}}],[\"表示生成readview时系统中应该分配给下一个事务的\",{\"1\":{\"797\":1}}],[\"表示生产环境\",{\"1\":{\"403\":1}}],[\"表示在生成readview时当前系统中活跃的读写事务的\",{\"1\":{\"797\":1}}],[\"表示在隔2个房屋偷到的最大金额\",{\"1\":{\"113\":1}}],[\"表示开启这个逻辑\",{\"1\":{\"786\":1}}],[\"表示开发环境\",{\"1\":{\"403\":1}}],[\"表示获取锁失败\",{\"1\":{\"763\":1}}],[\"表示获取锁成功\",{\"1\":{\"763\":1}}],[\"表示每次提交事务都write\",{\"1\":{\"810\":1}}],[\"表示每次提交事务都会执行fsync\",{\"1\":{\"810\":1}}],[\"表示每次提交事务都只write\",{\"1\":{\"810\":1}}],[\"表示每次事务提交时都只把\",{\"1\":{\"753\":1}}],[\"表示每次事务提交时都将进行同步\",{\"1\":{\"753\":1}}],[\"表示每次事务提交时不进行刷盘操作\",{\"1\":{\"753\":1}}],[\"表示每个孩子的评分\",{\"1\":{\"359\":1}}],[\"表示压根儿不打算从表中读出任何记录\",{\"1\":{\"710\":1}}],[\"表示索引的长度\",{\"1\":{\"687\":1}}],[\"表示最大记录\",{\"1\":{\"680\":1}}],[\"表示最小记录\",{\"1\":{\"680\":1}}],[\"表示b+树非叶节点记录\",{\"1\":{\"680\":1}}],[\"表示普通记录\",{\"1\":{\"680\":1}}],[\"表示下一条地址相对于本条记录的地址偏移量\",{\"1\":{\"643\":1}}],[\"表示下标在\",{\"1\":{\"157\":1}}],[\"表示下标以\",{\"1\":{\"146\":1,\"152\":1}}],[\"表示记录的类型\",{\"1\":{\"643\":1}}],[\"表示该列的值唯一\",{\"1\":{\"615\":1}}],[\"表示只能存1位的二进制值\",{\"1\":{\"601\":1}}],[\"表示双精度浮点数\",{\"1\":{\"599\":1}}],[\"表示单精度浮点数\",{\"1\":{\"599\":1}}],[\"表示默认从0开始\",{\"1\":{\"595\":1}}],[\"表示用\",{\"1\":{\"595\":1}}],[\"表示显示宽度\",{\"1\":{\"595\":1}}],[\"表示查询出所有字段\",{\"1\":{\"520\":1}}],[\"表示法\",{\"1\":{\"495\":1}}],[\"表示当调用接口的qps达到阈值时\",{\"1\":{\"409\":1}}],[\"表示当前结点\",{\"1\":{\"381\":1}}],[\"表示当前机票没有被使用过\",{\"1\":{\"213\":1}}],[\"表示测试环境\",{\"1\":{\"403\":1}}],[\"表示有覆盖\",{\"1\":{\"372\":1}}],[\"表示无覆盖\",{\"1\":{\"372\":1}}],[\"表示水平直径在\",{\"1\":{\"363\":1}}],[\"表示k\",{\"1\":{\"362\":1}}],[\"表示h\",{\"1\":{\"362\":1}}],[\"表示队列中一些人的属性\",{\"1\":{\"361\":1}}],[\"表示总的剩余油量\",{\"1\":{\"356\":1}}],[\"表示总金额\",{\"1\":{\"102\":1,\"106\":1}}],[\"表示从起始点到当前加油站所剩余油量\",{\"1\":{\"356\":1}}],[\"表示从索引\",{\"1\":{\"351\":1}}],[\"表示优先级队列\",{\"1\":{\"337\":1}}],[\"表示的算术表达式\",{\"1\":{\"330\":1}}],[\"表示若干个区间的集合\",{\"1\":{\"294\":1}}],[\"表示左边之和\",{\"1\":{\"293\":1}}],[\"表示雨水从单元格\",{\"1\":{\"233\":1}}],[\"表示坐标\",{\"1\":{\"233\":1}}],[\"表示一趟独立的查询\",{\"1\":{\"702\":1}}],[\"表示一个拥有\",{\"1\":{\"495\":1}}],[\"表示一个根据\",{\"1\":{\"330\":1}}],[\"表示一个图像\",{\"1\":{\"297\":1}}],[\"表示一个陆地单元格\",{\"1\":{\"229\":1}}],[\"表示一个海洋单元格\",{\"1\":{\"229\":1}}],[\"表示一支给定股票第\",{\"1\":{\"119\":1}}],[\"表示所有与node相连的节点列表\",{\"1\":{\"224\":2}}],[\"表示飞机出发和降落的机场地点\",{\"1\":{\"212\":1}}],[\"表示同一树枝上\",{\"1\":{\"211\":1}}],[\"表示同一层上\",{\"1\":{\"211\":1}}],[\"表示要删除t中的第i个元素\",{\"1\":{\"146\":1}}],[\"表示找到一个公共元素\",{\"1\":{\"146\":1}}],[\"表示nums1第i\",{\"1\":{\"141\":1}}],[\"表示nums以\",{\"1\":{\"137\":1}}],[\"表示不区分来源\",{\"1\":{\"409\":1}}],[\"表示不考虑text2的第\",{\"1\":{\"139\":1}}],[\"表示不考虑text1的第\",{\"1\":{\"139\":1}}],[\"表示不同面额的硬币\",{\"1\":{\"102\":1,\"106\":1}}],[\"表示text1从\",{\"1\":{\"139\":1}}],[\"表示以nums1以\",{\"1\":{\"137\":1}}],[\"表示某支股票第\",{\"1\":{\"121\":1}}],[\"表示连着偷相邻的房屋\",{\"1\":{\"113\":1}}],[\"表示s串从\",{\"1\":{\"155\":1}}],[\"表示s\",{\"1\":{\"111\":2}}],[\"表示s1是合法\",{\"1\":{\"111\":1}}],[\"表示空串是合法的\",{\"1\":{\"111\":1}}],[\"表示前i个元素\",{\"1\":{\"143\":2}}],[\"表示前i个元素的最长递增子序列为dp\",{\"1\":{\"133\":2}}],[\"表示前i个房屋\",{\"1\":{\"113\":1}}],[\"表示前\",{\"1\":{\"111\":1}}],[\"表示凑成金额j时\",{\"1\":{\"107\":1}}],[\"表示和为j时\",{\"1\":{\"105\":1,\"109\":2}}],[\"表示和为\",{\"1\":{\"105\":1}}],[\"表示金额为j时\",{\"1\":{\"103\":1}}],[\"表示i个0\",{\"1\":{\"101\":1}}],[\"表示第i天在\",{\"1\":{\"124\":1}}],[\"表示第\",{\"1\":{\"96\":1,\"127\":1,\"129\":1,\"361\":1}}],[\"表示容量为j时\",{\"1\":{\"92\":1,\"99\":1}}],[\"表示重量为\",{\"1\":{\"92\":1}}],[\"表示装入\",{\"1\":{\"91\":1}}],[\"表示拆分成2个正整数\",{\"1\":{\"87\":1}}],[\"表示将\",{\"1\":{\"87\":2}}],[\"表示爬到第\",{\"1\":{\"83\":1}}],[\"表示\",{\"1\":{\"62\":1,\"78\":1,\"89\":1,\"95\":1,\"96\":1,\"111\":1,\"155\":1,\"216\":1,\"261\":1,\"293\":1,\"304\":1,\"356\":1,\"372\":1,\"518\":1,\"767\":2}}],[\"尽心四舍五入\",{\"1\":{\"548\":1}}],[\"尽量使用\",{\"1\":{\"725\":1}}],[\"尽量使用双引号\",{\"1\":{\"518\":1}}],[\"尽量将大事务拆成多个小事务来处理\",{\"1\":{\"786\":1}}],[\"尽量将摄像头放在非叶子节点上\",{\"1\":{\"372\":1}}],[\"尽量将俩堆的重量分成相等的情况\",{\"1\":{\"97\":1}}],[\"尽量选择最大的\",{\"1\":{\"360\":2}}],[\"尽管\",{\"1\":{\"134\":1}}],[\"尽可能的接近\",{\"1\":{\"97\":1}}],[\"题意很简单\",{\"1\":{\"313\":1}}],[\"题比较简单\",{\"1\":{\"267\":1}}],[\"题一样\",{\"1\":{\"207\":2,\"274\":1}}],[\"题一样了\",{\"1\":{\"97\":1}}],[\"题\",{\"1\":{\"195\":1}}],[\"题中\",{\"1\":{\"97\":1}}],[\"题目\",{\"1\":{\"573\":2,\"574\":1,\"575\":1,\"578\":3,\"579\":3}}],[\"题目太废话\",{\"1\":{\"394\":1}}],[\"题目保证可以到达\",{\"1\":{\"351\":1}}],[\"题目比较简单\",{\"1\":{\"331\":1}}],[\"题目数据确保队列可以被重建\",{\"1\":{\"361\":1}}],[\"题目数据\",{\"1\":{\"216\":1,\"390\":1}}],[\"题目数据保证\",{\"1\":{\"277\":1}}],[\"题目数据保证答案唯一\",{\"1\":{\"336\":1}}],[\"题目数据保证答案符合\",{\"1\":{\"104\":1}}],[\"题目数据保证答案小于等于\",{\"1\":{\"84\":1}}],[\"题目数据保证结果符合\",{\"1\":{\"102\":1}}],[\"题目数据保证输入是一棵有效的二叉搜索树\",{\"1\":{\"69\":1}}],[\"题目数据保证输入的树是\",{\"1\":{\"34\":1}}],[\"题目说明硬币的数量无限\",{\"1\":{\"103\":1}}],[\"题目要求将为0元素所在的列和行都置为0\",{\"1\":{\"301\":1}}],[\"题目要求将结点的值改为比当前结点值\",{\"1\":{\"74\":1}}],[\"题目要求和\",{\"1\":{\"274\":1}}],[\"题目要求\",{\"1\":{\"250\":1,\"258\":1,\"277\":1}}],[\"题目要求不与边界相连的陆地单元格的数量\",{\"1\":{\"230\":1}}],[\"题目要求所需的最小步数\",{\"1\":{\"150\":1}}],[\"题目要求找到最后一层最左边的结点\",{\"1\":{\"43\":1}}],[\"题目中重要的俩个条件\",{\"1\":{\"273\":1}}],[\"题目中要求返回下标\",{\"1\":{\"175\":1}}],[\"题目中要求求最大连线数\",{\"1\":{\"141\":1}}],[\"题目中规定每一天不能\",{\"1\":{\"122\":1}}],[\"题目中给了\",{\"1\":{\"70\":1}}],[\"题目中说\",{\"1\":{\"66\":1}}],[\"说白了就是对feign接口的调用情况进行监控和输出\",{\"1\":{\"470\":1}}],[\"说过所有的回溯问题都可以抽象成一颗二叉树\",{\"1\":{\"187\":1}}],[\"说到这\",{\"1\":{\"97\":1}}],[\"说明此时的\",{\"1\":{\"800\":1}}],[\"说明在生成readview之前已经被提交\",{\"1\":{\"800\":1}}],[\"说明创建readview时生成该版本的事务已经被提交\",{\"1\":{\"798\":1}}],[\"说明创建readview时生成该版本的事务还是活跃的\",{\"1\":{\"798\":1}}],[\"说明准备使用`sort\",{\"1\":{\"710\":1}}],[\"说明准备使用`union`索引合并的方式执行查询\",{\"1\":{\"710\":1}}],[\"说明准备使用`intersect`索引\",{\"1\":{\"710\":1}}],[\"说明要校验的参数\",{\"1\":{\"497\":1,\"504\":1}}],[\"说明没有环\",{\"1\":{\"395\":1}}],[\"说明没有相交结点\",{\"1\":{\"392\":1}}],[\"说明不满足递增了\",{\"1\":{\"370\":1}}],[\"说明不满足二叉搜索树\",{\"1\":{\"56\":1}}],[\"说明需要重新射一箭\",{\"1\":{\"364\":3}}],[\"说明需要进行下一次跳跃\",{\"1\":{\"352\":1}}],[\"说明右半段是有序的\",{\"1\":{\"277\":1}}],[\"说明左半段是有序的\",{\"1\":{\"277\":1}}],[\"说明左子树上存在公共祖先\",{\"1\":{\"62\":1}}],[\"说明最小值在左半边\",{\"1\":{\"276\":1}}],[\"说明最小值在右半边\",{\"1\":{\"276\":1}}],[\"说明mid及mid之前都没有错误\",{\"1\":{\"274\":1}}],[\"说明当前数太小\",{\"1\":{\"241\":1}}],[\"说明当前结点就是公共祖先\",{\"1\":{\"62\":1}}],[\"说明它到不了当前单元格\",{\"1\":{\"234\":1}}],[\"说明找到了一条路径\",{\"1\":{\"224\":1}}],[\"说明是由上一个航班回溯来的\",{\"1\":{\"213\":2}}],[\"说明是叶子节点\",{\"1\":{\"41\":1}}],[\"说明有一组合法的ip地址\",{\"1\":{\"201\":1}}],[\"说明为一组集合\",{\"1\":{\"193\":2}}],[\"说明符合题意\",{\"1\":{\"187\":1}}],[\"说明元素较大\",{\"1\":{\"177\":1}}],[\"说明元素较小\",{\"1\":{\"177\":1}}],[\"说明这个数还没有求过\",{\"1\":{\"171\":1}}],[\"说明相差一个字符\",{\"1\":{\"155\":1}}],[\"说明指向同一个字符\",{\"1\":{\"155\":1,\"261\":1}}],[\"说明遍历时要从下标为1开始\",{\"1\":{\"137\":1}}],[\"说明遍历到当前结点为止\",{\"1\":{\"60\":1}}],[\"说明root的整颗右子树都符合修剪条件\",{\"1\":{\"70\":1}}],[\"说明root的整颗右子树都要修剪掉\",{\"1\":{\"70\":1}}],[\"说明root的整颗左子树都符合修剪条件\",{\"1\":{\"70\":1}}],[\"说明root的整颗左子树都要修剪掉\",{\"1\":{\"70\":1}}],[\"说明root就是公共祖先\",{\"1\":{\"64\":2}}],[\"说明公共祖先在\",{\"1\":{\"64\":2}}],[\"说明已经有了一个切割方案\",{\"1\":{\"199\":1}}],[\"说明已经出现比上一个元素出现频率更高的元素了\",{\"1\":{\"60\":1}}],[\"说明已经没有结点了\",{\"1\":{\"33\":1}}],[\"说明到达叶子节点\",{\"1\":{\"28\":1}}],[\"说明到达了左边最底部的结点\",{\"1\":{\"7\":1}}],[\"说明\",{\"1\":{\"27\":1,\"62\":2,\"63\":1,\"173\":1,\"273\":2,\"278\":1,\"321\":1,\"350\":2,\"356\":1,\"579\":1,\"605\":1,\"689\":1,\"797\":1,\"831\":1,\"836\":1,\"837\":1}}],[\"说明还未到达左边最底部的结点\",{\"1\":{\"7\":1}}],[\"石头\",{\"1\":{\"96\":1}}],[\"且都是小写字母\",{\"1\":{\"823\":1}}],[\"且随着数据量的增加\",{\"1\":{\"642\":1}}],[\"且使用的系统和事务日志资源少\",{\"1\":{\"589\":1}}],[\"且数字呈\",{\"1\":{\"369\":1}}],[\"且满足\",{\"1\":{\"363\":1}}],[\"且满足下列条件\",{\"1\":{\"189\":1}}],[\"且元素按顺时针顺序螺旋排列的\",{\"1\":{\"287\":1}}],[\"且所有的机票\",{\"1\":{\"212\":1}}],[\"且不包含任何额外的空格\",{\"1\":{\"244\":1}}],[\"且不能含有前导\",{\"1\":{\"200\":1}}],[\"且不重复的三元组\",{\"1\":{\"176\":1}}],[\"且绘制的直线不与任何其他连线\",{\"1\":{\"140\":1}}],[\"且\",{\"1\":{\"96\":1,\"176\":1,\"212\":1,\"379\":1,\"413\":1}}],[\"year默认格式就是\",{\"1\":{\"602\":1}}],[\"year类型\",{\"1\":{\"602\":1}}],[\"year\",{\"1\":{\"555\":1,\"557\":2,\"602\":1}}],[\"yyyy\",{\"1\":{\"444\":3,\"602\":1}}],[\"you\",{\"1\":{\"429\":2,\"431\":6}}],[\"yml是系统级的\",{\"1\":{\"452\":1}}],[\"yml是用户级的资源配置项\",{\"1\":{\"452\":1}}],[\"yml\",{\"1\":{\"403\":2}}],[\"yaml配置\",{\"1\":{\"477\":1}}],[\"yaml配置文件\",{\"1\":{\"443\":1}}],[\"yaml配置重定向\",{\"1\":{\"422\":1}}],[\"yaml配置自定义返回信息\",{\"1\":{\"422\":1}}],[\"yaml\",{\"1\":{\"402\":2,\"403\":3,\"404\":4,\"408\":1,\"410\":1,\"419\":1,\"422\":1,\"429\":1,\"432\":1,\"433\":1,\"434\":1,\"446\":1,\"452\":4,\"464\":1,\"489\":1}}],[\"yangzhaoguang\",{\"1\":{\"398\":1,\"439\":1,\"440\":1}}],[\"y++\",{\"1\":{\"305\":1}}],[\"y\",{\"1\":{\"96\":6,\"100\":2,\"193\":2,\"226\":2,\"228\":12,\"230\":12,\"232\":13,\"234\":6,\"305\":7,\"363\":1,\"369\":2,\"532\":4,\"548\":3,\"550\":2,\"558\":3}}],[\"块石头的重量\",{\"1\":{\"96\":1}}],[\"装满之后\",{\"1\":{\"95\":1}}],[\"非阻塞并发读\",{\"1\":{\"791\":1}}],[\"非主属性\",{\"1\":{\"736\":1}}],[\"非核心业务\",{\"1\":{\"733\":1}}],[\"非聚簇索引\",{\"0\":{\"651\":1}}],[\"非聚集\",{\"1\":{\"649\":1}}],[\"非叶子节点\",{\"1\":{\"648\":1}}],[\"非叶子节点比左右孩子结点大\",{\"1\":{\"337\":1}}],[\"非叶子节点比左右孩子结点小\",{\"1\":{\"337\":1}}],[\"非负\",{\"1\":{\"596\":1}}],[\"非自连接\",{\"0\":{\"535\":1}}],[\"非等值连接\",{\"0\":{\"534\":1}}],[\"非rdbms\",{\"0\":{\"510\":1}}],[\"非关系型数据库\",{\"0\":{\"510\":1},\"1\":{\"510\":1}}],[\"非\",{\"0\":{\"508\":1}}],[\"非常不推荐自增id作为主键的数据库设计\",{\"1\":{\"733\":1}}],[\"非常耗时\",{\"1\":{\"658\":1}}],[\"非常频繁改变的\",{\"1\":{\"604\":1}}],[\"非常像\",{\"1\":{\"366\":1}}],[\"非常类似\",{\"1\":{\"139\":1}}],[\"非严格递增\",{\"1\":{\"312\":1}}],[\"非严格递增排列\",{\"1\":{\"312\":1}}],[\"非递减顺序\",{\"1\":{\"240\":1,\"281\":2}}],[\"非递减顺序排列\",{\"1\":{\"240\":1}}],[\"非递归\",{\"1\":{\"39\":1,\"45\":1}}],[\"非水平线\",{\"1\":{\"140\":1}}],[\"非空的唯一索引代替\",{\"1\":{\"650\":1}}],[\"非空且唯一\",{\"1\":{\"613\":1}}],[\"非空约束只能出现在表对象的列上\",{\"1\":{\"614\":1}}],[\"非空约束\",{\"0\":{\"614\":1},\"1\":{\"613\":1}}],[\"非空\",{\"1\":{\"94\":1}}],[\"重做中继日志中的事件\",{\"1\":{\"820\":1}}],[\"重做日志文件\",{\"1\":{\"751\":1}}],[\"重做日志的缓冲\",{\"1\":{\"751\":1}}],[\"重做日志\",{\"1\":{\"747\":1}}],[\"重启服务\",{\"1\":{\"635\":1}}],[\"重启之后\",{\"1\":{\"454\":1}}],[\"重命名表\",{\"1\":{\"588\":1}}],[\"重命名字段\",{\"1\":{\"588\":1}}],[\"重试5次删除缓存\",{\"1\":{\"852\":1}}],[\"重试表需要记录一个重试次数字段\",{\"1\":{\"851\":1}}],[\"重试3次\",{\"1\":{\"467\":1}}],[\"重试间最大间隔时间为1s\",{\"1\":{\"467\":1}}],[\"重试俩次\",{\"1\":{\"467\":1}}],[\"重试机制\",{\"0\":{\"467\":1},\"1\":{\"850\":1}}],[\"重要的内容\",{\"1\":{\"876\":1}}],[\"重要\",{\"1\":{\"426\":1,\"441\":1}}],[\"重定向跳转\",{\"1\":{\"422\":2}}],[\"重叠\",{\"1\":{\"294\":1}}],[\"重新启动一次\",{\"1\":{\"809\":1}}],[\"重新从下一个加油站开始累加\",{\"1\":{\"356\":1}}],[\"重新找\",{\"1\":{\"348\":1}}],[\"重新排序\",{\"1\":{\"283\":1}}],[\"重新排序或删除\",{\"1\":{\"200\":1}}],[\"重新指向下一个单词的尾部\",{\"1\":{\"245\":1}}],[\"重新遍历\",{\"1\":{\"209\":1}}],[\"重复读\",{\"1\":{\"746\":1}}],[\"重复这个过程恰好\",{\"1\":{\"353\":1}}],[\"重复项删除操作会选择两个相邻且相同的字母\",{\"1\":{\"327\":1}}],[\"重复的元素\",{\"1\":{\"313\":1}}],[\"重复的肯定是相邻的俩个数\",{\"1\":{\"267\":1}}],[\"重复上面操作\",{\"1\":{\"245\":1}}],[\"重复使用相同的元素\",{\"1\":{\"240\":1}}],[\"重复交易\",{\"1\":{\"122\":1}}],[\"重复增加了物品0\",{\"1\":{\"92\":1}}],[\"重量对应本地中的数组元素值\",{\"1\":{\"95\":1}}],[\"重量为\",{\"1\":{\"91\":1}}],[\"重量w\",{\"1\":{\"91\":1}}],[\"放在通用模块\",{\"1\":{\"464\":1}}],[\"放或者不放\",{\"1\":{\"97\":1}}],[\"放回\",{\"1\":{\"97\":1}}],[\"放入新数组的尾端\",{\"1\":{\"283\":1}}],[\"放入一个新数组尾端\",{\"1\":{\"282\":1}}],[\"放入map集合\",{\"1\":{\"165\":1}}],[\"放入第\",{\"1\":{\"92\":1}}],[\"放入0~i个物品重量为\",{\"1\":{\"91\":1}}],[\"放不下任何物品\",{\"1\":{\"91\":1}}],[\"放第i\",{\"1\":{\"91\":1}}],[\"背包\",{\"1\":{\"97\":1,\"111\":1}}],[\"背包不能放入重复的元素\",{\"1\":{\"95\":1}}],[\"背包的容量为\",{\"1\":{\"95\":1}}],[\"背包容量就是完全平方数的和\",{\"1\":{\"109\":1}}],[\"背包容量的每一个值\",{\"1\":{\"103\":1}}],[\"背包容量\",{\"1\":{\"91\":1}}],[\"背包问题\",{\"0\":{\"90\":1}}],[\"价值v\",{\"1\":{\"91\":1}}],[\"二十\",{\"0\":{\"830\":1}}],[\"二进制日志转储线程\",{\"1\":{\"820\":1}}],[\"二进制日志文件\",{\"1\":{\"808\":1}}],[\"二进制日志\",{\"0\":{\"808\":1},\"1\":{\"805\":2}}],[\"二是用于\",{\"1\":{\"808\":1}}],[\"二是采用了行级锁\",{\"1\":{\"774\":1}}],[\"二是并没有实现接口编程\",{\"1\":{\"462\":1}}],[\"二级索引就是除主键列之外的列创建的索引\",{\"1\":{\"651\":1}}],[\"二级索引\",{\"0\":{\"651\":1}}],[\"二级索引访问需要两次索引查找\",{\"1\":{\"650\":1}}],[\"二元关系\",{\"1\":{\"509\":1}}],[\"二阶段如果是回滚的话\",{\"1\":{\"436\":1}}],[\"二阶段如是顺利提交的话\",{\"1\":{\"436\":1}}],[\"二阶段\",{\"1\":{\"436\":1}}],[\"二\",{\"0\":{\"400\":1,\"448\":1,\"516\":1}}],[\"二分法来加快查询速度\",{\"1\":{\"645\":1}}],[\"二分法\",{\"1\":{\"275\":1},\"2\":{\"319\":1}}],[\"二分查找是一个简单\",{\"1\":{\"270\":1}}],[\"二分查找\",{\"0\":{\"269\":1}}],[\"二维数组数组结构保存所有路径\",{\"1\":{\"222\":1}}],[\"二维数组\",{\"0\":{\"91\":1}}],[\"二叉搜索树满足下列约束条件\",{\"1\":{\"73\":1}}],[\"二叉搜索树中的任意一个结点都不相同\",{\"1\":{\"66\":1}}],[\"二叉搜索树的题目往往都可以使用递归来解决\",{\"1\":{\"68\":1}}],[\"二叉搜索树的最小绝对差\",{\"1\":{\"58\":1}}],[\"二叉搜索树的中序遍历一定是升序的\",{\"1\":{\"56\":1,\"60\":1}}],[\"二叉搜索树的性质\",{\"1\":{\"54\":1}}],[\"二叉搜索树定义如下\",{\"1\":{\"55\":1}}],[\"二叉搜索树\",{\"0\":{\"659\":1},\"1\":{\"54\":1,\"71\":1,\"88\":1}}],[\"二叉树遍历\",{\"2\":{\"76\":1}}],[\"二叉树遍历方式分为三种\",{\"1\":{\"0\":1}}],[\"二叉树是一棵满足\",{\"1\":{\"71\":1}}],[\"二叉树不包含值为\",{\"1\":{\"67\":1}}],[\"二叉树搜索树\",{\"1\":{\"54\":1}}],[\"二叉树定义如下\",{\"1\":{\"23\":1}}],[\"二叉树中序遍历\",{\"1\":{\"7\":1}}],[\"二叉树前序遍历\",{\"1\":{\"6\":1}}],[\"二叉树迭代遍历\",{\"0\":{\"5\":1}}],[\"二叉树递归遍历\",{\"0\":{\"1\":1}}],[\"二叉树的所有路径\",{\"1\":{\"45\":1,\"187\":1}}],[\"二叉树的\",{\"1\":{\"25\":1}}],[\"二叉树的节点个数的范围是\",{\"1\":{\"15\":1,\"21\":1,\"42\":1}}],[\"二叉树的层次遍历却是一个二维数组\",{\"1\":{\"12\":1}}],[\"二叉树的层序遍历有俩种思想\",{\"1\":{\"29\":1}}],[\"二叉树的层序遍历\",{\"0\":{\"10\":1},\"1\":{\"12\":2}}],[\"二叉树的迭代遍历也可以用栈来实现\",{\"1\":{\"5\":1}}],[\"二叉树的迭代遍历相较于递归比较困难一些\",{\"1\":{\"5\":1}}],[\"二叉树的后序遍历\",{\"1\":{\"0\":1}}],[\"二叉树的中序遍历\",{\"1\":{\"0\":1}}],[\"二叉树的前序遍历\",{\"1\":{\"0\":1}}],[\"二叉树的遍历\",{\"1\":{\"0\":1,\"372\":1}}],[\"二叉树的结点位置按照对应的完全二叉树的位置相吻合\",{\"1\":{\"0\":1}}],[\"二叉树大纲\",{\"1\":{\"0\":1}}],[\"二叉树\",{\"0\":{\"0\":1},\"1\":{\"46\":1},\"2\":{\"76\":1}}],[\"掌握01\",{\"1\":{\"90\":1}}],[\"分类为\",{\"1\":{\"884\":1}}],[\"分类方式二\",{\"1\":{\"570\":1}}],[\"分类方式一\",{\"1\":{\"570\":1}}],[\"分离完成后我们再导入atguigu\",{\"1\":{\"832\":1}}],[\"分页优化一\",{\"1\":{\"726\":1}}],[\"分页优化\",{\"0\":{\"726\":1}}],[\"分词技术\",{\"1\":{\"686\":1}}],[\"分成单列索引和联合索引\",{\"1\":{\"686\":1}}],[\"分固定长度和可变长度列\",{\"1\":{\"604\":1}}],[\"分子建模\",{\"1\":{\"600\":1}}],[\"分钟和秒组合成时间并返回\",{\"1\":{\"557\":1}}],[\"分钟和秒的时\",{\"1\":{\"556\":1}}],[\"分\",{\"1\":{\"554\":1,\"555\":1,\"602\":3}}],[\"分组次之\",{\"1\":{\"477\":1}}],[\"分组\",{\"1\":{\"421\":1,\"561\":1}}],[\"分组背包等等\",{\"1\":{\"90\":1}}],[\"分支对应的是\",{\"1\":{\"399\":7}}],[\"分布式\",{\"1\":{\"837\":1}}],[\"分布式链路追踪\",{\"0\":{\"483\":1}}],[\"分布式配置\",{\"0\":{\"452\":1},\"1\":{\"452\":1}}],[\"分布式配置管理\",{\"1\":{\"399\":1}}],[\"分布式任务调度\",{\"1\":{\"399\":1}}],[\"分布式事务处理过程的一id+三组件模型\",{\"1\":{\"426\":1}}],[\"分布式事务\",{\"1\":{\"399\":1}}],[\"分发糖果\",{\"1\":{\"362\":1}}],[\"分发糖果有点类似\",{\"1\":{\"362\":1}}],[\"分治法\",{\"1\":{\"347\":1}}],[\"分配给孩子\",{\"1\":{\"343\":1}}],[\"分隔的参数值\",{\"1\":{\"491\":1}}],[\"分隔符可通过\",{\"1\":{\"452\":1}}],[\"分隔开\",{\"1\":{\"244\":1}}],[\"分隔\",{\"1\":{\"200\":1}}],[\"分割回文串\",{\"1\":{\"201\":1}}],[\"分割成一些子串\",{\"1\":{\"198\":1}}],[\"分割等和子集\",{\"1\":{\"97\":1}}],[\"分析sql\",{\"1\":{\"699\":1}}],[\"分析器先做\",{\"1\":{\"634\":1}}],[\"分析\",{\"1\":{\"115\":1}}],[\"分为两个部分\",{\"1\":{\"407\":1}}],[\"分为俩种情况\",{\"1\":{\"304\":2}}],[\"分为\",{\"1\":{\"90\":1,\"805\":1}}],[\"分别如下\",{\"1\":{\"797\":1}}],[\"分别为a=1和b=2\",{\"1\":{\"757\":1}}],[\"分别为tinytext\",{\"1\":{\"605\":1}}],[\"分别创建三条索引\",{\"1\":{\"715\":1}}],[\"分别表示唯一索引\",{\"1\":{\"687\":1}}],[\"分别保存左边和右边的和\",{\"1\":{\"292\":1}}],[\"分别计算\",{\"1\":{\"291\":1}}],[\"分别代表了皇后和空位\",{\"1\":{\"214\":1}}],[\"分别是普通索引\",{\"1\":{\"686\":1}}],[\"分别是compact\",{\"1\":{\"675\":1}}],[\"分别是文件头\",{\"1\":{\"667\":1}}],[\"分别是创建数据库\",{\"1\":{\"582\":1}}],[\"分别是\",{\"1\":{\"40\":1,\"508\":1,\"599\":1,\"643\":1,\"725\":1,\"835\":1}}],[\"分别来自第\",{\"1\":{\"12\":1}}],[\"由指定的消费者监听死信队列\",{\"1\":{\"852\":1}}],[\"由系统自行判断什么时候执行fsync\",{\"1\":{\"810\":1}}],[\"由os自\",{\"1\":{\"753\":1}}],[\"由一个或者多个属性组成\",{\"1\":{\"736\":1}}],[\"由外向里思考\",{\"1\":{\"579\":1}}],[\"由外向内一圈圈的画下去\",{\"1\":{\"288\":1}}],[\"由\",{\"1\":{\"449\":1,\"516\":1}}],[\"由它获得tc服务的集群名称\",{\"1\":{\"432\":1}}],[\"由方法一得到关键公式为\",{\"1\":{\"299\":1}}],[\"由第一种方法得出的公式\",{\"1\":{\"299\":1}}],[\"由若干字符\",{\"1\":{\"231\":1}}],[\"由大写英文字母组成\",{\"1\":{\"212\":1}}],[\"由小写英文字母组成\",{\"1\":{\"151\":1,\"154\":1}}],[\"由英文字母组成\",{\"1\":{\"147\":1}}],[\"由此我们可以推算出规律\",{\"1\":{\"126\":1}}],[\"由哪种情况可以得来\",{\"1\":{\"91\":1}}],[\"由j为头结点时\",{\"1\":{\"89\":1}}],[\"由于请求d未删除\",{\"1\":{\"849\":1}}],[\"由于卡顿未来得及删除缓存\",{\"1\":{\"849\":1}}],[\"由于隔离级别为\",{\"1\":{\"800\":1}}],[\"由于可以读到未提交事务修改过的记录\",{\"1\":{\"797\":1}}],[\"由于都为5增加了间隙锁\",{\"1\":{\"776\":1}}],[\"由于姓名\",{\"1\":{\"737\":1}}],[\"由于在\",{\"1\":{\"729\":1}}],[\"由于在插入数据的时候并\",{\"1\":{\"654\":1}}],[\"由于索引没有以\",{\"1\":{\"716\":1}}],[\"由于数据物理存储排序方式只能有一种\",{\"1\":{\"650\":1}}],[\"由于数据都是紧密相连\",{\"1\":{\"650\":1}}],[\"由于实际存储的长度不确定\",{\"1\":{\"605\":1}}],[\"由于char平均占用的空间多于varchar\",{\"1\":{\"604\":1}}],[\"由于搜索引擎会爬取大量的数据\",{\"1\":{\"510\":1}}],[\"由于断路保护等需要aop实现\",{\"1\":{\"477\":1}}],[\"由于默认httpurlconnection没有连接池\",{\"1\":{\"468\":1}}],[\"由于每个服务都需要必要的配置信息才能运行\",{\"1\":{\"452\":1}}],[\"由于每个版本都是基于之前的版本开发的\",{\"1\":{\"274\":1}}],[\"由于订单模块需要调用支付模块\",{\"1\":{\"446\":1}}],[\"由于maven使用版本较高\",{\"1\":{\"441\":1}}],[\"由于这两个记录并不是我们自己插入的\",{\"1\":{\"680\":1}}],[\"由于这两个链表不相交\",{\"1\":{\"390\":1}}],[\"由于这道题并不是求组合\",{\"1\":{\"107\":1}}],[\"由于不是每位顾客都得到了正确的找零\",{\"1\":{\"357\":1}}],[\"由于所有客户都得到了正确的找零\",{\"1\":{\"357\":1}}],[\"由于他们的尺寸都是1\",{\"1\":{\"343\":1}}],[\"由于创建的大顶堆\",{\"1\":{\"338\":1}}],[\"由于是单调递减\",{\"1\":{\"335\":1}}],[\"由于是求序列的排列方式\",{\"1\":{\"209\":1}}],[\"由于两字母相邻且相同\",{\"1\":{\"327\":1}}],[\"由于left指针向右移动了一位\",{\"1\":{\"286\":1}}],[\"由于题目说数字了无重复\",{\"1\":{\"277\":1}}],[\"由于题比较简单\",{\"1\":{\"268\":1}}],[\"由于我们想要查询\",{\"1\":{\"651\":1}}],[\"由于我们下标从0开始\",{\"1\":{\"298\":1}}],[\"由于我们要得到$\",{\"1\":{\"261\":1}}],[\"由于我们需要遍历board所有位置\",{\"1\":{\"217\":1}}],[\"由于我们使用的是递归\",{\"1\":{\"62\":1}}],[\"由于元素可以重复\",{\"1\":{\"195\":2}}],[\"由于横向遍历时\",{\"1\":{\"187\":1}}],[\"由于递推关系式中依赖于\",{\"1\":{\"128\":1}}],[\"由于只能买一次\",{\"1\":{\"120\":1}}],[\"由于当前节点的状态由儿子节点转移而来\",{\"1\":{\"117\":1}}],[\"由于要求最少值\",{\"1\":{\"109\":1}}],[\"由于重量和价值是等价的\",{\"1\":{\"95\":1}}],[\"由于楼梯数要比层数大1\",{\"1\":{\"83\":1}}],[\"由于\",{\"1\":{\"81\":1,\"122\":1,\"408\":1,\"457\":1,\"717\":1,\"728\":1,\"770\":1}}],[\"由于后续遍历根节点总是在最后遍历\",{\"1\":{\"47\":1}}],[\"由于树是空的\",{\"1\":{\"44\":1}}],[\"由于栈先进后出\",{\"1\":{\"6\":1}}],[\"任务列表\",{\"0\":{\"877\":1}}],[\"任务调度服务\",{\"1\":{\"399\":2}}],[\"任一字段\",{\"1\":{\"736\":1}}],[\"任一\",{\"1\":{\"578\":1}}],[\"任何情况都可以被复制\",{\"1\":{\"823\":1}}],[\"任何一种隔离级别都不允许这种问题的发生\",{\"1\":{\"763\":1}}],[\"任何地点存储和访问任意类型的数据\",{\"1\":{\"399\":2}}],[\"任何时间\",{\"1\":{\"399\":2}}],[\"任何不在边界上\",{\"1\":{\"231\":1}}],[\"任何边界上的\",{\"1\":{\"231\":1}}],[\"任何\",{\"1\":{\"200\":1}}],[\"任何顺序\",{\"1\":{\"186\":1}}],[\"任何数据类型\",{\"1\":{\"686\":1}}],[\"任何数\",{\"1\":{\"87\":1}}],[\"任意选取若干个元素组合成一个集合\",{\"1\":{\"203\":1}}],[\"任意的\",{\"1\":{\"179\":1}}],[\"任意有效的结果\",{\"1\":{\"65\":1}}],[\"任意顺序\",{\"1\":{\"38\":1,\"59\":1,\"178\":1,\"192\":1,\"194\":1,\"202\":1,\"204\":1,\"206\":1,\"336\":1}}],[\"拆分更多的正整数\",{\"1\":{\"87\":1}}],[\"拆分俩个以上的正整数\",{\"1\":{\"87\":1}}],[\"拆分俩个正整数\",{\"1\":{\"87\":1}}],[\"拆分成整数的最大乘积为\",{\"1\":{\"87\":1}}],[\"他会对\",{\"1\":{\"522\":1}}],[\"他是事务的发起者\",{\"1\":{\"426\":1}}],[\"他最后得\",{\"1\":{\"370\":1}}],[\"他与\",{\"1\":{\"155\":1}}],[\"他的行是逐渐递加的\",{\"1\":{\"304\":1}}],[\"他的行是逐渐递减的\",{\"1\":{\"304\":1}}],[\"他的总价值也为0\",{\"1\":{\"91\":1}}],[\"他的每个正整数的最大乘积取决于上一个整合的最大乘积\",{\"1\":{\"87\":1}}],[\"他所有的子树均为二叉树\",{\"1\":{\"37\":1}}],[\"×\",{\"1\":{\"86\":3,\"172\":1,\"233\":1,\"297\":1,\"300\":1}}],[\"kv\",{\"1\":{\"449\":1}}],[\"kafka\",{\"1\":{\"429\":1}}],[\"kj\",{\"1\":{\"361\":1}}],[\"kind\",{\"1\":{\"429\":1}}],[\"ki\",{\"1\":{\"361\":3}}],[\"k+1$\",{\"1\":{\"334\":1}}],[\"k+1\",{\"1\":{\"277\":1,\"334\":1,\"335\":1}}],[\"k++\",{\"1\":{\"217\":2,\"226\":1,\"228\":1}}],[\"kul\",{\"1\":{\"213\":1}}],[\"k=4\",{\"1\":{\"188\":1}}],[\"k就是\",{\"1\":{\"187\":1}}],[\"knapsack01\",{\"1\":{\"91\":1}}],[\"k\",{\"1\":{\"86\":2,\"125\":7,\"126\":11,\"145\":1,\"176\":4,\"186\":5,\"187\":10,\"188\":9,\"189\":5,\"190\":10,\"191\":8,\"193\":2,\"217\":16,\"226\":4,\"228\":4,\"252\":7,\"253\":2,\"254\":2,\"277\":4,\"282\":2,\"283\":3,\"312\":6,\"333\":5,\"334\":2,\"335\":4,\"336\":6,\"338\":3,\"353\":6,\"354\":7,\"362\":5,\"500\":1}}],[\"key锁也包含\",{\"1\":{\"778\":1}}],[\"key锁\",{\"1\":{\"777\":1}}],[\"key3\",{\"1\":{\"704\":1,\"705\":1,\"710\":1}}],[\"key1即可\",{\"1\":{\"710\":1}}],[\"key1`而不需要回表操作\",{\"1\":{\"710\":1}}],[\"key1\",{\"1\":{\"704\":6,\"705\":1,\"708\":1,\"709\":2,\"710\":16}}],[\"key2\",{\"1\":{\"704\":2}}],[\"keys\",{\"1\":{\"701\":1}}],[\"key缓存\",{\"1\":{\"630\":1}}],[\"key是一个键值对的映射\",{\"1\":{\"491\":1}}],[\"key和一个\",{\"1\":{\"491\":1}}],[\"key`\",{\"1\":{\"428\":4}}],[\"key存储值\",{\"1\":{\"175\":1}}],[\"key\",{\"0\":{\"706\":1,\"777\":1},\"1\":{\"67\":6,\"68\":6,\"165\":1,\"428\":14,\"431\":6,\"440\":1,\"449\":1,\"452\":1,\"491\":1,\"510\":3,\"613\":2,\"615\":3,\"616\":5,\"617\":8,\"618\":12,\"619\":1,\"620\":3,\"643\":1,\"687\":6,\"701\":2,\"704\":2,\"736\":1,\"777\":3}}],[\"到底该学习哪个呢\",{\"1\":{\"835\":1}}],[\"到底是right\",{\"1\":{\"270\":1}}],[\"到从服务器上\",{\"1\":{\"819\":1}}],[\"到在生成readview之前已提交事务所做的更改\",{\"1\":{\"765\":1}}],[\"到redo\",{\"1\":{\"757\":2}}],[\"到undo\",{\"1\":{\"757\":2}}],[\"到一条结果的时候就不会继续扫描了\",{\"1\":{\"729\":1}}],[\"到server端做where过滤\",{\"1\":{\"728\":1}}],[\"到磁盘进行排序的情况\",{\"1\":{\"725\":1}}],[\"到最后也是需要对每个表进行\",{\"1\":{\"701\":1}}],[\"到最后一天一定是没有股票的状态\",{\"1\":{\"120\":1,\"122\":1}}],[\"到位置\",{\"1\":{\"383\":1}}],[\"到当前加油站所剩油量\",{\"1\":{\"356\":1}}],[\"到第\",{\"1\":{\"356\":1}}],[\"到这\",{\"1\":{\"299\":1}}],[\"到关键公式\",{\"1\":{\"299\":2}}],[\"到节点\",{\"1\":{\"223\":2}}],[\"到目前为止\",{\"1\":{\"203\":1}}],[\"到\",{\"1\":{\"88\":1,\"140\":2,\"200\":1,\"257\":1,\"276\":1,\"287\":1,\"696\":1}}],[\"到每一个坐标可能的路径种类\",{\"1\":{\"85\":1}}],[\"到达下标\",{\"1\":{\"349\":1}}],[\"到达下标为\",{\"1\":{\"82\":5}}],[\"到达\",{\"1\":{\"83\":2}}],[\"到达第\",{\"1\":{\"83\":1}}],[\"到达楼梯顶部\",{\"1\":{\"82\":2}}],[\"上下角标\",{\"0\":{\"872\":1}}],[\"上下左右四个方向\",{\"1\":{\"226\":1}}],[\"上创建一个索引\",{\"1\":{\"686\":1}}],[\"上述函数\",{\"1\":{\"558\":1}}],[\"上述中type\",{\"1\":{\"557\":1}}],[\"上世纪70年代开发出来\",{\"1\":{\"516\":1}}],[\"上游服务为了保护系统整体的可用性\",{\"1\":{\"472\":1}}],[\"上的配置时\",{\"1\":{\"453\":1}}],[\"上增加的配置就会保存到\",{\"1\":{\"454\":1}}],[\"上增加\",{\"1\":{\"435\":1}}],[\"上图中哈希函数h有可能将两个不同的关键字映射到相同的位置\",{\"1\":{\"658\":1}}],[\"上图中\",{\"1\":{\"645\":1}}],[\"上图比如1秒钟打进来10个线程\",{\"1\":{\"412\":1}}],[\"上图显示了摄像头放置的有效位置之一\",{\"1\":{\"371\":1}}],[\"上执行\",{\"1\":{\"399\":1}}],[\"上一篇\",{\"1\":{\"858\":1}}],[\"上一结点\",{\"1\":{\"382\":1}}],[\"上一个未偷最大金额\",{\"1\":{\"115\":1}}],[\"上一个\",{\"1\":{\"115\":1}}],[\"上一个结点的值\",{\"1\":{\"60\":1}}],[\"上式即便写成\",{\"1\":{\"330\":1}}],[\"上反复执行重复项删除操作\",{\"1\":{\"327\":1}}],[\"上进行了\",{\"1\":{\"277\":1}}],[\"上边界\",{\"1\":{\"234\":1}}],[\"上单元格\",{\"1\":{\"233\":1}}],[\"上\",{\"1\":{\"229\":1,\"304\":4,\"729\":1,\"820\":1}}],[\"上面两个参数都是yes\",{\"1\":{\"826\":1}}],[\"上面这种办法读取出binlog日志的全文内容比较多\",{\"1\":{\"809\":1}}],[\"上面这几个聚合函数都会自动过滤null值\",{\"1\":{\"562\":1}}],[\"上面这几种情况\",{\"1\":{\"152\":1,\"153\":1}}],[\"上面介绍了几种并发事务执行过程中可能遇到的一些问题\",{\"1\":{\"746\":1}}],[\"上面是全局过滤器\",{\"1\":{\"504\":1}}],[\"上面是将所有的起跳点都尝试一遍\",{\"1\":{\"350\":1}}],[\"上面说了通过\",{\"1\":{\"424\":1}}],[\"上面那个是\",{\"1\":{\"415\":1}}],[\"上面的图其实就是\",{\"1\":{\"648\":1}}],[\"上面的controller中\",{\"1\":{\"447\":1}}],[\"上面的公式表示\",{\"1\":{\"299\":1}}],[\"上面的结果\",{\"1\":{\"85\":1}}],[\"上面又有s\",{\"1\":{\"155\":1}}],[\"种\",{\"1\":{\"593\":1,\"649\":1,\"686\":2,\"819\":1}}],[\"种可以从\",{\"1\":{\"147\":2}}],[\"种方式\",{\"1\":{\"105\":1}}],[\"种方法让最终目标和为\",{\"1\":{\"98\":1}}],[\"种方法\",{\"1\":{\"81\":1,\"99\":4}}],[\"种组合方式\",{\"1\":{\"105\":1}}],[\"种二叉搜索树\",{\"1\":{\"89\":1}}],[\"种路径\",{\"1\":{\"85\":1}}],[\"jg\",{\"1\":{\"534\":4}}],[\"job\",{\"1\":{\"534\":2,\"573\":2,\"578\":8,\"579\":2}}],[\"join的形式\",{\"1\":{\"703\":2}}],[\"join\",{\"1\":{\"201\":2,\"245\":2,\"248\":1,\"538\":4,\"539\":5,\"541\":9,\"565\":4,\"689\":1,\"699\":1,\"701\":3,\"702\":1,\"704\":1,\"707\":1,\"709\":1,\"710\":2,\"724\":1,\"728\":1}}],[\"junit\",{\"1\":{\"442\":1}}],[\"jump\",{\"1\":{\"352\":1}}],[\"jpeg\",{\"1\":{\"429\":1}}],[\"js\",{\"1\":{\"429\":1,\"608\":6}}],[\"json等格式\",{\"1\":{\"510\":1}}],[\"jsonformat\",{\"1\":{\"444\":2}}],[\"json\",{\"0\":{\"608\":1},\"1\":{\"419\":3,\"422\":1,\"423\":1,\"424\":1,\"463\":1,\"469\":1,\"608\":7}}],[\"jdbcconnection>\",{\"1\":{\"442\":1}}],[\"jdbc\",{\"1\":{\"429\":2,\"431\":21,\"432\":2,\"442\":11,\"443\":2,\"452\":2}}],[\"jdk\",{\"1\":{\"399\":7}}],[\"jdk8\",{\"1\":{\"267\":1}}],[\"jmeter\",{\"1\":{\"411\":1}}],[\"january\",{\"1\":{\"555\":1}}],[\"jackson\",{\"1\":{\"444\":1}}],[\"jar是jdk8编译的\",{\"1\":{\"422\":1}}],[\"jar\",{\"1\":{\"407\":1,\"441\":3,\"485\":3}}],[\"java例如平衡二叉搜索树\",{\"1\":{\"658\":1}}],[\"javascript\",{\"1\":{\"608\":2}}],[\"java中的synchronized\",{\"1\":{\"781\":1}}],[\"java中的一个字段\",{\"1\":{\"512\":1}}],[\"java中的对象\",{\"1\":{\"512\":1}}],[\"java中的类\",{\"1\":{\"512\":1}}],[\"java中可以使用priorityqueue\",{\"1\":{\"337\":1}}],[\"java编译版本\",{\"1\":{\"441\":1}}],[\"java<\",{\"1\":{\"432\":1,\"441\":1,\"442\":3,\"443\":1}}],[\"javax\",{\"1\":{\"423\":1}}],[\"java\",{\"1\":{\"12\":1,\"29\":1,\"406\":1,\"407\":3,\"419\":2,\"422\":1,\"442\":3,\"444\":1,\"454\":4,\"474\":1,\"477\":1,\"478\":1,\"485\":1,\"488\":1,\"492\":1,\"782\":1}}],[\"j表示每一行的元素\",{\"1\":{\"311\":1}}],[\"j表示拆分的正整数\",{\"1\":{\"87\":1}}],[\"j指针时\",{\"1\":{\"283\":1}}],[\"j指向尾端\",{\"1\":{\"282\":1}}],[\"j相差一个字符\",{\"1\":{\"261\":1}}],[\"j区间内是否是回文子串\",{\"1\":{\"261\":1}}],[\"jfk\",{\"1\":{\"212\":13,\"213\":4}}],[\"j+2\",{\"1\":{\"126\":1}}],[\"j+1\",{\"1\":{\"126\":2,\"179\":1,\"245\":1,\"262\":1}}],[\"j++\",{\"1\":{\"85\":1,\"87\":1,\"89\":1,\"91\":3,\"103\":3,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"133\":1,\"137\":2,\"139\":1,\"141\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":3,\"155\":1,\"157\":1,\"175\":1,\"179\":1,\"187\":1,\"215\":2,\"217\":2,\"226\":2,\"228\":2,\"230\":4,\"232\":4,\"234\":1,\"262\":1,\"289\":1,\"298\":2,\"299\":1,\"302\":2,\"311\":1}}],[\"j为右子树\",{\"1\":{\"89\":1}}],[\"j拆分成多个正整数\",{\"1\":{\"87\":1}}],[\"j\",{\"1\":{\"85\":13,\"87\":24,\"89\":8,\"91\":26,\"92\":15,\"93\":13,\"95\":16,\"97\":8,\"99\":15,\"101\":15,\"103\":19,\"105\":12,\"107\":24,\"109\":17,\"111\":12,\"113\":2,\"126\":21,\"133\":6,\"137\":21,\"139\":17,\"140\":3,\"141\":10,\"146\":16,\"148\":24,\"150\":8,\"152\":47,\"153\":49,\"155\":29,\"157\":24,\"175\":4,\"176\":4,\"179\":9,\"187\":2,\"193\":2,\"199\":8,\"215\":14,\"216\":1,\"217\":6,\"223\":3,\"225\":1,\"226\":21,\"227\":1,\"228\":11,\"229\":1,\"230\":18,\"231\":1,\"232\":24,\"234\":5,\"245\":3,\"261\":16,\"262\":8,\"282\":7,\"283\":8,\"289\":9,\"297\":1,\"298\":10,\"299\":73,\"302\":8,\"303\":1,\"311\":6,\"343\":5,\"351\":3,\"361\":2}}],[\"向主库发送请求更新\",{\"1\":{\"820\":1}}],[\"向set类型的字段插入set成员中不存在的值时\",{\"1\":{\"607\":1}}],[\"向\",{\"1\":{\"426\":3}}],[\"向tc注册分支事务\",{\"1\":{\"426\":1}}],[\"向网关发送一次请求\",{\"1\":{\"422\":1}}],[\"向前跳转的最大长度\",{\"1\":{\"351\":1}}],[\"向零截断\",{\"1\":{\"330\":1}}],[\"向两边扩张\",{\"1\":{\"275\":1}}],[\"向左继续搜索找到开始下标\",{\"1\":{\"275\":1}}],[\"向四个方向移动\",{\"1\":{\"226\":1}}],[\"向数组中的每个整数前添加\",{\"1\":{\"98\":1}}],[\"向下\",{\"1\":{\"84\":6}}],[\"向右继续搜索找到结束下标\",{\"1\":{\"275\":1}}],[\"向右\",{\"1\":{\"84\":3}}],[\"向上爬一个台阶\",{\"1\":{\"82\":2}}],[\"向上爬两个台阶\",{\"1\":{\"82\":5}}],[\"爬到第i层的最低花费\",{\"1\":{\"83\":1}}],[\"爬到第i层楼梯\",{\"1\":{\"81\":1}}],[\"节约索引存储\",{\"1\":{\"836\":1}}],[\"节省了大量的io操作\",{\"1\":{\"650\":1}}],[\"节\",{\"1\":{\"604\":1}}],[\"节使用\",{\"1\":{\"83\":2}}],[\"节楼梯时\",{\"1\":{\"83\":1}}],[\"节楼梯最低的花费\",{\"1\":{\"83\":1}}],[\"节点下\",{\"1\":{\"823\":1}}],[\"节点上的每个摄影头都可以监视其父对象\",{\"1\":{\"371\":1}}],[\"节点为null\",{\"1\":{\"117\":1}}],[\"节点值的总和\",{\"1\":{\"74\":1}}],[\"节点值唯一\",{\"1\":{\"67\":1}}],[\"节点键的节点\",{\"1\":{\"73\":2}}],[\"节点数的范围\",{\"1\":{\"67\":1}}],[\"节点数在\",{\"1\":{\"40\":1}}],[\"节点\",{\"1\":{\"61\":2,\"63\":2}}],[\"节点的状态值\",{\"1\":{\"372\":1}}],[\"节点的右子树仅包含键\",{\"1\":{\"73\":1}}],[\"节点的右子树只包含\",{\"1\":{\"55\":1}}],[\"节点的左子树仅包含键\",{\"1\":{\"73\":1}}],[\"节点的左子树只包含\",{\"1\":{\"55\":1}}],[\"节点的值\",{\"1\":{\"42\":1}}],[\"花费体力为0\",{\"1\":{\"83\":1}}],[\"总用户数量有多少\",{\"1\":{\"731\":1}}],[\"总体来看存在以下几方面的问题\",{\"1\":{\"731\":1}}],[\"总索引长度至少为256字节\",{\"1\":{\"642\":1}}],[\"总之consul提供了一种完整的服务网格解决方案\",{\"1\":{\"449\":1}}],[\"总额度\",{\"1\":{\"431\":1}}],[\"总库存\",{\"1\":{\"431\":1}}],[\"总调用数\",{\"1\":{\"414\":1}}],[\"总调用次数\",{\"1\":{\"413\":1}}],[\"总\",{\"1\":{\"414\":1,\"415\":1}}],[\"总和\",{\"1\":{\"360\":1}}],[\"总和最大\",{\"1\":{\"257\":1}}],[\"总剩余油量\",{\"1\":{\"356\":1}}],[\"总会到达下标为\",{\"1\":{\"349\":1}}],[\"总利润\",{\"1\":{\"129\":1}}],[\"总利润为\",{\"1\":{\"121\":2}}],[\"总共包含4种类型\",{\"1\":{\"605\":1}}],[\"总共需要4支箭\",{\"1\":{\"363\":1}}],[\"总共有\",{\"1\":{\"84\":1}}],[\"总共花费\",{\"1\":{\"83\":1}}],[\"总花费为\",{\"1\":{\"82\":2}}],[\"总结起来就是访问最新提交的快照\",{\"1\":{\"798\":1}}],[\"总结起来\",{\"1\":{\"222\":1}}],[\"总结\",{\"0\":{\"9\":1,\"29\":1,\"153\":1,\"218\":1,\"339\":1,\"633\":1,\"801\":1},\"1\":{\"117\":1,\"618\":2,\"702\":1}}],[\"之为回滚\",{\"1\":{\"742\":1}}],[\"之内\",{\"1\":{\"334\":1}}],[\"之后其他线程的以下语句会被阻塞\",{\"1\":{\"785\":1}}],[\"之后回滚的时候只需要把这个主键值对应的\",{\"1\":{\"755\":1}}],[\"之后以\",{\"1\":{\"753\":1}}],[\"之后若是sessionb回滚\",{\"1\":{\"746\":1}}],[\"之后\",{\"1\":{\"700\":1,\"746\":2,\"835\":1}}],[\"之后就抛弃\",{\"1\":{\"634\":1}}],[\"之后的select操作都\",{\"1\":{\"765\":1}}],[\"之后的权限判断逻辑\",{\"1\":{\"625\":1}}],[\"之后的数字和为\",{\"1\":{\"290\":3}}],[\"之后我们得到字符串\",{\"1\":{\"327\":1}}],[\"之后要扣减手续费\",{\"1\":{\"130\":1}}],[\"之后再将它们卖出\",{\"1\":{\"123\":1}}],[\"之前\",{\"1\":{\"402\":1,\"492\":1}}],[\"之前的数字和为\",{\"1\":{\"290\":3}}],[\"之前都是数组的动态规划\",{\"1\":{\"117\":1}}],[\"之前添加\",{\"1\":{\"98\":2}}],[\"之外\",{\"1\":{\"116\":1}}],[\"之和等于目标数\",{\"1\":{\"240\":3}}],[\"之和\",{\"1\":{\"81\":1}}],[\"之间的学生记录呢\",{\"1\":{\"696\":1}}],[\"之间的请求\",{\"1\":{\"492\":1}}],[\"之间用单个空格连接的结果字符串\",{\"1\":{\"244\":1}}],[\"之间组成\",{\"1\":{\"200\":1}}],[\"之间\",{\"1\":{\"19\":1,\"73\":2,\"269\":2,\"798\":1,\"800\":1}}],[\"阶码\",{\"1\":{\"599\":1}}],[\"阶\",{\"1\":{\"80\":10}}],[\"阶你才能到达楼顶\",{\"1\":{\"80\":1}}],[\"或主键\",{\"1\":{\"737\":1}}],[\"或将排序放到程序端去做\",{\"1\":{\"726\":1}}],[\"或将从表中外键引用该主表的关系先删除\",{\"1\":{\"618\":1}}],[\"或先删除外键约束\",{\"1\":{\"618\":1}}],[\"或非关联\",{\"1\":{\"570\":1}}],[\"或关联\",{\"1\":{\"570\":1}}],[\"或关联条件\",{\"1\":{\"533\":2}}],[\"或聚集\",{\"1\":{\"561\":1}}],[\"或lcase\",{\"1\":{\"552\":1}}],[\"或右\",{\"1\":{\"537\":2}}],[\"或字段名\",{\"1\":{\"518\":1}}],[\"或之后\",{\"1\":{\"488\":1}}],[\"或是\",{\"1\":{\"357\":1}}],[\"或是在范围\",{\"1\":{\"330\":1}}],[\"或不与边界上的\",{\"1\":{\"231\":1}}],[\"或不删除\",{\"1\":{\"132\":1}}],[\"或竖直方向上相邻的陆地连接形成\",{\"1\":{\"225\":1}}],[\"或出售股票\",{\"1\":{\"121\":1}}],[\"或下标为\",{\"1\":{\"82\":1}}],[\"或\",{\"1\":{\"80\":1,\"98\":1,\"225\":1,\"227\":1,\"229\":1,\"231\":1,\"278\":1,\"330\":1,\"404\":1,\"518\":2,\"552\":1,\"687\":1,\"700\":1,\"764\":1,\"767\":1,\"807\":1,\"809\":1,\"819\":1,\"823\":1,\"831\":4}}],[\"或者写入mq\",{\"1\":{\"853\":1}}],[\"或者对数据进行增删改都会进行当前读\",{\"1\":{\"791\":1}}],[\"或者没有获取到锁\",{\"1\":{\"763\":1}}],[\"或者加锁失败\",{\"1\":{\"763\":1}}],[\"或者加锁成功\",{\"1\":{\"763\":1}}],[\"或者人为的停止当前事务的执行\",{\"1\":{\"742\":1}}],[\"或者重用之类的情况出现\",{\"1\":{\"732\":1}}],[\"或者称为业务数据架构师的工作\",{\"1\":{\"727\":1}}],[\"或者<>\",{\"0\":{\"719\":1}}],[\"或者磁盘中\",{\"1\":{\"710\":1}}],[\"或者删掉slow\",{\"1\":{\"698\":1}}],[\"或者使用\",{\"1\":{\"687\":1}}],[\"或者在表创建之后通过\",{\"1\":{\"612\":1}}],[\"或者不需要去除重复的数据\",{\"1\":{\"540\":1}}],[\"或者有一个\",{\"1\":{\"416\":1}}],[\"或者链表中的一个有效索引\",{\"1\":{\"393\":1}}],[\"或者path中最后一个元素大于当前元素\",{\"1\":{\"207\":2}}],[\"或者\",{\"1\":{\"64\":1,\"81\":1,\"89\":1,\"105\":1,\"321\":2,\"334\":1,\"418\":1,\"476\":1,\"521\":1,\"542\":1,\"568\":1,\"605\":1,\"648\":1,\"687\":2,\"689\":1,\"700\":1,\"725\":1,\"728\":1,\"744\":1,\"745\":1,\"746\":2,\"770\":1,\"782\":1}}],[\"初始值为0\",{\"1\":{\"851\":1}}],[\"初始间隔时间为100ms\",{\"1\":{\"467\":1}}],[\"初始请求一次\",{\"1\":{\"467\":1}}],[\"初始位置为\",{\"1\":{\"351\":1}}],[\"初始状态设\",{\"1\":{\"334\":1}}],[\"初始状态下\",{\"1\":{\"23\":1}}],[\"初始为\",{\"1\":{\"262\":1}}],[\"初始密码为字符串\",{\"1\":{\"255\":1}}],[\"初始化都为1\",{\"1\":{\"360\":1}}],[\"初始化就是false\",{\"1\":{\"155\":1}}],[\"初始化全为false\",{\"1\":{\"155\":1}}],[\"初始化成0\",{\"1\":{\"109\":1}}],[\"初始化尽量初始化成一个最小的非负整数\",{\"1\":{\"92\":1}}],[\"初始化dp数组\",{\"1\":{\"91\":2}}],[\"初始化横竖就可\",{\"1\":{\"85\":1}}],[\"初始化\",{\"1\":{\"85\":2,\"87\":1,\"89\":2,\"92\":1,\"95\":1,\"99\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":1,\"120\":1,\"122\":1,\"124\":1,\"126\":2,\"128\":1,\"133\":2,\"143\":1,\"146\":1,\"148\":1,\"152\":3,\"155\":1,\"157\":1}}],[\"初始化f0=0\",{\"1\":{\"79\":1}}],[\"递增加一\",{\"1\":{\"304\":1}}],[\"递增\",{\"1\":{\"282\":1}}],[\"递增子序列中\",{\"1\":{\"206\":1}}],[\"递推关系式依赖于第一行和第一列的数据\",{\"1\":{\"152\":1}}],[\"递推关系式\",{\"1\":{\"92\":1,\"95\":1,\"103\":1,\"109\":1,\"115\":1}}],[\"递推公式\",{\"1\":{\"85\":1,\"105\":1,\"107\":1,\"120\":1,\"122\":1,\"124\":1,\"126\":1,\"128\":1,\"130\":1,\"133\":1,\"137\":1,\"139\":1,\"153\":1,\"157\":1}}],[\"递推公式为\",{\"1\":{\"85\":1}}],[\"递推公式其实题目中已经给出\",{\"1\":{\"79\":1}}],[\"递归三部曲\",{\"1\":{\"386\":1}}],[\"递归结束后\",{\"1\":{\"372\":1}}],[\"递归之后要进行回溯\",{\"1\":{\"224\":1}}],[\"递归之后就做相反的操作\",{\"1\":{\"218\":1}}],[\"递归之后就要逆向操作\",{\"1\":{\"190\":2,\"191\":1}}],[\"递归之后就要做相同的逆操作\",{\"1\":{\"187\":1}}],[\"递归之前干什么\",{\"1\":{\"190\":2,\"191\":1}}],[\"递归之前做了什么递归之后就要回溯\",{\"1\":{\"224\":2}}],[\"递归之前做了什么\",{\"1\":{\"187\":1,\"218\":1}}],[\"递归和回溯是息息相关的\",{\"1\":{\"187\":1}}],[\"递归调用的过程就是纵向遍历\",{\"1\":{\"187\":1}}],[\"递归调用如下所示\",{\"1\":{\"50\":1}}],[\"递归的深度构成的树的深度\",{\"1\":{\"185\":1}}],[\"递归的深度\",{\"1\":{\"184\":1}}],[\"递归的终止条件为二叉树的高度\",{\"1\":{\"184\":1}}],[\"递归右子树所得到的最大和\",{\"1\":{\"117\":1}}],[\"递归创建左右子树\",{\"1\":{\"72\":1}}],[\"递归左右子树\",{\"1\":{\"66\":1}}],[\"递归左子树所得到的最大和\",{\"1\":{\"117\":1}}],[\"递归左子树\",{\"1\":{\"47\":1,\"70\":1}}],[\"递归找左右字数\",{\"1\":{\"51\":1}}],[\"递归地在最大值\",{\"1\":{\"50\":2}}],[\"递归地构建\",{\"1\":{\"50\":1}}],[\"递归处理左右子树\",{\"1\":{\"49\":1}}],[\"递归+回溯\",{\"1\":{\"45\":1}}],[\"递归与回溯一一对应\",{\"1\":{\"39\":1}}],[\"递归比较左右子树\",{\"1\":{\"33\":1}}],[\"递归版本的先序遍历代码如下\",{\"1\":{\"39\":1}}],[\"递归版本\",{\"1\":{\"12\":1}}],[\"递归遍历左子树\",{\"1\":{\"2\":2}}],[\"递归\",{\"1\":{\"2\":1,\"12\":1,\"31\":1,\"33\":1,\"39\":2,\"41\":1,\"45\":1,\"47\":1,\"54\":2,\"66\":2,\"185\":3,\"190\":1,\"222\":1,\"224\":2}}],[\"递归方法比较简单\",{\"1\":{\"1\":1}}],[\"通用查询日志文件的名称是atguigu01\",{\"1\":{\"806\":1}}],[\"通用查询日志处于关闭状态\",{\"1\":{\"806\":1}}],[\"通用查询日志用来\",{\"1\":{\"806\":1}}],[\"通用查询日志\",{\"0\":{\"806\":1},\"1\":{\"805\":2}}],[\"通用的格式\",{\"1\":{\"558\":1}}],[\"通用http返回状态码\",{\"1\":{\"444\":1}}],[\"通用mapper\",{\"1\":{\"442\":2}}],[\"通用mapper4之tk\",{\"1\":{\"441\":1}}],[\"通用mapper4\",{\"1\":{\"432\":1,\"443\":1}}],[\"通常\",{\"1\":{\"658\":1}}],[\"通常情况下都是因为子查询中的表用到了外部的表\",{\"1\":{\"579\":1}}],[\"通常可以将nginx至于\",{\"1\":{\"487\":1}}],[\"通常在客户端\",{\"1\":{\"475\":1}}],[\"通常在开发中\",{\"1\":{\"447\":1}}],[\"通常在\",{\"1\":{\"222\":1}}],[\"通常用于解决\",{\"1\":{\"339\":1}}],[\"通常用\",{\"1\":{\"78\":1}}],[\"通过如下指定判定文件中没有student表结构\",{\"1\":{\"831\":1}}],[\"通过这种冗余的方式可以换取数据库的高可用性\",{\"1\":{\"819\":1}}],[\"通过readview找到符合条件的记录版本\",{\"1\":{\"765\":1}}],[\"通过创建覆盖索引能够比较好地提高性能\",{\"1\":{\"726\":1}}],[\"通过创建唯一索引\",{\"1\":{\"642\":1}}],[\"通过二分查找法的方式进行检索\",{\"1\":{\"673\":1}}],[\"通过二分法找到相等的元素后\",{\"1\":{\"275\":1}}],[\"通过索引査找\",{\"1\":{\"641\":1}}],[\"通过目录中找到对应文章的页码\",{\"1\":{\"641\":1}}],[\"通过部门id查询出工资比平均工资大的员工\",{\"1\":{\"579\":2}}],[\"通过查询结果查看左右连接区别\",{\"1\":{\"539\":1}}],[\"通过减少不常用的功能\",{\"1\":{\"510\":1}}],[\"通过允许模板化的路径段来操作请求路径\",{\"1\":{\"502\":1}}],[\"通过维持一组许可证\",{\"1\":{\"480\":1}}],[\"通过payfeignapi调用服务端暴露的接口\",{\"1\":{\"464\":1}}],[\"通过openfeign\",{\"1\":{\"464\":1}}],[\"通过定义一个接口\",{\"1\":{\"462\":1}}],[\"通过负载均衡调用\",{\"1\":{\"459\":1}}],[\"通过调用\",{\"1\":{\"459\":1}}],[\"通过调节双指针的位置\",{\"1\":{\"285\":1}}],[\"通过浏览器的地址栏输入url\",{\"1\":{\"446\":1}}],[\"通过namespace分组区分环境\",{\"1\":{\"404\":1}}],[\"通过group分组区分环境\",{\"1\":{\"404\":1}}],[\"通过模拟可以发现\",{\"1\":{\"334\":1}}],[\"通过\",{\"1\":{\"312\":1,\"411\":1,\"420\":1,\"612\":1,\"741\":1,\"801\":1,\"866\":1,\"869\":1}}],[\"通过下图可以看出\",{\"1\":{\"304\":2}}],[\"通过第二次遍历修改原矩阵的值\",{\"1\":{\"301\":1}}],[\"通过for循环\",{\"1\":{\"286\":1}}],[\"通过俩层\",{\"1\":{\"285\":1}}],[\"通过去重操作\",{\"1\":{\"267\":1}}],[\"通过对比转换前后的长度就可以得知是否重复\",{\"1\":{\"267\":1}}],[\"通过填充空格来解决数独问题\",{\"1\":{\"216\":1}}],[\"通过图中可以看出\",{\"1\":{\"205\":1}}],[\"通过图片其实也可以看出与组合\",{\"1\":{\"209\":1}}],[\"通过图片其实可以看出\",{\"1\":{\"47\":1}}],[\"通过图片我们可以看出来\",{\"1\":{\"193\":1}}],[\"通过回溯做的题目类型\",{\"1\":{\"183\":1}}],[\"通过递推关系式可以看出\",{\"1\":{\"146\":1}}],[\"通过上面图片也可以得知\",{\"1\":{\"372\":1}}],[\"通过上面图中可以看到\",{\"1\":{\"199\":1}}],[\"通过上面的描述\",{\"1\":{\"155\":1}}],[\"通过上面的例子我们可以看出来\",{\"1\":{\"97\":1}}],[\"通过上图其实就可看出来了\",{\"1\":{\"191\":1}}],[\"通过上图可以得知\",{\"1\":{\"85\":1}}],[\"通过修剪二叉搜索树\",{\"1\":{\"69\":1}}],[\"通过题意我们可以发现\",{\"1\":{\"334\":1}}],[\"通过题意我们很清楚的知道使用先序遍历\",{\"1\":{\"39\":1}}],[\"通过题目我们可以得知\",{\"1\":{\"391\":1}}],[\"通过题目可以得知\",{\"1\":{\"273\":1}}],[\"通过题目可以知道\",{\"1\":{\"215\":1}}],[\"通过题目描述中也可以得知\",{\"1\":{\"31\":1}}],[\"斐波那契数列\",{\"1\":{\"78\":1}}],[\"斐波那契数\",{\"1\":{\"78\":1}}],[\"动式更新\",{\"1\":{\"836\":1}}],[\"动态刷新\",{\"0\":{\"453\":1}}],[\"动态的配置管理设施是必不可少的\",{\"1\":{\"452\":1}}],[\"动态规划求全排列问题\",{\"1\":{\"105\":1}}],[\"动态规划的思路是\",{\"1\":{\"101\":1}}],[\"动态规划的每一步都是由上一步推导出来来的\",{\"1\":{\"77\":1}}],[\"动态规划五部曲\",{\"1\":{\"77\":1}}],[\"动态规划与贪心的区别\",{\"1\":{\"77\":1}}],[\"动态规划\",{\"0\":{\"77\":1},\"1\":{\"87\":1,\"120\":1,\"122\":1,\"146\":1,\"261\":1},\"2\":{\"159\":1}}],[\"动画来源于\",{\"1\":{\"279\":1}}],[\"动图\",{\"1\":{\"12\":1}}],[\"求总和\",{\"1\":{\"562\":1}}],[\"求平均值\",{\"1\":{\"562\":1}}],[\"求和\",{\"1\":{\"354\":1}}],[\"求解\",{\"1\":{\"347\":1}}],[\"求解每一个子问题的最优解\",{\"1\":{\"342\":1}}],[\"求摆动序列的长度\",{\"1\":{\"346\":1}}],[\"求得每俩个元素的最小值加起来的和最大\",{\"1\":{\"258\":1}}],[\"求得最大利润\",{\"1\":{\"122\":1}}],[\"求他的排列方式\",{\"1\":{\"209\":1}}],[\"求交集\",{\"1\":{\"168\":1}}],[\"求组合问题则相反\",{\"1\":{\"105\":1}}],[\"求组合问题\",{\"1\":{\"105\":1}}],[\"求恰由\",{\"1\":{\"88\":1}}],[\"求节点5的新值为\",{\"1\":{\"74\":1}}],[\"求出差值\",{\"1\":{\"97\":3}}],[\"求出二叉树的高度\",{\"1\":{\"43\":1}}],[\"求出二叉树的最大深度\",{\"1\":{\"37\":1}}],[\"求出该树的节点个数\",{\"1\":{\"34\":1}}],[\"gm\",{\"1\":{\"586\":1}}],[\"gmt+8\",{\"1\":{\"444\":2}}],[\"gmt\",{\"1\":{\"428\":1,\"836\":4}}],[\"guides\",{\"1\":{\"475\":1,\"479\":1,\"482\":1}}],[\"gwflowruledatasource\",{\"1\":{\"424\":2}}],[\"global|session\",{\"1\":{\"695\":1,\"746\":2}}],[\"globalexceptionhandler\",{\"1\":{\"445\":2}}],[\"global\",{\"1\":{\"429\":2,\"431\":3,\"698\":3,\"806\":2,\"809\":3}}],[\"globalsession\",{\"1\":{\"428\":1}}],[\"globalfilter\",{\"1\":{\"423\":1,\"498\":1,\"503\":1}}],[\"globaltransactional\",{\"1\":{\"399\":1,\"426\":2,\"432\":2,\"435\":3}}],[\"gap锁\",{\"1\":{\"778\":4}}],[\"gap锁的提出仅仅是为了防止插入幻影记录而提出的\",{\"1\":{\"776\":1}}],[\"gap\",{\"0\":{\"776\":1},\"1\":{\"775\":1}}],[\"game\",{\"1\":{\"737\":1}}],[\"gatewaypredicate\",{\"1\":{\"497\":1}}],[\"gateway中原有predicate是怎么写的\",{\"1\":{\"497\":1}}],[\"gateway包括许多内置的\",{\"1\":{\"491\":1}}],[\"gateway将路由匹配作为spring\",{\"1\":{\"491\":1}}],[\"gateway自带的routepredicatefactory\",{\"1\":{\"491\":1}}],[\"gatewayfilterfactory<c>\",{\"1\":{\"504\":1}}],[\"gatewayfilterfactory\",{\"1\":{\"504\":1}}],[\"gatewayfilterchain\",{\"1\":{\"503\":1,\"504\":1}}],[\"gatewayfilter\",{\"1\":{\"488\":1,\"498\":1,\"504\":2}}],[\"gatewayflowrule\",{\"1\":{\"423\":1}}],[\"gatewayrulemanager\",{\"1\":{\"423\":1,\"424\":1}}],[\"gatewaycallbackmanager\",{\"1\":{\"422\":1,\"423\":1}}],[\"gatewayconfiguration\",{\"1\":{\"423\":2}}],[\"gatewayconfig\",{\"1\":{\"422\":1}}],[\"gateway版本为2022\",{\"1\":{\"422\":1}}],[\"gateway整合sentinel的依赖\",{\"1\":{\"422\":1}}],[\"gateway<\",{\"1\":{\"422\":2,\"423\":1,\"489\":1}}],[\"gateway9528\",{\"1\":{\"422\":1}}],[\"gateway\",{\"0\":{\"487\":1,\"488\":1},\"1\":{\"399\":1,\"421\":2,\"422\":3,\"423\":2,\"487\":4,\"488\":6,\"489\":5,\"491\":3,\"492\":3,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":6,\"500\":2,\"502\":4,\"504\":1},\"2\":{\"506\":1}}],[\"gas\",{\"1\":{\"355\":6,\"356\":5}}],[\"gis\",{\"1\":{\"637\":1}}],[\"git\",{\"1\":{\"398\":1,\"439\":1,\"440\":1}}],[\"github\",{\"1\":{\"398\":1,\"399\":3,\"401\":1,\"405\":2,\"407\":1,\"428\":1,\"431\":1,\"439\":1,\"440\":1,\"442\":1,\"462\":1,\"468\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":2,\"486\":2}}],[\"gif\",{\"1\":{\"250\":1}}],[\"general\",{\"1\":{\"806\":7}}],[\"generator<\",{\"1\":{\"442\":2}}],[\"generator\",{\"1\":{\"442\":6}}],[\"generator2024中生成的\",{\"1\":{\"443\":1}}],[\"generator2024\",{\"1\":{\"442\":1}}],[\"generatorconfiguration>\",{\"1\":{\"442\":1}}],[\"generatorconfiguration\",{\"1\":{\"442\":1}}],[\"generatorconfig\",{\"1\":{\"431\":1,\"442\":2}}],[\"generate\",{\"1\":{\"311\":1}}],[\"generatematrix\",{\"1\":{\"289\":1}}],[\"gender\",{\"1\":{\"686\":1}}],[\"getrawquery\",{\"1\":{\"503\":1}}],[\"getresponse\",{\"1\":{\"504\":2}}],[\"getrequest\",{\"1\":{\"497\":1,\"503\":4,\"504\":1}}],[\"getreturncodeenumv2\",{\"1\":{\"444\":4}}],[\"getreturncodeenum\",{\"1\":{\"444\":1}}],[\"getreasonphrase\",{\"1\":{\"423\":1}}],[\"gethost\",{\"1\":{\"503\":1}}],[\"getheight\",{\"1\":{\"43\":4}}],[\"geturi\",{\"1\":{\"503\":4}}],[\"getusertype\",{\"1\":{\"497\":1}}],[\"getuserid\",{\"1\":{\"432\":2}}],[\"getattribute\",{\"1\":{\"503\":1}}],[\"getattributes\",{\"1\":{\"503\":1}}],[\"getall\",{\"1\":{\"443\":2}}],[\"getorder\",{\"1\":{\"503\":1}}],[\"getordefault\",{\"1\":{\"165\":1,\"338\":2}}],[\"getfirst\",{\"1\":{\"497\":1}}],[\"getforobject\",{\"1\":{\"402\":1,\"446\":1,\"459\":1}}],[\"getqueryparams\",{\"1\":{\"497\":1,\"504\":1}}],[\"getstatus\",{\"1\":{\"504\":1}}],[\"getstores\",{\"1\":{\"463\":2}}],[\"getserveraddr\",{\"1\":{\"424\":1}}],[\"getter\",{\"1\":{\"444\":1,\"497\":1,\"504\":1}}],[\"getbyid\",{\"1\":{\"443\":4}}],[\"getxid\",{\"1\":{\"432\":2}}],[\"getport\",{\"1\":{\"503\":1}}],[\"getproductid\",{\"1\":{\"432\":1}}],[\"getproperty\",{\"1\":{\"424\":1}}],[\"getpath\",{\"1\":{\"503\":1}}],[\"getpaybyorderno\",{\"1\":{\"420\":2}}],[\"getpayinfo\",{\"1\":{\"402\":1,\"446\":1,\"464\":4}}],[\"getparameter\",{\"1\":{\"418\":1}}],[\"getdataid\",{\"1\":{\"424\":1}}],[\"getdatasource\",{\"1\":{\"424\":1}}],[\"getgroupid\",{\"1\":{\"424\":1}}],[\"getname\",{\"1\":{\"481\":2}}],[\"getnacos\",{\"1\":{\"424\":2}}],[\"getnextnum\",{\"1\":{\"171\":2}}],[\"getinstances\",{\"1\":{\"460\":1}}],[\"getinfobyconsul\",{\"1\":{\"459\":1}}],[\"getintersectionnode\",{\"1\":{\"392\":1}}],[\"getid\",{\"1\":{\"432\":1}}],[\"getifavailable\",{\"1\":{\"423\":1}}],[\"getcount\",{\"1\":{\"432\":1}}],[\"getcode\",{\"1\":{\"420\":1,\"444\":4,\"445\":1}}],[\"getconfiginfo\",{\"1\":{\"403\":1}}],[\"getmoney\",{\"1\":{\"432\":1}}],[\"getmessage\",{\"1\":{\"416\":1,\"444\":2,\"445\":2}}],[\"getmapping\",{\"1\":{\"402\":2,\"403\":1,\"410\":2,\"416\":1,\"417\":1,\"418\":1,\"420\":1,\"432\":1,\"443\":1,\"446\":2,\"459\":1,\"464\":4,\"477\":3,\"480\":1,\"481\":1,\"482\":1}}],[\"getminimumdifference\",{\"1\":{\"58\":1}}],[\"getkey\",{\"1\":{\"338\":1}}],[\"getvalue\",{\"1\":{\"338\":1,\"424\":2}}],[\"getlast\",{\"1\":{\"213\":2}}],[\"get\",{\"1\":{\"12\":1,\"47\":1,\"49\":1,\"56\":2,\"60\":1,\"175\":1,\"193\":4,\"207\":2,\"213\":26,\"296\":3,\"311\":4,\"420\":1,\"443\":1,\"446\":2,\"451\":1,\"459\":3,\"463\":2,\"464\":3,\"489\":1,\"558\":2}}],[\"gnid\",{\"1\":{\"246\":1}}],[\"gold\",{\"1\":{\"497\":1}}],[\"governing\",{\"1\":{\"429\":1}}],[\"go\",{\"1\":{\"406\":1,\"449\":1}}],[\"god\",{\"1\":{\"246\":1}}],[\"good\",{\"1\":{\"244\":2}}],[\"g\",{\"1\":{\"193\":2,\"343\":6,\"344\":5,\"518\":2,\"699\":2,\"725\":1,\"822\":1,\"826\":1}}],[\"granularity\",{\"1\":{\"768\":1,\"771\":1}}],[\"grant\",{\"1\":{\"444\":1,\"517\":1,\"539\":1,\"825\":2}}],[\"grades\",{\"1\":{\"534\":2}}],[\"grade\",{\"1\":{\"419\":5,\"534\":1}}],[\"graph\",{\"1\":{\"223\":8,\"224\":17}}],[\"grpc\",{\"1\":{\"406\":1}}],[\"grep\",{\"1\":{\"831\":3,\"832\":1}}],[\"greatest\",{\"1\":{\"548\":1}}],[\"greater\",{\"1\":{\"73\":2}}],[\"greenwich\",{\"1\":{\"399\":2}}],[\"group`\",{\"1\":{\"428\":1}}],[\"group可以把不同的微服务划分到同一个分组里面去\",{\"1\":{\"404\":1}}],[\"group默认是default\",{\"1\":{\"404\":1}}],[\"group=default\",{\"1\":{\"404\":1}}],[\"group和dataid逻辑上区分两个目标对象\",{\"1\":{\"404\":1}}],[\"groupid\",{\"0\":{\"404\":1},\"1\":{\"419\":2}}],[\"groupid>\",{\"1\":{\"399\":1,\"402\":14,\"403\":2,\"408\":1,\"419\":1,\"422\":4,\"423\":4,\"432\":17,\"441\":14,\"442\":14,\"443\":13,\"446\":7,\"450\":3,\"452\":2,\"459\":1,\"463\":1,\"468\":2,\"477\":2,\"480\":1,\"481\":1,\"482\":1,\"486\":11,\"489\":4}}],[\"group\",{\"0\":{\"563\":1,\"726\":1},\"1\":{\"399\":1,\"404\":8,\"419\":2,\"428\":1,\"429\":9,\"432\":5,\"477\":1,\"563\":6,\"564\":4,\"565\":3,\"574\":1,\"578\":7,\"579\":2,\"689\":2,\"710\":2,\"726\":6}}],[\"groupanagrams\",{\"1\":{\"165\":1}}],[\"grid\",{\"1\":{\"225\":5,\"226\":25,\"227\":8,\"228\":25,\"229\":7,\"230\":27}}],[\"搜索时间复杂度就是o\",{\"1\":{\"660\":1}}],[\"搜索速度稍慢\",{\"1\":{\"605\":1}}],[\"搜索引擎\",{\"1\":{\"686\":1}}],[\"搜索引擎领域的数据存储形式\",{\"1\":{\"510\":1}}],[\"搜索引擎数据库是应用在\",{\"1\":{\"510\":1}}],[\"搜索引擎数据库\",{\"1\":{\"510\":1}}],[\"搜索插入位置\",{\"0\":{\"273\":1}}],[\"搜索叶子节点就是找的其中一个结果了\",{\"1\":{\"185\":1}}],[\"搜索二叉树\",{\"2\":{\"76\":1}}],[\"搜索\",{\"1\":{\"73\":1}}],[\"时候执行备份的sql语句实现数据库数据的重现\",{\"1\":{\"830\":1}}],[\"时的列名\",{\"1\":{\"727\":1}}],[\"时的最大价值\",{\"1\":{\"91\":1}}],[\"时type就是system\",{\"1\":{\"704\":1}}],[\"时circuitbreaker将进入开启open状态\",{\"1\":{\"477\":1}}],[\"时往输入栈里面push\",{\"1\":{\"322\":1}}],[\"时间上的代价\",{\"1\":{\"656\":1}}],[\"时间和秒钟的转换\",{\"0\":{\"556\":1}}],[\"时间格式修改\",{\"1\":{\"444\":1}}],[\"时间的判断依据\",{\"1\":{\"412\":1}}],[\"时间复杂度会退化为0\",{\"1\":{\"658\":1}}],[\"时间复杂度完成此题\",{\"1\":{\"345\":1}}],[\"时间复杂度也都取决于该步\",{\"1\":{\"337\":1}}],[\"时间\",{\"0\":{\"554\":1},\"1\":{\"177\":1,\"476\":1,\"554\":1}}],[\"时所获得的最大利润\",{\"1\":{\"126\":1}}],[\"时一样\",{\"1\":{\"89\":1}}],[\"时\",{\"1\":{\"70\":1,\"89\":2,\"91\":2,\"95\":1,\"105\":1,\"155\":2,\"187\":1,\"188\":2,\"191\":1,\"195\":1,\"201\":1,\"205\":1,\"273\":1,\"276\":1,\"352\":1,\"366\":2,\"369\":1,\"370\":1,\"462\":1,\"477\":2,\"540\":1,\"550\":3,\"555\":1,\"595\":1,\"602\":2,\"660\":1,\"725\":1,\"742\":1,\"749\":1,\"753\":1,\"755\":2,\"799\":1}}],[\"道题差不多\",{\"1\":{\"70\":1}}],[\"唯一索引\",{\"1\":{\"686\":2}}],[\"唯一索引名就和唯一约束名一样\",{\"1\":{\"615\":1}}],[\"唯一性索引\",{\"1\":{\"686\":2}}],[\"唯一性约束允许列值为空\",{\"1\":{\"615\":1}}],[\"唯一性约束\",{\"0\":{\"615\":1},\"1\":{\"687\":1}}],[\"唯一键列\",{\"1\":{\"617\":1}}],[\"唯一约束可以是某一个列的值唯一\",{\"1\":{\"615\":1}}],[\"唯一约束\",{\"1\":{\"613\":1}}],[\"唯一区别的就是\",{\"1\":{\"528\":1}}],[\"唯一有效的解决方案如下所示\",{\"1\":{\"216\":1}}],[\"唯一可能的三元组和为\",{\"1\":{\"176\":1}}],[\"唯一可能的三元组和不为\",{\"1\":{\"176\":1}}],[\"唯一的实现\",{\"1\":{\"733\":1}}],[\"唯一的问题是\",{\"1\":{\"381\":1}}],[\"唯一的\",{\"1\":{\"379\":1}}],[\"唯一的区别就是这道题要求是不连续的子序列\",{\"1\":{\"139\":1}}],[\"唯一的区别就是房屋是首尾相连的\",{\"1\":{\"115\":1}}],[\"唯一的答案\",{\"1\":{\"69\":1}}],[\"唯一\",{\"1\":{\"69\":1,\"166\":1,\"355\":1,\"379\":1,\"513\":1}}],[\"原文\",{\"1\":{\"845\":1}}],[\"原子性要求\",{\"1\":{\"755\":1}}],[\"原子性是指事务是一个不可分割的工作单位\",{\"1\":{\"741\":1}}],[\"原子性\",{\"1\":{\"737\":1,\"741\":1,\"747\":1,\"755\":1}}],[\"原因\",{\"1\":{\"724\":1,\"729\":1}}],[\"原因4\",{\"1\":{\"658\":1}}],[\"原因3\",{\"1\":{\"658\":1}}],[\"原因2\",{\"1\":{\"658\":1}}],[\"原因1\",{\"1\":{\"658\":1}}],[\"原因就在于\",{\"1\":{\"598\":1}}],[\"原因就是中序遍历访问和处理的结点不是同一个\",{\"1\":{\"9\":1}}],[\"原理是一样的\",{\"1\":{\"480\":1,\"481\":1}}],[\"原理\",{\"0\":{\"436\":1}}],[\"原理很简单\",{\"1\":{\"377\":1}}],[\"原本我以为将\",{\"1\":{\"360\":1}}],[\"原则就是尽量将\",{\"1\":{\"344\":1}}],[\"原来\",{\"1\":{\"381\":1,\"382\":1,\"597\":1}}],[\"原来的值会被\",{\"1\":{\"299\":1}}],[\"原来是一个升序排序的数组\",{\"1\":{\"276\":1}}],[\"原始数组是递增的\",{\"1\":{\"282\":1}}],[\"原地修改\",{\"0\":{\"299\":1}}],[\"原地修改输入数组\",{\"1\":{\"249\":1}}],[\"原地\",{\"1\":{\"278\":2,\"297\":1,\"312\":1}}],[\"原数组为\",{\"1\":{\"276\":3}}],[\"原数组\",{\"1\":{\"276\":1}}],[\"原01背包递推关系式\",{\"1\":{\"101\":1}}],[\"原有的父代子代关系都应当保留\",{\"1\":{\"69\":1}}],[\"使业务\",{\"1\":{\"786\":1}}],[\"使数据从一种状态变换到另一种状态\",{\"1\":{\"741\":1}}],[\"使数组变为\",{\"1\":{\"277\":1}}],[\"使开发人员能够更容易地编写可靠\",{\"1\":{\"474\":1}}],[\"使剩余区间互不重叠\",{\"1\":{\"365\":1}}],[\"使\",{\"1\":{\"312\":1,\"805\":1}}],[\"使每个元素\",{\"1\":{\"312\":1}}],[\"使每个子串都是\",{\"1\":{\"198\":1}}],[\"使每个节点\",{\"1\":{\"73\":1}}],[\"使求得的差值最小\",{\"1\":{\"97\":1}}],[\"使得文件碎片比较多\",{\"1\":{\"605\":1}}],[\"使得对于安全性能很高的数据访问要求得以实现\",{\"1\":{\"509\":1}}],[\"使得服务b也变得不可用\",{\"1\":{\"472\":1}}],[\"使得从\",{\"1\":{\"257\":1}}],[\"使得两个子集的元素和相等\",{\"1\":{\"94\":1}}],[\"使得所有节点的值在\",{\"1\":{\"69\":1}}],[\"使用指南\",{\"1\":{\"884\":2},\"2\":{\"857\":1,\"859\":1,\"880\":1,\"887\":1,\"888\":1}}],[\"使用定时任务重试\",{\"1\":{\"853\":1}}],[\"使用两阶段提交后\",{\"1\":{\"812\":1}}],[\"使用mysqlbinlog命令来读取filename中的内容\",{\"1\":{\"809\":1}}],[\"使用map保存数字和字母的映射关系\",{\"1\":{\"193\":2}}],[\"使用map保存inorder节点值与下标的对应关系\",{\"1\":{\"49\":1}}],[\"使用日志恢复数据\",{\"1\":{\"809\":1}}],[\"使用s\",{\"1\":{\"746\":1}}],[\"使用set去重\",{\"1\":{\"207\":1}}],[\"使用set集合避免重复的三元组\",{\"1\":{\"177\":1}}],[\"使用grep命令\",{\"1\":{\"831\":2}}],[\"使用g\",{\"1\":{\"746\":1}}],[\"使用下面语句查看自动提交是否关闭\",{\"1\":{\"745\":1}}],[\"使用icp\",{\"1\":{\"728\":1}}],[\"使用索引\",{\"1\":{\"726\":1}}],[\"使用索引的原则几乎跟order\",{\"1\":{\"726\":1}}],[\"使用索引的目的就是为了减少磁盘io的次数\",{\"1\":{\"641\":1}}],[\"使用索引比不适用索引效率要高\",{\"1\":{\"719\":1}}],[\"使用覆盖索引\",{\"1\":{\"719\":1}}],[\"使用覆盖索引的情况下\",{\"1\":{\"710\":1}}],[\"使用具体的索引列\",{\"1\":{\"719\":1}}],[\"使用命令\",{\"0\":{\"809\":1},\"1\":{\"698\":1}}],[\"使用如下命令\",{\"1\":{\"698\":1}}],[\"使用场景\",{\"1\":{\"696\":1}}],[\"使用最频繁的列放到联合索引的左侧\",{\"1\":{\"689\":1}}],[\"使用字符串前缀创建索引\",{\"1\":{\"689\":1}}],[\"使用列的类型小的创建索引\",{\"1\":{\"689\":1}}],[\"使用alter\",{\"1\":{\"687\":1}}],[\"使用的是\",{\"1\":{\"715\":1}}],[\"使用的一种关键技术\",{\"1\":{\"686\":1}}],[\"使用的整数类型取值范围太小\",{\"1\":{\"598\":1}}],[\"使用组合索引时遵循\",{\"1\":{\"686\":1}}],[\"使用记录主键值的大小进行记录和页的排序\",{\"1\":{\"650\":1}}],[\"使用哪些索引进行查询\",{\"1\":{\"629\":1}}],[\"使用多行比较操作符\",{\"1\":{\"576\":1}}],[\"使用右连接时\",{\"1\":{\"539\":1}}],[\"使用了更灵活的方式来表示\",{\"1\":{\"495\":1}}],[\"使用了\",{\"1\":{\"464\":1}}],[\"使用开发者模式启动\",{\"1\":{\"449\":1}}],[\"使用递归的时候\",{\"1\":{\"386\":1}}],[\"使用递归解题也符合要求\",{\"1\":{\"23\":1}}],[\"使用优先级队列进行排序\",{\"1\":{\"338\":1}}],[\"使用标准的栈操作\",{\"1\":{\"321\":1}}],[\"使用俩个栈实现队列\",{\"1\":{\"322\":1}}],[\"使用俩个标记数组\",{\"1\":{\"302\":1}}],[\"使用俩层for循环\",{\"1\":{\"177\":1}}],[\"使用辅助矩阵\",{\"0\":{\"298\":1}}],[\"使用另一个矩阵来旋转图像\",{\"1\":{\"297\":1}}],[\"使用二分法\",{\"1\":{\"276\":1}}],[\"使用双层\",{\"1\":{\"217\":1}}],[\"使用过的元素在后续的遍历还会使用到\",{\"1\":{\"209\":1}}],[\"使用回溯时通常要在终止条件时\",{\"1\":{\"203\":1}}],[\"使用数组的话\",{\"1\":{\"193\":1}}],[\"使用数组和map集合都可以\",{\"1\":{\"193\":1}}],[\"使用普通集合即可\",{\"1\":{\"177\":1}}],[\"使用一种称之为\",{\"1\":{\"770\":1}}],[\"使用一个临时结点用于移动结点\",{\"1\":{\"382\":1}}],[\"使用一个临时结点\",{\"1\":{\"378\":1}}],[\"使用一个指针\",{\"1\":{\"7\":1}}],[\"使用一层\",{\"1\":{\"177\":1}}],[\"使用hash算法去重的操作也是很麻烦的\",{\"1\":{\"177\":1}}],[\"使用hash法呢\",{\"1\":{\"177\":1}}],[\"使用hash表\",{\"1\":{\"175\":1}}],[\"使用三层for循环\",{\"1\":{\"177\":1}}],[\"使用\",{\"1\":{\"35\":1,\"89\":2,\"249\":1,\"267\":1,\"276\":1,\"307\":1,\"313\":1,\"399\":1,\"416\":1,\"449\":1,\"464\":1,\"482\":1,\"524\":1,\"527\":1,\"569\":1,\"595\":1,\"598\":1,\"600\":1,\"654\":1,\"658\":1,\"686\":1,\"689\":1,\"699\":1,\"702\":1,\"704\":1,\"728\":1,\"797\":3,\"831\":2}}],[\"结构来实现的\",{\"1\":{\"770\":1}}],[\"结构化查询语言\",{\"1\":{\"516\":1}}],[\"结论\",{\"1\":{\"564\":1,\"579\":1}}],[\"结束熔断\",{\"1\":{\"412\":1}}],[\"结束循环后\",{\"1\":{\"382\":1}}],[\"结束下标为\",{\"1\":{\"254\":1}}],[\"结束下标就为\",{\"1\":{\"254\":1}}],[\"结束递归\",{\"1\":{\"234\":1}}],[\"结束\",{\"1\":{\"195\":1,\"518\":1}}],[\"结束条件\",{\"1\":{\"68\":1}}],[\"结果值从最好到最坏依次是\",{\"1\":{\"704\":1}}],[\"结果得不偿失\",{\"1\":{\"604\":1}}],[\"结果2\",{\"1\":{\"559\":1}}],[\"结果1\",{\"1\":{\"559\":1}}],[\"结果表中相应的列为空\",{\"1\":{\"537\":1}}],[\"结果\",{\"1\":{\"527\":1,\"800\":2}}],[\"结果缓存\",{\"1\":{\"474\":1}}],[\"结果状态\",{\"1\":{\"444\":1}}],[\"结果不出所料\",{\"1\":{\"360\":1}}],[\"结果集中不包含一个表与另一个表不匹配的行\",{\"1\":{\"537\":1}}],[\"结果集中最后一个区间的末尾元素\",{\"1\":{\"296\":1}}],[\"结果集合\",{\"1\":{\"296\":1}}],[\"结果为\",{\"1\":{\"169\":1}}],[\"结果需要对\",{\"1\":{\"147\":1}}],[\"结尾的\",{\"1\":{\"152\":2,\"153\":2}}],[\"结尾的word2\",{\"1\":{\"152\":4,\"153\":2}}],[\"结尾的word1\",{\"1\":{\"152\":2}}],[\"结尾的t\",{\"1\":{\"146\":1}}],[\"结尾的s\",{\"1\":{\"146\":1}}],[\"结点右子树中所含节点的值\",{\"1\":{\"59\":1}}],[\"结点左子树中所含节点的值\",{\"1\":{\"59\":1}}],[\"结点的和\",{\"1\":{\"45\":1}}],[\"结点的\",{\"1\":{\"20\":1}}],[\"结点的出队入队过程为\",{\"1\":{\"12\":1}}],[\"结点进队列和出队列的过程\",{\"1\":{\"12\":1}}],[\"相对前面三个比较能接受一些\",{\"1\":{\"849\":1}}],[\"相对来说写的操作比较少\",{\"1\":{\"783\":1}}],[\"相对顺序\",{\"1\":{\"312\":1}}],[\"相互不阻塞的\",{\"1\":{\"767\":1}}],[\"相互之间形成单链表\",{\"1\":{\"671\":1}}],[\"相继对一条记录做改动时\",{\"1\":{\"763\":1}}],[\"相关信息\",{\"1\":{\"866\":1}}],[\"相关数据\",{\"1\":{\"641\":1}}],[\"相关子查询按照一行接一行的顺序执行\",{\"1\":{\"579\":1}}],[\"相关子查询\",{\"0\":{\"579\":1}}],[\"相关\",{\"1\":{\"570\":1}}],[\"相关题目\",{\"0\":{\"272\":1}}],[\"相连单元格高度\",{\"1\":{\"234\":1}}],[\"相连\",{\"1\":{\"231\":1}}],[\"相连的\",{\"1\":{\"231\":1}}],[\"相连的节点\",{\"1\":{\"224\":2}}],[\"相邻两个孩子评分更高的孩子会获得更多的糖果\",{\"1\":{\"359\":1,\"360\":1}}],[\"相邻\",{\"1\":{\"227\":2,\"233\":1}}],[\"相邻元素进行比较\",{\"1\":{\"177\":1}}],[\"相邻的房屋装有相互连通的防盗系统\",{\"1\":{\"114\":1}}],[\"相比于\",{\"1\":{\"835\":1}}],[\"相比就更小\",{\"1\":{\"212\":1}}],[\"相比\",{\"1\":{\"153\":1}}],[\"相反\",{\"1\":{\"274\":1,\"345\":1,\"598\":1}}],[\"相反如果等于\",{\"1\":{\"273\":1}}],[\"相反如果大于\",{\"1\":{\"241\":1}}],[\"相反也一样\",{\"1\":{\"152\":1,\"153\":1}}],[\"相反则去左子树上去搜索\",{\"1\":{\"66\":1}}],[\"相交节点前有\",{\"1\":{\"390\":4}}],[\"相交节点的值为\",{\"1\":{\"390\":2}}],[\"相交\",{\"1\":{\"140\":1}}],[\"相等的字符弹栈\",{\"1\":{\"329\":1}}],[\"相等的\",{\"1\":{\"304\":1}}],[\"相等或者不相等\",{\"1\":{\"261\":1}}],[\"相等则返回\",{\"1\":{\"291\":1}}],[\"相等则保存\",{\"1\":{\"241\":1}}],[\"相等则跳过\",{\"1\":{\"205\":1}}],[\"相等时\",{\"1\":{\"148\":1,\"153\":1,\"155\":1}}],[\"相等\",{\"1\":{\"137\":1,\"148\":1,\"150\":1,\"153\":1,\"177\":1}}],[\"相当于是一\",{\"1\":{\"819\":1}}],[\"相当于java的switch\",{\"1\":{\"559\":1}}],[\"相当于java的if\",{\"1\":{\"559\":1}}],[\"相当于进行了一次跳跃\",{\"1\":{\"352\":1}}],[\"相当于只记录上坡和下坡数之和\",{\"1\":{\"346\":1}}],[\"相当于t要删除元素\",{\"1\":{\"153\":1}}],[\"相当于\",{\"1\":{\"122\":1}}],[\"相当于拆分\",{\"1\":{\"87\":1}}],[\"相同sql查询也会重新获取一次\",{\"1\":{\"799\":1}}],[\"相同点\",{\"1\":{\"589\":1,\"645\":1}}],[\"相同的输入永远可以得到相同的输出\",{\"1\":{\"658\":1}}],[\"相同的x值会产生相同的随机\",{\"1\":{\"548\":1}}],[\"相同的时候\",{\"1\":{\"153\":2}}],[\"相同的话\",{\"1\":{\"137\":2}}],[\"相同\",{\"1\":{\"73\":1,\"362\":1,\"552\":3}}],[\"相较于上一条效率低\",{\"1\":{\"717\":1}}],[\"相较于三数之和\",{\"1\":{\"179\":2}}],[\"相较于二维数组的实现\",{\"1\":{\"92\":1}}],[\"相较于自上而下来说\",{\"1\":{\"37\":1}}],[\"相较于最大深度\",{\"1\":{\"28\":1}}],[\"保全整体的措施就叫做熔断\",{\"1\":{\"472\":1}}],[\"保险丝闭合恢复\",{\"1\":{\"412\":1}}],[\"保险丝跳闸断电\",{\"1\":{\"412\":1,\"477\":1}}],[\"保持字段名和类型的一致性\",{\"1\":{\"583\":1}}],[\"保持其原始结构\",{\"1\":{\"390\":1}}],[\"保持相对顺序\",{\"1\":{\"141\":1}}],[\"保证服务的正常运行\",{\"1\":{\"819\":1}}],[\"保证服务的高可靠性\",{\"1\":{\"409\":1}}],[\"保证读写的正确性\",{\"1\":{\"773\":1}}],[\"保证这些页之间不需要是物理上的连续\",{\"1\":{\"668\":1}}],[\"保证分布式事务\",{\"1\":{\"436\":1}}],[\"保证当前孩子既比左孩子多又比右孩子多\",{\"1\":{\"360\":2}}],[\"保证当前孩子的糖果数量\",{\"1\":{\"360\":3}}],[\"保证当前值为最小值或者队列为空\",{\"1\":{\"335\":1}}],[\"保证右边孩子的糖果数量\",{\"1\":{\"360\":1}}],[\"保证push的元素一定是当前队列中的最小值\",{\"1\":{\"334\":1}}],[\"保证队列的单调递减\",{\"1\":{\"334\":1}}],[\"保证输入为\",{\"1\":{\"223\":1}}],[\"保证和为\",{\"1\":{\"194\":1}}],[\"保证每个学生至少能够分到1个糖果\",{\"1\":{\"360\":1}}],[\"保证每个元素只使用一次\",{\"1\":{\"95\":1}}],[\"保证每个物品仅增加一遍\",{\"1\":{\"92\":2}}],[\"保证val\",{\"1\":{\"65\":1}}],[\"保证\",{\"1\":{\"65\":1,\"216\":1,\"355\":1,\"390\":1,\"454\":1}}],[\"保存在硬盘中\",{\"1\":{\"751\":1}}],[\"保存在内存中\",{\"1\":{\"751\":1}}],[\"保存每个字符的最远下标\",{\"1\":{\"368\":1}}],[\"保存子数组和\",{\"1\":{\"348\":1}}],[\"保存连续的1的个数\",{\"1\":{\"308\":1}}],[\"保存结果\",{\"1\":{\"308\":1}}],[\"保存最大的连续1的个数\",{\"1\":{\"307\":1}}],[\"保存被覆盖的值\",{\"1\":{\"299\":2}}],[\"保存的是移动窗口内所有元素的和\",{\"1\":{\"286\":1}}],[\"保存回文子串\",{\"1\":{\"262\":1}}],[\"保存\",{\"1\":{\"262\":1,\"299\":1,\"667\":1}}],[\"保存大西洋可以到达的地点\",{\"1\":{\"234\":1}}],[\"保存太平洋可以到达的地点\",{\"1\":{\"234\":1}}],[\"保存ip地址的每一段\",{\"1\":{\"201\":2}}],[\"保存所有合法的ip地址\",{\"1\":{\"201\":2}}],[\"保存所有的切割方案\",{\"1\":{\"199\":1}}],[\"保存当前组合\",{\"1\":{\"195\":1}}],[\"保存集合的和\",{\"1\":{\"195\":1}}],[\"保存map中分好组的集合\",{\"1\":{\"165\":1}}],[\"保存字符出现的次数\",{\"1\":{\"163\":1}}],[\"保存爬到第i层有dp\",{\"1\":{\"81\":1}}],[\"保存前n项的和\",{\"1\":{\"79\":1}}],[\"保存前\",{\"1\":{\"79\":1}}],[\"保存遍历的上一个结点的值\",{\"1\":{\"58\":1}}],[\"保存上一个结点的值\",{\"1\":{\"58\":1}}],[\"保存中序遍历的值与下标对应关系\",{\"1\":{\"47\":1}}],[\"保存路径\",{\"1\":{\"39\":1}}],[\"保存路径的栈和保存结点的栈使用一个栈来实现\",{\"1\":{\"39\":1}}],[\"比赛的时间和地点就重复了\",{\"1\":{\"737\":1}}],[\"比赛场地只依赖于比赛编号\",{\"1\":{\"737\":1}}],[\"比赛场地\",{\"1\":{\"737\":1}}],[\"比赛时间\",{\"1\":{\"737\":2}}],[\"比赛时间和比赛场地等属性\",{\"1\":{\"737\":1}}],[\"比赛编号\",{\"1\":{\"737\":3}}],[\"比赛表\",{\"1\":{\"737\":1}}],[\"比方说下边这个查询中只\",{\"1\":{\"710\":1}}],[\"比方说某个列包含值2\",{\"1\":{\"689\":1}}],[\"比方说我们新建一个\",{\"1\":{\"704\":1}}],[\"比方说我们插入的4行记录的主键值分别是\",{\"1\":{\"672\":1}}],[\"比方说我们想让b+树按\",{\"1\":{\"652\":1}}],[\"比方说我们现在有三个环境\",{\"1\":{\"404\":1}}],[\"比我小的向左\",{\"1\":{\"659\":1}}],[\"比我大的向右\",{\"1\":{\"659\":1}}],[\"比用户记录需要的存储空间小多了\",{\"1\":{\"646\":1}}],[\"比整数大多了\",{\"1\":{\"599\":1}}],[\"比例阈值＝慢调用次数➗调用次数\",{\"1\":{\"412\":1}}],[\"比例阈值\",{\"1\":{\"412\":1}}],[\"比左\",{\"1\":{\"360\":1}}],[\"比当前值小的元素都弹出\",{\"1\":{\"334\":1}}],[\"比它小\",{\"1\":{\"276\":1}}],[\"比原来数组小就说明有重复的\",{\"1\":{\"268\":1}}],[\"比对长度即可\",{\"1\":{\"267\":1}}],[\"比如说我们只想恢复某一个库\",{\"1\":{\"832\":1}}],[\"比如使用\",{\"1\":{\"818\":1,\"853\":1}}],[\"比如使用uuid作为主键\",{\"1\":{\"604\":1}}],[\"比如这样\",{\"1\":{\"791\":1}}],[\"比如行锁\",{\"1\":{\"781\":1}}],[\"比如innodb\",{\"1\":{\"779\":1}}],[\"比如数据页或数据表加上意向锁\",{\"1\":{\"771\":1}}],[\"比如银行存钱\",{\"1\":{\"765\":1}}],[\"比如mysql在\",{\"1\":{\"764\":1}}],[\"比如myisam\",{\"1\":{\"704\":1}}],[\"比如page\",{\"1\":{\"753\":1}}],[\"比如去重\",{\"1\":{\"710\":1}}],[\"比如只是一个常数或者是某个列\",{\"1\":{\"707\":1}}],[\"比如varchar\",{\"1\":{\"678\":1}}],[\"比如本页中已经存储了多少条记录\",{\"1\":{\"674\":1}}],[\"比如页的编号\",{\"1\":{\"668\":1}}],[\"比如我们让主库负责写\",{\"1\":{\"819\":1}}],[\"比如我们把id值为8的\",{\"1\":{\"775\":1}}],[\"比如我们\",{\"1\":{\"710\":1}}],[\"比如我们给出的数据顺序是\",{\"1\":{\"659\":1}}],[\"比如我变成\",{\"1\":{\"232\":1}}],[\"比如列为性别\",{\"1\":{\"658\":1}}],[\"比如以读为主或者只读的应用\",{\"1\":{\"655\":1}}],[\"比如uuid\",{\"1\":{\"650\":1}}],[\"比如是根据\",{\"1\":{\"634\":1}}],[\"比如表缓存\",{\"1\":{\"630\":1}}],[\"比如query\",{\"1\":{\"630\":1}}],[\"比如select\",{\"1\":{\"627\":1}}],[\"比如大型网站的中央数据库\",{\"1\":{\"618\":1}}],[\"比如门牌号码101\",{\"1\":{\"604\":1}}],[\"比如涉\",{\"1\":{\"600\":1}}],[\"比如计算化学\",{\"1\":{\"600\":1}}],[\"比如双十一的交易量\",{\"1\":{\"598\":1}}],[\"比如商品编号\",{\"1\":{\"598\":1}}],[\"比如车站每日的客流量等\",{\"1\":{\"598\":1}}],[\"比如统计工厂的固定资产库存数量等\",{\"1\":{\"598\":1}}],[\"比如系统设定取值范围很小且固定的场景\",{\"1\":{\"598\":1}}],[\"比如设置为5意味着\",{\"1\":{\"476\":1}}],[\"比如某些配置文件中的内容大部分都是相同的\",{\"1\":{\"452\":1}}],[\"比如订单模块\",{\"1\":{\"426\":1}}],[\"比如\",{\"1\":{\"92\":1,\"177\":1,\"179\":1,\"197\":1,\"201\":1,\"218\":1,\"288\":1,\"298\":1,\"313\":1,\"366\":1,\"370\":1,\"410\":1,\"419\":1,\"510\":2,\"618\":1,\"658\":1,\"680\":1,\"689\":1,\"704\":1,\"710\":2,\"731\":1,\"732\":1,\"749\":1,\"755\":3,\"763\":1,\"773\":1,\"776\":1,\"791\":1,\"797\":1,\"822\":1,\"823\":3}}],[\"比\",{\"1\":{\"64\":4,\"589\":1}}],[\"比较重要的两对option参数是\",{\"1\":{\"809\":1}}],[\"比较记录的大小就是比较主键的大小\",{\"1\":{\"672\":1}}],[\"比较两个字符串\",{\"1\":{\"552\":1}}],[\"比较字符串s1\",{\"1\":{\"552\":1}}],[\"比较的结果为假则返回0\",{\"1\":{\"528\":1}}],[\"比较的结果为真则返回1\",{\"1\":{\"528\":1}}],[\"比较运算符经常被用来作为select查询语句的条件来使用\",{\"1\":{\"528\":1}}],[\"比较运算符用来对表达式左边的操作数和右边的操作数进行比较\",{\"1\":{\"528\":1}}],[\"比较运算符\",{\"0\":{\"528\":1}}],[\"比较\",{\"1\":{\"360\":1}}],[\"比较数组中第一个元素\",{\"1\":{\"338\":1}}],[\"比较头尾字符\",{\"1\":{\"199\":1}}],[\"比较时被覆盖\",{\"1\":{\"107\":1}}],[\"比较左子树的右孩子结点和右子树的左孩子结点\",{\"1\":{\"33\":1}}],[\"比较左子树的左孩子结点和右子树的右孩子结点\",{\"1\":{\"33\":1}}],[\"比较它们的值\",{\"1\":{\"33\":1}}],[\"此文字有脚注^first\",{\"1\":{\"875\":1}}],[\"此语句必须执行\",{\"1\":{\"825\":1}}],[\"此参数的最大和默认值是1gb\",{\"1\":{\"823\":1}}],[\"此\",{\"1\":{\"598\":1}}],[\"此类数据库可存放并获取文档\",{\"1\":{\"510\":1}}],[\"此步骤省略~\",{\"1\":{\"432\":1}}],[\"此步判断其实已经包在\",{\"1\":{\"62\":1}}],[\"此项目包含开发分布式应用微服务的必需组件\",{\"1\":{\"399\":1}}],[\"此篇中\",{\"1\":{\"339\":1}}],[\"此例子中就是\",{\"1\":{\"277\":2}}],[\"此道题目很明显是情形一\",{\"1\":{\"250\":1}}],[\"此外\",{\"1\":{\"225\":1,\"510\":1,\"755\":1,\"818\":1,\"822\":1}}],[\"此题看着并不难\",{\"1\":{\"279\":1}}],[\"此题也不例外\",{\"1\":{\"261\":1}}],[\"此题的唯一一个难点\",{\"1\":{\"195\":1}}],[\"此题中\",{\"1\":{\"72\":1}}],[\"此处的回溯有返回值是因为我们只需要找到一种合理的行程返回即可\",{\"1\":{\"213\":1}}],[\"此处不能在像\",{\"1\":{\"207\":2}}],[\"此处需要注意的是\",{\"1\":{\"193\":1}}],[\"此处我将数字字符串转换成字符数组\",{\"1\":{\"193\":1}}],[\"此处就是删除结点的逻辑\",{\"1\":{\"68\":1}}],[\"此处也可以用返回值来确定要删除的结点\",{\"1\":{\"68\":1}}],[\"此时请求c过来查询缓存没有\",{\"1\":{\"848\":1}}],[\"此时并不会重新生成\",{\"1\":{\"800\":1}}],[\"此时student\",{\"1\":{\"800\":1}}],[\"此时sql语句查询出来id=1的一条数据\",{\"1\":{\"800\":1}}],[\"此时innodb自动生成了一个ix\",{\"1\":{\"771\":2}}],[\"此时由于没有提交事务\",{\"1\":{\"767\":1}}],[\"此时加锁\",{\"1\":{\"765\":1}}],[\"此时若是\",{\"1\":{\"763\":1}}],[\"此时事务b对该数据进行了修改并提\",{\"1\":{\"746\":1}}],[\"此时a账户余额为\",{\"1\":{\"741\":1}}],[\"此时可以使用\",{\"1\":{\"529\":1}}],[\"此时还有额外的两个设置属性\",{\"1\":{\"476\":1}}],[\"此时访问\",{\"1\":{\"451\":1,\"489\":1}}],[\"此时已经将俩个模块注册到\",{\"1\":{\"451\":1}}],[\"此时已经出现相同的数了\",{\"1\":{\"170\":1}}],[\"此时在\",{\"1\":{\"454\":1,\"464\":1}}],[\"此时在发送请求时\",{\"1\":{\"435\":1}}],[\"此时在这俩种选择当中\",{\"1\":{\"360\":1}}],[\"此时如果出发流控规则\",{\"1\":{\"422\":1}}],[\"此时如果当前孩子\",{\"1\":{\"360\":2}}],[\"此时pa=pb\",{\"1\":{\"392\":1}}],[\"此时pre就是反转后的头结点\",{\"1\":{\"382\":1}}],[\"此时cur和pre指向的都是当前结点\",{\"1\":{\"382\":1}}],[\"此时父节点就是有覆盖的状态\",{\"1\":{\"372\":1}}],[\"此时需要状态转移的公式\",{\"1\":{\"372\":1}}],[\"此时更新\",{\"1\":{\"366\":1}}],[\"此时有俩种选择\",{\"1\":{\"360\":1}}],[\"此时油量充足\",{\"1\":{\"356\":1}}],[\"此时油量不足\",{\"1\":{\"356\":1}}],[\"此时油箱有\",{\"1\":{\"355\":8}}],[\"此时l=5\",{\"1\":{\"334\":1}}],[\"此时l=4\",{\"1\":{\"334\":1}}],[\"此时l=3\",{\"1\":{\"334\":1}}],[\"此时l=2\",{\"1\":{\"334\":1}}],[\"此时l=0\",{\"1\":{\"334\":1}}],[\"此时输出栈的顺序才和队列一致\",{\"1\":{\"322\":1}}],[\"此时的\",{\"1\":{\"313\":1}}],[\"此时说明\",{\"1\":{\"273\":1}}],[\"此时我就想到了能不能使用set集合自动去重\",{\"1\":{\"177\":1}}],[\"此时要判断\",{\"1\":{\"155\":1}}],[\"此时就不符合第三范式\",{\"1\":{\"737\":1}}],[\"此时就不是从气球的尾端射出\",{\"1\":{\"364\":1}}],[\"此时就可以看到c2被阻塞\",{\"1\":{\"767\":1}}],[\"此时就可以随心所以得进行限流配置了\",{\"1\":{\"422\":1}}],[\"此时就可以使用sentinel提供的授权规则来实现\",{\"1\":{\"418\":1}}],[\"此时就要进行贪心选择\",{\"1\":{\"360\":2}}],[\"此时就将\",{\"1\":{\"279\":1}}],[\"此时就是把利润分解为每天为单位的维度\",{\"1\":{\"122\":1}}],[\"此时就达到了最近的叶子结点\",{\"1\":{\"28\":1}}],[\"此时target\",{\"1\":{\"99\":1}}],[\"此时接入上面返回的左子树或者右子树\",{\"1\":{\"70\":1}}],[\"此时root为要删除的结点\",{\"1\":{\"68\":1}}],[\"此时\",{\"1\":{\"60\":1,\"97\":2,\"276\":2,\"279\":1,\"280\":1,\"497\":1,\"690\":1,\"800\":1}}],[\"此时不再是输出结点\",{\"1\":{\"39\":1}}],[\"此时队列中的结点是\",{\"1\":{\"12\":1}}],[\"本页面就是一个示例\",{\"1\":{\"858\":1}}],[\"本地的日志文件\",{\"1\":{\"813\":1}}],[\"本身是一个函数\",{\"1\":{\"658\":1}}],[\"本身也是公共祖先\",{\"1\":{\"62\":1}}],[\"本部门\",{\"1\":{\"612\":1}}],[\"本部门的平均工资\",{\"1\":{\"579\":1}}],[\"本来打算节约存储的\",{\"1\":{\"604\":1}}],[\"本次只讲解了\",{\"1\":{\"426\":1}}],[\"本案例的dataid是\",{\"1\":{\"403\":1}}],[\"本文档只讲解微服务的基础使用\",{\"1\":{\"398\":1,\"439\":1}}],[\"本节点有覆盖\",{\"1\":{\"372\":2}}],[\"本节点有摄像头\",{\"1\":{\"372\":2}}],[\"本节点所连接的其他节点\",{\"1\":{\"222\":1}}],[\"本层集合中元素\",{\"1\":{\"185\":2}}],[\"本题状态转移没有择优的过程\",{\"1\":{\"372\":1}}],[\"本题和动态规划\",{\"1\":{\"153\":1}}],[\"本题和\",{\"1\":{\"73\":1}}],[\"本题中\",{\"1\":{\"36\":1}}],[\"本题中递归程序占用的栈空间不算做额外的空间复杂度\",{\"1\":{\"23\":1}}],[\"因\",{\"1\":{\"598\":1}}],[\"因而\",{\"1\":{\"299\":1}}],[\"因为无法进行预发布\",{\"1\":{\"836\":1}}],[\"因为确实太多了\",{\"1\":{\"835\":1}}],[\"因为不同\",{\"1\":{\"835\":1}}],[\"因为mysql根据\",{\"1\":{\"812\":1}}],[\"因为mysql执行单条insert语句插入多行数据比使用多条insert语句\",{\"1\":{\"542\":1}}],[\"因为该记录并没有更早的版本\",{\"1\":{\"794\":1}}],[\"因为该题不能进行排序\",{\"1\":{\"207\":2}}],[\"因为写的操作具有\",{\"1\":{\"783\":1}}],[\"因为锁会占用内存空间\",{\"1\":{\"779\":1}}],[\"因为一个事务的\",{\"1\":{\"810\":1}}],[\"因为一个页中可以有多个行记录\",{\"1\":{\"779\":1}}],[\"因为一对一可以创建成一张表\",{\"1\":{\"513\":1}}],[\"因为要一条一条执行\",{\"1\":{\"772\":1}}],[\"因为要判断队首元素是否在滑动窗口之内\",{\"1\":{\"334\":1}}],[\"因为自增锁有三种模式\",{\"1\":{\"772\":1}}],[\"因为此时redo\",{\"1\":{\"757\":1}}],[\"因为此时最长重复子数组为1\",{\"1\":{\"137\":1}}],[\"因为你定义了一个状态\",{\"1\":{\"741\":2}}],[\"因为建立与维护临时表要付出很大成本的\",{\"1\":{\"710\":1}}],[\"因为开启慢查询日志会或多或少带来一定的性能影响\",{\"1\":{\"697\":1}}],[\"因为更新数据的时候\",{\"1\":{\"690\":1}}],[\"因为每增加一张表就相当于增加了一次嵌套的循环\",{\"1\":{\"689\":1}}],[\"因为数据存储在文件中只能按照一种顺序进行存储\",{\"1\":{\"686\":1}}],[\"因为数据都存储在叶子结点上\",{\"1\":{\"662\":1}}],[\"因为数组中的存储空间是连续的\",{\"1\":{\"279\":1}}],[\"因为将会导致被更新的行移动\",{\"1\":{\"650\":1}}],[\"因为聚簇索引将索引和数据保存在同一个b+树中\",{\"1\":{\"650\":1}}],[\"因为各个页中的记录并没有规律\",{\"1\":{\"643\":1}}],[\"因为查询缓存往往效率不高\",{\"1\":{\"634\":1}}],[\"因为查询语句使用的非常的频繁\",{\"1\":{\"517\":1}}],[\"因为外键约束的系统开销而变得非常慢\",{\"1\":{\"618\":1}}],[\"因为被依赖\",{\"1\":{\"618\":1}}],[\"因为ename不是整数类\",{\"1\":{\"617\":1}}],[\"因为主键是数据记录的唯一标识\",{\"1\":{\"616\":1}}],[\"因为对于innodb数据表\",{\"1\":{\"604\":1}}],[\"因为varchar每次存储都要有额外的计算\",{\"1\":{\"604\":1}}],[\"因为varchar还要占个\",{\"1\":{\"604\":1}}],[\"因为他固定长度\",{\"1\":{\"604\":1}}],[\"因为他们是相邻的\",{\"1\":{\"114\":1}}],[\"因为浮点数是不准确的\",{\"1\":{\"599\":1}}],[\"因为很多时候查询需要从结果集中获取数据\",{\"1\":{\"568\":1}}],[\"因为innodb真的要去数一遍\",{\"1\":{\"562\":1}}],[\"因为划分的片段数较少\",{\"1\":{\"367\":1}}],[\"因为返程需要消耗\",{\"1\":{\"355\":1}}],[\"因为没有足够的汽油可以让你行驶到下一个加油站\",{\"1\":{\"355\":1}}],[\"因为反转偶数次仍然是它本身\",{\"1\":{\"354\":1}}],[\"因为差值\",{\"1\":{\"345\":1}}],[\"因为最终都是到矩阵中间的位置结束\",{\"1\":{\"288\":1}}],[\"因为在\",{\"1\":{\"271\":1}}],[\"因为当前这个\",{\"1\":{\"271\":1}}],[\"因为当前背包的价值由前一个背包的价值得来\",{\"1\":{\"93\":1}}],[\"因为首尾元素相等\",{\"1\":{\"261\":1}}],[\"因为下标从\",{\"1\":{\"241\":1}}],[\"因为是由低\",{\"1\":{\"234\":1}}],[\"因为岛屿只能包含水平或垂直这四个方向上的\",{\"1\":{\"227\":1}}],[\"因为这样我们才能拼接更多的区间\",{\"1\":{\"366\":1}}],[\"因为这样属于同时参与了多笔交易\",{\"1\":{\"123\":1}}],[\"因为这两种方式都是用了递归\",{\"1\":{\"218\":1}}],[\"因为我们现在只有两张\",{\"1\":{\"357\":1}}],[\"因为我们要根据首元素判断是否合并\",{\"1\":{\"295\":1}}],[\"因为我们定义的是左闭右开区间\",{\"1\":{\"271\":1}}],[\"因为我们定义的是左闭右闭区间\",{\"1\":{\"271\":1}}],[\"因为我们for循环从0开始\",{\"1\":{\"211\":1}}],[\"因为我们需要使用\",{\"1\":{\"193\":1}}],[\"因为排完序后会影响原序列的递增顺序\",{\"1\":{\"207\":1}}],[\"因为10\",{\"1\":{\"189\":1}}],[\"因为只剩下3个元素\",{\"1\":{\"188\":1}}],[\"因为把重复的元素也都计算了一遍\",{\"1\":{\"177\":1}}],[\"因为它阻止不了除了程序以外的数据库操作\",{\"1\":{\"783\":1}}],[\"因为它把每一行都保存在内存中了\",{\"1\":{\"725\":1}}],[\"因为它们已经是无重叠的了\",{\"1\":{\"365\":1}}],[\"因为它在边界上\",{\"1\":{\"229\":1}}],[\"因为它包含了另外一个质因数\",{\"1\":{\"172\":1}}],[\"因为它含\",{\"1\":{\"100\":1}}],[\"因为空集是所有字符串的子集\",{\"1\":{\"148\":1}}],[\"因为空集是所有字符串子集\",{\"1\":{\"148\":1}}],[\"因为从\",{\"1\":{\"140\":1}}],[\"因为卖出价格需要大于买入价格\",{\"1\":{\"119\":1}}],[\"因为0是合法的\",{\"1\":{\"111\":1}}],[\"因为\",{\"1\":{\"110\":2,\"113\":1,\"134\":1,\"174\":1,\"177\":1,\"201\":2,\"267\":1,\"271\":2,\"436\":1,\"689\":1,\"737\":1}}],[\"因为根据定义最近公共祖先节点可以为节点本身\",{\"1\":{\"61\":1,\"63\":1}}],[\"因此数据库系统需要在\",{\"1\":{\"768\":1}}],[\"因此产生了锁\",{\"1\":{\"760\":1}}],[\"因此删除某一个仓库\",{\"1\":{\"737\":1}}],[\"因此复杂度为\",{\"1\":{\"729\":1}}],[\"因此时间复杂度为\",{\"1\":{\"729\":1}}],[\"因此name就无法使用索引\",{\"1\":{\"718\":1}}],[\"因此没有索引可以使用\",{\"1\":{\"716\":1}}],[\"因此查询优化器可能对涉及子查询的查询语句进行重写\",{\"1\":{\"702\":1}}],[\"因此无须建立索引\",{\"1\":{\"690\":1}}],[\"因此无论使用\",{\"1\":{\"604\":1}}],[\"因此范围查找可以通过指针连接查找\",{\"1\":{\"662\":1}}],[\"因此同样的磁盘页大小\",{\"1\":{\"662\":1}}],[\"因此从聚簇索引中获取数据比非\",{\"1\":{\"650\":1}}],[\"因此就需要在增加一个目录页\",{\"1\":{\"646\":1}}],[\"因此就无需\",{\"1\":{\"271\":1}}],[\"因此占用内存\",{\"1\":{\"636\":1}}],[\"因此每种存储引擎的索引不一定完全相同\",{\"1\":{\"642\":1}}],[\"因此每执行一次外部查询\",{\"1\":{\"579\":1}}],[\"因此每一种排列方式元素个数肯定都是一样的\",{\"1\":{\"209\":2}}],[\"因此会将\",{\"1\":{\"763\":1}}],[\"因此会报错\",{\"1\":{\"522\":1}}],[\"因此会计入失败的请求\",{\"1\":{\"477\":1}}],[\"因此对于cidr地址\",{\"1\":{\"495\":1}}],[\"因此空结点只能是有覆盖的状态\",{\"1\":{\"372\":1}}],[\"因此为了避免产生笛卡尔积\",{\"1\":{\"533\":1}}],[\"因此为了保证头结点能和其他结点保持一致的操作\",{\"1\":{\"389\":1}}],[\"因此为了尽可能的让气球重叠\",{\"1\":{\"364\":1}}],[\"因此为了使花费最少\",{\"1\":{\"83\":1}}],[\"因此更新新的起始点\",{\"1\":{\"356\":1}}],[\"因此将\",{\"1\":{\"352\":1}}],[\"因此永远也到不了\",{\"1\":{\"350\":2}}],[\"因此按照value值进行排序\",{\"1\":{\"338\":1}}],[\"因此再次步\",{\"1\":{\"337\":1}}],[\"因此循环条件应该是\",{\"1\":{\"313\":1}}],[\"因此循环应该从下到上\",{\"1\":{\"261\":1}}],[\"因此最终位置为\",{\"1\":{\"304\":1}}],[\"因此起点元素的位置为\",{\"1\":{\"304\":1}}],[\"因此有\",{\"1\":{\"299\":2}}],[\"因此有多少元素就需要多少的编辑距离\",{\"1\":{\"152\":1}}],[\"因此得出\",{\"1\":{\"299\":1}}],[\"因此sum也要减去移动的元素值\",{\"1\":{\"286\":1}}],[\"因此如果不是特别大的内容\",{\"1\":{\"605\":1}}],[\"因此如果在sql题目中有\",{\"1\":{\"539\":1}}],[\"因此如果\",{\"1\":{\"277\":2}}],[\"因此保留mid的取值\",{\"1\":{\"276\":1}}],[\"因此可以借助于\",{\"1\":{\"867\":1}}],[\"因此可以被访问\",{\"1\":{\"800\":1}}],[\"因此可以利用双指针\",{\"1\":{\"282\":1}}],[\"因此可以利用二分法找无序的那一部分\",{\"1\":{\"276\":1}}],[\"因此可以使用双指针算法\",{\"1\":{\"177\":1}}],[\"因此可以使用01背包求解\",{\"1\":{\"101\":1}}],[\"因此使用\",{\"1\":{\"274\":1,\"468\":1}}],[\"因此需要查询俩次b+树\",{\"1\":{\"651\":1}}],[\"因此需要单独的创建\",{\"1\":{\"489\":1}}],[\"因此需要配置\",{\"1\":{\"454\":1}}],[\"因此需要使用一个额外变量\",{\"1\":{\"299\":1}}],[\"因此需要向左移动\",{\"1\":{\"273\":1}}],[\"因此需要向右移动\",{\"1\":{\"273\":1}}],[\"因此需要从\",{\"1\":{\"271\":1}}],[\"因此需要将上一个元素清空\",{\"1\":{\"60\":1}}],[\"因此需要将当前节点的值放入集合中\",{\"1\":{\"60\":1}}],[\"因此跳过\",{\"1\":{\"234\":1}}],[\"因此跳过nums\",{\"1\":{\"211\":1}}],[\"因此要回溯到上一个结点继续搜索\",{\"1\":{\"224\":1}}],[\"因此递归\",{\"1\":{\"222\":1}}],[\"因此递推公式为\",{\"1\":{\"120\":1,\"122\":1}}],[\"因此递推关系式为\",{\"1\":{\"113\":1,\"128\":1}}],[\"因此不可以被访问\",{\"1\":{\"800\":1}}],[\"因此不需要返回值\",{\"1\":{\"217\":1}}],[\"因此不能在简单的判断\",{\"1\":{\"179\":1}}],[\"因此只有\",{\"1\":{\"211\":1}}],[\"因此元素个数肯定能是和原序列个数相等的\",{\"1\":{\"209\":1}}],[\"因此当我们使用\",{\"1\":{\"689\":1}}],[\"因此当\",{\"1\":{\"205\":1,\"304\":2,\"386\":1}}],[\"因此仍然需要使用\",{\"1\":{\"203\":1}}],[\"因此以得出\",{\"1\":{\"188\":1}}],[\"因此所有的回溯都可以抽象成树结构\",{\"1\":{\"184\":1}}],[\"因此存储关系为\",{\"1\":{\"175\":1}}],[\"因此选用map\",{\"1\":{\"175\":1}}],[\"因此遍历顺序应该为\",{\"1\":{\"155\":1}}],[\"因此它的全部质因数是\",{\"1\":{\"172\":1}}],[\"因此它的连线数为2\",{\"1\":{\"141\":1}}],[\"因此它相同的结点一定是相邻的\",{\"1\":{\"60\":1}}],[\"因此在我们创建索引\",{\"1\":{\"718\":1}}],[\"因此在页结构中专门设计了页目录这个模块\",{\"1\":{\"673\":1}}],[\"因此在高并发的场景下建议使用\",{\"1\":{\"655\":1}}],[\"因此在java中我们可以直接用\",{\"1\":{\"391\":1}}],[\"因此在\",{\"1\":{\"271\":1,\"420\":1,\"770\":1}}],[\"因此在遍历过程中我们需要一个额外变量来保存最大值\",{\"1\":{\"143\":1}}],[\"因此在推导递推公式时\",{\"1\":{\"139\":1}}],[\"因此在使用一维数组时\",{\"1\":{\"95\":1}}],[\"因此长度为\",{\"1\":{\"132\":1}}],[\"因此买入的时候还要算上之前买卖的利润\",{\"1\":{\"122\":1}}],[\"因此买入的时候一定是负利润\",{\"1\":{\"122\":1}}],[\"因此利润增加\",{\"1\":{\"122\":1}}],[\"因此利润一定是股票的负数\",{\"1\":{\"120\":1}}],[\"因此是完全背包\",{\"1\":{\"109\":1}}],[\"因此先遍历背包或者是物品都可以\",{\"1\":{\"107\":1}}],[\"因此这种遍历顺序是求全排列的遍历顺序\",{\"1\":{\"103\":1}}],[\"因此这种遍历顺序正是求组合的遍历顺序\",{\"1\":{\"103\":1}}],[\"因此答案是\",{\"1\":{\"100\":1}}],[\"因此该题的关系式为\",{\"1\":{\"95\":1}}],[\"因此求出来一定是正整数且最少\",{\"1\":{\"97\":1}}],[\"因此求\",{\"1\":{\"89\":1}}],[\"因此一层一层的从左往右遍历即可\",{\"1\":{\"85\":1}}],[\"因此第i层的方法其实就是\",{\"1\":{\"81\":1}}],[\"因此清空res集合\",{\"1\":{\"60\":1}}],[\"因此postorder\",{\"1\":{\"47\":1}}],[\"因此我们重新创建一个\",{\"1\":{\"447\":1}}],[\"因此我们就可以假设将起始点设在\",{\"1\":{\"356\":1}}],[\"因此我们直接套用回溯算法模板\",{\"1\":{\"224\":1}}],[\"因此我们仍然需要使用\",{\"1\":{\"213\":1}}],[\"因此我们还要判断集合中是否有这个元素\",{\"1\":{\"209\":1}}],[\"因此我们还需要一个变量\",{\"1\":{\"348\":1}}],[\"因此我们还需要初始化第一行\",{\"1\":{\"91\":1}}],[\"因此我们还需要再多一层比较\",{\"1\":{\"60\":1}}],[\"因此我们不能和\",{\"1\":{\"207\":1}}],[\"因此我们先通过map集合找出数字对应的集合\",{\"1\":{\"193\":1}}],[\"因此我们要从后往前\",{\"1\":{\"370\":1}}],[\"因此我们要进行俩次遍历\",{\"1\":{\"360\":1}}],[\"因此我们要用双层\",{\"1\":{\"217\":1}}],[\"因此我们要定义一个\",{\"1\":{\"155\":1}}],[\"因此我们要初始化俩天的买入\",{\"1\":{\"128\":1}}],[\"因此我们要采用后序遍历\",{\"1\":{\"117\":1}}],[\"因此我们在遍历过程维护一个最低价格\",{\"1\":{\"120\":1}}],[\"因此我们需要一个\",{\"1\":{\"187\":1}}],[\"因此我们需要一个指针\",{\"1\":{\"7\":1}}],[\"因此我们需要初始化\",{\"1\":{\"152\":1}}],[\"因此我们需要保存上一个结点的值\",{\"1\":{\"58\":1}}],[\"因此我们可以将多个目录项放到一个页中\",{\"1\":{\"645\":1}}],[\"因此我们可以考虑使用递归\",{\"1\":{\"386\":1}}],[\"因此我们可以考虑额外使用一个指针\",{\"1\":{\"382\":1}}],[\"因此我们可以考虑跳过重复元素\",{\"1\":{\"177\":1}}],[\"因此我们可以得出结论\",{\"1\":{\"298\":1}}],[\"因此我们可以先升序\",{\"1\":{\"258\":1}}],[\"因此我们可以使用临时变量保存\",{\"1\":{\"299\":1}}],[\"因此我们可以使用临时变量\",{\"1\":{\"299\":1}}],[\"因此我们可以使用一个\",{\"1\":{\"211\":1}}],[\"因此我们可以使用递归判断所有的子树是否为二叉树\",{\"1\":{\"37\":1}}],[\"因此我们可以利用\",{\"1\":{\"170\":1}}],[\"因此我们可以通过回文串的性质下手\",{\"1\":{\"155\":1}}],[\"因此我们可以设两个变量\",{\"1\":{\"115\":1}}],[\"因此我们可以推出关系式为\",{\"1\":{\"111\":1}}],[\"因此我们可以看出来使用完全背包进行求解\",{\"1\":{\"103\":1}}],[\"因此我们可以认为\",{\"1\":{\"95\":1}}],[\"因此我们可以用\",{\"1\":{\"87\":1}}],[\"因此我们可以判断当前结点是否比上一个节点大\",{\"1\":{\"56\":1}}],[\"因此返回它的上一结点pre\",{\"1\":{\"382\":1}}],[\"因此返回\",{\"1\":{\"17\":1,\"390\":1}}],[\"因此\",{\"1\":{\"12\":1,\"83\":1,\"95\":1,\"101\":1,\"117\":1,\"148\":1,\"153\":1,\"193\":1,\"195\":1,\"209\":1,\"211\":1,\"240\":3,\"261\":1,\"313\":1,\"355\":2,\"361\":1,\"447\":1,\"472\":1,\"599\":3,\"650\":2,\"727\":1,\"773\":1,\"864\":1}}],[\"xtrabackup\",{\"1\":{\"830\":1}}],[\"x型记录锁\",{\"1\":{\"775\":1}}],[\"x锁的\",{\"1\":{\"770\":1}}],[\"x锁\",{\"0\":{\"770\":1},\"1\":{\"770\":2,\"771\":1}}],[\"xx\",{\"1\":{\"618\":2}}],[\"xxx\",{\"1\":{\"651\":1}}],[\"xxxgatewayfilterfactory\",{\"1\":{\"504\":2}}],[\"xxxroutepredicatefactory\",{\"1\":{\"497\":2}}],[\"x为弧度值\",{\"1\":{\"549\":1}}],[\"xsd\",{\"1\":{\"441\":2}}],[\"xsi\",{\"1\":{\"441\":1}}],[\"xsi=\",{\"1\":{\"441\":1}}],[\"xstart\",{\"1\":{\"363\":4}}],[\"xmlmapper\",{\"1\":{\"442\":1}}],[\"xml<\",{\"1\":{\"442\":2}}],[\"xmlschema\",{\"1\":{\"441\":1}}],[\"xmlns\",{\"1\":{\"441\":1}}],[\"xmlns=\",{\"1\":{\"441\":1}}],[\"xml\",{\"1\":{\"429\":1,\"431\":1,\"432\":1,\"433\":1,\"434\":1,\"441\":1,\"442\":2,\"443\":1,\"452\":1,\"469\":2}}],[\"xid检查\",{\"1\":{\"432\":1}}],[\"xid`\",{\"1\":{\"428\":2}}],[\"xid\",{\"1\":{\"426\":6,\"432\":4}}],[\"xa\",{\"1\":{\"426\":1,\"432\":1}}],[\"x``end\",{\"1\":{\"363\":2}}],[\"x``start\",{\"1\":{\"363\":1}}],[\"xend之间的气球\",{\"1\":{\"363\":1}}],[\"xend\",{\"1\":{\"363\":2}}],[\"xy\",{\"1\":{\"363\":1}}],[\"x++\",{\"1\":{\"305\":1}}],[\"x\",{\"1\":{\"61\":3,\"63\":3,\"84\":1,\"96\":6,\"99\":7,\"100\":2,\"151\":1,\"193\":2,\"226\":2,\"227\":1,\"228\":13,\"229\":1,\"230\":13,\"231\":36,\"232\":18,\"233\":1,\"234\":6,\"287\":1,\"303\":1,\"305\":7,\"321\":3,\"323\":2,\"363\":3,\"369\":2,\"399\":12,\"444\":2,\"532\":4,\"548\":12,\"549\":9,\"550\":7,\"551\":4,\"552\":1,\"767\":1,\"771\":1,\"832\":1,\"877\":1}}],[\"qps\",{\"1\":{\"411\":2}}],[\"qps表示通过qps进行限流\",{\"1\":{\"409\":1}}],[\"quarter\",{\"1\":{\"555\":1}}],[\"quarkus\",{\"1\":{\"406\":1}}],[\"quickstart\",{\"1\":{\"485\":1}}],[\"query=username\",{\"1\":{\"494\":1}}],[\"query\",{\"0\":{\"494\":1,\"696\":1},\"1\":{\"429\":1,\"494\":2,\"516\":1,\"696\":5,\"697\":2,\"698\":7,\"767\":1,\"771\":2,\"805\":1,\"809\":1,\"832\":2}}],[\"que\",{\"1\":{\"362\":3}}],[\"queue<int\",{\"1\":{\"226\":1,\"228\":1,\"230\":1,\"232\":1}}],[\"queue<object>\",{\"1\":{\"39\":1}}],[\"queue<node>\",{\"1\":{\"20\":1,\"24\":1}}],[\"queue<treenode>\",{\"1\":{\"12\":3,\"14\":1,\"16\":1,\"22\":1,\"29\":1,\"31\":1,\"39\":1,\"43\":2,\"54\":1}}],[\"queue\",{\"1\":{\"12\":20,\"14\":7,\"16\":7,\"18\":7,\"20\":6,\"22\":7,\"24\":8,\"26\":7,\"28\":7,\"29\":6,\"31\":6,\"33\":10,\"35\":7,\"39\":16,\"43\":13,\"54\":6,\"226\":5,\"228\":5,\"230\":5,\"232\":5,\"321\":4,\"335\":8,\"361\":3,\"481\":1}}],[\"q在root的左右子树中\",{\"1\":{\"62\":1}}],[\"q=root\",{\"1\":{\"62\":1}}],[\"q和p在二叉树的异侧\",{\"1\":{\"62\":1}}],[\"q的公共祖先\",{\"1\":{\"62\":1}}],[\"q\",{\"1\":{\"61\":7,\"62\":5,\"63\":5,\"64\":12,\"81\":4,\"193\":2,\"214\":10,\"215\":8,\"334\":4,\"832\":1}}],[\"百度百科中最近公共祖先的定义为\",{\"1\":{\"61\":1,\"63\":1}}],[\"满\",{\"1\":{\"835\":1}}],[\"满外连接\",{\"1\":{\"541\":1}}],[\"满足特定查找算法\",{\"1\":{\"642\":1}}],[\"满足胃口\",{\"1\":{\"344\":1}}],[\"满足\",{\"1\":{\"61\":1,\"63\":1,\"176\":1,\"369\":1}}],[\"满足如下定义\",{\"1\":{\"59\":1}}],[\"满二叉树\",{\"1\":{\"0\":1}}],[\"假如另一个事务已经修改了记录但是尚未提交\",{\"1\":{\"797\":1}}],[\"假如该事务修改的这些页面可能并不相邻\",{\"1\":{\"749\":1}}],[\"假如只select\",{\"1\":{\"727\":1}}],[\"假如数据\",{\"1\":{\"583\":1}}],[\"假如被占用会自动从8719开始依次+1扫描\",{\"1\":{\"408\":1,\"420\":1}}],[\"假如元素等于3\",{\"1\":{\"350\":1}}],[\"假如第\",{\"1\":{\"122\":1}}],[\"假如表达式中的加法总和为\",{\"1\":{\"99\":1}}],[\"假定所有机票至少存在一种合理的行程\",{\"1\":{\"212\":1}}],[\"假定\",{\"1\":{\"59\":1}}],[\"假设在高并发的场景中\",{\"1\":{\"848\":1}}],[\"假设请求a先执行数据库写操作\",{\"1\":{\"847\":1}}],[\"假设现在有事务\",{\"1\":{\"800\":1}}],[\"假设现在表\",{\"1\":{\"800\":1}}],[\"假设之后两个事务id分别为\",{\"1\":{\"794\":1}}],[\"假设事务\",{\"1\":{\"772\":1}}],[\"假设第一次筛选出\",{\"1\":{\"728\":1}}],[\"假设第一个位置为\",{\"1\":{\"291\":1}}],[\"假设第一个元素为最大值\",{\"1\":{\"51\":1}}],[\"假设没有icp\",{\"1\":{\"728\":1}}],[\"假设输入内容有微小偏差\",{\"1\":{\"658\":1}}],[\"假设以c2列作为二级索引\",{\"1\":{\"651\":1}}],[\"假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录\",{\"1\":{\"648\":1}}],[\"假设所有操作都是有效的\",{\"1\":{\"321\":1}}],[\"假设微服务a调用微服务b和微服务c\",{\"1\":{\"471\":1}}],[\"假设找到的被删除结点的前一个结点为\",{\"1\":{\"389\":1}}],[\"假设当前数字比前一个数字大时\",{\"1\":{\"370\":1}}],[\"假设当前孩子的评分是相邻之间最高的\",{\"1\":{\"360\":1}}],[\"假设我想查询每一个员工所在得部门名称\",{\"1\":{\"533\":1}}],[\"假设我有两个集合\",{\"1\":{\"532\":1}}],[\"假设我用卡号作为主键\",{\"1\":{\"732\":1}}],[\"假设我用end\",{\"1\":{\"366\":1}}],[\"假设我用\",{\"1\":{\"356\":1}}],[\"假设我们要执行这样一条sql\",{\"1\":{\"651\":1}}],[\"假设我们有百万条数据\",{\"1\":{\"565\":1}}],[\"假设我们设为\",{\"1\":{\"391\":1}}],[\"假设我们用\",{\"1\":{\"195\":1,\"348\":1}}],[\"假设我们\",{\"1\":{\"193\":1}}],[\"假设我们从第0层一次性爬俩步到第二层\",{\"1\":{\"83\":1}}],[\"假设对角线用\",{\"1\":{\"304\":1}}],[\"假设起点元素matrix\",{\"1\":{\"299\":1}}],[\"假设用\",{\"1\":{\"293\":1,\"356\":1,\"391\":1}}],[\"假设你只修改\",{\"1\":{\"749\":1}}],[\"假设你是一位很棒的家长\",{\"1\":{\"343\":1}}],[\"假设你有\",{\"1\":{\"274\":1}}],[\"假设你正在爬楼梯\",{\"1\":{\"80\":1}}],[\"假设字符串的长度为\",{\"1\":{\"253\":1}}],[\"假设left指向首元素\",{\"1\":{\"241\":1}}],[\"假设n=4\",{\"1\":{\"188\":1}}],[\"假设使用\",{\"1\":{\"187\":1}}],[\"假设每一种面额的硬币有无限个\",{\"1\":{\"102\":1}}],[\"假设有俩个事务\",{\"1\":{\"771\":1}}],[\"假设有n张表进行查询\",{\"1\":{\"533\":1}}],[\"假设有打乱顺序的一群人站成一个队列\",{\"1\":{\"361\":1}}],[\"假设有\",{\"1\":{\"97\":1}}],[\"假设石头的重量分别为\",{\"1\":{\"96\":1}}],[\"假设头结点为\",{\"1\":{\"89\":1}}],[\"假设拆分出第一个整数为\",{\"1\":{\"87\":1}}],[\"假设为root\",{\"1\":{\"68\":1}}],[\"假设\",{\"1\":{\"62\":1,\"83\":1,\"99\":1,\"103\":1,\"188\":1}}],[\"假设由递归产生的隐式调用栈的开销不被计算在内\",{\"1\":{\"59\":1}}],[\"假设最大值下标为rootindex\",{\"1\":{\"51\":1}}],[\"假设二叉树中至少有一个节点\",{\"1\":{\"42\":1}}],[\"出\",{\"1\":{\"725\":1}}],[\"出发\",{\"1\":{\"355\":1}}],[\"出发的先生\",{\"1\":{\"212\":1}}],[\"出队\",{\"1\":{\"222\":1,\"226\":1}}],[\"出现了第二种\",{\"1\":{\"725\":1}}],[\"出现了`using\",{\"1\":{\"710\":1}}],[\"出现脏写就需要转人工处理\",{\"1\":{\"436\":1}}],[\"出现的原因是由于\",{\"1\":{\"420\":1}}],[\"出现的个数\",{\"1\":{\"147\":1}}],[\"出现异常降级会执行\",{\"1\":{\"416\":1}}],[\"出现\",{\"1\":{\"348\":1}}],[\"出现在父工程中\",{\"1\":{\"441\":1}}],[\"出现在\",{\"1\":{\"269\":1}}],[\"出现过则不是快乐数\",{\"1\":{\"170\":1}}],[\"出现频率最高的元素\",{\"1\":{\"59\":1}}],[\"出售\",{\"1\":{\"121\":1}}],[\"出来的结点\",{\"1\":{\"24\":1}}],[\"技巧\",{\"1\":{\"58\":1}}],[\"用shell语法分离出创建表的语句及插入数据的语句后\",{\"1\":{\"832\":1}}],[\"用这些日志文件\",{\"1\":{\"805\":1}}],[\"用更好的方式去处理\",{\"1\":{\"791\":1}}],[\"用完后再把资源转让给其它线程\",{\"1\":{\"781\":1}}],[\"用相应的分析工具\",{\"1\":{\"694\":1}}],[\"用外键约束\",{\"1\":{\"618\":1}}],[\"用空间换时间\",{\"1\":{\"604\":1}}],[\"用占用字节数少\",{\"1\":{\"598\":1}}],[\"用得最多\",{\"1\":{\"598\":1}}],[\"用0在左边填充\",{\"1\":{\"597\":1}}],[\"用`\",{\"1\":{\"583\":1}}],[\"用count\",{\"1\":{\"562\":1}}],[\"用法\",{\"1\":{\"555\":1}}],[\"用字符串pad对str最右边进行填充\",{\"1\":{\"552\":1}}],[\"用字符串pad对str最左边进行填充\",{\"1\":{\"552\":1}}],[\"用字符串b替换字符串str中所有出现的字符串a\",{\"1\":{\"552\":1}}],[\"用户无法手动操作意向锁\",{\"1\":{\"771\":1}}],[\"用户可以从候选键中选择一个作为主键\",{\"1\":{\"736\":1}}],[\"用户可以利用\",{\"1\":{\"421\":1}}],[\"用户记录里的一条条数据如何记录\",{\"1\":{\"671\":1}}],[\"用户记录\",{\"0\":{\"671\":1},\"1\":{\"667\":1}}],[\"用户记录的页也是根据页中用户记录的主键大小顺序排成一个\",{\"1\":{\"650\":1}}],[\"用户记录的不同点\",{\"1\":{\"645\":1}}],[\"用户名称\",{\"1\":{\"831\":1}}],[\"用户名密码认证通过\",{\"1\":{\"625\":1}}],[\"用户名或密码不对\",{\"1\":{\"625\":1}}],[\"用户名或密码错误\",{\"1\":{\"444\":1}}],[\"用户名唯一\",{\"1\":{\"612\":1}}],[\"用户自定义完整性\",{\"1\":{\"612\":1}}],[\"用户的访问权限和\",{\"1\":{\"517\":1}}],[\"用户账号id\",{\"1\":{\"440\":1,\"443\":1}}],[\"用户id\",{\"1\":{\"431\":2}}],[\"用于处理所有\",{\"1\":{\"821\":1}}],[\"用于保证事务的持久性\",{\"1\":{\"811\":1}}],[\"用于主从服务器架构中\",{\"1\":{\"805\":1}}],[\"用于较大整数的计算\",{\"1\":{\"598\":1}}],[\"用于定义数据库\",{\"1\":{\"517\":1}}],[\"用于添加\",{\"1\":{\"517\":1}}],[\"用于配置谓词或过滤器\",{\"1\":{\"491\":1}}],[\"用于监控对依赖服务的调用\",{\"1\":{\"475\":1}}],[\"用于获取全局事务id\",{\"1\":{\"432\":1}}],[\"用于通用的\",{\"1\":{\"416\":1}}],[\"用于在抛出异常的时候提供fallback处理逻辑\",{\"1\":{\"416\":1}}],[\"用于指定防护资源\",{\"1\":{\"416\":1}}],[\"用于进行租户粒度的配置隔离\",{\"1\":{\"404\":1}}],[\"用最少数量的箭引爆气球\",{\"1\":{\"366\":1}}],[\"用一个数组记录每个字母出现的最远下标\",{\"1\":{\"368\":1}}],[\"用一个数组返回这个矩阵中的所有元素\",{\"1\":{\"303\":1}}],[\"用一个变量保存\",{\"1\":{\"350\":1}}],[\"用一个变量进行累加\",{\"1\":{\"26\":1}}],[\"用\",{\"1\":{\"231\":1,\"835\":1}}],[\"用栈的话还要考虑先进后出的顺序\",{\"1\":{\"222\":1}}],[\"用以表示一个\",{\"1\":{\"200\":1}}],[\"用下标表数组\",{\"1\":{\"193\":1}}],[\"用n减也行\",{\"1\":{\"190\":1}}],[\"用整数数组\",{\"1\":{\"96\":1}}],[\"用转化为\",{\"1\":{\"85\":1}}],[\"用返回值确定插入的结点\",{\"1\":{\"68\":1}}],[\"用来定位当前正在使用的中继日志\",{\"1\":{\"813\":1}}],[\"用来存储不同类型的日志\",{\"1\":{\"805\":1}}],[\"用来存放公共的类\",{\"1\":{\"447\":1}}],[\"用来指定创建索引\",{\"1\":{\"687\":1}}],[\"用来指向当前遍历的数字\",{\"1\":{\"193\":1}}],[\"用来唯一标识表中的一行记录\",{\"1\":{\"616\":1}}],[\"用来限制某个字段\",{\"1\":{\"615\":1}}],[\"用来限制对于下游服务的最大并发数量\",{\"1\":{\"479\":1}}],[\"用来过滤数据的\",{\"1\":{\"564\":1}}],[\"用来筛选符合条件的结果\",{\"1\":{\"525\":1}}],[\"用来标识自己\",{\"1\":{\"511\":1}}],[\"用来保证事务的原子性\",{\"1\":{\"747\":1}}],[\"用来保证事务的持\",{\"1\":{\"747\":1}}],[\"用来保护\",{\"1\":{\"487\":1}}],[\"用来保存每一个切割方案\",{\"1\":{\"199\":1}}],[\"用来保存字母\",{\"1\":{\"193\":1}}],[\"用来保存结果值\",{\"1\":{\"58\":1}}],[\"用来处理请求的来源\",{\"1\":{\"418\":1}}],[\"用来遍历\",{\"1\":{\"377\":1,\"378\":1}}],[\"用来记录并维护系统当前活跃事务\",{\"1\":{\"796\":1}}],[\"用来记录在mysql中\",{\"1\":{\"697\":1}}],[\"用来记录下一步能够覆盖的元素距离\",{\"1\":{\"352\":1}}],[\"用来记录当前位置能够覆盖的最远距离\",{\"1\":{\"352\":1}}],[\"用来记录当前节点是否被访问过\",{\"1\":{\"222\":1}}],[\"用来表示棋盘\",{\"1\":{\"215\":1}}],[\"用来收集\",{\"1\":{\"190\":1}}],[\"用来寻找公共祖先\",{\"1\":{\"62\":1}}],[\"去走后\",{\"1\":{\"625\":1}}],[\"去除重复记录\",{\"1\":{\"540\":1}}],[\"去掉auto\",{\"1\":{\"617\":1}}],[\"去掉字符串s结尾处的s1\",{\"1\":{\"552\":1}}],[\"去掉字符串s开始处的s1\",{\"1\":{\"552\":1}}],[\"去掉字符串s开始与结尾的s1\",{\"1\":{\"552\":1}}],[\"去掉字符串s开始与结尾的空格\",{\"1\":{\"552\":1}}],[\"去掉字符串s右侧的空格\",{\"1\":{\"552\":1}}],[\"去掉字符串s左侧的空格\",{\"1\":{\"552\":1}}],[\"去掉重复的department\",{\"1\":{\"522\":1}}],[\"去掉重复行\",{\"0\":{\"522\":1}}],[\"去掉括号后表达式无歧义\",{\"1\":{\"330\":1}}],[\"去调用服务端接口\",{\"1\":{\"462\":1}}],[\"去最大值\",{\"1\":{\"307\":2}}],[\"去重问题均要先对数组进行排序\",{\"1\":{\"211\":1}}],[\"去重是针对同一层是否有重复元素\",{\"1\":{\"205\":1}}],[\"去重操作\",{\"1\":{\"197\":1}}],[\"去重\",{\"1\":{\"179\":1}}],[\"去右子树上搜素\",{\"1\":{\"66\":1}}],[\"去右子树查找\",{\"1\":{\"54\":2}}],[\"去左子树查找\",{\"1\":{\"54\":2}}],[\"什么是readview\",{\"0\":{\"796\":1}}],[\"什么是mvcc\",{\"0\":{\"790\":1}}],[\"什么是覆盖索引\",{\"1\":{\"727\":1}}],[\"什么是校验和\",{\"1\":{\"668\":1}}],[\"什么是约束\",{\"1\":{\"612\":1}}],[\"什么是网关\",{\"1\":{\"487\":1}}],[\"什么是相对顺序\",{\"1\":{\"313\":1}}],[\"什么是层序遍历\",{\"1\":{\"12\":1}}],[\"什么性质呢\",{\"1\":{\"54\":1}}],[\"什么先序\",{\"1\":{\"54\":1}}],[\"数堆\",{\"1\":{\"660\":1}}],[\"数的使用场景\",{\"1\":{\"599\":1}}],[\"数值超过m位\",{\"1\":{\"597\":1}}],[\"数值\",{\"1\":{\"562\":1}}],[\"数值函数\",{\"0\":{\"547\":1}}],[\"数\",{\"1\":{\"548\":1}}],[\"数据一致性\",{\"2\":{\"855\":1}}],[\"数据备份实际上是一种冗余的机制\",{\"1\":{\"819\":1}}],[\"数据同步\",{\"1\":{\"813\":1}}],[\"数据复制\",{\"1\":{\"808\":1}}],[\"数据恢复\",{\"1\":{\"808\":1}}],[\"数据内容中\",{\"1\":{\"800\":1}}],[\"数据定义语句日志\",{\"1\":{\"805\":2}}],[\"数据定义语句\",{\"1\":{\"785\":1}}],[\"数据定义语言\",{\"1\":{\"517\":1,\"627\":1}}],[\"数据更新语句\",{\"1\":{\"785\":1}}],[\"数据也是一种供许多用户共享的\",{\"1\":{\"760\":1}}],[\"数据并发的问题\",{\"1\":{\"746\":1}}],[\"数据从一个\",{\"1\":{\"741\":1}}],[\"数据冗余\",{\"1\":{\"737\":1}}],[\"数据读取操作的操作类型\",{\"1\":{\"700\":1}}],[\"数据量小的表最好不要使用索引\",{\"1\":{\"690\":1}}],[\"数据页的\",{\"1\":{\"667\":1}}],[\"数据页的内部结构\",{\"0\":{\"667\":1}}],[\"数据页是我们最常使用的页\",{\"1\":{\"667\":1}}],[\"数据又是递增的\",{\"1\":{\"662\":1}}],[\"数据记录地址\",{\"1\":{\"654\":1}}],[\"数据记录的地址\",{\"1\":{\"653\":1}}],[\"数据文件\",{\"1\":{\"654\":1}}],[\"数据文件结构\",{\"1\":{\"636\":1,\"637\":1}}],[\"数据访问更快\",{\"1\":{\"650\":1}}],[\"数据即索引\",{\"1\":{\"650\":1}}],[\"数据的增删改\",{\"1\":{\"785\":1}}],[\"数据的存储是没有顺序的\",{\"1\":{\"658\":1}}],[\"数据的唯一性\",{\"1\":{\"642\":1}}],[\"数据的实际长度比char类型声明的长度小\",{\"1\":{\"604\":1}}],[\"数据和索引存储在不同的文件中\",{\"1\":{\"637\":1}}],[\"数据完整性\",{\"1\":{\"612\":1}}],[\"数据交换格式\",{\"1\":{\"608\":1}}],[\"数据检索更快\",{\"1\":{\"604\":1}}],[\"数据存储引擎和数据列\",{\"1\":{\"604\":1}}],[\"数据表中常用的几种键和\",{\"1\":{\"736\":1}}],[\"数据表n\",{\"1\":{\"588\":1}}],[\"数据表2\",{\"1\":{\"588\":1}}],[\"数据表1\",{\"1\":{\"588\":1}}],[\"数据类型\",{\"1\":{\"587\":3,\"602\":1,\"614\":4,\"615\":7,\"616\":6,\"617\":10,\"618\":4,\"620\":5}}],[\"数据查询语言\",{\"1\":{\"517\":1}}],[\"数据控制语言\",{\"1\":{\"517\":1}}],[\"数据操作语言\",{\"1\":{\"517\":1,\"627\":1}}],[\"数据库字段名的修改代价很大\",{\"1\":{\"836\":1}}],[\"数据库服务器的所有\",{\"1\":{\"806\":1}}],[\"数据库服务器的优化步骤\",{\"0\":{\"694\":1}}],[\"数据库会自动给更大一级的空间\",{\"1\":{\"771\":1}}],[\"数据库宕机了\",{\"1\":{\"749\":1}}],[\"数据库自身的错误\",{\"1\":{\"742\":1}}],[\"数据库范式\",{\"0\":{\"737\":1}}],[\"数据库中的键\",{\"1\":{\"736\":1}}],[\"数据库中的一个列\",{\"1\":{\"512\":1}}],[\"数据库中的一条记录\",{\"1\":{\"512\":1}}],[\"数据库中的一张表\",{\"1\":{\"512\":1}}],[\"数据库的\",{\"1\":{\"837\":1}}],[\"数据库的名称\",{\"1\":{\"831\":1}}],[\"数据库的名称2\",{\"1\":{\"831\":1}}],[\"数据库的名称1\",{\"1\":{\"831\":1}}],[\"数据库的设计规范\",{\"0\":{\"736\":1}}],[\"数据库的cpu资源是极其宝贵的\",{\"1\":{\"726\":1}}],[\"数据库的io成本\",{\"1\":{\"642\":1}}],[\"数据库管理存储空间的基本单位是页\",{\"1\":{\"666\":1}}],[\"数据库不用从多\",{\"1\":{\"650\":1}}],[\"数据库不能同名\",{\"1\":{\"583\":1}}],[\"数据库系统或常用方法冲突\",{\"1\":{\"583\":1}}],[\"数据库名\",{\"1\":{\"518\":2,\"583\":2,\"585\":3,\"586\":1}}],[\"数据库\",{\"1\":{\"632\":1,\"666\":1,\"809\":2},\"2\":{\"514\":1,\"515\":1,\"543\":1,\"544\":1,\"566\":1,\"567\":1,\"580\":1,\"581\":1,\"590\":1,\"591\":1,\"609\":1,\"610\":1,\"621\":1,\"622\":1,\"638\":1,\"639\":1,\"663\":1,\"664\":1,\"682\":1,\"683\":1,\"691\":1,\"692\":1,\"711\":1,\"712\":1,\"734\":1,\"735\":1,\"738\":1,\"739\":1,\"758\":1,\"759\":1,\"787\":1,\"788\":1,\"802\":1,\"803\":1,\"814\":1,\"815\":1,\"828\":1,\"829\":1,\"833\":1,\"834\":1,\"838\":1,\"839\":1,\"841\":1,\"842\":1}}],[\"数据库表sql\",{\"1\":{\"440\":1}}],[\"数据库当前业务数据\",{\"1\":{\"436\":1}}],[\"数据库正常回滚了\",{\"1\":{\"435\":1}}],[\"数据库准备\",{\"0\":{\"428\":1}}],[\"数据库本身\",{\"1\":{\"426\":1}}],[\"数学运算异常\",{\"1\":{\"444\":1}}],[\"数量级增\",{\"1\":{\"689\":1}}],[\"数量不对\",{\"1\":{\"522\":1}}],[\"数量\",{\"1\":{\"431\":1,\"696\":1,\"737\":1}}],[\"数独部分空格内已填入了数字\",{\"1\":{\"216\":1}}],[\"数独的解法需\",{\"1\":{\"216\":1}}],[\"数字越小优先级越高\",{\"1\":{\"503\":1}}],[\"数字和空格\",{\"1\":{\"244\":1}}],[\"数字可以\",{\"1\":{\"194\":1}}],[\"数字\",{\"1\":{\"193\":1,\"216\":3}}],[\"数组遍历一遍\",{\"1\":{\"360\":1}}],[\"数组每个元素的能够跳的最远距离都计算一遍\",{\"1\":{\"350\":1}}],[\"数组总和\",{\"1\":{\"293\":2}}],[\"数组变为\",{\"1\":{\"281\":2}}],[\"数组来进行标记使用过的机票\",{\"1\":{\"213\":1}}],[\"数组中每个数字出现的频率\",{\"1\":{\"337\":1}}],[\"数组中前\",{\"1\":{\"336\":1}}],[\"数组中不相同的元素的个数\",{\"1\":{\"336\":1}}],[\"数组中无法删除元素\",{\"1\":{\"313\":1}}],[\"数组中连续的1在数组的末尾\",{\"1\":{\"308\":1}}],[\"数组中的每个元素代表你在该位置可以跳跃的最大长度\",{\"1\":{\"349\":1,\"350\":1}}],[\"数组中的值\",{\"1\":{\"277\":1}}],[\"数组中的元素\",{\"1\":{\"202\":1}}],[\"数组中的元素而不改变其余元素的顺序\",{\"1\":{\"132\":1}}],[\"数组中可能含有重复元素\",{\"1\":{\"206\":1}}],[\"数组中同一个元素在答案里不能重复出现\",{\"1\":{\"174\":1}}],[\"数组的定义可以看出\",{\"1\":{\"143\":1}}],[\"数组尽可能初始化为较大的值\",{\"1\":{\"109\":1}}],[\"数组元素总和\",{\"1\":{\"95\":2}}],[\"数组不能分割成两个元素和相等的子集\",{\"1\":{\"94\":1}}],[\"数组可以分割成\",{\"1\":{\"94\":1}}],[\"数组\",{\"0\":{\"265\":1},\"1\":{\"94\":1,\"168\":1,\"222\":2,\"230\":1,\"276\":1,\"307\":1,\"361\":1},\"2\":{\"319\":1}}],[\"数组最后一个元素为根结点\",{\"1\":{\"47\":1}}],[\"数中节点数在\",{\"1\":{\"53\":1}}],[\"e参数来备份事件\",{\"1\":{\"831\":1}}],[\"event\",{\"1\":{\"820\":1}}],[\"events\",{\"1\":{\"809\":3,\"820\":1,\"831\":1}}],[\"evalrpn\",{\"1\":{\"332\":1}}],[\"europe\",{\"1\":{\"767\":1}}],[\"ession\",{\"1\":{\"746\":1}}],[\"equal\",{\"1\":{\"822\":1}}],[\"equalsignorecase\",{\"1\":{\"444\":2,\"497\":1}}],[\"equals\",{\"1\":{\"163\":1,\"213\":6}}],[\"eq\",{\"1\":{\"704\":3,\"728\":1}}],[\"eid\",{\"1\":{\"617\":2,\"618\":1}}],[\"either\",{\"1\":{\"429\":1}}],[\"e3\",{\"1\":{\"548\":2}}],[\"e2\",{\"1\":{\"548\":2,\"569\":4}}],[\"e1\",{\"1\":{\"548\":2,\"569\":3,\"579\":5}}],[\"employee\",{\"1\":{\"536\":2,\"559\":1,\"573\":7,\"575\":1,\"578\":2,\"579\":4,\"587\":3,\"617\":2}}],[\"employees为为主表\",{\"1\":{\"539\":1}}],[\"employees\",{\"1\":{\"520\":2,\"521\":1,\"522\":3,\"523\":1,\"525\":1,\"529\":1,\"533\":8,\"534\":1,\"536\":3,\"538\":2,\"539\":2,\"541\":9,\"559\":1,\"562\":5,\"563\":1,\"564\":2,\"569\":6,\"573\":7,\"574\":2,\"575\":1,\"578\":11,\"579\":8,\"587\":3}}],[\"emp\",{\"1\":{\"533\":6,\"534\":4,\"536\":4,\"538\":4,\"539\":4,\"541\":16,\"618\":2,\"687\":5}}],[\"empower\",{\"1\":{\"418\":3}}],[\"empower授权规则\",{\"1\":{\"418\":1}}],[\"empowercontroller\",{\"1\":{\"418\":1}}],[\"emptylist\",{\"1\":{\"423\":1}}],[\"empty\",{\"1\":{\"321\":6,\"323\":3}}],[\"err\",{\"1\":{\"807\":2}}],[\"errno\",{\"1\":{\"618\":1}}],[\"error=\",{\"1\":{\"807\":1}}],[\"errormessage\",{\"1\":{\"423\":1}}],[\"errorcode\",{\"1\":{\"423\":1}}],[\"error\",{\"1\":{\"416\":2,\"444\":2,\"445\":2,\"617\":2,\"618\":1,\"807\":4,\"809\":1,\"822\":2}}],[\"eraseoverlapintervals\",{\"1\":{\"366\":1}}],[\"elt\",{\"1\":{\"552\":1}}],[\"elasticsearch\",{\"1\":{\"510\":1}}],[\"element\",{\"1\":{\"444\":3}}],[\"elementtype\",{\"1\":{\"416\":2}}],[\"else\",{\"1\":{\"7\":1,\"37\":1,\"41\":1,\"54\":2,\"60\":2,\"66\":3,\"91\":1,\"101\":1,\"120\":1,\"135\":1,\"139\":1,\"141\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":1,\"157\":1,\"175\":1,\"177\":4,\"179\":2,\"199\":2,\"201\":2,\"242\":2,\"271\":4,\"273\":1,\"274\":1,\"275\":2,\"276\":1,\"277\":4,\"283\":1,\"296\":1,\"305\":1,\"308\":1,\"311\":1,\"326\":1,\"329\":1,\"346\":1,\"358\":3,\"366\":1,\"372\":2,\"378\":1,\"395\":1,\"504\":1,\"559\":6,\"575\":1}}],[\"echo\",{\"1\":{\"454\":3}}],[\"ec9e\",{\"1\":{\"404\":1}}],[\"eccbbbbdec\",{\"1\":{\"367\":1}}],[\"edgware\",{\"1\":{\"399\":1}}],[\"edocteel\",{\"1\":{\"246\":1}}],[\"ekat\",{\"1\":{\"246\":1}}],[\"extra\",{\"0\":{\"710\":1},\"1\":{\"701\":1}}],[\"extract\",{\"1\":{\"555\":2}}],[\"extend\",{\"1\":{\"429\":1}}],[\"extends\",{\"1\":{\"416\":2,\"497\":1,\"504\":1}}],[\"extension\",{\"1\":{\"403\":5,\"404\":2}}],[\"exist\",{\"1\":{\"481\":1}}],[\"exists`额外信息\",{\"1\":{\"710\":1}}],[\"exists\",{\"1\":{\"428\":4,\"431\":3,\"440\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"595\":1,\"729\":2}}],[\"exclusive\",{\"1\":{\"771\":1}}],[\"exclusions>\",{\"1\":{\"442\":1,\"450\":1}}],[\"exclusion>\",{\"1\":{\"442\":1,\"450\":1}}],[\"excludes>\",{\"1\":{\"442\":1}}],[\"exclude>\",{\"1\":{\"442\":1}}],[\"except\",{\"1\":{\"429\":1}}],[\"exceptionhandler\",{\"1\":{\"445\":1}}],[\"exception\",{\"1\":{\"417\":1,\"423\":1,\"424\":1,\"432\":2,\"445\":2,\"477\":1,\"478\":1}}],[\"exceptionstotrace\",{\"1\":{\"416\":1}}],[\"exceptionstoignore\",{\"1\":{\"416\":2}}],[\"exchange\",{\"1\":{\"423\":1,\"503\":9,\"504\":5}}],[\"explain显示的执行计划中type值\",{\"1\":{\"728\":1}}],[\"explain\",{\"1\":{\"700\":3,\"701\":1,\"702\":1,\"704\":10,\"705\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":18,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"726\":3,\"728\":1}}],[\"expr\",{\"1\":{\"557\":4,\"559\":1,\"562\":1}}],[\"expression\",{\"1\":{\"563\":1}}],[\"express\",{\"1\":{\"429\":1}}],[\"exp\",{\"1\":{\"550\":1}}],[\"expect\",{\"1\":{\"454\":1}}],[\"expectednums\",{\"1\":{\"312\":3}}],[\"expire\",{\"1\":{\"428\":4,\"809\":1,\"823\":1}}],[\"exportinputstack\",{\"1\":{\"323\":3}}],[\"example类似于mp中的querywrapper\",{\"1\":{\"432\":1}}],[\"example\",{\"1\":{\"244\":2,\"432\":3,\"491\":2,\"492\":1,\"502\":2,\"504\":1}}],[\"exe\",{\"1\":{\"449\":1,\"454\":1}}],[\"exetension\",{\"1\":{\"403\":1}}],[\"exec\",{\"1\":{\"485\":1}}],[\"exection\",{\"1\":{\"151\":2}}],[\"execution\",{\"1\":{\"151\":2}}],[\"exention\",{\"1\":{\"151\":2}}],[\"enhance\",{\"1\":{\"869\":1}}],[\"encrypted\",{\"1\":{\"809\":1}}],[\"encoding=\",{\"1\":{\"441\":1,\"442\":1}}],[\"ename\",{\"1\":{\"617\":3,\"618\":1}}],[\"enabled\",{\"1\":{\"420\":1,\"468\":1,\"469\":2,\"477\":2}}],[\"enablediscoveryclient\",{\"1\":{\"403\":1,\"432\":1,\"450\":1,\"464\":1,\"489\":1}}],[\"enablefeignclients\",{\"1\":{\"420\":1,\"432\":1,\"463\":3,\"464\":2}}],[\"enabling\",{\"1\":{\"405\":1}}],[\"enum类型的成员个数的上限为65535个\",{\"1\":{\"606\":1}}],[\"enum类型的取值范围需要在定义字段时进行指定\",{\"1\":{\"606\":1}}],[\"enum类型也叫作枚举类型\",{\"1\":{\"606\":1}}],[\"enum\",{\"0\":{\"606\":1},\"1\":{\"444\":1,\"603\":1,\"606\":8}}],[\"en\",{\"1\":{\"442\":1}}],[\"enter\",{\"1\":{\"481\":1}}],[\"entities\",{\"1\":{\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"entity拷贝到此模块\",{\"1\":{\"443\":1}}],[\"entity\",{\"1\":{\"432\":1,\"512\":1,\"612\":1}}],[\"entrytype\",{\"1\":{\"416\":3}}],[\"entry类型\",{\"1\":{\"416\":1}}],[\"entryset\",{\"1\":{\"338\":1,\"424\":1}}],[\"entry\",{\"1\":{\"338\":3}}],[\"entry<integer\",{\"1\":{\"338\":1}}],[\"engine=myisam\",{\"1\":{\"635\":2,\"704\":1}}],[\"engine=innodb\",{\"1\":{\"431\":3,\"440\":1}}],[\"engines\",{\"1\":{\"631\":1,\"635\":1,\"741\":1}}],[\"engine<\",{\"1\":{\"442\":1}}],[\"engine\",{\"1\":{\"428\":4,\"431\":3,\"635\":1}}],[\"enention\",{\"1\":{\"151\":2}}],[\"endpoint\",{\"1\":{\"486\":1}}],[\"end即可\",{\"1\":{\"366\":1}}],[\"endingdelimiter\",{\"1\":{\"442\":1}}],[\"endi\",{\"1\":{\"294\":2,\"365\":2}}],[\"end++\",{\"1\":{\"275\":1}}],[\"end为了防止每段中只有一个元素\",{\"1\":{\"201\":2}}],[\"end\",{\"1\":{\"51\":8,\"199\":4,\"201\":8,\"261\":1,\"275\":4,\"299\":8,\"364\":9,\"366\":9,\"559\":4,\"575\":1}}],[\"e\",{\"1\":{\"151\":2,\"193\":2,\"249\":2,\"416\":4,\"434\":2,\"445\":6,\"477\":2,\"481\":2,\"512\":1,\"579\":8,\"599\":1,\"831\":1,\"832\":2}}],[\"etco\",{\"1\":{\"149\":1}}],[\"east\",{\"1\":{\"767\":1,\"771\":1}}],[\"ea\",{\"1\":{\"149\":2}}],[\"eat\",{\"1\":{\"149\":2,\"150\":1,\"164\":2}}],[\"该参数后面跟数据库名称\",{\"1\":{\"831\":1}}],[\"该参数控制\",{\"1\":{\"753\":1}}],[\"该版本可以被访问\",{\"1\":{\"798\":1}}],[\"该版本不可以被访问\",{\"1\":{\"798\":1}}],[\"该类型的undo日志就没用了\",{\"1\":{\"794\":1}}],[\"该事务就不会对磁上的数据做任何影响\",{\"1\":{\"757\":1}}],[\"该语句可以在已经开启的事务中间执行\",{\"1\":{\"746\":1}}],[\"该方案适用于主键自增的表\",{\"1\":{\"726\":1}}],[\"该方案中\",{\"1\":{\"214\":1}}],[\"该表的访问方法就是index\",{\"1\":{\"704\":1}}],[\"该表通常称为\",{\"1\":{\"513\":1}}],[\"该索引列的值也可以是null值时\",{\"1\":{\"704\":1}}],[\"该索引指向创建时对应的多个字段\",{\"1\":{\"686\":1}}],[\"该派生表对应的子查询的select\",{\"1\":{\"703\":1}}],[\"该子查询对应的select\",{\"1\":{\"703\":1}}],[\"该子查询的第一个select关键字代表的那个查询的select\",{\"1\":{\"703\":1}}],[\"该子集中\",{\"1\":{\"100\":1}}],[\"该条记录的table列代表着该\",{\"1\":{\"701\":1}}],[\"该如何思考呢\",{\"1\":{\"694\":1}}],[\"该列中的值越集中\",{\"1\":{\"689\":1}}],[\"该列中的值越分散\",{\"1\":{\"689\":1}}],[\"该列必须从数据表中定义的多个列中选择\",{\"1\":{\"687\":1}}],[\"该列表不能包含相同的组合两次\",{\"1\":{\"189\":1}}],[\"该记录的数据\",{\"1\":{\"618\":1}}],[\"该项功能需要配合\",{\"1\":{\"595\":1}}],[\"该pattern是ant风格的模式\",{\"1\":{\"493\":1}}],[\"该链表应变为\",{\"1\":{\"379\":2}}],[\"该节点无覆盖\",{\"1\":{\"372\":2}}],[\"该节点有覆盖\",{\"1\":{\"372\":1}}],[\"该算式的逆波兰表达式写法为\",{\"1\":{\"330\":1}}],[\"该算式转化为常见的中缀算术表达式为\",{\"1\":{\"330\":3}}],[\"该位置就是\",{\"1\":{\"299\":3}}],[\"该长度范围内\",{\"1\":{\"278\":1}}],[\"该元素的位置就是就是要返回的值\",{\"1\":{\"273\":1}}],[\"该数组需恰好覆盖输入中的所有区间\",{\"1\":{\"294\":1}}],[\"该数组已按\",{\"1\":{\"240\":1}}],[\"该数列由\",{\"1\":{\"78\":1}}],[\"该次遍历的结束索引\",{\"1\":{\"199\":1}}],[\"该树的节点值各不相同\",{\"1\":{\"73\":1}}],[\"该题我们可以采用双次遍历的方法\",{\"1\":{\"389\":1}}],[\"该题是求出第一个错误版本\",{\"1\":{\"274\":1}}],[\"该题目使用单调递减队列比较容易理解一些\",{\"1\":{\"334\":1}}],[\"该题目完全可以利用双指针的方法\",{\"1\":{\"241\":1}}],[\"该题目求\",{\"1\":{\"234\":1}}],[\"该题与n皇后的区别就是\",{\"1\":{\"217\":1}}],[\"该题不能排序\",{\"1\":{\"207\":1}}],[\"该题大概一看其实和\",{\"1\":{\"207\":1}}],[\"该题相较于\",{\"1\":{\"205\":1,\"211\":1}}],[\"该题相较于上面几题的区别就是\",{\"1\":{\"197\":1}}],[\"该题就是典型回溯问题\",{\"1\":{\"187\":1}}],[\"该题最主要的目的其实就是找和\",{\"1\":{\"170\":1}}],[\"该题要求连续的递增序列\",{\"1\":{\"135\":1}}],[\"该题可能删除多个结点\",{\"1\":{\"70\":1}}],[\"该题和上面三题思路一样\",{\"1\":{\"72\":1}}],[\"该题和\",{\"1\":{\"51\":1}}],[\"该结点的值已经是出现的频率最高了\",{\"1\":{\"60\":1}}],[\"该结点为最左侧的结点\",{\"1\":{\"43\":1}}],[\"该结点为叶子结点\",{\"1\":{\"39\":1}}],[\"该结点就是叶子结点\",{\"1\":{\"41\":1}}],[\"看似很合理\",{\"1\":{\"732\":1}}],[\"看课件理解索引条件下推\",{\"1\":{\"710\":1}}],[\"看源码其实能看出来\",{\"1\":{\"504\":1}}],[\"看\",{\"1\":{\"422\":1}}],[\"看hash表中是否包含该结点\",{\"1\":{\"392\":1}}],[\"看了上面的图\",{\"1\":{\"211\":1}}],[\"看到type列的值是ref\",{\"1\":{\"704\":1}}],[\"看到这道题的首先第一个想法就是暴力法\",{\"1\":{\"291\":1}}],[\"看到这里\",{\"1\":{\"184\":1}}],[\"看到回溯的题目\",{\"1\":{\"193\":1}}],[\"看下面这张图\",{\"1\":{\"49\":1}}],[\"看一下下面这张图\",{\"1\":{\"47\":1}}],[\"为每个\",{\"1\":{\"866\":1}}],[\"为每个孩子所需要糖果的数量\",{\"1\":{\"360\":1}}],[\"为0的时候\",{\"1\":{\"810\":1}}],[\"为后缀的文件就会增加一个\",{\"1\":{\"809\":1}}],[\"为后缀的文件\",{\"1\":{\"809\":2}}],[\"为名称\",{\"1\":{\"809\":2}}],[\"为活跃状态\",{\"1\":{\"800\":1}}],[\"为活跃的事务id列表\",{\"1\":{\"797\":1}}],[\"为读操作增加写锁\",{\"1\":{\"767\":1}}],[\"为读操作增加读锁\",{\"1\":{\"767\":1}}],[\"为保证数据的一致性\",{\"1\":{\"760\":1}}],[\"为基数太小列的建立索引效果可能不好\",{\"1\":{\"689\":1}}],[\"为需要创建索引的字段列\",{\"1\":{\"687\":1}}],[\"为需要的元素\",{\"1\":{\"188\":1}}],[\"为同义词\",{\"1\":{\"687\":1}}],[\"为同一层的第一个元素\",{\"1\":{\"197\":1}}],[\"为处理巨大数据量的最大性能设计\",{\"1\":{\"636\":1}}],[\"为理想的数据交换语言\",{\"1\":{\"608\":1}}],[\"为字符串实际长度加1个字节\",{\"1\":{\"604\":1}}],[\"为可选参数\",{\"1\":{\"542\":1,\"687\":3}}],[\"为指定字段设置别名\",{\"1\":{\"521\":1}}],[\"为了丰富文档写作\",{\"1\":{\"868\":1}}],[\"为了解决两份日志之间的逻辑一致问题\",{\"1\":{\"812\":1}}],[\"为了解决上面二叉查找树退化成链表的问题\",{\"1\":{\"660\":1}}],[\"为了安全起见\",{\"1\":{\"810\":1}}],[\"为了尽可能提高数据库的并发度\",{\"1\":{\"768\":1}}],[\"为了简化理解\",{\"1\":{\"763\":1}}],[\"为了避免以上这种情况\",{\"1\":{\"737\":1}}],[\"为了避免混乱\",{\"1\":{\"533\":1}}],[\"为了能得到一个数据页中存储的记录的状态信息\",{\"1\":{\"674\":1}}],[\"为了检测一个页是否完整\",{\"1\":{\"668\":1}}],[\"为了充分利用聚簇索引的聚簇的特性\",{\"1\":{\"650\":1}}],[\"为了管理方便\",{\"1\":{\"635\":1}}],[\"为了保证数据的完整性\",{\"1\":{\"612\":1}}],[\"为了提高可读性\",{\"1\":{\"518\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"393\":1}}],[\"为分隔符\",{\"1\":{\"493\":1}}],[\"为负载均衡器的抽象和实现\",{\"1\":{\"458\":1}}],[\"为用户打造一站式的分布式解决方案\",{\"1\":{\"426\":1}}],[\"为qps\",{\"1\":{\"419\":1}}],[\"为配置内容的数据格式\",{\"1\":{\"403\":1}}],[\"为空时\",{\"1\":{\"403\":1}}],[\"为空的时候\",{\"1\":{\"68\":1}}],[\"为微服务应用构建消息驱动能力\",{\"1\":{\"399\":1}}],[\"为偶数\",{\"1\":{\"304\":1}}],[\"为偶数时\",{\"1\":{\"299\":1}}],[\"为偶数时表示\",{\"1\":{\"126\":1}}],[\"为终止条件\",{\"1\":{\"271\":1}}],[\"为海洋\",{\"1\":{\"230\":1}}],[\"为当前遍历时要截取的子串\",{\"1\":{\"199\":2}}],[\"为当前for循环中\",{\"1\":{\"188\":1}}],[\"为起始索引\",{\"1\":{\"199\":1}}],[\"为还需要选择的元素\",{\"1\":{\"188\":1}}],[\"为已经选择的元素\",{\"1\":{\"188\":1}}],[\"为判断\",{\"1\":{\"173\":1}}],[\"为止\",{\"1\":{\"170\":1}}],[\"为奇数\",{\"1\":{\"304\":1}}],[\"为奇数时\",{\"1\":{\"299\":1}}],[\"为奇数时表示\",{\"1\":{\"126\":1}}],[\"为奇数为买入\",{\"1\":{\"126\":1}}],[\"为5\",{\"1\":{\"99\":1}}],[\"为例\",{\"1\":{\"95\":1,\"137\":1,\"141\":1,\"143\":1}}],[\"为左子树\",{\"1\":{\"89\":1}}],[\"为树的高度\",{\"1\":{\"67\":1}}],[\"为不同节点且均存在于给定的二叉搜索树中\",{\"1\":{\"63\":1}}],[\"为\",{\"1\":{\"62\":1,\"142\":1,\"227\":1,\"231\":1,\"257\":1,\"273\":1,\"347\":1,\"390\":7,\"459\":1,\"728\":1,\"800\":2}}],[\"为二叉树的中序遍历序列\",{\"1\":{\"48\":1}}],[\"为二叉树的前序遍历序列\",{\"1\":{\"48\":1}}],[\"为什么需要\",{\"0\":{\"749\":1}}],[\"为什么需要页目录\",{\"1\":{\"673\":1}}],[\"为什么需要约束\",{\"1\":{\"612\":1}}],[\"为什么不将完整的用户记录都放到叶子节点中呢\",{\"1\":{\"651\":1}}],[\"为什么\",{\"1\":{\"618\":1}}],[\"为什么浮点数类型的无符号数取值范围\",{\"1\":{\"599\":1}}],[\"为什么返回数值是整数\",{\"1\":{\"278\":1}}],[\"为什么要这么移动呢\",{\"1\":{\"391\":1}}],[\"为什么要先找10+5呢\",{\"1\":{\"358\":1}}],[\"为什么要覆盖\",{\"1\":{\"313\":1}}],[\"为什么要和n比\",{\"1\":{\"304\":1}}],[\"为什么要和m比\",{\"1\":{\"304\":1}}],[\"为什么要使用索引\",{\"0\":{\"641\":1}}],[\"为什么要使用\",{\"1\":{\"276\":1}}],[\"为什么要标注\",{\"1\":{\"226\":1}}],[\"为什么会判断\",{\"1\":{\"211\":1}}],[\"为什么没有增加呢\",{\"1\":{\"152\":1,\"153\":1}}],[\"为什么没有中序呢\",{\"1\":{\"31\":1}}],[\"为什么还要考虑\",{\"1\":{\"148\":1,\"153\":1}}],[\"为什么将选\",{\"1\":{\"117\":1}}],[\"为什么呢\",{\"1\":{\"7\":1,\"382\":1,\"741\":2}}],[\"均是\",{\"1\":{\"492\":1}}],[\"均存在于给定的二叉树中\",{\"1\":{\"61\":1}}],[\"均出现在\",{\"1\":{\"48\":1}}],[\"均\",{\"1\":{\"48\":1}}],[\"找不到文件启动失败\",{\"1\":{\"454\":1}}],[\"找回5元\",{\"1\":{\"358\":2}}],[\"找到查询的关键字\",{\"1\":{\"658\":1}}],[\"找到与请求相匹配的路由\",{\"1\":{\"488\":1}}],[\"找到与val相等的结点\",{\"1\":{\"377\":1}}],[\"找到每一个元素能够跳跃的最远距离\",{\"1\":{\"350\":1}}],[\"找到为0的元素的位置\",{\"1\":{\"301\":1}}],[\"找到输出元素\",{\"1\":{\"280\":1}}],[\"找到\",{\"1\":{\"260\":1,\"384\":1,\"389\":1,\"436\":1}}],[\"找到反转字符串的起始点\",{\"1\":{\"253\":1}}],[\"找到所有被\",{\"1\":{\"231\":1}}],[\"找到即返回\",{\"1\":{\"213\":1}}],[\"找到nums的排列方式\",{\"1\":{\"209\":2}}],[\"找到一种填充结果就返回\",{\"1\":{\"217\":1}}],[\"找到一个合理的行程返回\",{\"1\":{\"213\":2}}],[\"找到一个空的位置插入即可\",{\"1\":{\"66\":1}}],[\"找到一组解之后\",{\"1\":{\"177\":1}}],[\"找到最长且\",{\"1\":{\"134\":1}}],[\"找到其中最长严格递增子序列的长度\",{\"1\":{\"132\":1}}],[\"找到修剪的结点\",{\"1\":{\"70\":1}}],[\"找到删除的结点\",{\"1\":{\"68\":1}}],[\"找到该树中两个指定节点的最近公共祖先\",{\"1\":{\"61\":1,\"63\":1}}],[\"找到等于val的结点返回即可\",{\"1\":{\"54\":1}}],[\"找到数组最大值的下标\",{\"1\":{\"51\":1}}],[\"找到根结点\",{\"1\":{\"47\":1}}],[\"找出适合的贪心策略\",{\"1\":{\"342\":1}}],[\"找出该数组中满足其和\",{\"1\":{\"284\":1}}],[\"找出中间索引\",{\"1\":{\"271\":2}}],[\"找出\",{\"1\":{\"194\":1,\"196\":1}}],[\"找出所有相加之和为\",{\"1\":{\"189\":1}}],[\"找出其中最长的回文子序列\",{\"1\":{\"156\":1}}],[\"找出其最小深度\",{\"1\":{\"27\":1}}],[\"找出选择左孩子\",{\"1\":{\"117\":1}}],[\"找出并返回所有该数组中不同的递增子序列\",{\"1\":{\"206\":1}}],[\"找出并返回\",{\"1\":{\"59\":1}}],[\"找出最小的即可\",{\"1\":{\"58\":1}}],[\"找出最后一层的第一个结点\",{\"1\":{\"43\":1}}],[\"找出根节点\",{\"1\":{\"47\":1}}],[\"直至找到未被占用的端口\",{\"1\":{\"408\":1,\"420\":1}}],[\"直径\",{\"1\":{\"364\":1}}],[\"直到超时\",{\"1\":{\"786\":1}}],[\"直到它拿到锁\",{\"1\":{\"781\":1}}],[\"直到拥有\",{\"1\":{\"778\":1}}],[\"直到事务\",{\"1\":{\"772\":1}}],[\"直到str的长度为len个字符\",{\"1\":{\"552\":2}}],[\"直到无法继续删除\",{\"1\":{\"327\":1}}],[\"直到找到与条件符合的记录\",{\"1\":{\"641\":1}}],[\"直到找到\",{\"1\":{\"313\":1}}],[\"直到找到一个输出元素\",{\"1\":{\"279\":1}}],[\"直到相遇为止\",{\"1\":{\"250\":1}}],[\"直到没有元素了\",{\"1\":{\"222\":1}}],[\"直到\",{\"1\":{\"173\":1,\"245\":1}}],[\"直到构建出二叉树\",{\"1\":{\"49\":1}}],[\"直到构成一个二叉树\",{\"1\":{\"47\":1}}],[\"直接进入等待\",{\"1\":{\"786\":1}}],[\"直接影响我们是否能有效的利用索引\",{\"1\":{\"689\":1}}],[\"直接将结果反馈给客户端\",{\"1\":{\"630\":1}}],[\"直接将集合反转即可\",{\"1\":{\"14\":1}}],[\"直接读行数\",{\"1\":{\"562\":1}}],[\"直接把系统拉升到高水位可能瞬间把系统压垮\",{\"1\":{\"411\":1}}],[\"直接报错\",{\"1\":{\"411\":1}}],[\"直接\",{\"1\":{\"410\":1,\"617\":1}}],[\"直接收下\",{\"1\":{\"358\":1}}],[\"直接加入\",{\"1\":{\"334\":2}}],[\"直接加入结果数组中\",{\"1\":{\"296\":1}}],[\"直接入队\",{\"1\":{\"334\":2}}],[\"直接入栈\",{\"1\":{\"325\":1,\"328\":1}}],[\"直接压入输入栈\",{\"1\":{\"323\":1}}],[\"直接在原矩阵中修改\",{\"1\":{\"299\":1}}],[\"直接遍历\",{\"1\":{\"275\":1}}],[\"直接使用\",{\"1\":{\"273\":1}}],[\"直接减掉\",{\"1\":{\"191\":1}}],[\"直接剪掉\",{\"1\":{\"191\":1}}],[\"直接双层for循环\",{\"1\":{\"175\":1}}],[\"直接用cur表示\",{\"1\":{\"115\":1}}],[\"直接删除结点\",{\"1\":{\"68\":1}}],[\"直接删除即可\",{\"1\":{\"68\":1}}],[\"直接插入数组末尾即可\",{\"1\":{\"273\":1}}],[\"直接插入\",{\"1\":{\"66\":1}}],[\"直接返回成功\",{\"1\":{\"853\":1}}],[\"直接返回false\",{\"1\":{\"163\":1}}],[\"直接返回null\",{\"1\":{\"70\":1}}],[\"直接返回\",{\"1\":{\"54\":1,\"704\":1}}],[\"直接返回true\",{\"1\":{\"45\":1}}],[\"直接返回深度即可\",{\"1\":{\"28\":1}}],[\"请使用绝对链接\",{\"1\":{\"885\":1}}],[\"请阅读\",{\"1\":{\"868\":1}}],[\"请先阅读\",{\"1\":{\"865\":1}}],[\"请先停止\",{\"1\":{\"826\":1}}],[\"请参考\",{\"1\":{\"836\":1}}],[\"请参考示例图\",{\"1\":{\"216\":1}}],[\"请看官方文档\",{\"1\":{\"703\":1}}],[\"请在sql语句中使\",{\"1\":{\"583\":1}}],[\"请稍后重试\",{\"1\":{\"444\":2}}],[\"请稍后再试\",{\"1\":{\"422\":1,\"444\":4,\"472\":1,\"477\":1,\"480\":1,\"481\":1}}],[\"请联系管理员授予权限\",{\"1\":{\"444\":1}}],[\"请求c查询缓存\",{\"1\":{\"849\":1}}],[\"请求d删除缓存\",{\"1\":{\"849\":1}}],[\"请求d先写数据库\",{\"1\":{\"849\":1}}],[\"请求d先删除数据库\",{\"1\":{\"848\":1}}],[\"请求d卡顿结束\",{\"1\":{\"848\":1}}],[\"请求d由于卡顿还未更新数据库\",{\"1\":{\"848\":1}}],[\"请求a卡顿结束\",{\"1\":{\"847\":1}}],[\"请求b在请求a卡顿的过程中\",{\"1\":{\"847\":1}}],[\"请求参数相关\",{\"0\":{\"500\":1}}],[\"请求参数中的usertype=diamonds\",{\"1\":{\"497\":1}}],[\"请求参数中的usertype与配置的usertype相等\",{\"1\":{\"497\":1}}],[\"请求头kv\",{\"1\":{\"499\":1}}],[\"请求头相关\",{\"0\":{\"499\":1}}],[\"请求鉴权\",{\"1\":{\"498\":1}}],[\"请求的细节\",{\"1\":{\"470\":1}}],[\"请求压缩\",{\"1\":{\"469\":1}}],[\"请求太过频繁\",{\"1\":{\"423\":1}}],[\"请求失败\",{\"1\":{\"422\":1}}],[\"请求数小于该值时即使异常比率超出阈值也不会熔断\",{\"1\":{\"419\":1}}],[\"请求\",{\"0\":{\"469\":1},\"1\":{\"410\":2}}],[\"请以对角线遍历的顺序\",{\"1\":{\"303\":1}}],[\"请不要\",{\"1\":{\"297\":1}}],[\"请必须使用时间复杂度为\",{\"1\":{\"273\":1}}],[\"请返回更新后的密码字符串\",{\"1\":{\"255\":1}}],[\"请返回将\",{\"1\":{\"151\":1}}],[\"请\",{\"1\":{\"176\":1}}],[\"请注意\",{\"1\":{\"104\":1,\"140\":1,\"278\":1,\"315\":1}}],[\"请计算\",{\"1\":{\"78\":1}}],[\"请你反转从位置\",{\"1\":{\"383\":1}}],[\"请你反转链表\",{\"1\":{\"380\":1}}],[\"请你反转字符串中\",{\"1\":{\"244\":1}}],[\"请你删除链表中所有满足\",{\"1\":{\"376\":1}}],[\"请你重新构造并返回输入数组\",{\"1\":{\"361\":1}}],[\"请你给每个孩子分发糖果\",{\"1\":{\"359\":1}}],[\"请你仅使用两个栈实现先入先出队列\",{\"1\":{\"321\":1}}],[\"请你\",{\"1\":{\"312\":1}}],[\"请你合并所有重叠的区间\",{\"1\":{\"294\":1}}],[\"请你返回其中出现频率前\",{\"1\":{\"336\":1}}],[\"请你返回\",{\"1\":{\"290\":1}}],[\"请你返回满足上述条件\",{\"1\":{\"290\":1}}],[\"请你返回该数组所有可能的子集\",{\"1\":{\"204\":1}}],[\"请你找到\",{\"1\":{\"290\":1}}],[\"请你找出给定目标值在数组中的开始位置和结束位置\",{\"1\":{\"275\":1}}],[\"请你找出所有从节点\",{\"1\":{\"223\":1}}],[\"请你找出一个具有最大和的连续子数组\",{\"1\":{\"142\":1,\"347\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"390\":1}}],[\"请你找出并返回数组中的\",{\"1\":{\"276\":1}}],[\"请你找出并返回满足下述全部条件且不重复的四元组\",{\"1\":{\"178\":1}}],[\"请你找出并返回\",{\"1\":{\"100\":1}}],[\"请你计算该表达式\",{\"1\":{\"330\":1}}],[\"请你计算网格中岛屿的数量\",{\"1\":{\"225\":1}}],[\"请你计算并返回可以凑成总金额的硬币组合数\",{\"1\":{\"102\":1}}],[\"请你计算并返回达到楼梯顶部的最低花费\",{\"1\":{\"82\":1}}],[\"请你按字典排序返回最小的行程组合\",{\"1\":{\"212\":1}}],[\"请你对该行程进行重新规划排序\",{\"1\":{\"212\":1}}],[\"请你在该数组中找出\",{\"1\":{\"174\":1}}],[\"请你判断\",{\"1\":{\"172\":1}}],[\"请你判断是否可以将这个数组分割成两个子集\",{\"1\":{\"94\":1}}],[\"请你将图像顺时针旋转\",{\"1\":{\"297\":1}}],[\"请你将\",{\"1\":{\"164\":1,\"198\":1}}],[\"请你将其转换为累加树\",{\"1\":{\"73\":1}}],[\"请你将其转换为一棵\",{\"1\":{\"71\":1}}],[\"请你统计并返回这个字符串中\",{\"1\":{\"154\":1}}],[\"请你从数组中找出满足相加之和等于目标数\",{\"1\":{\"240\":1}}],[\"请你从\",{\"1\":{\"104\":1}}],[\"请你构造并返回这颗\",{\"1\":{\"46\":1}}],[\"请构造二叉树并返回其根节点\",{\"1\":{\"48\":1}}],[\"请找出该二叉树的\",{\"1\":{\"42\":1}}],[\"请找出该二叉树中每一层的最大值\",{\"1\":{\"21\":1}}],[\"思路很简单\",{\"1\":{\"381\":1}}],[\"思路和26题一样\",{\"1\":{\"316\":1}}],[\"思路分\",{\"0\":{\"234\":1}}],[\"思路分析\",{\"0\":{\"12\":1,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"31\":1,\"33\":1,\"35\":1,\"37\":1,\"39\":1,\"41\":1,\"43\":1,\"45\":1,\"47\":1,\"49\":1,\"51\":1,\"54\":1,\"56\":1,\"58\":1,\"60\":1,\"62\":1,\"64\":1,\"66\":1,\"68\":1,\"70\":1,\"72\":1,\"74\":1,\"79\":1,\"81\":1,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"95\":1,\"97\":1,\"99\":1,\"101\":1,\"103\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":1,\"117\":1,\"120\":1,\"122\":1,\"124\":1,\"126\":1,\"128\":1,\"130\":1,\"133\":1,\"135\":1,\"137\":1,\"139\":1,\"141\":1,\"143\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":1,\"155\":1,\"157\":1,\"162\":1,\"165\":1,\"167\":1,\"170\":1,\"173\":1,\"175\":1,\"177\":1,\"179\":1,\"187\":1,\"190\":1,\"193\":1,\"195\":1,\"197\":1,\"199\":1,\"201\":1,\"203\":1,\"205\":1,\"207\":1,\"209\":1,\"211\":1,\"213\":1,\"215\":1,\"217\":1,\"224\":1,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"241\":1,\"245\":1,\"247\":1,\"253\":1,\"256\":1,\"258\":1,\"261\":1,\"267\":1,\"270\":1,\"279\":1,\"282\":1,\"285\":1,\"288\":1,\"291\":1,\"295\":1,\"301\":1,\"304\":1,\"307\":1,\"310\":1,\"313\":1,\"316\":1,\"322\":1,\"325\":1,\"328\":1,\"331\":1,\"334\":1,\"337\":1,\"344\":1,\"346\":1,\"348\":1,\"350\":1,\"352\":1,\"354\":1,\"356\":1,\"358\":1,\"360\":1,\"362\":1,\"364\":1,\"366\":1,\"368\":1,\"370\":1,\"372\":1,\"377\":1,\"381\":1,\"384\":1,\"386\":1,\"389\":1,\"391\":1,\"394\":1},\"1\":{\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1}}],[\"思路其实和\",{\"1\":{\"49\":1}}],[\"思路一样\",{\"1\":{\"45\":1,\"232\":1,\"328\":1}}],[\"不适合\",{\"1\":{\"837\":1}}],[\"不得使用外键与级联\",{\"1\":{\"837\":1}}],[\"不得不考虑一个现实问题就是磁盘\",{\"1\":{\"657\":1}}],[\"不但节约数据库表空间\",{\"1\":{\"836\":1}}],[\"不但不会提高查询效率\",{\"1\":{\"690\":1}}],[\"不一样\",{\"1\":{\"812\":1}}],[\"不一定按顺序\",{\"1\":{\"361\":1}}],[\"不指定就是所有行\",{\"1\":{\"809\":1}}],[\"不指定就是0\",{\"1\":{\"809\":1}}],[\"不指定就是从整个文件首个pos点开始算\",{\"1\":{\"809\":1}}],[\"不指定就是第一个binlog文件\",{\"1\":{\"809\":1}}],[\"不容易分辨查看到pos点信息\",{\"1\":{\"809\":1}}],[\"不与行级锁冲突表级锁\",{\"1\":{\"771\":1}}],[\"不与列一起\",{\"1\":{\"613\":1}}],[\"不加锁的简单的select都属于快照读\",{\"1\":{\"791\":1}}],[\"不加锁\",{\"1\":{\"763\":1,\"791\":1}}],[\"不加global只是当前窗口有效\",{\"1\":{\"698\":1}}],[\"不进行同步\",{\"1\":{\"753\":1}}],[\"不进行买卖股票\",{\"1\":{\"124\":1}}],[\"不支持icp优化方法\",{\"1\":{\"728\":1}}],[\"不支持的认证模式\",{\"1\":{\"444\":1}}],[\"不等于\",{\"0\":{\"719\":1}}],[\"不等于null\",{\"1\":{\"614\":1}}],[\"不将数字抽象成n\",{\"1\":{\"699\":1}}],[\"不含10秒\",{\"1\":{\"697\":1}}],[\"不建议用无序的值作为索引\",{\"1\":{\"690\":1}}],[\"不附加任何限制条件\",{\"1\":{\"686\":1}}],[\"不仅是对单个关键字的查询上\",{\"1\":{\"662\":1}}],[\"不仅会创建\",{\"1\":{\"587\":1}}],[\"不论是共享gap锁还是独占gap锁\",{\"1\":{\"776\":1}}],[\"不论是内存临时表还是磁盘临时表都\",{\"1\":{\"724\":1}}],[\"不论是存放用户记录\",{\"1\":{\"648\":1}}],[\"不论我们的查询语句有多复杂\",{\"1\":{\"701\":1}}],[\"不论读一行\",{\"1\":{\"666\":1}}],[\"不论客户端进程和服务器进程是采用哪种方式进行通信\",{\"1\":{\"624\":1}}],[\"不缓存真实数据\",{\"1\":{\"636\":1,\"655\":1}}],[\"不推荐使用查询缓存\",{\"1\":{\"630\":1}}],[\"不推荐使用指定显示宽度的year\",{\"1\":{\"602\":1}}],[\"不会出现某些特定情况下\",{\"1\":{\"823\":1}}],[\"不会影响到服务\",{\"1\":{\"819\":1}}],[\"不会影响到从库进行\",{\"1\":{\"819\":1}}],[\"不会全表扫描的话\",{\"1\":{\"729\":1}}],[\"不会存在索引\",{\"1\":{\"724\":1}}],[\"不会对插入的数据有任何影响\",{\"1\":{\"595\":1}}],[\"不会报错\",{\"1\":{\"521\":1,\"564\":1}}],[\"不去重\",{\"1\":{\"540\":1}}],[\"不显示任何日志\",{\"1\":{\"470\":1}}],[\"不想新建seata\",{\"1\":{\"429\":2}}],[\"不在表示前面有单个字符\",{\"1\":{\"529\":1}}],[\"不在同一个类中\",{\"1\":{\"416\":1}}],[\"不在范围内\",{\"1\":{\"70\":1}}],[\"不可重复读的问题\",{\"1\":{\"799\":1}}],[\"不可重复读和幻读\",{\"1\":{\"746\":1}}],[\"不可重复读\",{\"1\":{\"746\":4,\"764\":1,\"765\":1,\"793\":2}}],[\"不可再次拆分\",{\"1\":{\"737\":1}}],[\"不可更新\",{\"1\":{\"650\":1}}],[\"不可访问\",{\"1\":{\"412\":1}}],[\"不可以被访问\",{\"1\":{\"800\":1}}],[\"不可以继续执行操作\",{\"1\":{\"763\":1}}],[\"不可以\",{\"1\":{\"240\":1}}],[\"不需要记录每一行的变化\",{\"1\":{\"823\":1}}],[\"不需要再进行排序\",{\"1\":{\"725\":1}}],[\"不需要建立临时表\",{\"1\":{\"724\":1}}],[\"不需要预先定义长度\",{\"1\":{\"605\":1}}],[\"不需要经过sql层\",{\"1\":{\"510\":1}}],[\"不需要持久化\",{\"1\":{\"423\":1}}],[\"不需要额外的\",{\"1\":{\"407\":1}}],[\"不需要考虑数组中超出新长度后面的元素\",{\"1\":{\"312\":2}}],[\"不依赖任何框架\",{\"1\":{\"407\":1}}],[\"不允许别的事务在id值为8的记录前边的间隙插入新记录\",{\"1\":{\"776\":1}}],[\"不允许你使用系统自带的外键约束\",{\"1\":{\"618\":1}}],[\"不允许\",{\"1\":{\"605\":1}}],[\"不允许修改\",{\"1\":{\"393\":1}}],[\"不允许使用额外数组\",{\"1\":{\"250\":1}}],[\"不作为参数进行传递\",{\"1\":{\"393\":1}}],[\"不满足胃口\",{\"1\":{\"344\":1}}],[\"不满足题意\",{\"1\":{\"100\":1}}],[\"不如说它是一种思想\",{\"1\":{\"344\":1}}],[\"不对实参作任何拷贝\",{\"1\":{\"278\":1}}],[\"不对应任何字母\",{\"1\":{\"192\":1}}],[\"不行嘛\",{\"1\":{\"276\":1}}],[\"不幸的是\",{\"1\":{\"274\":1}}],[\"不使用二分查找\",{\"1\":{\"273\":1}}],[\"不包含组函数的过滤条件\",{\"1\":{\"565\":2}}],[\"不包含直接返回400\",{\"1\":{\"504\":1}}],[\"不包含任何开头或结尾空格\",{\"1\":{\"246\":1}}],[\"不包含其他质因数\",{\"1\":{\"173\":1}}],[\"不关心他是否重复访问\",{\"1\":{\"230\":1}}],[\"不要使用\",{\"1\":{\"729\":1}}],[\"不要使用额外的数组空间\",{\"1\":{\"278\":1}}],[\"不要定义冗余或重复的索引\",{\"1\":{\"690\":1}}],[\"不要设置索引\",{\"1\":{\"690\":1}}],[\"不要以为唯一索引影响了\",{\"1\":{\"689\":1}}],[\"不要修改主键字段的值\",{\"1\":{\"616\":1}}],[\"不要持续访问9001加大微服务负担\",{\"1\":{\"420\":1}}],[\"不要搞混运算顺序\",{\"1\":{\"331\":1}}],[\"不要太在意\",{\"1\":{\"273\":1}}],[\"不要给另外的数组分配额外的空间\",{\"1\":{\"249\":1}}],[\"不要忘记将0结点加入到路径当中\",{\"1\":{\"224\":1}}],[\"不要求按特定顺序\",{\"1\":{\"223\":1}}],[\"不要求字典中出现的单词全部都使用\",{\"1\":{\"110\":1}}],[\"不冲突则放入棋盘内\",{\"1\":{\"215\":1}}],[\"不然会导致结\",{\"1\":{\"599\":1}}],[\"不然很容易懵的\",{\"1\":{\"386\":1}}],[\"不然像\",{\"1\":{\"201\":1}}],[\"不然操作的始终是同一个item集合\",{\"1\":{\"187\":2}}],[\"不定义sum\",{\"1\":{\"190\":1}}],[\"不再包含质因数\",{\"1\":{\"173\":1}}],[\"不考虑元素的顺序\",{\"1\":{\"203\":1}}],[\"不考虑输出结果的顺序\",{\"1\":{\"166\":1}}],[\"不考虑增加和替换\",{\"1\":{\"153\":1}}],[\"不改变剩余字符顺序的情况下\",{\"1\":{\"156\":1}}],[\"不用每次都对数据上锁\",{\"1\":{\"782\":1}}],[\"不用把整个页的数据都刷新回磁盘\",{\"1\":{\"749\":1}}],[\"不用回表\",{\"1\":{\"727\":1}}],[\"不用担心数据超出范围影响可靠性的问题\",{\"1\":{\"598\":1}}],[\"不用进行反转了\",{\"1\":{\"354\":1}}],[\"不用替换的元素\",{\"1\":{\"279\":1}}],[\"不用我们手动去重呢\",{\"1\":{\"177\":1}}],[\"不用考虑\",{\"1\":{\"155\":1}}],[\"不用s\",{\"1\":{\"148\":2,\"153\":2}}],[\"不相关\",{\"1\":{\"570\":1}}],[\"不相同的时候\",{\"1\":{\"153\":3}}],[\"不相等则\",{\"1\":{\"291\":1}}],[\"不相等的情况为false\",{\"1\":{\"155\":1}}],[\"不相等时\",{\"1\":{\"148\":1,\"153\":1,\"155\":1,\"313\":1}}],[\"不相等\",{\"1\":{\"148\":1,\"153\":1}}],[\"不操作\",{\"1\":{\"152\":1}}],[\"不符合连续递增\",{\"1\":{\"135\":1}}],[\"不难写出这样的递推公式\",{\"1\":{\"128\":1}}],[\"不持有\",{\"1\":{\"126\":1}}],[\"不持有股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"不选中则表示非集群环境\",{\"1\":{\"409\":1}}],[\"不选择右孩子的最大值\",{\"1\":{\"117\":1}}],[\"不选择左孩子的最大值\",{\"1\":{\"117\":1}}],[\"不选择节点2\",{\"1\":{\"117\":1}}],[\"不选则当前节点\",{\"1\":{\"117\":1}}],[\"不选则为0\",{\"1\":{\"117\":1}}],[\"不选当前节点子树最大和\",{\"1\":{\"117\":1}}],[\"不选作为状态\",{\"1\":{\"117\":1}}],[\"不选\",{\"1\":{\"117\":5}}],[\"不选node节点\",{\"1\":{\"117\":1}}],[\"不能被拆开\",{\"1\":{\"810\":1}}],[\"不能被其他事务干扰\",{\"1\":{\"741\":1}}],[\"不能避免脏读\",{\"1\":{\"746\":1}}],[\"不能只依赖主键的一部分\",{\"1\":{\"737\":1}}],[\"不能单独使用\",{\"1\":{\"617\":1}}],[\"不能组合非空\",{\"1\":{\"614\":1}}],[\"不能存在两条完全相同无法区分的记录\",{\"1\":{\"612\":1}}],[\"不能一次选取多个值\",{\"1\":{\"606\":1}}],[\"不能负数\",{\"1\":{\"477\":1}}],[\"不能同一斜线\",{\"1\":{\"215\":1}}],[\"不能同列\",{\"1\":{\"215\":1}}],[\"不能同行\",{\"1\":{\"215\":1}}],[\"不能有重复元素可以理解为\",{\"1\":{\"211\":2}}],[\"不能有重复的组合\",{\"1\":{\"197\":1,\"211\":1}}],[\"不能\",{\"1\":{\"200\":1,\"202\":1,\"204\":1}}],[\"不能因为\",{\"1\":{\"179\":1}}],[\"不能使用nums\",{\"1\":{\"177\":1}}],[\"不能选择儿子节点最大值为2\",{\"1\":{\"117\":1}}],[\"不能选儿子节点\",{\"1\":{\"117\":1}}],[\"不能分割成等长的子集\",{\"1\":{\"95\":1}}],[\"不偷当前屋\",{\"1\":{\"115\":1}}],[\"不偷第一间房屋\",{\"1\":{\"115\":2}}],[\"不偷最后一间\",{\"1\":{\"115\":2}}],[\"不偷\",{\"1\":{\"113\":1}}],[\"不触动警报装置的情况下\",{\"1\":{\"112\":1}}],[\"不是所有的update语句都能被复制\",{\"1\":{\"823\":1}}],[\"不是意向锁\",{\"1\":{\"778\":1}}],[\"不是减号\",{\"1\":{\"661\":1}}],[\"不是末尾节点\",{\"1\":{\"379\":1}}],[\"不是链表中的最后一个节点\",{\"1\":{\"379\":1}}],[\"不是摆动序列\",{\"1\":{\"345\":1}}],[\"不是丑数\",{\"1\":{\"172\":1,\"173\":1}}],[\"不是\",{\"1\":{\"108\":1,\"138\":1,\"145\":1,\"169\":1,\"306\":1,\"357\":1}}],[\"不是最大值的时候\",{\"1\":{\"107\":1}}],[\"不是整除的话\",{\"1\":{\"99\":1}}],[\"不放入第\",{\"1\":{\"92\":1}}],[\"不放第\",{\"1\":{\"91\":1}}],[\"不应该是链表的最后一个节点\",{\"1\":{\"379\":1}}],[\"不应该\",{\"1\":{\"69\":1}}],[\"不为\",{\"1\":{\"52\":1}}],[\"不断删除缓存\",{\"1\":{\"851\":1}}],[\"不断移动双指针\",{\"1\":{\"381\":1}}],[\"不断进行更新\",{\"1\":{\"350\":2}}],[\"不断更新下一步所覆盖的最大范围\",{\"1\":{\"352\":1}}],[\"不断更新回文子串\",{\"1\":{\"262\":1}}],[\"不断更新这个变量\",{\"1\":{\"58\":1}}],[\"不断的递归\",{\"1\":{\"215\":1}}],[\"不断递归达到叶子节点时\",{\"1\":{\"187\":1}}],[\"不断维护这俩个变量\",{\"1\":{\"120\":1}}],[\"不断循环上面的步骤\",{\"1\":{\"49\":1}}],[\"不断重复上面的四步\",{\"1\":{\"47\":1}}],[\"不同客户端之间共享\",{\"1\":{\"630\":1}}],[\"不同点\",{\"1\":{\"589\":1}}],[\"不同组合\",{\"1\":{\"194\":1}}],[\"不同的存储引擎具有的功能不同\",{\"1\":{\"631\":1}}],[\"不同的版本可能有所差异\",{\"1\":{\"602\":1}}],[\"不同的namespace之间是隔离的\",{\"1\":{\"404\":1}}],[\"不同的命名空间下\",{\"1\":{\"404\":1}}],[\"不同的三元组是\",{\"1\":{\"176\":1}}],[\"不同的子序列\",{\"1\":{\"153\":2}}],[\"不同的是\",{\"1\":{\"105\":1}}],[\"不同\",{\"1\":{\"46\":1,\"104\":1}}],[\"不存在死锁问题\",{\"1\":{\"783\":1}}],[\"不存在则创建数据库\",{\"1\":{\"585\":1}}],[\"不存在重复数据\",{\"1\":{\"540\":1}}],[\"不存在符合要求的\",{\"1\":{\"290\":1}}],[\"不存在有效的组合\",{\"1\":{\"189\":1}}],[\"不存在\",{\"1\":{\"44\":1,\"269\":1}}],[\"不过适用场景也会相对乐观\",{\"1\":{\"783\":1}}],[\"不过锁结构的\",{\"1\":{\"763\":1}}],[\"不过也存在一种情况\",{\"1\":{\"658\":1}}],[\"不过leetcode用不了\",{\"1\":{\"171\":1}}],[\"不过\",{\"1\":{\"12\":1}}],[\"我在右对齐\",{\"1\":{\"873\":1}}],[\"我只要更改内存中的数据我就刷新回磁盘\",{\"1\":{\"749\":1}}],[\"我只愿意等待1秒\",{\"1\":{\"480\":1}}],[\"我建议你首先确保数据不会超过取值范围\",{\"1\":{\"598\":1}}],[\"我想要查询部门id\",{\"1\":{\"533\":1}}],[\"我想查询名字第二个字符带有\",{\"1\":{\"529\":1}}],[\"我是居中的\",{\"1\":{\"873\":1}}],[\"我是美丽分割线\",{\"1\":{\"503\":1}}],[\"我是ordernacoscontroller83调用者\",{\"1\":{\"402\":1}}],[\"我希望一次修改\",{\"1\":{\"452\":1}}],[\"我的代码\",{\"1\":{\"440\":1}}],[\"我的第一想法是\",{\"1\":{\"43\":1}}],[\"我直接想到的方法就是暴力法\",{\"1\":{\"285\":1}}],[\"我直接从右向左层序遍历\",{\"1\":{\"43\":1}}],[\"我举个栗子\",{\"1\":{\"74\":1}}],[\"我才用的左闭右开区间\",{\"1\":{\"51\":1}}],[\"我们通过主从复制将主库上的数据复制到了从库上\",{\"1\":{\"819\":1}}],[\"我们常常将\",{\"1\":{\"818\":1}}],[\"我们给这些问题\",{\"1\":{\"746\":1}}],[\"我们把这个撤销的过程称\",{\"1\":{\"742\":1}}],[\"我们现在知道\",{\"1\":{\"742\":1}}],[\"我们谁也无法预测在项目的整个生命周期中\",{\"1\":{\"732\":1}}],[\"我们`最好能使用索引来替代掉使用临时表`\",{\"1\":{\"710\":1}}],[\"我们`更关注在连接查询\",{\"1\":{\"709\":1}}],[\"我们看一下select\",{\"1\":{\"703\":1}}],[\"我们看左右子节点其实和\",{\"1\":{\"89\":1}}],[\"我们这里所说的\",{\"1\":{\"689\":1}}],[\"我们这道题该如何做呢\",{\"1\":{\"60\":1}}],[\"我们插入的4条记录在本页中的位置分别是\",{\"1\":{\"680\":1}}],[\"我们自己插入的记录就是普通记录\",{\"1\":{\"680\":1}}],[\"我们自己插入的四条记录的min\",{\"1\":{\"680\":1}}],[\"我们自己存储的记录会按照指定的行格式存储到\",{\"1\":{\"670\":1}}],[\"我们平时的数据以行为单位来向表中插入数据\",{\"1\":{\"675\":1}}],[\"我们平时在做贪心类的题目\",{\"1\":{\"342\":1}}],[\"我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串\",{\"1\":{\"668\":1}}],[\"我们知道\",{\"1\":{\"654\":1}}],[\"我们知道所谓的递归\",{\"1\":{\"5\":1}}],[\"我们根据这个以c2列大小排序的b+树只能确定我们要查找记录的主键值\",{\"1\":{\"651\":1}}],[\"我们一般定义主键为\",{\"1\":{\"650\":1}}],[\"我们一般都会定义一个自增的id列为主键\",{\"1\":{\"650\":1}}],[\"我们一定要先确定一个纬度\",{\"1\":{\"362\":1}}],[\"我们也把非聚集\",{\"1\":{\"649\":1}}],[\"我们也可以简称为next\",{\"1\":{\"777\":1}}],[\"我们也可以发现\",{\"1\":{\"304\":1}}],[\"我们也可以认为\",{\"1\":{\"211\":1}}],[\"我们也可以利用这些条件做题\",{\"1\":{\"33\":1}}],[\"我们的实际用户记录其实都存放在b+树的最底层的节点上\",{\"1\":{\"648\":1}}],[\"我们都把它们存放到b+树这个数据结构中了\",{\"1\":{\"648\":1}}],[\"我们都可以使用map来存储\",{\"1\":{\"337\":1}}],[\"我们新分配了一个编号为30的页来专门存储目录项记录\",{\"1\":{\"645\":1}}],[\"我们并不知道我们的搜索条件匹配哪些页中的记录\",{\"1\":{\"643\":1}}],[\"我们还能对从服务器进行\",{\"1\":{\"819\":1}}],[\"我们还是要避免\",{\"1\":{\"725\":1}}],[\"我们还经常遇到一种数据\",{\"1\":{\"603\":1}}],[\"我们还需要进行判断\",{\"1\":{\"348\":1}}],[\"我们还需要知道每条对角线的起点元素的位置\",{\"1\":{\"304\":1}}],[\"我们按内查询是否被执行多次\",{\"1\":{\"570\":1}}],[\"我们按内查询的结果返回一条还是多条记录\",{\"1\":{\"570\":1}}],[\"我们按顺序收取\",{\"1\":{\"357\":2}}],[\"我们先了解mysql\",{\"1\":{\"539\":1}}],[\"我们先确定\",{\"1\":{\"362\":1}}],[\"我们使用\",{\"1\":{\"447\":1}}],[\"我们底层调用的是post方法\",{\"1\":{\"446\":1}}],[\"我们在索引的数据结构章节讲过\",{\"1\":{\"680\":1}}],[\"我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢\",{\"1\":{\"643\":1}}],[\"我们在来说为什么where会比havign执行效率高\",{\"1\":{\"565\":1}}],[\"我们在使用\",{\"1\":{\"420\":1}}],[\"我们在树的节点上安装摄像头\",{\"1\":{\"371\":1}}],[\"我们才能修改指针\",{\"1\":{\"381\":1}}],[\"我们如何找到当前结点与上一结点\",{\"1\":{\"381\":1}}],[\"我们想删除它其中的一个节点\",{\"1\":{\"379\":1}}],[\"我们分别有三个数字来表示\",{\"1\":{\"372\":1}}],[\"我们称为\",{\"1\":{\"778\":1}}],[\"我们称这个整数是单调递增的\",{\"1\":{\"369\":1}}],[\"我们称之为\",{\"1\":{\"116\":1,\"819\":2}}],[\"我们将构建链表\",{\"1\":{\"379\":1}}],[\"我们将\",{\"1\":{\"366\":1}}],[\"我们尽量更新较小的值\",{\"1\":{\"366\":1}}],[\"我们仍然使用一个变量记录一个区间的\",{\"1\":{\"366\":1}}],[\"我们仍然先对\",{\"1\":{\"366\":1}}],[\"我们仍需要使用\",{\"1\":{\"193\":1}}],[\"我们无法退回\",{\"1\":{\"357\":1}}],[\"我们找还一张\",{\"1\":{\"357\":1}}],[\"我们收取一张\",{\"1\":{\"357\":2}}],[\"我们从这两个标准发布的页数也能看出\",{\"1\":{\"835\":1}}],[\"我们从\",{\"1\":{\"355\":1}}],[\"我们从根节点开始访问\",{\"1\":{\"7\":1}}],[\"我们以第一个元素为起跳点\",{\"1\":{\"350\":1}}],[\"我们同样可以抽象成二叉树\",{\"1\":{\"215\":1}}],[\"我们仅需要一种结果\",{\"1\":{\"213\":1}}],[\"我们不断移动上一结点和当前结点\",{\"1\":{\"382\":1}}],[\"我们不仅要比较孩子的左边\",{\"1\":{\"360\":1}}],[\"我们不可能让它无限重复\",{\"1\":{\"195\":1}}],[\"我们不需要自己维护一个数据结构\",{\"1\":{\"12\":1}}],[\"我们遍历的应该是数字对应的字母集合\",{\"1\":{\"193\":1}}],[\"我们首先需要知道\",{\"1\":{\"835\":1}}],[\"我们首先要知道\",{\"1\":{\"193\":1}}],[\"我们首先来观察一下\",{\"1\":{\"12\":1}}],[\"我们已经说过了\",{\"1\":{\"187\":1}}],[\"我们要把这个字符串划分为尽可能多的片段\",{\"1\":{\"367\":1}}],[\"我们要确定\",{\"1\":{\"362\":1}}],[\"我们要根据某个值来返回对应的下标\",{\"1\":{\"175\":1}}],[\"我们要将\",{\"1\":{\"99\":1}}],[\"我们很难找到\",{\"1\":{\"155\":1}}],[\"我们取最大值\",{\"1\":{\"117\":1}}],[\"我们发现又回到了起点\",{\"1\":{\"299\":1}}],[\"我们发现\",{\"1\":{\"115\":1}}],[\"我们说一个事务在\",{\"1\":{\"778\":1}}],[\"我们说先遍历物品还是先遍历背包都无所谓\",{\"1\":{\"103\":1}}],[\"我们说了有俩种方案可以得到当前的总价值\",{\"1\":{\"91\":1}}],[\"我们只能倒序\",{\"1\":{\"92\":1}}],[\"我们只需要掌握一些核心的功能\",{\"1\":{\"835\":1}}],[\"我们只需要部分数据\",{\"1\":{\"831\":1}}],[\"我们只需要考虑其中一个小问题\",{\"1\":{\"386\":1}}],[\"我们只需要维护队首最大的元素即可\",{\"1\":{\"334\":1}}],[\"我们只需要判断它的左子节点是否有左右孩子结点\",{\"1\":{\"41\":1}}],[\"我们只需要将层序遍历结果中\",{\"1\":{\"16\":1}}],[\"我们直接跳过root结点及左子树\",{\"1\":{\"70\":1}}],[\"我们直接跳过root结点及右子树\",{\"1\":{\"70\":1}}],[\"我们怎么知道当前结点出现的频率是不是最高的呢\",{\"1\":{\"60\":1}}],[\"我们就说该事\",{\"1\":{\"742\":1}}],[\"我们就说该事务处在\",{\"1\":{\"742\":3}}],[\"我们就是先从前往后遍历\",{\"1\":{\"362\":1}}],[\"我们就要选择较大的值\",{\"1\":{\"360\":1}}],[\"我们就要找到每条对角线的规律\",{\"1\":{\"304\":1}}],[\"我们就需要知道共有几条对角线\",{\"1\":{\"304\":1}}],[\"我们就需要考虑首尾相连了\",{\"1\":{\"115\":1}}],[\"我们就可以使用\",{\"1\":{\"700\":1}}],[\"我们就可以创建三个namespace\",{\"1\":{\"404\":1}}],[\"我们就可以利用\",{\"1\":{\"362\":1}}],[\"我们就可以利用这个条件\",{\"1\":{\"273\":1}}],[\"我们就可以将这道题转换为01背包问题了\",{\"1\":{\"95\":1}}],[\"我们就跳过当前元素\",{\"1\":{\"211\":1}}],[\"我们就偷一间\",{\"1\":{\"115\":1}}],[\"我们就记录这个结点\",{\"1\":{\"60\":1}}],[\"我们就无法这样做了\",{\"1\":{\"7\":1}}],[\"我们又要用到上面的技巧了\",{\"1\":{\"60\":1}}],[\"我们可以采用\",{\"1\":{\"782\":1}}],[\"我们可以通过主从复制的方式来\",{\"1\":{\"819\":1}}],[\"我们可以通过候选键\",{\"1\":{\"737\":1}}],[\"我们可以通过配置来调整日志级别\",{\"1\":{\"470\":1}}],[\"我们可以直接在聚簇索引上进行查找\",{\"1\":{\"696\":1}}],[\"我们可以为快速定位记录所在的数据页而\",{\"1\":{\"643\":1}}],[\"我们可以这样想\",{\"1\":{\"477\":1}}],[\"我们可以看到每一个方法都配备了一个\",{\"1\":{\"420\":1}}],[\"我们可以将每个部门的id\",{\"1\":{\"579\":1}}],[\"我们可以将\",{\"1\":{\"350\":1}}],[\"我们可以将这个饼干\",{\"1\":{\"343\":1}}],[\"我们可以删除\",{\"1\":{\"327\":1}}],[\"我们可以逆向分析\",{\"1\":{\"234\":1}}],[\"我们可以定义一个全局变量\",{\"1\":{\"222\":1}}],[\"我们可以定义一个递归\",{\"1\":{\"62\":1}}],[\"我们可以得到的最小和是1+2+3+4\",{\"1\":{\"189\":1}}],[\"我们可以得知\",{\"1\":{\"155\":1,\"273\":1}}],[\"我们可以\",{\"1\":{\"166\":1}}],[\"我们可以利用hash表\",{\"1\":{\"394\":1}}],[\"我们可以利用俩个变量\",{\"1\":{\"352\":1}}],[\"我们可以利用这个原理\",{\"1\":{\"162\":1}}],[\"我们可以利用滚动数组的思想\",{\"1\":{\"81\":1}}],[\"我们可以发现当\",{\"1\":{\"126\":1}}],[\"我们可以找一下规律\",{\"1\":{\"126\":1}}],[\"我们可以用\",{\"1\":{\"111\":1}}],[\"我们可以尝试使用j来定位\",{\"1\":{\"111\":1}}],[\"我们可以使用\",{\"1\":{\"41\":1,\"337\":1}}],[\"我们可以依据上面为模板进行改良\",{\"1\":{\"39\":1}}],[\"我们需要把数据改回原先的样子\",{\"1\":{\"755\":1}}],[\"我们需要进行5次\",{\"1\":{\"660\":1}}],[\"我们需要进行排序\",{\"1\":{\"364\":1}}],[\"我们需要解决如下问题\",{\"1\":{\"483\":1}}],[\"我们需要手动\",{\"1\":{\"462\":1}}],[\"我们需要使用俩个指针\",{\"1\":{\"250\":1}}],[\"我们需要分情况讨论\",{\"1\":{\"68\":1}}],[\"我们需要判断\",{\"1\":{\"60\":1}}],[\"我们需要回溯到初始结点\",{\"1\":{\"39\":1}}],[\"我们需要稍微修改一下代码\",{\"1\":{\"12\":1}}],[\"我们是将左孩子\",{\"1\":{\"20\":1}}],[\"我们\",{\"1\":{\"12\":1,\"643\":1}}],[\"我们当然更倾向于更方便写\",{\"1\":{\"12\":1}}],[\"我们用\",{\"1\":{\"12\":1,\"643\":1}}],[\"我们访问结点和处理结点的顺序是一致的\",{\"1\":{\"7\":1}}],[\"累加起来\",{\"1\":{\"99\":1}}],[\"累加从后到当前节点的和\",{\"1\":{\"74\":1}}],[\"累加左子节点的值即可\",{\"1\":{\"41\":1}}],[\"累加结点的值\",{\"1\":{\"18\":1}}],[\"俩阶段提交\",{\"0\":{\"812\":1}}],[\"俩张表连接\",{\"1\":{\"579\":1}}],[\"俩中发现方式\",{\"1\":{\"449\":1}}],[\"俩者的移动次数其实是一样的\",{\"1\":{\"391\":1}}],[\"俩个注解实现\",{\"1\":{\"458\":1}}],[\"俩个openfeign调用接口\",{\"1\":{\"431\":1}}],[\"俩个结点交换时\",{\"1\":{\"386\":1}}],[\"俩个栈都为空\",{\"1\":{\"323\":1}}],[\"俩个指针倒序遍历字符串\",{\"1\":{\"245\":1}}],[\"俩个字符串相等\",{\"1\":{\"162\":1}}],[\"俩个字符串的删除操作\",{\"1\":{\"153\":1}}],[\"俩个字符串的子序列长度为\",{\"1\":{\"146\":1}}],[\"俩个target值都不会超过\",{\"1\":{\"97\":1}}],[\"俩种锁的使用场景\",{\"0\":{\"783\":1}}],[\"俩种情况取最大值\",{\"1\":{\"157\":1}}],[\"俩种情况\",{\"1\":{\"97\":1,\"115\":1}}],[\"俩种方案选择最大价值的为结果\",{\"1\":{\"91\":1}}],[\"俩种方法\",{\"1\":{\"41\":1}}],[\"俩颗子树互为镜像\",{\"1\":{\"33\":1}}],[\"俩颗对称的子树它的根的值是相等的\",{\"1\":{\"33\":1}}],[\"有了这个readview\",{\"1\":{\"798\":1}}],[\"有些时候一张表的数据量很大\",{\"1\":{\"831\":1}}],[\"有些搜索条件中虽然出现了索引列\",{\"1\":{\"710\":1}}],[\"有些存储引擎支持更多的索引数和更大的索引长度\",{\"1\":{\"642\":1}}],[\"有除了该索引包含的列之外的其他搜索条件时\",{\"1\":{\"710\":1}}],[\"有时候我们既想\",{\"1\":{\"777\":1}}],[\"有时候主机迁移了\",{\"1\":{\"452\":1}}],[\"有时不是真实的表名字\",{\"1\":{\"701\":1}}],[\"有大量重复数据的列上不要建立索引\",{\"1\":{\"690\":1}}],[\"有多个\",{\"1\":{\"686\":1}}],[\"有多少记录就往这个文件中塞多少记录就成了\",{\"1\":{\"654\":1}}],[\"有多少个元素就需要多少编辑距离变成空串\",{\"1\":{\"152\":2}}],[\"有多少方法呢\",{\"1\":{\"99\":1}}],[\"有多少种\",{\"1\":{\"88\":1}}],[\"有别于avl算法\",{\"1\":{\"660\":1}}],[\"有没有精准的数据类型呢\",{\"1\":{\"599\":1}}],[\"有符号数取值范围大于等于零的部分呢\",{\"1\":{\"599\":1}}],[\"有哪些非关系型数据库\",{\"1\":{\"510\":1}}],[\"有哪些来源可以推出dp\",{\"1\":{\"99\":1}}],[\"有30位用于网络地址和子网掩码\",{\"1\":{\"495\":1}}],[\"有名称\",{\"1\":{\"491\":1}}],[\"有点类似于springmvc的执行流程\",{\"1\":{\"488\":1}}],[\"有什么区别\",{\"1\":{\"487\":1}}],[\"有序\",{\"1\":{\"658\":1}}],[\"有序进行\",{\"1\":{\"472\":1}}],[\"有序数组的平方\",{\"0\":{\"281\":1}}],[\"有问题的节点\",{\"1\":{\"471\":1}}],[\"有类型的异常\",{\"1\":{\"416\":1}}],[\"有请求之后才会开始进行监控\",{\"1\":{\"408\":1}}],[\"有交点\",{\"1\":{\"390\":1}}],[\"有覆盖状态\",{\"1\":{\"372\":1}}],[\"有覆盖或者无覆盖的状态\",{\"1\":{\"372\":1}}],[\"有摄像头\",{\"1\":{\"372\":1}}],[\"有如下三种\",{\"1\":{\"372\":1}}],[\"有以下几种情况\",{\"1\":{\"261\":1}}],[\"有以下的特点\",{\"1\":{\"213\":1}}],[\"有三个\",{\"1\":{\"229\":1}}],[\"有三种方式可以实现\",{\"1\":{\"422\":1}}],[\"有三种方法可以爬到楼顶\",{\"1\":{\"80\":1}}],[\"有三种情况\",{\"1\":{\"153\":1}}],[\"有向无环图\",{\"1\":{\"223\":2}}],[\"有步操作是\",{\"1\":{\"211\":1}}],[\"有几种排列方式\",{\"1\":{\"183\":1,\"218\":1}}],[\"有的朋友会发现\",{\"1\":{\"152\":1,\"153\":1}}],[\"有可能会不适\",{\"1\":{\"618\":1}}],[\"有可能会删除头结点\",{\"1\":{\"389\":1}}],[\"有可能造成事故\",{\"1\":{\"589\":1}}],[\"有可能是最小值\",{\"1\":{\"276\":1}}],[\"有可能是需要返回的位置\",{\"1\":{\"273\":2}}],[\"有可能\",{\"1\":{\"128\":1}}],[\"有可能不买卖\",{\"1\":{\"124\":1}}],[\"有可能买卖俩次\",{\"1\":{\"124\":1}}],[\"有可能买卖一次\",{\"1\":{\"124\":1}}],[\"有可能被更新\",{\"1\":{\"67\":1}}],[\"有所不同\",{\"1\":{\"117\":1}}],[\"有四种方式可以凑成总金额\",{\"1\":{\"102\":1}}],[\"有俩种计算阈值的方式\",{\"1\":{\"475\":1}}],[\"有俩种方式\",{\"1\":{\"421\":1}}],[\"有俩种递归方式\",{\"1\":{\"37\":1}}],[\"有俩部分组成\",{\"1\":{\"153\":1}}],[\"有俩个问题\",{\"1\":{\"749\":1}}],[\"有俩个表\",{\"1\":{\"736\":1}}],[\"有俩个选择\",{\"1\":{\"360\":2}}],[\"有俩个疑问\",{\"1\":{\"304\":1}}],[\"有俩个地方可以进行剪枝\",{\"1\":{\"191\":1}}],[\"有俩个方向可以推导出来\",{\"1\":{\"143\":1}}],[\"有俩个纬度\",{\"1\":{\"101\":1}}],[\"有\",{\"1\":{\"99\":5,\"100\":1,\"147\":2,\"361\":5}}],[\"有一些情况下对结果集中的记录进行排序是可以使用到索引的\",{\"1\":{\"710\":1}}],[\"有一些球形气球贴在一堵用\",{\"1\":{\"363\":1}}],[\"有一定的参考意义\",{\"1\":{\"706\":1}}],[\"有一堆钞票\",{\"1\":{\"342\":1}}],[\"有一堆石头\",{\"1\":{\"96\":1}}],[\"有一个共同的风险点\",{\"1\":{\"850\":1}}],[\"有一个读数据请求c\",{\"1\":{\"848\":1}}],[\"有一个思路就是采用数据库集群的方案\",{\"1\":{\"818\":1}}],[\"有一个毫无疑问的缺陷就是崩溃后无法安全恢复\",{\"1\":{\"637\":1}}],[\"有一个单链表的\",{\"1\":{\"379\":1}}],[\"有一个大小为\",{\"1\":{\"333\":1}}],[\"有一个词\",{\"1\":{\"246\":1}}],[\"有一个\",{\"1\":{\"233\":1}}],[\"有一个weight纬度变成了俩个纬度\",{\"1\":{\"101\":1}}],[\"有一个背包\",{\"1\":{\"91\":1}}],[\"有n种物品\",{\"1\":{\"90\":3}}],[\"有关系\",{\"1\":{\"81\":1,\"115\":1}}],[\"有dp\",{\"1\":{\"81\":1,\"99\":1,\"101\":1}}],[\"有两个主要的标准\",{\"1\":{\"835\":1}}],[\"有两个左叶子\",{\"1\":{\"40\":1}}],[\"有两种方式来配置谓词和过滤器\",{\"1\":{\"491\":1}}],[\"有两种方法可以爬到楼顶\",{\"1\":{\"80\":1}}],[\"有两条路径\",{\"1\":{\"223\":1}}],[\"有效的算符为\",{\"1\":{\"330\":1}}],[\"有效的括号\",{\"1\":{\"328\":1}}],[\"有效的字符串一定是成双成对的\",{\"1\":{\"325\":1}}],[\"有效的字母异位词\",{\"1\":{\"162\":1}}],[\"有效字符串需满足\",{\"1\":{\"324\":1}}],[\"有效\",{\"1\":{\"55\":1,\"200\":2,\"334\":5}}],[\"改为\",{\"1\":{\"763\":2}}],[\"改动\",{\"1\":{\"755\":1}}],[\"改成2\",{\"1\":{\"749\":1}}],[\"改成你自己\",{\"1\":{\"454\":1}}],[\"改进的算法\",{\"1\":{\"725\":1}}],[\"改进思路和第二种方法\",{\"1\":{\"39\":1}}],[\"改操作可能会对节点和记录的排序造成破坏\",{\"1\":{\"656\":1}}],[\"改操作时\",{\"1\":{\"656\":1}}],[\"改变指针方向\",{\"1\":{\"382\":1}}],[\"改变保留在树中的元素的相对结构\",{\"1\":{\"69\":1}}],[\"改变入队方式\",{\"1\":{\"20\":1}}],[\"改良后的代码\",{\"1\":{\"43\":1}}],[\"入栈\",{\"1\":{\"39\":1,\"325\":1}}],[\"入队\",{\"1\":{\"33\":2,\"222\":2,\"226\":1}}],[\"入队即可\",{\"1\":{\"20\":1}}],[\"按序转换成所有列名\",{\"1\":{\"729\":1}}],[\"按字段的默认顺序插入数据\",{\"1\":{\"542\":1}}],[\"按账单\",{\"1\":{\"357\":1}}],[\"按以下方法修改该数组\",{\"1\":{\"353\":1}}],[\"按升序排列\",{\"1\":{\"277\":1}}],[\"按照严重性来排一下序\",{\"1\":{\"746\":1}}],[\"按照范式级别\",{\"1\":{\"736\":1}}],[\"按照order\",{\"1\":{\"725\":1}}],[\"按照列表中的值重新从列表中读取\",{\"1\":{\"725\":1}}],[\"按照\",{\"1\":{\"686\":2}}],[\"按照记录的插入顺序\",{\"1\":{\"654\":1}}],[\"按照聚簇索引排列顺序\",{\"1\":{\"650\":1}}],[\"按照主键的顺序插入是最快的方式\",{\"1\":{\"650\":1}}],[\"按照主键的大小\",{\"1\":{\"650\":1}}],[\"按照主键记录查询支付流水信息\",{\"1\":{\"464\":1}}],[\"按照department\",{\"1\":{\"579\":1}}],[\"按照字符串fmt对str进行解析\",{\"1\":{\"558\":1}}],[\"按照字符串fmt格式化时间time值\",{\"1\":{\"558\":1}}],[\"按照字符串fmt格式化日期date值\",{\"1\":{\"558\":1}}],[\"按照时间\",{\"1\":{\"478\":1}}],[\"按照次数\",{\"1\":{\"477\":1}}],[\"按照id查询订单支付流水信息\",{\"1\":{\"464\":1}}],[\"按照轮询算法原理\",{\"1\":{\"460\":1}}],[\"按照k的值进行插入\",{\"1\":{\"362\":1}}],[\"按照k升序\",{\"1\":{\"362\":1}}],[\"按照身高大小降序\",{\"1\":{\"362\":1}}],[\"按照国际象棋的规则\",{\"1\":{\"214\":1}}],[\"按照从顶部到底部的顺序\",{\"1\":{\"15\":1}}],[\"按任意顺序\",{\"1\":{\"208\":1,\"210\":1}}],[\"按\",{\"1\":{\"38\":1,\"71\":1,\"240\":1}}],[\"自定\",{\"1\":{\"627\":1}}],[\"自定义对齐\",{\"0\":{\"873\":1}}],[\"自定义标题\",{\"1\":{\"870\":5}}],[\"自定义函数及事件的\",{\"1\":{\"831\":1}}],[\"自定义单一内置过滤器\",{\"0\":{\"504\":1}}],[\"自定义全局过滤器\",{\"0\":{\"503\":1}}],[\"自定义过滤器\",{\"1\":{\"498\":1,\"503\":1}}],[\"自定义的断言\",{\"1\":{\"497\":1}}],[\"自定义的\",{\"1\":{\"497\":1,\"504\":1}}],[\"自定义predicate断言\",{\"0\":{\"497\":1}}],[\"自定义描述\",{\"1\":{\"444\":1}}],[\"自定义状态码\",{\"1\":{\"444\":1}}],[\"自定义返回的例外信息\",{\"1\":{\"423\":1}}],[\"自定义限流处理器\",{\"1\":{\"422\":1}}],[\"自定义\",{\"1\":{\"421\":1}}],[\"自定义一个请求转换器\",{\"1\":{\"418\":1}}],[\"自定义测试\",{\"1\":{\"379\":1}}],[\"自增锁是一种比较特殊的表级锁\",{\"1\":{\"772\":1}}],[\"自增锁\",{\"0\":{\"772\":1},\"1\":{\"772\":2}}],[\"自增id是局部唯一的\",{\"1\":{\"731\":1}}],[\"自增id的性能较差\",{\"1\":{\"731\":1}}],[\"自增id的问题\",{\"0\":{\"731\":1}}],[\"自增id除了简单其他都是缺点\",{\"1\":{\"731\":1}}],[\"自增id做主键\",{\"1\":{\"731\":1}}],[\"自增约束的列的数据类型必须是整数类型\",{\"1\":{\"617\":1}}],[\"自增长列约束的列必须是键列\",{\"1\":{\"617\":1}}],[\"自增列\",{\"0\":{\"617\":1}}],[\"自连接\",{\"0\":{\"536\":1},\"1\":{\"569\":1}}],[\"自我引用\",{\"1\":{\"513\":2}}],[\"自动提交的功能\",{\"1\":{\"745\":1}}],[\"自动会添加\",{\"1\":{\"595\":1}}],[\"自动添加路径前缀\",{\"1\":{\"502\":1}}],[\"自动重试\",{\"1\":{\"474\":1}}],[\"自己本地的路径\",{\"1\":{\"823\":1}}],[\"自己维护的\",{\"1\":{\"771\":1}}],[\"自己独有+自带版本号\",{\"1\":{\"442\":2}}],[\"自己设定的\",{\"1\":{\"412\":1}}],[\"自己指向自己\",{\"1\":{\"382\":1}}],[\"自己的状态\",{\"1\":{\"372\":1}}],[\"自身及其直接子对象\",{\"1\":{\"371\":1}}],[\"自下而上\",{\"1\":{\"37\":1}}],[\"自上而下类似与前序遍历\",{\"1\":{\"37\":1}}],[\"自上而下\",{\"1\":{\"37\":1}}],[\"自底向上的层序遍历\",{\"1\":{\"13\":1}}],[\"$temp\",{\"1\":{\"389\":1}}],[\"$head\",{\"1\":{\"386\":1}}],[\"$cur\",{\"1\":{\"381\":1}}],[\"$count\",{\"1\":{\"307\":1}}],[\"$count$\",{\"1\":{\"307\":2}}],[\"$pre\",{\"1\":{\"381\":1}}],[\"$path\",{\"1\":{\"39\":1}}],[\"$上一结点\",{\"1\":{\"377\":2}}],[\"$node\",{\"1\":{\"377\":1}}],[\"$numbers\",{\"1\":{\"241\":1}}],[\"$nums$\",{\"1\":{\"307\":2}}],[\"$nums\",{\"1\":{\"177\":1,\"179\":1,\"276\":2,\"313\":3}}],[\"$o\",{\"1\":{\"337\":1}}],[\"$r\",{\"1\":{\"334\":1}}],[\"$res$\",{\"1\":{\"307\":1}}],[\"$root\",{\"1\":{\"62\":2}}],[\"$rootindex\",{\"1\":{\"47\":2}}],[\"$matrix\",{\"1\":{\"299\":5}}],[\"$a\",{\"1\":{\"299\":2}}],[\"$在第\",{\"1\":{\"298\":1}}],[\"$low\",{\"1\":{\"276\":2}}],[\"$leftsum\",{\"1\":{\"293\":1}}],[\"$left\",{\"1\":{\"33\":1}}],[\"$dp\",{\"1\":{\"261\":1}}],[\"$$matrix\",{\"1\":{\"299\":1}}],[\"$$\",{\"1\":{\"261\":2,\"295\":2,\"299\":20}}],[\"$s\",{\"1\":{\"261\":1}}],[\"$最大的起始元素\",{\"1\":{\"188\":1}}],[\"$最大起始元素\",{\"1\":{\"188\":1}}],[\"$那么还需要选择的元素\",{\"1\":{\"188\":1}}],[\"$的和\",{\"1\":{\"177\":1}}],[\"$是什么\",{\"1\":{\"47\":1}}],[\"$\",{\"1\":{\"37\":1,\"39\":1,\"47\":1,\"241\":1,\"261\":5,\"273\":2,\"276\":2,\"293\":1,\"298\":2,\"299\":16,\"304\":19,\"313\":3,\"334\":1,\"337\":1,\"381\":1,\"402\":2,\"403\":9,\"419\":2,\"429\":3,\"442\":7,\"450\":1,\"452\":1,\"464\":1,\"489\":1,\"608\":4,\"832\":1}}],[\"$一个二叉树\",{\"1\":{\"37\":1}}],[\"+∞\",{\"1\":{\"776\":1}}],[\"+config\",{\"1\":{\"504\":1}}],[\"+cost\",{\"1\":{\"83\":2}}],[\"+id+\",{\"1\":{\"477\":1}}],[\"+id\",{\"1\":{\"446\":1}}],[\"+i\",{\"1\":{\"443\":2}}],[\"+updateresult\",{\"1\":{\"432\":1}}],[\"+orderfromdb\",{\"1\":{\"432\":2}}],[\"+xid\",{\"1\":{\"432\":2}}],[\"+e\",{\"1\":{\"416\":1}}],[\"+nums\",{\"1\":{\"348\":1}}],[\"+5c\",{\"1\":{\"173\":1}}],[\"++l\",{\"1\":{\"275\":1}}],[\"++left\",{\"1\":{\"177\":1,\"179\":1}}],[\"++\",{\"1\":{\"163\":1,\"230\":1,\"242\":1,\"372\":1}}],[\"+1\",{\"1\":{\"98\":4}}],[\"+2\",{\"1\":{\"98\":1}}],[\"+dp\",{\"1\":{\"85\":2}}],[\"+\",{\"0\":{\"484\":1,\"672\":1},\"1\":{\"35\":2,\"37\":2,\"39\":18,\"43\":1,\"45\":2,\"47\":3,\"49\":5,\"51\":1,\"72\":1,\"78\":7,\"79\":3,\"80\":5,\"81\":4,\"83\":2,\"85\":1,\"86\":3,\"87\":1,\"91\":7,\"92\":8,\"93\":2,\"95\":4,\"97\":2,\"98\":18,\"99\":3,\"101\":5,\"103\":1,\"105\":1,\"106\":2,\"107\":7,\"108\":3,\"109\":4,\"111\":1,\"112\":3,\"113\":3,\"114\":1,\"115\":8,\"116\":3,\"117\":4,\"120\":3,\"121\":1,\"122\":5,\"124\":5,\"126\":17,\"128\":5,\"129\":1,\"130\":2,\"133\":3,\"134\":2,\"137\":4,\"139\":4,\"141\":3,\"143\":2,\"146\":4,\"147\":1,\"148\":7,\"150\":4,\"152\":11,\"153\":10,\"157\":6,\"169\":5,\"170\":4,\"171\":2,\"173\":1,\"174\":1,\"175\":1,\"176\":14,\"177\":11,\"178\":3,\"179\":6,\"188\":5,\"189\":8,\"190\":2,\"191\":3,\"193\":2,\"194\":2,\"197\":2,\"199\":3,\"201\":6,\"207\":2,\"213\":3,\"217\":2,\"226\":4,\"228\":4,\"230\":4,\"232\":4,\"234\":2,\"241\":1,\"242\":2,\"256\":1,\"257\":10,\"271\":4,\"273\":3,\"274\":4,\"276\":4,\"277\":3,\"286\":1,\"290\":9,\"292\":1,\"299\":1,\"304\":2,\"305\":3,\"311\":1,\"313\":1,\"330\":27,\"332\":3,\"334\":1,\"335\":3,\"338\":1,\"350\":1,\"351\":2,\"355\":8,\"360\":8,\"390\":2,\"391\":4,\"402\":8,\"416\":1,\"429\":1,\"432\":7,\"433\":1,\"434\":1,\"443\":1,\"446\":3,\"452\":1,\"459\":1,\"462\":1,\"470\":1,\"477\":1,\"481\":7,\"503\":6,\"522\":1,\"523\":1,\"527\":2,\"541\":1,\"654\":1,\"696\":18,\"701\":39,\"719\":1,\"727\":1,\"736\":1,\"745\":9,\"751\":9,\"767\":9,\"771\":18,\"806\":9,\"807\":9,\"809\":21,\"886\":1}}],[\"+=gas\",{\"1\":{\"356\":1}}],[\"+=\",{\"1\":{\"18\":1,\"41\":2,\"52\":1,\"74\":1,\"89\":4,\"99\":3,\"103\":4,\"105\":2,\"122\":1,\"126\":4,\"190\":2,\"191\":1,\"195\":2,\"197\":1,\"259\":1,\"286\":1,\"292\":2,\"293\":2,\"356\":3}}],[\"个线程\",{\"1\":{\"820\":1}}],[\"个方面的作用\",{\"1\":{\"819\":1}}],[\"个事务看起来什么都没做\",{\"1\":{\"755\":1}}],[\"个球员参加\",{\"1\":{\"737\":1}}],[\"个页的查询\",{\"1\":{\"696\":1}}],[\"个连接条件\",{\"1\":{\"533\":1}}],[\"个身高更高或者相同的人排在他前面\",{\"1\":{\"361\":4}}],[\"个身高大于或等于\",{\"1\":{\"361\":1}}],[\"个人的属性\",{\"1\":{\"361\":1}}],[\"个人的身高为\",{\"1\":{\"361\":1}}],[\"个糖果\",{\"1\":{\"359\":1}}],[\"个孩子站成一排\",{\"1\":{\"359\":1}}],[\"个加油站时\",{\"1\":{\"356\":1}}],[\"个加油站需要消耗汽油\",{\"1\":{\"355\":1}}],[\"个加油站开往第\",{\"1\":{\"355\":1}}],[\"个加油站有汽油\",{\"1\":{\"355\":1}}],[\"个加油站\",{\"1\":{\"355\":1}}],[\"个高频元素的集合是唯一的\",{\"1\":{\"336\":1}}],[\"个区间的末尾元素\",{\"1\":{\"295\":1}}],[\"个区间的首元素小于或者等于\",{\"1\":{\"295\":1}}],[\"个正整数的数组和一个正整数\",{\"1\":{\"284\":1}}],[\"个版本\",{\"1\":{\"274\":1}}],[\"个位置\",{\"1\":{\"253\":1}}],[\"个皇后放置在\",{\"1\":{\"214\":1}}],[\"个数据块中提取数据\",{\"1\":{\"650\":1}}],[\"个数的乘积数\",{\"1\":{\"532\":1}}],[\"个数的组合\",{\"1\":{\"186\":1,\"189\":1}}],[\"个数字\",{\"1\":{\"333\":1}}],[\"个数为dp\",{\"1\":{\"148\":1,\"153\":1}}],[\"个整数组成的数组\",{\"1\":{\"178\":1}}],[\"个字符按原顺序移动至字符串末尾\",{\"1\":{\"255\":1}}],[\"个字符\",{\"1\":{\"139\":2,\"252\":3}}],[\"个元素包含唯一元素\",{\"1\":{\"312\":1}}],[\"个元素的旋转\",{\"1\":{\"299\":1}}],[\"个元素有序的\",{\"1\":{\"269\":1}}],[\"个元素是一支给定的股票在第\",{\"1\":{\"123\":1}}],[\"个元素\",{\"1\":{\"119\":1,\"188\":2}}],[\"个完全平方数\",{\"1\":{\"109\":1}}],[\"个硬币\",{\"1\":{\"107\":2}}],[\"个子集\",{\"1\":{\"101\":1}}],[\"个1的情况下\",{\"1\":{\"101\":1}}],[\"个物品的价值\",{\"1\":{\"91\":1}}],[\"个物品的重量\",{\"1\":{\"91\":2}}],[\"个物品\",{\"1\":{\"91\":4,\"92\":2}}],[\"个\",{\"1\":{\"86\":1,\"100\":5,\"109\":1,\"194\":1,\"252\":2,\"689\":1}}],[\"个台阶向上爬需要支付的费用\",{\"1\":{\"82\":1}}],[\"个台阶\",{\"1\":{\"80\":1}}],[\"个节点可以由下面\",{\"1\":{\"660\":1}}],[\"个节点的\",{\"1\":{\"223\":1}}],[\"个节点组成且节点值从\",{\"1\":{\"88\":1}}],[\"个节点\",{\"1\":{\"34\":1,\"390\":4}}],[\"个结点的二叉搜索树的数量时就是\",{\"1\":{\"89\":1}}],[\"个结点的二叉树称为满二叉树\",{\"1\":{\"0\":1}}],[\"个结点\",{\"1\":{\"12\":1,\"388\":1}}],[\"h1\",{\"1\":{\"883\":2}}],[\"h2o\",{\"1\":{\"872\":1}}],[\"hy000\",{\"1\":{\"618\":1,\"809\":1}}],[\"hc5<\",{\"1\":{\"468\":1}}],[\"hc5\",{\"1\":{\"468\":2}}],[\"hh\",{\"1\":{\"444\":3}}],[\"html\",{\"1\":{\"429\":1,\"432\":1,\"441\":1,\"443\":1,\"446\":1,\"449\":1,\"458\":1}}],[\"httpclient\",{\"1\":{\"468\":1}}],[\"httpclient5\",{\"1\":{\"468\":3}}],[\"httpcomponents\",{\"1\":{\"468\":1}}],[\"httpurlconnection发送http请求\",{\"1\":{\"468\":1}}],[\"http<\",{\"1\":{\"423\":1}}],[\"http\",{\"1\":{\"402\":1,\"418\":2,\"422\":4,\"429\":2,\"432\":1,\"435\":1,\"441\":5,\"442\":1,\"443\":1,\"446\":2,\"449\":3,\"451\":2,\"470\":1,\"485\":1,\"486\":1,\"502\":2}}],[\"httpstatus\",{\"1\":{\"422\":2,\"423\":2,\"445\":1,\"504\":1}}],[\"httpservletrequest\",{\"1\":{\"418\":3}}],[\"https\",{\"1\":{\"12\":1,\"73\":1,\"398\":1,\"401\":1,\"426\":1,\"427\":1,\"428\":1,\"431\":1,\"439\":1,\"440\":1,\"442\":1,\"449\":1,\"458\":1,\"462\":1,\"475\":1,\"479\":1,\"482\":1,\"485\":1,\"491\":3,\"492\":1,\"502\":2,\"504\":1}}],[\"have\",{\"1\":{\"822\":1}}],[\"having中的子查询\",{\"0\":{\"574\":1}}],[\"having\",{\"1\":{\"564\":3,\"565\":3,\"574\":1,\"578\":2}}],[\"havign过滤就非常轻松了\",{\"1\":{\"565\":1}}],[\"havign\",{\"0\":{\"564\":1},\"1\":{\"564\":2}}],[\"half\",{\"1\":{\"475\":1,\"476\":1}}],[\"handling\",{\"1\":{\"474\":1}}],[\"handlermapping\",{\"1\":{\"491\":1}}],[\"handlerequest\",{\"1\":{\"423\":1}}],[\"handler\",{\"1\":{\"423\":3,\"488\":5}}],[\"hash索引使用存储引擎\",{\"1\":{\"658\":1}}],[\"hash结构效率高\",{\"1\":{\"658\":1}}],[\"hash结构\",{\"0\":{\"658\":1}}],[\"hashicorp\",{\"1\":{\"449\":1}}],[\"hashmap\",{\"1\":{\"422\":1}}],[\"hashmap<character\",{\"1\":{\"193\":4}}],[\"hashmap<string\",{\"1\":{\"165\":1}}],[\"hashmap<>\",{\"1\":{\"49\":1,\"165\":1,\"175\":1,\"193\":2,\"338\":1,\"423\":1}}],[\"hashmap<integer\",{\"1\":{\"47\":2,\"49\":1,\"175\":1,\"338\":1}}],[\"hash是保存同一层的元素\",{\"1\":{\"207\":1}}],[\"hash表中\",{\"1\":{\"391\":1}}],[\"hash表中查找是否有与当前值匹配的值即可\",{\"1\":{\"175\":1}}],[\"hash表\",{\"1\":{\"175\":1}}],[\"hash表的key\",{\"1\":{\"165\":1}}],[\"hash\",{\"1\":{\"162\":1,\"175\":1,\"207\":2,\"392\":3,\"395\":3,\"650\":1,\"658\":9,\"701\":1}}],[\"hashset<listnode>\",{\"1\":{\"392\":1,\"395\":1}}],[\"hashset<integer>\",{\"1\":{\"171\":2,\"207\":2}}],[\"hashset<>\",{\"1\":{\"111\":1,\"168\":2,\"177\":1,\"207\":2,\"392\":1,\"395\":1,\"423\":1}}],[\"hashset<string>\",{\"1\":{\"111\":1}}],[\"haspathsum\",{\"1\":{\"45\":4}}],[\"hutool<\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1,\"446\":1}}],[\"hutool\",{\"1\":{\"402\":1,\"432\":1,\"441\":3,\"442\":1,\"443\":1,\"446\":1}}],[\"hope\",{\"1\":{\"884\":1}}],[\"hour\",{\"1\":{\"555\":1,\"557\":1}}],[\"hostname\",{\"1\":{\"807\":1,\"822\":1}}],[\"host=\",{\"1\":{\"493\":1,\"826\":1}}],[\"host\",{\"0\":{\"493\":1},\"1\":{\"450\":1,\"452\":1,\"464\":1,\"489\":1,\"493\":2,\"831\":2}}],[\"home\",{\"1\":{\"429\":2}}],[\"hoxton\",{\"1\":{\"399\":1}}],[\"horse\",{\"1\":{\"151\":2}}],[\"hj\",{\"1\":{\"361\":1}}],[\"hire\",{\"1\":{\"587\":3}}],[\"history\",{\"1\":{\"579\":1}}],[\"history表中employee\",{\"1\":{\"579\":1}}],[\"hijhklij\",{\"1\":{\"367\":2}}],[\"hi\",{\"1\":{\"361\":4}}],[\"highest\",{\"1\":{\"423\":1,\"534\":1}}],[\"high$\",{\"1\":{\"276\":2}}],[\"high\",{\"1\":{\"69\":5,\"70\":12,\"276\":6}}],[\"heap\",{\"1\":{\"680\":1}}],[\"header的部分\",{\"1\":{\"674\":1}}],[\"header中的校验和相对应的\",{\"1\":{\"669\":1}}],[\"header中带有x\",{\"1\":{\"493\":1}}],[\"header=x\",{\"1\":{\"493\":1}}],[\"header\",{\"0\":{\"493\":1,\"674\":1},\"1\":{\"493\":3,\"501\":1,\"667\":2}}],[\"headers\",{\"1\":{\"470\":2}}],[\"headb相交结点前的结点个数为\",{\"1\":{\"391\":1}}],[\"headb\",{\"1\":{\"390\":1,\"391\":3,\"392\":5}}],[\"heada\",{\"1\":{\"390\":1,\"391\":2,\"392\":5}}],[\"head\",{\"1\":{\"376\":4,\"378\":2,\"379\":5,\"380\":4,\"382\":5,\"383\":3,\"384\":2,\"385\":3,\"386\":4,\"387\":9,\"388\":3,\"389\":5,\"393\":4,\"395\":2}}],[\"hex\",{\"1\":{\"551\":1}}],[\"help\",{\"1\":{\"699\":1,\"809\":1}}],[\"helper\",{\"1\":{\"47\":4,\"49\":4,\"51\":4,\"72\":4}}],[\"hello\",{\"1\":{\"244\":2,\"477\":1}}],[\"heights\",{\"1\":{\"233\":7,\"234\":13}}],[\"height1\",{\"1\":{\"37\":4}}],[\"height\",{\"1\":{\"37\":5,\"43\":3,\"565\":1}}],[\"h\",{\"1\":{\"34\":1,\"67\":2,\"151\":1,\"193\":2,\"249\":6,\"362\":4,\"558\":2,\"831\":3,\"832\":1}}],[\"若失败5次仍然未成功可以保存到表中通知相关人员做下一步处理\",{\"1\":{\"852\":1}}],[\"若多次重试之后仍然失败\",{\"1\":{\"850\":1}}],[\"若想用mysqldump备份整个实例\",{\"1\":{\"831\":1}}],[\"若在id值为25的记录增加间隙锁\",{\"1\":{\"776\":1}}],[\"若在9之后系统宕机\",{\"1\":{\"757\":1}}],[\"若该记录已经被其他事务占用\",{\"1\":{\"756\":1}}],[\"若employees表中employee\",{\"1\":{\"579\":1}}],[\"若员工department\",{\"1\":{\"575\":1}}],[\"若俩边有一个为\",{\"1\":{\"528\":1}}],[\"若一头含有多参则重写一行设置\",{\"1\":{\"499\":1}}],[\"若为null返回false\",{\"1\":{\"497\":1}}],[\"若为time\",{\"1\":{\"476\":1}}],[\"若异常不相同或者不是父子类的关系\",{\"1\":{\"477\":1}}],[\"若count\",{\"1\":{\"476\":1}}],[\"若你第一次因为\",{\"1\":{\"454\":1}}],[\"若嫌麻烦\",{\"1\":{\"440\":1}}],[\"若资源和\",{\"1\":{\"416\":1}}],[\"若同时配置了\",{\"1\":{\"416\":1}}],[\"若希望使用其他类的函数\",{\"1\":{\"416\":3}}],[\"若hash表中已经存在某个结点\",{\"1\":{\"394\":1}}],[\"若hash表中每个字符的出现次数都为0\",{\"1\":{\"162\":1}}],[\"若当前数字比后一个数字大\",{\"1\":{\"370\":1}}],[\"若当前孩子分数\",{\"1\":{\"360\":2}}],[\"若有相交结点\",{\"1\":{\"392\":1}}],[\"若有一个气球的直径的开始和结束坐标为\",{\"1\":{\"363\":1}}],[\"若有面额为10的\",{\"1\":{\"358\":1}}],[\"若身高相同\",{\"1\":{\"362\":1}}],[\"若右边孩子分数\",{\"1\":{\"360\":1}}],[\"若10不够则找\",{\"1\":{\"358\":1}}],[\"若k还有剩余\",{\"1\":{\"354\":1}}],[\"若k最后为偶数个\",{\"1\":{\"354\":1}}],[\"若k最后为奇数\",{\"1\":{\"354\":1}}],[\"若key相同则放入同一个集合内\",{\"1\":{\"165\":1}}],[\"若没有负数或者反转完\",{\"1\":{\"354\":1}}],[\"若没有将当前值放入hash表\",{\"1\":{\"175\":1}}],[\"若上一次是上坡\",{\"1\":{\"346\":1}}],[\"若m\",{\"1\":{\"300\":1}}],[\"若旋转\",{\"1\":{\"276\":2}}],[\"若是之前做过主从复制\",{\"1\":{\"826\":1}}],[\"若是新增一个目录项或者删除一个目录项\",{\"1\":{\"645\":1}}],[\"若是相差多个字符\",{\"1\":{\"261\":1}}],[\"若是丑数\",{\"1\":{\"173\":1}}],[\"若9个数都试完了\",{\"1\":{\"217\":2}}],[\"若两个四元组元素一一对应\",{\"1\":{\"178\":1}}],[\"若剩下的数等于\",{\"1\":{\"173\":1}}],[\"若不实现此方法\",{\"1\":{\"497\":1,\"504\":1}}],[\"若不符合\",{\"1\":{\"492\":1}}],[\"若不符合直接返回false\",{\"1\":{\"325\":1}}],[\"若不存在环\",{\"1\":{\"395\":1}}],[\"若不在则弹出队首的元素\",{\"1\":{\"335\":1}}],[\"若不相等\",{\"1\":{\"139\":1}}],[\"若不是返回\",{\"1\":{\"37\":1}}],[\"若\",{\"1\":{\"62\":2,\"137\":1,\"139\":1,\"157\":2,\"161\":1,\"177\":3,\"304\":1,\"354\":1,\"356\":1,\"360\":2,\"362\":1,\"413\":1}}],[\"若left\",{\"1\":{\"62\":1}}],[\"若只有一个结点\",{\"1\":{\"62\":1}}],[\"若最底层为第\",{\"1\":{\"34\":1}}],[\"若根结点的左\",{\"1\":{\"0\":1}}],[\"并授权slave\",{\"1\":{\"825\":1}}],[\"并重新启用新的relaylog文件\",{\"1\":{\"826\":1}}],[\"并重新记录当前这个频率更高的元素\",{\"1\":{\"60\":1}}],[\"并重启mysql服务\",{\"1\":{\"806\":1}}],[\"并请求锁定对方占用的资源\",{\"1\":{\"786\":1}}],[\"并防止其他用户读取正在写入的同一资源\",{\"1\":{\"767\":1}}],[\"并非完全依赖于主键\",{\"1\":{\"737\":1}}],[\"并非全部where条件都可以用icp筛选\",{\"1\":{\"728\":1}}],[\"并没有完全依赖于主键\",{\"1\":{\"737\":1}}],[\"并为其插入1条记录\",{\"1\":{\"704\":1}}],[\"并为其创建\",{\"1\":{\"628\":1}}],[\"并\",{\"1\":{\"696\":1,\"746\":1}}],[\"并使用\",{\"1\":{\"645\":1}}],[\"并使这些整数的乘积最大化\",{\"1\":{\"86\":1}}],[\"并完成与存储引擎的交互\",{\"1\":{\"632\":1}}],[\"并在\",{\"1\":{\"630\":1}}],[\"并在需要的时候将它还原为各编程语言所支持的数据格式\",{\"1\":{\"608\":1}}],[\"并在一段时间后尝试重新请求依赖服务\",{\"1\":{\"475\":1}}],[\"并有效地提升网络传输效\",{\"1\":{\"608\":1}}],[\"并检查数据完整性\",{\"1\":{\"517\":1}}],[\"并以特定的格式进行存储\",{\"1\":{\"510\":1}}],[\"并以列表形式返回\",{\"1\":{\"194\":1}}],[\"并判断出服务之间的依赖关系是否合理\",{\"1\":{\"483\":1}}],[\"并发执行\",{\"1\":{\"800\":1}}],[\"并发执行的各个事务之间不能互相干扰\",{\"1\":{\"741\":1}}],[\"并发控制\",{\"1\":{\"790\":1}}],[\"并发度一般\",{\"1\":{\"779\":1}}],[\"并发度高\",{\"1\":{\"774\":1}}],[\"并发性能差\",{\"1\":{\"772\":1}}],[\"并发问题的解决方案\",{\"0\":{\"765\":1}}],[\"并发事务访问相同的记录\",{\"0\":{\"761\":1}}],[\"并发事务可以发生不同严重程度的问题\",{\"1\":{\"746\":1}}],[\"并发访问性能的一个重要因素\",{\"1\":{\"760\":1}}],[\"并发操作进行控制\",{\"1\":{\"760\":1}}],[\"并发的\",{\"1\":{\"741\":1}}],[\"并发的线程数\",{\"1\":{\"481\":1}}],[\"并发线程数表示通过并发线程数限流\",{\"1\":{\"409\":1}}],[\"并开启服务降级\",{\"1\":{\"478\":1}}],[\"并允许一些请求通过以测试服务是否恢复正常\",{\"1\":{\"477\":1}}],[\"并允许通过一定数量的请求\",{\"1\":{\"475\":1}}],[\"并进入服务降级\",{\"1\":{\"476\":1}}],[\"并进行了条件\",{\"1\":{\"579\":1}}],[\"并进行了\",{\"1\":{\"276\":1}}],[\"并拒绝所有请求\",{\"1\":{\"475\":1}}],[\"并根据中继日志的内容对从服务器的数据进行更新\",{\"1\":{\"813\":1}}],[\"并根据数据字\",{\"1\":{\"628\":1}}],[\"并根据\",{\"1\":{\"426\":1}}],[\"并调用物流中心的服务通知商品发货\",{\"1\":{\"425\":1}}],[\"并对其访问进行限流或者其它操作\",{\"1\":{\"417\":1}}],[\"并指定\",{\"1\":{\"416\":1}}],[\"并指定fallbackclass里面的方法\",{\"1\":{\"416\":1}}],[\"并指定blockhandlerclass里面的方法\",{\"1\":{\"416\":1}}],[\"并更换俩者的指针方向\",{\"1\":{\"382\":1}}],[\"并更改指针方向\",{\"1\":{\"381\":1}}],[\"并不会限制其他事务对这条记录加记录锁或者继续加gap锁\",{\"1\":{\"776\":1}}],[\"并不会引起什么\",{\"1\":{\"762\":1}}],[\"并不会引入\",{\"1\":{\"441\":1}}],[\"并不是有多少个select就会有多少id\",{\"1\":{\"702\":1}}],[\"并不是单调递增的数字\",{\"1\":{\"370\":1}}],[\"并不容易实现\",{\"1\":{\"177\":1}}],[\"并记录下file和position的值\",{\"1\":{\"825\":1}}],[\"并记录\",{\"1\":{\"364\":1}}],[\"并返还\",{\"1\":{\"357\":1}}],[\"并返回交换后链表的头节点\",{\"1\":{\"385\":1}}],[\"并返回反转后的链表\",{\"1\":{\"380\":1}}],[\"并返回移除后数组的新长度\",{\"1\":{\"278\":1}}],[\"并返回其长度\",{\"1\":{\"284\":1}}],[\"并返回其索引\",{\"1\":{\"273\":1}}],[\"并返回其根节点\",{\"1\":{\"30\":1}}],[\"并返回\",{\"1\":{\"241\":1,\"294\":1,\"376\":1}}],[\"并返回它们的数组下标\",{\"1\":{\"174\":1}}],[\"并返回可以绘制的最大连线数\",{\"1\":{\"140\":1}}],[\"并返回该序列的长度\",{\"1\":{\"134\":1,\"156\":1}}],[\"并输出这个最大数值\",{\"1\":{\"343\":1}}],[\"并讲解结果放入栈中\",{\"1\":{\"332\":1}}],[\"并删除它们\",{\"1\":{\"327\":1}}],[\"并保留到小数点后面y位\",{\"1\":{\"548\":1}}],[\"并保持相对顺序\",{\"1\":{\"313\":1}}],[\"并保证二叉搜索树的性质不变\",{\"1\":{\"67\":1}}],[\"并按照它们最初在\",{\"1\":{\"312\":1}}],[\"并按上述情形进行了多次旋转\",{\"1\":{\"276\":1}}],[\"并移动双指针\",{\"1\":{\"280\":1}}],[\"并将这个结构\",{\"1\":{\"628\":1}}],[\"并将这些区域里所有的\",{\"1\":{\"231\":1}}],[\"并将它们的结果组合成单个结果集\",{\"1\":{\"540\":1}}],[\"并将节点传递给你的函数\",{\"1\":{\"379\":1}}],[\"并将\",{\"1\":{\"353\":1,\"629\":1}}],[\"并将结果压入栈中\",{\"1\":{\"330\":1}}],[\"并将单词放到\",{\"1\":{\"245\":1}}],[\"并往下递归\",{\"1\":{\"224\":1}}],[\"并加入到\",{\"1\":{\"203\":2}}],[\"并结束本层递归\",{\"1\":{\"185\":1}}],[\"并选择在\",{\"1\":{\"119\":1}}],[\"并且还仍在开着\",{\"1\":{\"826\":1}}],[\"并且还需要判断\",{\"1\":{\"201\":1}}],[\"并且执行日志中的事件\",{\"1\":{\"820\":1}}],[\"并且拷贝到本地的中继日志\",{\"1\":{\"820\":1}}],[\"并且把读取到的信息写入\",{\"1\":{\"813\":1}}],[\"并且把随机io变成了顺序io\",{\"1\":{\"725\":1}}],[\"并且没有对应binlog日志\",{\"1\":{\"812\":1}}],[\"并且后缀名按1递增\",{\"1\":{\"809\":1}}],[\"并且只有活跃的事务才会有\",{\"1\":{\"796\":1}}],[\"并且当语句执行完之后就会释放\",{\"1\":{\"772\":1}}],[\"并且当前航班的起点必须是上一个航班的终点才能构成一个合理的行程\",{\"1\":{\"213\":1}}],[\"并且在事务向包含了\",{\"1\":{\"772\":1}}],[\"并且在画每一边时都要遵循这个规则\",{\"1\":{\"288\":1}}],[\"并且成功访问到了数据\",{\"1\":{\"771\":1}}],[\"并且增加写锁\",{\"1\":{\"767\":1}}],[\"并且该语句的`where`子句中\",{\"1\":{\"710\":1}}],[\"并且该语句的`where`\",{\"1\":{\"710\":1}}],[\"并且该表使用的存储引擎的统计数据是精确的\",{\"1\":{\"704\":1}}],[\"并且该子查询是相关子查询\",{\"1\":{\"703\":1}}],[\"并且该子查询是不相关子查询\",{\"1\":{\"703\":1}}],[\"并且该字段在多张表中的\",{\"1\":{\"689\":1}}],[\"并且分析结果也是一样的\",{\"1\":{\"700\":1}}],[\"并且索引中的列尽可能少\",{\"1\":{\"690\":1}}],[\"并且左右两个子树都是一棵平衡二叉树\",{\"1\":{\"660\":1}}],[\"并且左括号后面一定是对应的右括号\",{\"1\":{\"325\":1}}],[\"并且会占用更多的磁盘空间以保存数据和\",{\"1\":{\"636\":1,\"655\":1}}],[\"并且返回用户需要查询的结果\",{\"1\":{\"627\":1}}],[\"并且返回链表的头结点\",{\"1\":{\"388\":1}}],[\"并且一个表可以建立多个外键约束\",{\"1\":{\"618\":1}}],[\"并且组合的值不允许重复\",{\"1\":{\"616\":1}}],[\"并且相互对应\",{\"1\":{\"540\":1}}],[\"并且含有\",{\"1\":{\"529\":1}}],[\"并且通过openfeign\",{\"1\":{\"477\":1}}],[\"并且要重写方法\",{\"1\":{\"420\":1}}],[\"并且要构成合理的行程\",{\"1\":{\"213\":1}}],[\"并且保证给定的节点\",{\"1\":{\"379\":1}}],[\"并且记录end值\",{\"1\":{\"364\":1}}],[\"并且走完一圈后\",{\"1\":{\"356\":1}}],[\"并且上一个是上坡\",{\"1\":{\"346\":1}}],[\"并且上一个航班没有使用过\",{\"1\":{\"213\":2}}],[\"并且上一次是下坡\",{\"1\":{\"346\":1}}],[\"并且每种存储引擎不一定支持所有索引类型\",{\"1\":{\"642\":1}}],[\"并且每块饼干\",{\"1\":{\"343\":1}}],[\"并且每座岛屿只能由水平方向和\",{\"1\":{\"225\":1}}],[\"并且栈一定是空的\",{\"1\":{\"325\":1}}],[\"并且原数组\",{\"1\":{\"312\":2}}],[\"并且平方后的数组也要求是递增\",{\"1\":{\"282\":1}}],[\"并且进入到\",{\"1\":{\"226\":1}}],[\"并且使皇后彼此之间不能相互攻击\",{\"1\":{\"214\":1}}],[\"并且如果能构成一个合理的行程\",{\"1\":{\"213\":1}}],[\"并且前一个元素已经被使用了\",{\"1\":{\"211\":1}}],[\"并且也不能比较前后俩个元素\",{\"1\":{\"211\":1}}],[\"并且将元素增加到\",{\"1\":{\"209\":1}}],[\"并且判断是否符合递增的条件\",{\"1\":{\"207\":1}}],[\"并且判断的条件值不在是0\",{\"1\":{\"179\":1}}],[\"并且\",{\"1\":{\"190\":1,\"261\":1,\"273\":1,\"278\":2,\"413\":1,\"414\":1,\"415\":1,\"481\":1}}],[\"并且我们还需要知道下标和值的对应关系\",{\"1\":{\"175\":1}}],[\"并且我们还需要一个变量maxcount\",{\"1\":{\"60\":1}}],[\"并且不包含n\",{\"1\":{\"171\":1}}],[\"并且字典中的单词可以重复使用\",{\"1\":{\"110\":1}}],[\"并且满足\",{\"1\":{\"97\":1}}],[\"并且最小值一定是在无序的那部分上\",{\"1\":{\"276\":1}}],[\"并且最大值为子集的和\",{\"1\":{\"95\":1}}],[\"并且最下面一层的节点都集中在该层最左边的若干位置\",{\"1\":{\"34\":1}}],[\"并且重量不超出背包的容量\",{\"1\":{\"91\":1}}],[\"并且val在二叉树中不存在\",{\"1\":{\"66\":1}}],[\"并且求出当前结点与这个变量的差\",{\"1\":{\"58\":1}}],[\">>\",{\"1\":{\"608\":1}}],[\">1\",{\"1\":{\"559\":1}}],[\">1634348884\",{\"1\":{\"554\":1}}],[\">正确\",{\"1\":{\"559\":1}}],[\">account\",{\"1\":{\"434\":2}}],[\">storage\",{\"1\":{\"433\":2}}],[\">right\",{\"1\":{\"372\":1}}],[\">left\",{\"1\":{\"372\":1}}],[\">高\",{\"1\":{\"234\":1}}],[\">target\",{\"1\":{\"197\":1,\"275\":1}}],[\">分解成两问题\",{\"1\":{\"115\":1}}],[\">=1\",{\"1\":{\"295\":1}}],[\">=d\",{\"1\":{\"97\":1}}],[\">=\",{\"1\":{\"51\":1,\"70\":1,\"86\":1,\"87\":1,\"92\":2,\"93\":1,\"95\":1,\"97\":3,\"99\":1,\"101\":2,\"103\":1,\"105\":1,\"145\":1,\"155\":1,\"157\":1,\"201\":2,\"203\":2,\"205\":1,\"207\":2,\"215\":4,\"226\":4,\"228\":3,\"230\":4,\"232\":4,\"234\":2,\"245\":2,\"273\":3,\"277\":2,\"282\":1,\"285\":1,\"286\":1,\"289\":2,\"304\":3,\"305\":1,\"335\":1,\"337\":1,\"343\":1,\"344\":1,\"350\":2,\"352\":1,\"356\":3,\"360\":2,\"370\":1,\"800\":2}}],[\">=0的\",{\"1\":{\"356\":1}}],[\">=0\",{\"1\":{\"37\":1,\"215\":2,\"245\":1,\"262\":1,\"305\":1,\"344\":2,\"356\":1}}],[\">3\",{\"1\":{\"38\":1}}],[\">5\",{\"1\":{\"38\":1}}],[\">2\",{\"1\":{\"38\":1}}],[\">\",{\"1\":{\"33\":1,\"37\":1,\"39\":7,\"44\":2,\"47\":2,\"49\":2,\"54\":2,\"60\":3,\"64\":2,\"66\":2,\"68\":1,\"70\":2,\"72\":1,\"78\":1,\"84\":6,\"91\":1,\"120\":1,\"133\":2,\"135\":1,\"137\":1,\"143\":1,\"151\":8,\"155\":1,\"165\":1,\"177\":5,\"179\":9,\"189\":1,\"191\":2,\"195\":4,\"197\":2,\"201\":7,\"205\":1,\"207\":2,\"211\":2,\"213\":3,\"223\":4,\"226\":1,\"228\":2,\"230\":1,\"232\":1,\"234\":1,\"242\":1,\"257\":3,\"261\":1,\"262\":1,\"271\":4,\"274\":3,\"276\":1,\"277\":3,\"296\":2,\"304\":8,\"334\":1,\"338\":3,\"346\":1,\"350\":2,\"354\":2,\"358\":1,\"360\":17,\"362\":2,\"364\":5,\"366\":1,\"370\":1,\"379\":4,\"389\":1,\"402\":10,\"408\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":1,\"416\":2,\"422\":4,\"423\":1,\"424\":3,\"431\":11,\"432\":25,\"433\":1,\"434\":1,\"441\":15,\"442\":24,\"443\":11,\"444\":1,\"446\":5,\"452\":1,\"463\":1,\"468\":2,\"477\":2,\"480\":1,\"481\":3,\"482\":1,\"486\":11,\"489\":3,\"503\":1,\"512\":3,\"559\":7,\"564\":2,\"565\":10,\"569\":2,\"574\":1,\"579\":3,\"608\":5,\"619\":1,\"704\":11,\"705\":1,\"708\":1,\"710\":1,\"726\":1,\"746\":11,\"777\":1,\"831\":10,\"832\":3}}],[\"可读性较差\",{\"1\":{\"835\":1}}],[\"可选\",{\"1\":{\"823\":5,\"824\":2}}],[\"可选项\",{\"1\":{\"809\":1}}],[\"可选属性\",{\"0\":{\"594\":1}}],[\"可查看参数帮助\",{\"1\":{\"809\":1}}],[\"可串行化\",{\"1\":{\"746\":1}}],[\"可重复读解决了脏读\",{\"1\":{\"793\":1}}],[\"可重复读\",{\"1\":{\"746\":1,\"777\":1,\"793\":1,\"800\":1}}],[\"可靠性不高\",{\"1\":{\"731\":1}}],[\"可靠性的平衡问题\",{\"1\":{\"598\":1}}],[\"可直接将计数器的值返回\",{\"1\":{\"729\":1}}],[\"可使用索引\",{\"0\":{\"720\":1}}],[\"可设置自增长\",{\"1\":{\"617\":1}}],[\"可通过where条件控制\",{\"1\":{\"587\":1}}],[\"可通过增加\",{\"1\":{\"458\":1}}],[\"可省略\",{\"1\":{\"538\":1,\"539\":1}}],[\"可看成传统关系型数据库的功能\",{\"1\":{\"510\":1}}],[\"可视化\",{\"1\":{\"449\":1}}],[\"可配置fallbackclass\",{\"1\":{\"416\":2}}],[\"可配置blockhandlerclass\",{\"1\":{\"416\":1}}],[\"可为起始索引\",{\"1\":{\"355\":1}}],[\"可获得\",{\"1\":{\"355\":1}}],[\"可任意推导出下面任一公式\",{\"1\":{\"299\":1}}],[\"可被视为重叠区间\",{\"1\":{\"294\":1}}],[\"可能有这样的需求\",{\"1\":{\"832\":1}}],[\"可能遇到了某些错误\",{\"1\":{\"742\":1}}],[\"可能用到的索引\",{\"1\":{\"705\":1}}],[\"可能包含\",{\"1\":{\"645\":1}}],[\"可能需要将idea升级成2023\",{\"1\":{\"441\":1}}],[\"可能的最大和\",{\"1\":{\"353\":1,\"354\":1}}],[\"可能是简称\",{\"1\":{\"701\":1}}],[\"可能是某个标量\",{\"1\":{\"568\":1}}],[\"可能是正数或负数\",{\"1\":{\"345\":1}}],[\"可能是mid是第一个出错的\",{\"1\":{\"274\":1}}],[\"可能大家会清晰不少\",{\"1\":{\"211\":1}}],[\"可能前一天中持有股票\",{\"1\":{\"122\":1}}],[\"可能前一天有股票\",{\"1\":{\"120\":1}}],[\"可能前一天也没有股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"可能存在多种有效的插入方式\",{\"1\":{\"65\":1}}],[\"可能会导致同样的语句锁住更大的范围\",{\"1\":{\"776\":1}}],[\"可能会涉及到临时表\",{\"1\":{\"702\":1}}],[\"可能会\",{\"1\":{\"618\":1}}],[\"可能会造成溢出\",{\"1\":{\"274\":1}}],[\"可能会丢失\",{\"1\":{\"177\":1}}],[\"可能会溢出或者导致不正确的值\",{\"1\":{\"107\":1}}],[\"可能会发现使用回溯进行求解\",{\"1\":{\"95\":1}}],[\"可能会有疑问\",{\"1\":{\"39\":1}}],[\"可能会交换俩次\",{\"1\":{\"31\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"864\":1}}],[\"可以根据redo\",{\"1\":{\"757\":1}}],[\"可以立即进行重试\",{\"1\":{\"850\":1}}],[\"可以完成这个功能\",{\"1\":{\"831\":1}}],[\"可以执行如下操作\",{\"1\":{\"826\":1}}],[\"可以执行重复项删除操作\",{\"1\":{\"327\":1}}],[\"可以据此来审核数据库的安全等情况\",{\"1\":{\"823\":1}}],[\"可以实现\",{\"1\":{\"819\":1}}],[\"可以实现的\",{\"1\":{\"774\":1}}],[\"可以帮助我们准确定位问题\",{\"1\":{\"806\":1}}],[\"可以帮助我们通过一个sql\",{\"1\":{\"724\":1}}],[\"可以查看mysql内部发生的事情\",{\"1\":{\"805\":1}}],[\"可以查看支持事务的执行引擎\",{\"1\":{\"741\":1}}],[\"可以让读写互相不阻塞\",{\"1\":{\"801\":1}}],[\"可以被访问\",{\"1\":{\"800\":1}}],[\"可以直接执行操作\",{\"1\":{\"763\":1}}],[\"可以直接使用api进行其操作\",{\"1\":{\"245\":1}}],[\"可以指定恢复数据的开始位置和结束位置\",{\"1\":{\"809\":1}}],[\"可以指定恢复数据库的起始时间点和结束时间点\",{\"1\":{\"809\":1}}],[\"可以指\",{\"1\":{\"755\":1}}],[\"可以避免脏读\",{\"1\":{\"746\":2}}],[\"可以唯一标识一条数据\",{\"1\":{\"736\":1}}],[\"可以非常容易猜测用户id的值为多少\",{\"1\":{\"731\":1}}],[\"可以把随机io变成顺序io加快查询效率\",{\"1\":{\"727\":1}}],[\"可以把limit\",{\"1\":{\"726\":1}}],[\"可以认为是一组\",{\"1\":{\"702\":1}}],[\"可以有多个\",{\"1\":{\"686\":1,\"820\":1}}],[\"可以有两部分组成\",{\"1\":{\"148\":1,\"153\":1}}],[\"可以说\",{\"1\":{\"657\":1}}],[\"可以为目录页在抽取出一个目录页\",{\"1\":{\"647\":1}}],[\"可以为负数\",{\"1\":{\"557\":2}}],[\"可以显著\",{\"1\":{\"642\":1}}],[\"可以提高查询速度\",{\"1\":{\"642\":1}}],[\"可以提供两种资源维度的限流\",{\"1\":{\"421\":1}}],[\"可以\",{\"1\":{\"642\":1,\"819\":1}}],[\"可以保证数据库表中每一行\",{\"1\":{\"642\":1}}],[\"可以确保事务\",{\"1\":{\"636\":1}}],[\"可以分为\",{\"1\":{\"634\":1}}],[\"可以作用在多个列上\",{\"1\":{\"613\":1}}],[\"可以一次\",{\"1\":{\"607\":1}}],[\"可以存比较大的文本段\",{\"1\":{\"605\":1}}],[\"可以存在相同的\",{\"1\":{\"404\":1}}],[\"可以将这些\",{\"1\":{\"794\":1}}],[\"可以将锁分成乐观锁和悲观锁\",{\"1\":{\"780\":1}}],[\"可以将\",{\"1\":{\"608\":1}}],[\"可以将整数类型设\",{\"1\":{\"596\":1}}],[\"可以将word2增加一个c\",{\"1\":{\"152\":1,\"153\":1}}],[\"可以适用于字符串\",{\"1\":{\"562\":1}}],[\"可以嵌套\",{\"1\":{\"545\":1}}],[\"可以给出多条select语句\",{\"1\":{\"540\":1}}],[\"可以写在一行或者多行\",{\"1\":{\"518\":1}}],[\"可以限制并发执行的数量\",{\"1\":{\"479\":1}}],[\"可以基于\",{\"1\":{\"476\":1}}],[\"可以暂时切断对下游服务的调用\",{\"1\":{\"472\":1}}],[\"可以设置为n\",{\"1\":{\"810\":1}}],[\"可以设置为\",{\"1\":{\"810\":1}}],[\"可以设置索引为唯一性索引\",{\"1\":{\"686\":1}}],[\"可以设置\",{\"1\":{\"453\":1}}],[\"可以设置一个虚拟头结点\",{\"1\":{\"377\":1}}],[\"可以接\",{\"1\":{\"440\":1}}],[\"可以还原业务数据\",{\"1\":{\"436\":1}}],[\"可以理解为选择的标准就是\",{\"1\":{\"729\":1}}],[\"可以理解为\",{\"1\":{\"426\":1}}],[\"可以配置多个\",{\"1\":{\"419\":1}}],[\"可以访问\",{\"1\":{\"412\":1}}],[\"可以访问的所有节点的列表\",{\"1\":{\"223\":1}}],[\"可以自行修改\",{\"1\":{\"409\":1}}],[\"可以通过它来找到该记录修改前的信息\",{\"1\":{\"794\":1}}],[\"可以通过这几个字段进行查询\",{\"1\":{\"686\":1}}],[\"可以通过索引进行查询\",{\"1\":{\"686\":1}}],[\"可以通过以下\",{\"1\":{\"599\":1}}],[\"可以通过\",{\"1\":{\"426\":1,\"615\":1,\"809\":1}}],[\"可以通过配置项\",{\"1\":{\"403\":1}}],[\"可以通过连续跟踪\",{\"1\":{\"393\":1}}],[\"可以通过从原始序列中删除一些\",{\"1\":{\"345\":1}}],[\"可以采用快慢双指针的方法\",{\"1\":{\"391\":1}}],[\"可以采用多次反转\",{\"1\":{\"256\":1}}],[\"可以无限地前进\",{\"1\":{\"363\":1}}],[\"可以射出的弓箭的数量\",{\"1\":{\"363\":1}}],[\"可以走完一圈\",{\"1\":{\"356\":1}}],[\"可以获得\",{\"1\":{\"355\":1}}],[\"可以多次选择同一个下标\",{\"1\":{\"353\":1}}],[\"可以多次买入\",{\"1\":{\"122\":1}}],[\"可以选择跳1步\",{\"1\":{\"350\":1}}],[\"可以选择儿子节点\",{\"1\":{\"117\":1}}],[\"可以选择儿子结点\",{\"1\":{\"117\":1}}],[\"可以先跳\",{\"1\":{\"349\":1}}],[\"可以先利用中序遍历保存到一个集合中\",{\"1\":{\"58\":1}}],[\"可以利用栈先进先出的特性\",{\"1\":{\"325\":1}}],[\"可以利用这个特点\",{\"1\":{\"165\":1}}],[\"可以转换成一个\",{\"1\":{\"267\":1}}],[\"可以匹配一个或者多个空字符\",{\"1\":{\"245\":1}}],[\"可以是mysql8\",{\"1\":{\"822\":1}}],[\"可以是xml\",{\"1\":{\"510\":1}}],[\"可以是简单的对象\",{\"1\":{\"510\":1}}],[\"可以是多个rm\",{\"1\":{\"426\":1}}],[\"可以是任意值\",{\"1\":{\"390\":1}}],[\"可以是\",{\"1\":{\"201\":1}}],[\"可以重复\",{\"1\":{\"197\":1}}],[\"可以形成一组候选\",{\"1\":{\"194\":1}}],[\"可以考虑使用什么样的hash表\",{\"1\":{\"175\":1}}],[\"可以对表起别名\",{\"1\":{\"533\":1}}],[\"可以对\",{\"1\":{\"173\":1}}],[\"可以删除任意一个字符串中的一个字符\",{\"1\":{\"149\":1}}],[\"可以画出两条不交叉的线\",{\"1\":{\"140\":1}}],[\"可以绘制一些连接两个数字\",{\"1\":{\"140\":1}}],[\"可以忽略\",{\"1\":{\"124\":1}}],[\"可以得到每天的利润序列\",{\"1\":{\"122\":1}}],[\"可以由参数\",{\"1\":{\"810\":1}}],[\"可以由两个下标\",{\"1\":{\"134\":1}}],[\"可以由\",{\"1\":{\"110\":2}}],[\"可以由dp\",{\"1\":{\"109\":1}}],[\"可以使用这个命令\",{\"1\":{\"785\":1}}],[\"可以使用下边两种方法之一\",{\"1\":{\"745\":1}}],[\"可以使用连接\",{\"1\":{\"724\":1}}],[\"可以使用公式\",{\"1\":{\"689\":1}}],[\"可以使用本地磁盘\",{\"1\":{\"632\":1}}],[\"可以使用check约束\",{\"1\":{\"619\":1}}],[\"可以使用group\",{\"1\":{\"563\":1}}],[\"可以使用空格或者\",{\"1\":{\"521\":1}}],[\"可以使用show\",{\"1\":{\"695\":1}}],[\"可以使用sql语句方便在一个表或者多个表进行复杂查询\",{\"1\":{\"509\":1}}],[\"可以使用set对同一层的元素进行去重\",{\"1\":{\"207\":2}}],[\"可以使用冒泡\",{\"1\":{\"337\":1}}],[\"可以使用\",{\"1\":{\"207\":1,\"608\":1,\"632\":1,\"831\":2}}],[\"可以使用多次\",{\"1\":{\"194\":1}}],[\"可以使用无限次\",{\"1\":{\"109\":1}}],[\"可以使用基础的二维数组\",{\"1\":{\"91\":1}}],[\"可以用\",{\"1\":{\"813\":1}}],[\"可以用于主从服务器之间的数据同步\",{\"1\":{\"805\":1}}],[\"可以用于较小范围的统计数据\",{\"1\":{\"598\":1}}],[\"可以用一个变量\",{\"1\":{\"135\":1}}],[\"可以用回溯算法\",{\"1\":{\"99\":1}}],[\"可以用下面的算法从\",{\"1\":{\"50\":1}}],[\"可以在数据库层面阻止其他事务对该数据的操作权限\",{\"1\":{\"783\":1}}],[\"可以在创建表时规定约束\",{\"1\":{\"612\":1}}],[\"可以在sql语句中实现不同的条件选择\",{\"1\":{\"559\":1}}],[\"可以在运行时通过控制台实时修改限流降级规则\",{\"1\":{\"399\":1}}],[\"可以在\",{\"1\":{\"98\":1,\"725\":1}}],[\"可以构造一个\",{\"1\":{\"98\":1}}],[\"可以发现\",{\"1\":{\"92\":1}}],[\"可以从\",{\"1\":{\"83\":1}}],[\"可以从第\",{\"1\":{\"83\":1}}],[\"可以证明\",{\"1\":{\"69\":1}}],[\"可以按任意顺序返回结果列表\",{\"1\":{\"164\":1}}],[\"可以按\",{\"1\":{\"59\":1}}],[\"可以看到c1读取成功\",{\"1\":{\"767\":1}}],[\"可以看到\",{\"1\":{\"12\":2}}],[\"翻转这棵二叉树\",{\"1\":{\"30\":1}}],[\"叶子节点的data域存放的是\",{\"1\":{\"653\":1}}],[\"叶子节点存储的是完整的用户记录\",{\"1\":{\"650\":1}}],[\"叶子节点\",{\"1\":{\"38\":1,\"44\":1,\"648\":1,\"651\":1}}],[\"叶子节点是指没有子节点的节点\",{\"1\":{\"27\":1}}],[\"叶子结点之间有指针相互关联\",{\"1\":{\"662\":1}}],[\"叶子结点\",{\"1\":{\"0\":1}}],[\"当删除失败后\",{\"1\":{\"850\":1}}],[\"当从库线程连接的时候\",{\"1\":{\"820\":1}}],[\"当主库读取事件\",{\"1\":{\"820\":1}}],[\"当主库出现写锁的时候\",{\"1\":{\"819\":1}}],[\"当主库进行更新的时候\",{\"1\":{\"819\":1}}],[\"当主表的记录被从表参照时\",{\"1\":{\"618\":1}}],[\"当有请求的时候\",{\"1\":{\"818\":1}}],[\"当mysql创建二进制日志文件时\",{\"1\":{\"809\":1}}],[\"当mysql检索char类型的数据时\",{\"1\":{\"604\":1}}],[\"当隔离级别为可重复读的时候\",{\"1\":{\"799\":1}}],[\"当你需要让整个库处于\",{\"1\":{\"785\":1}}],[\"当你将其中一棵覆盖到另一棵之上时\",{\"1\":{\"52\":1}}],[\"当其他线程想要访问数据时\",{\"1\":{\"781\":1}}],[\"当某个层级的锁数量超过了这个层级的阈值时\",{\"1\":{\"779\":1}}],[\"当某个结点没有左右孩子结点\",{\"1\":{\"41\":1}}],[\"当某个结点的左右子树都为空时\",{\"1\":{\"28\":1}}],[\"当没有的时候就会在内存中生成一个\",{\"1\":{\"763\":1}}],[\"当一个事务获取了一条记录的x型记录锁后\",{\"1\":{\"775\":1}}],[\"当一个事务获取了一条记录的s型记录锁后\",{\"1\":{\"775\":1}}],[\"当一个事务想对这条记录做改动时\",{\"1\":{\"763\":1}}],[\"当一个处在\",{\"1\":{\"742\":1}}],[\"当用户操作写完数据库\",{\"1\":{\"851\":1,\"852\":1}}],[\"当用户读取一行记录时\",{\"1\":{\"756\":1}}],[\"当用户下单时\",{\"1\":{\"430\":1}}],[\"当服务器重启时\",{\"1\":{\"747\":1}}],[\"当事务启动时\",{\"1\":{\"796\":1}}],[\"当事务提交后\",{\"1\":{\"794\":1}}],[\"当事务commit时\",{\"1\":{\"752\":1}}],[\"当事务处在\",{\"1\":{\"742\":1}}],[\"当事务中的最后一个操作执行完成\",{\"1\":{\"742\":1}}],[\"当3nf消除了主属性对码的部分函数依赖和传递函数依赖称为bcnf\",{\"1\":{\"737\":1}}],[\"当执行到最后一个sql时可以发现\",{\"1\":{\"715\":1}}],[\"当被驱动表不能有效的利用索引加快访问速度\",{\"1\":{\"710\":1}}],[\"当查询列表处有`min`或者`max`聚合函数\",{\"1\":{\"710\":1}}],[\"当查询语句的没有`from`子句时将会提示该额外信息\",{\"1\":{\"710\":1}}],[\"当查询优化器在执行包含子查询的语句时\",{\"1\":{\"703\":1}}],[\"当对一个表做增删改查操作的时候\",{\"1\":{\"773\":1}}],[\"当对普通二级索引进行等值匹配查询\",{\"1\":{\"704\":1}}],[\"当对表\",{\"1\":{\"642\":1}}],[\"当通过普通的二级索引列与常量进行等值匹配时来查询某个表\",{\"1\":{\"704\":1}}],[\"当表中\",{\"1\":{\"704\":1}}],[\"当涉及多个select时\",{\"1\":{\"702\":1}}],[\"当free\",{\"1\":{\"670\":1}}],[\"当目录页较多时\",{\"1\":{\"647\":1}}],[\"当需要产生唯一标识符或顺序值时\",{\"1\":{\"617\":1}}],[\"当需要检索json类型的字段中数据的某个具体值时\",{\"1\":{\"608\":1}}],[\"当创建主键约束时\",{\"1\":{\"616\":1}}],[\"当enum类型的字段没有声明为not\",{\"1\":{\"606\":1}}],[\"当enum类型包含256～65535个成员时\",{\"1\":{\"606\":1}}],[\"当enum类型包含1～255个成员时\",{\"1\":{\"606\":1}}],[\"当数据的精度超出了定点数类型的\",{\"1\":{\"600\":1}}],[\"当数据宽度小于5位的时候在数字前面需要用\",{\"1\":{\"595\":1}}],[\"当插入数据为负数时\",{\"1\":{\"596\":1}}],[\"当插入的数据不足3位\",{\"1\":{\"595\":1}}],[\"当使用索引访问来执行对某个表的查询\",{\"1\":{\"710\":1}}],[\"当使用索引列等值查询时\",{\"1\":{\"707\":1}}],[\"当使用\",{\"1\":{\"595\":1}}],[\"当过滤条件中没有聚合函数时\",{\"1\":{\"564\":1}}],[\"当过滤条件中有聚合函数时\",{\"1\":{\"564\":1}}],[\"当time2为一个数字时\",{\"1\":{\"557\":2}}],[\"当x\",{\"1\":{\"550\":3}}],[\"当x的值为负数时\",{\"1\":{\"548\":1}}],[\"当达到并发调用数量时\",{\"1\":{\"480\":1}}],[\"当慢调用比例高于阈值\",{\"1\":{\"478\":1}}],[\"当慢调用比例大于等于峰值时\",{\"1\":{\"476\":1}}],[\"当断路器开启时\",{\"1\":{\"477\":1}}],[\"当请求的失败率达到一定的阈值后\",{\"1\":{\"475\":1}}],[\"当依赖服务的故障率超过阈值时\",{\"1\":{\"475\":1}}],[\"当下游服务因访问压力过大而响应变慢或失败\",{\"1\":{\"472\":1}}],[\"当总请求数位4时\",{\"1\":{\"460\":1}}],[\"当总请求数位3时\",{\"1\":{\"460\":1}}],[\"当总请求数位2时\",{\"1\":{\"460\":1}}],[\"当总请求数为1时\",{\"1\":{\"460\":1}}],[\"当consul\",{\"1\":{\"454\":1}}],[\"当修改\",{\"1\":{\"453\":1}}],[\"当携带p1参数的请求\",{\"1\":{\"417\":1}}],[\"当流量突然增加时\",{\"1\":{\"411\":1}}],[\"当系统长期处于低水位的情况下\",{\"1\":{\"411\":1}}],[\"当关联的资源达到阈值时\",{\"1\":{\"410\":1}}],[\"当pa到达相交结点的移动次数为\",{\"1\":{\"391\":1}}],[\"当然除了\",{\"1\":{\"835\":1}}],[\"当然\",{\"1\":{\"725\":1,\"745\":1}}],[\"当然有些存储引擎比如innodb\",{\"1\":{\"632\":1}}],[\"当然有\",{\"1\":{\"599\":1}}],[\"当然我们可以在设置一个临时结点等于虚拟头结点\",{\"1\":{\"377\":1}}],[\"当然也可以用s\",{\"1\":{\"148\":1,\"153\":1}}],[\"当且仅当每个相邻位数上的数字\",{\"1\":{\"369\":1}}],[\"当遍历到某个字母的最远距离时\",{\"1\":{\"368\":1}}],[\"当遍历到这个最远下标时\",{\"1\":{\"368\":1}}],[\"当遍历到头时\",{\"1\":{\"222\":1}}],[\"当不重叠时\",{\"1\":{\"366\":1}}],[\"当不选择node节点时\",{\"1\":{\"117\":1}}],[\"当做存储容器\",{\"1\":{\"337\":1}}],[\"当元素从下往上遍历时\",{\"1\":{\"304\":1}}],[\"当元素从上往下遍历时\",{\"1\":{\"304\":2}}],[\"当我第一次看到这里时\",{\"1\":{\"304\":1}}],[\"当我们查询数据库在某个时间点的快照时\",{\"1\":{\"801\":1}}],[\"当我们向包含了\",{\"1\":{\"772\":1}}],[\"当我们的数据发生异常时\",{\"1\":{\"806\":1}}],[\"当我们的`limit`子句的参数为`0`时\",{\"1\":{\"710\":1}}],[\"当我们的查询列表以及搜索条件中只包含属于某个索引的列\",{\"1\":{\"710\":1}}],[\"当我们使用页锁的时候\",{\"1\":{\"779\":1}}],[\"当我们使用左\",{\"1\":{\"710\":1}}],[\"当我们使用全表扫描来执行对某个表的查询\",{\"1\":{\"710\":1}}],[\"当我们可以使用索引覆盖\",{\"1\":{\"704\":1}}],[\"当我们根据主键或者唯一二级索引列与常数进行等值匹配时\",{\"1\":{\"704\":1}}],[\"当我们遇到数据库调优问题的时候\",{\"1\":{\"694\":1}}],[\"当我们提到平衡二叉树时一般指的就是平衡二叉搜索树\",{\"1\":{\"660\":1}}],[\"当我们访问6次\",{\"1\":{\"477\":1}}],[\"当我们重新遍历的时候\",{\"1\":{\"209\":1}}],[\"当我们求不同集合之间的组合时\",{\"1\":{\"195\":1}}],[\"当我们求同一个集合中的不同组合时\",{\"1\":{\"195\":1}}],[\"当我们遍历数组时\",{\"1\":{\"175\":1}}],[\"当我们先遍历物品时\",{\"1\":{\"103\":1}}],[\"当我们将一条路径存到集合中\",{\"1\":{\"39\":1}}],[\"当矩阵大小\",{\"1\":{\"299\":2}}],[\"当处理完最后一行时\",{\"1\":{\"215\":1}}],[\"当字母长度等于数字长度时\",{\"1\":{\"193\":2}}],[\"当所剩余元素不足需要选择的元素个数时\",{\"1\":{\"191\":1}}],[\"当word1\",{\"1\":{\"153\":4}}],[\"当sql使用覆盖索引时\",{\"1\":{\"728\":1}}],[\"当set类型包含的成员个数不同时\",{\"1\":{\"607\":1}}],[\"当stack为空或者遇到不相等的元素\",{\"1\":{\"328\":1}}],[\"当sum\",{\"1\":{\"191\":1}}],[\"当s\",{\"1\":{\"148\":2,\"153\":2}}],[\"当选择node节点时\",{\"1\":{\"117\":1}}],[\"当金额为j时\",{\"1\":{\"107\":1}}],[\"当先遍历背包时\",{\"1\":{\"103\":1}}],[\"当decimal类型不指定精度和标度时\",{\"1\":{\"600\":1}}],[\"当deep增加时\",{\"1\":{\"12\":1}}],[\"当dp数组被填满之后\",{\"1\":{\"95\":1}}],[\"当头结点为\",{\"1\":{\"89\":2}}],[\"当左右子树都不为空时\",{\"1\":{\"70\":1}}],[\"当左右子树都为空时\",{\"1\":{\"28\":1}}],[\"当\",{\"1\":{\"68\":1,\"70\":2,\"91\":2,\"95\":1,\"126\":1,\"155\":3,\"157\":1,\"187\":1,\"188\":2,\"190\":1,\"195\":1,\"201\":1,\"203\":1,\"276\":1,\"304\":7,\"313\":3,\"352\":1,\"403\":1,\"410\":1,\"417\":1,\"418\":1,\"660\":1,\"763\":1}}],[\"当前读读取的是记录的最新版本\",{\"1\":{\"791\":1}}],[\"当前读实际上是一种加锁的操作\",{\"1\":{\"791\":1}}],[\"当前读\",{\"1\":{\"791\":2}}],[\"当前写操作没有完成前\",{\"1\":{\"767\":1}}],[\"当前事务可以通过undo读取之前的行版本信息\",{\"1\":{\"756\":1}}],[\"当前已经存在的会话无效\",{\"1\":{\"746\":1}}],[\"当前孩子分数\",{\"1\":{\"360\":1}}],[\"当前孩子的糖果数量\",{\"1\":{\"360\":1}}],[\"当前孩子\",{\"1\":{\"360\":7,\"362\":1}}],[\"当前是下坡\",{\"1\":{\"346\":1}}],[\"当前为上坡\",{\"1\":{\"346\":1}}],[\"当前元素比上一个元素小\",{\"1\":{\"346\":1}}],[\"当前元素比上一个元素大\",{\"1\":{\"346\":1}}],[\"当前元素不是输出元素时\",{\"1\":{\"280\":1}}],[\"当前元素是输出元素时\",{\"1\":{\"280\":1}}],[\"当前mid版本没有错误\",{\"1\":{\"274\":1}}],[\"当前单元格高度\",{\"1\":{\"234\":1}}],[\"当前单元格的高度\",{\"1\":{\"233\":1}}],[\"当前遍历的节点值等于图中最后一个元素值\",{\"1\":{\"224\":1}}],[\"当前位置覆盖的最大范围\",{\"1\":{\"352\":1}}],[\"当前位置能够到达的最远距离\",{\"1\":{\"350\":2}}],[\"当前位置已有数字\",{\"1\":{\"217\":1}}],[\"当前位置的右上方\",{\"1\":{\"215\":2}}],[\"当前位置的左上方\",{\"1\":{\"215\":2}}],[\"当前位置共有dp\",{\"1\":{\"85\":1}}],[\"当前机票的起点必然是上一个机票的终点\",{\"1\":{\"213\":2}}],[\"当前数字代表的字母集合\",{\"1\":{\"193\":2}}],[\"当前字符串使用1的个数\",{\"1\":{\"101\":1}}],[\"当前字符串使用0的个数\",{\"1\":{\"101\":1}}],[\"当前物品容量小于或等于背包容量\",{\"1\":{\"91\":1}}],[\"当前物品的容量大于背包容量\",{\"1\":{\"91\":1}}],[\"当前背包容量大于等于第\",{\"1\":{\"91\":1}}],[\"当前背包容量小于第\",{\"1\":{\"91\":1}}],[\"当前结果是由上一层和前一列得出\",{\"1\":{\"85\":1}}],[\"当前结点为\",{\"1\":{\"224\":1}}],[\"当前结点为这一层的最后一个节点\",{\"1\":{\"24\":1}}],[\"当前结点值\",{\"1\":{\"66\":2}}],[\"当前结点的值出现的频率还是最高\",{\"1\":{\"60\":1}}],[\"当前结点\",{\"1\":{\"60\":1}}],[\"当前节点的值\",{\"1\":{\"59\":2,\"117\":1}}],[\"当前节点的数\",{\"1\":{\"55\":2}}],[\"当前节点的下一个节点\",{\"1\":{\"24\":1}}],[\"当前层的第一个节点\",{\"1\":{\"24\":1}}],[\"则写入死信队列中\",{\"1\":{\"852\":1}}],[\"则我们需要在重试表中记录一个失败的状态\",{\"1\":{\"851\":1}}],[\"则恢复的时候不需要指定数据库名称\",{\"1\":{\"832\":1}}],[\"则采用row格式保存binlog\",{\"1\":{\"823\":1}}],[\"则克隆的虚拟机mysql\",{\"1\":{\"822\":1}}],[\"则可以这样操作\",{\"1\":{\"832\":1}}],[\"则可以不用获取自增锁\",{\"1\":{\"772\":1}}],[\"则可以得到\",{\"1\":{\"276\":2}}],[\"则对后续的事务有效\",{\"1\":{\"746\":1}}],[\"则对该被驱动表的访问方法就是eq\",{\"1\":{\"704\":1}}],[\"则会被记录到慢査询日志中\",{\"1\":{\"697\":1}}],[\"则会为表默认添加一个名为row\",{\"1\":{\"681\":1}}],[\"则会选取一个unique键作为主键\",{\"1\":{\"681\":1}}],[\"则会在\",{\"1\":{\"604\":1}}],[\"则两个长字节串肯定是不同的\",{\"1\":{\"668\":1}}],[\"则两种组合是不同的\",{\"1\":{\"194\":1}}],[\"则赋值为默\",{\"1\":{\"620\":1}}],[\"则mysql同样会进行四舍五入处理\",{\"1\":{\"600\":1}}],[\"则mysql会将字符串转化为数字进行比较\",{\"1\":{\"528\":1}}],[\"则mysql会按照字符串进行比较\",{\"1\":{\"528\":1}}],[\"则使用0在前面填充\",{\"1\":{\"595\":1}}],[\"则系统为每一种类型指定默认\",{\"1\":{\"595\":1}}],[\"则location为\",{\"1\":{\"575\":1}}],[\"则过滤条件放在\",{\"1\":{\"564\":1}}],[\"则过滤条件一定要放在havign中\",{\"1\":{\"564\":1}}],[\"则必须在\",{\"1\":{\"564\":1}}],[\"则必须使用\",{\"1\":{\"564\":1}}],[\"则必须最少记录10个样本\",{\"1\":{\"477\":1}}],[\"则尽量使用union\",{\"1\":{\"540\":1}}],[\"则连接条件中右边的表也称为\",{\"1\":{\"537\":1}}],[\"则连接条件中左边的表也称为\",{\"1\":{\"537\":1}}],[\"则最少需要\",{\"1\":{\"533\":1}}],[\"则结果为\",{\"1\":{\"528\":2}}],[\"则结束熔断\",{\"1\":{\"412\":1}}],[\"则比较结果为null\",{\"1\":{\"528\":1}}],[\"则10次调用中有50\",{\"1\":{\"476\":1}}],[\"则获得服务地址为\",{\"1\":{\"460\":4}}],[\"则每个微服务中关于数据库的配置几乎都是相同的\",{\"1\":{\"452\":1}}],[\"则无法实现微服务的负载均衡功能\",{\"1\":{\"447\":1}}],[\"则需要在my\",{\"1\":{\"807\":1}}],[\"则需要重新修改\",{\"1\":{\"447\":1}}],[\"则需要使用\",{\"1\":{\"419\":1}}],[\"则链表中存在环\",{\"1\":{\"393\":1}}],[\"则pa\",{\"1\":{\"391\":1}}],[\"则进行删除操作为\",{\"1\":{\"389\":1}}],[\"则到了分割点\",{\"1\":{\"368\":1}}],[\"则直接更新尾端值\",{\"1\":{\"366\":1}}],[\"则直接返回\",{\"1\":{\"62\":1}}],[\"则符合摆动序列\",{\"1\":{\"346\":2}}],[\"则只记录下坡\",{\"1\":{\"346\":1}}],[\"则数字序列称为\",{\"1\":{\"345\":1}}],[\"则res\",{\"1\":{\"334\":1}}],[\"则依次弹出后加入\",{\"1\":{\"334\":1}}],[\"则覆盖\",{\"1\":{\"314\":1}}],[\"则在该链表中没有环\",{\"1\":{\"393\":1}}],[\"则在后半部分找\",{\"1\":{\"277\":1}}],[\"则在前半部分找\",{\"1\":{\"277\":1}}],[\"则反转前\",{\"1\":{\"252\":1}}],[\"则表示长度默认是1个字符\",{\"1\":{\"604\":1}}],[\"则表示当调用接口的并发线程数达到阈值时\",{\"1\":{\"409\":1}}],[\"则表示在第i天持有股票的条件下\",{\"1\":{\"128\":1}}],[\"则表名所有皇后均放置完毕\",{\"1\":{\"215\":1}}],[\"则为外键\",{\"1\":{\"837\":1}}],[\"则为for循环的起始下标\",{\"1\":{\"205\":1}}],[\"则为当前要截取的字符串\",{\"1\":{\"199\":1}}],[\"则为null\",{\"1\":{\"24\":1}}],[\"则认为两个四元组重复\",{\"1\":{\"178\":1}}],[\"则说明主从配置成功\",{\"1\":{\"826\":1}}],[\"则说明无解\",{\"1\":{\"356\":1}}],[\"则说明\",{\"1\":{\"173\":1}}],[\"则称它们是\",{\"1\":{\"231\":1}}],[\"则称\",{\"1\":{\"161\":1}}],[\"则不存在\",{\"1\":{\"831\":1}}],[\"则不存在公共祖先\",{\"1\":{\"62\":1}}],[\"则不允许对父表对应候选键进行update\",{\"1\":{\"618\":1}}],[\"则不会计入\",{\"1\":{\"477\":1}}],[\"则不考虑第i个元素\",{\"1\":{\"146\":1}}],[\"则\",{\"1\":{\"146\":2,\"157\":2,\"224\":1,\"240\":1,\"355\":1,\"679\":1,\"776\":1}}],[\"则取\",{\"1\":{\"139\":1}}],[\"则dp\",{\"1\":{\"137\":1,\"139\":1}}],[\"则有\",{\"1\":{\"89\":1}}],[\"则乘积为\",{\"1\":{\"87\":2}}],[\"则该子查询的第一个select关键字代表的那个查询的select\",{\"1\":{\"703\":1}}],[\"则该子集的和为target\",{\"1\":{\"95\":1}}],[\"则该结点为相交结点\",{\"1\":{\"391\":1}}],[\"则该气球会被\",{\"1\":{\"363\":1}}],[\"则该字符串称为回文字符串\",{\"1\":{\"260\":1}}],[\"则该位置就是要插入的位置\",{\"1\":{\"66\":1}}],[\"则该层包含\",{\"1\":{\"34\":1}}],[\"则公共祖先在左子树\",{\"1\":{\"62\":1}}],[\"则公共祖先在右子树\",{\"1\":{\"62\":1}}],[\"则是利用\",{\"1\":{\"420\":1}}],[\"则是对同一树枝重复元素的判断\",{\"1\":{\"211\":1}}],[\"则是一组解\",{\"1\":{\"177\":1}}],[\"则是\",{\"1\":{\"51\":1}}],[\"则左子树搜索范围\",{\"1\":{\"51\":1}}],[\"则返回成功\",{\"1\":{\"851\":1,\"852\":1}}],[\"则返回value2\",{\"1\":{\"559\":1}}],[\"则返回sn\",{\"1\":{\"552\":1}}],[\"则返回s2\",{\"1\":{\"552\":1}}],[\"则返回s1\",{\"1\":{\"552\":1}}],[\"则返回null\",{\"1\":{\"549\":2,\"552\":1}}],[\"则返回true\",{\"1\":{\"497\":1}}],[\"则返回出发时加油站的编号\",{\"1\":{\"355\":1}}],[\"则返回它的下标\",{\"1\":{\"277\":1}}],[\"则返回面积为\",{\"1\":{\"227\":1}}],[\"则返回\",{\"1\":{\"37\":1,\"53\":1,\"62\":1,\"68\":1,\"110\":1,\"169\":1,\"393\":1}}],[\"则置为null\",{\"1\":{\"24\":1}}],[\"则指向下一个结点\",{\"1\":{\"24\":1}}],[\"则将其所在的行与列清零\",{\"1\":{\"300\":1}}],[\"则将剩余字符全部反转\",{\"1\":{\"252\":1}}],[\"则将\",{\"1\":{\"23\":1,\"241\":1}}],[\"你删除了一条记录\",{\"1\":{\"755\":1}}],[\"你插入一条记录\",{\"1\":{\"755\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"886\":1}}],[\"你也可以先购买\",{\"1\":{\"121\":1}}],[\"你也知道此时数据是不一致的\",{\"1\":{\"741\":1}}],[\"你自然就发现了此时数据是不一致的\",{\"1\":{\"741\":1}}],[\"你输入的是由多个字符串和空格组成的一条\",{\"1\":{\"634\":1}}],[\"你要注意的是\",{\"1\":{\"598\":1}}],[\"你要怎么拿\",{\"1\":{\"342\":1}}],[\"你传递过来也是null\",{\"1\":{\"500\":1}}],[\"你被限流了\",{\"1\":{\"482\":1}}],[\"你应该创建和编写\",{\"1\":{\"864\":1}}],[\"你应该提供整个链表\",{\"1\":{\"379\":1}}],[\"你应该尽量减少对调用\",{\"1\":{\"274\":1}}],[\"你将\",{\"1\":{\"379\":1}}],[\"你将从下标为\",{\"1\":{\"82\":2}}],[\"你都不可能绕环路行驶一周\",{\"1\":{\"355\":1}}],[\"你无法返回\",{\"1\":{\"355\":1}}],[\"你无法在第二天买入股票\",{\"1\":{\"127\":1}}],[\"你从其中的一个加油站出发\",{\"1\":{\"355\":1}}],[\"你最初位于数组的\",{\"1\":{\"349\":1}}],[\"你最多可以买\",{\"1\":{\"125\":1}}],[\"你最多可以完成\",{\"1\":{\"123\":1,\"125\":1}}],[\"你拥有的饼干数量和尺寸都足以让所有孩子满足\",{\"1\":{\"343\":1}}],[\"你有一辆油箱容量无限的的汽车\",{\"1\":{\"355\":1}}],[\"你有两个孩子和三块小饼干\",{\"1\":{\"343\":1}}],[\"你有三个孩子和两块小饼干\",{\"1\":{\"343\":1}}],[\"你有多少种不同的方法可以爬到楼顶呢\",{\"1\":{\"80\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"333\":1}}],[\"你只能采用\",{\"1\":{\"605\":1}}],[\"你只能让胃口值是1的孩子满足\",{\"1\":{\"343\":1}}],[\"你只能选择\",{\"1\":{\"119\":1}}],[\"你只能使用常量级额外空间\",{\"1\":{\"23\":1}}],[\"你所设计算法的时间复杂度\",{\"1\":{\"336\":1}}],[\"你所设计的解决方案必须只使用常量级的额外空间\",{\"1\":{\"240\":1}}],[\"你所使用的语言也许不支持栈\",{\"1\":{\"321\":1}}],[\"你能看到页的数量是刚才的\",{\"1\":{\"696\":1}}],[\"你能否用\",{\"1\":{\"345\":1}}],[\"你能尽量减少完成的操作次数吗\",{\"1\":{\"315\":1}}],[\"你能获得的\",{\"1\":{\"121\":1}}],[\"你不需要移除任何区间\",{\"1\":{\"365\":1}}],[\"你不需要考虑数组中超出新长度后面的元素\",{\"1\":{\"278\":3}}],[\"你不知道气球的确切\",{\"1\":{\"363\":1}}],[\"你不能从\",{\"1\":{\"355\":1}}],[\"你不能同时参与多笔交易\",{\"1\":{\"123\":1,\"125\":1,\"127\":1}}],[\"你不能在买入前卖出股票\",{\"1\":{\"119\":1}}],[\"你不能先偷窃\",{\"1\":{\"114\":1}}],[\"你想找出导致之后所有版本出错的第一个错误的版本\",{\"1\":{\"274\":1}}],[\"你是如何解决数据一致性问题的\",{\"0\":{\"844\":1}}],[\"你是产品经理\",{\"1\":{\"274\":1}}],[\"你是一个专业的小偷\",{\"1\":{\"112\":1,\"114\":1}}],[\"你的更新策略是什么\",{\"0\":{\"845\":1}}],[\"你的主机ip地址\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"你的目标是尽可能满足越多数量的孩子\",{\"1\":{\"343\":1}}],[\"你的产品的最新版本没有通过质量检测\",{\"1\":{\"274\":1}}],[\"你的任务是将这些数分成\",{\"1\":{\"257\":1}}],[\"你的函数应该填充它的每个\",{\"1\":{\"23\":1}}],[\"你必须给每个顾客正确找零\",{\"1\":{\"357\":1}}],[\"你必须在不修改节点内部的值的情况下完成本题\",{\"1\":{\"385\":1}}],[\"你必须在\",{\"1\":{\"297\":1}}],[\"你必须在再次购买前出售掉之前的股票\",{\"1\":{\"123\":2,\"125\":1,\"127\":1}}],[\"你必须仅使用\",{\"1\":{\"278\":1}}],[\"你必须设计一个时间复杂度为\",{\"1\":{\"276\":1,\"277\":1}}],[\"你必须设计并实现时间复杂度为\",{\"1\":{\"275\":1}}],[\"你必须\",{\"1\":{\"249\":1}}],[\"你\",{\"1\":{\"200\":1,\"321\":1,\"755\":1}}],[\"你返回所有和为\",{\"1\":{\"176\":1}}],[\"你会怎样改变代码\",{\"1\":{\"145\":1}}],[\"你在任何时候\",{\"1\":{\"121\":1}}],[\"你可以将图片和\",{\"1\":{\"885\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"885\":1}}],[\"你可以标记\",{\"1\":{\"876\":1}}],[\"你可以在\",{\"1\":{\"883\":1,\"884\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"861\":1}}],[\"你可以在发送下游请求之前或之后修改请求和响应\",{\"1\":{\"488\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"858\":1}}],[\"你可以通过调用\",{\"1\":{\"274\":1}}],[\"你可以简单理解为\",{\"1\":{\"642\":1}}],[\"你可以把整数看成小数的一个特例\",{\"1\":{\"599\":1}}],[\"你可以用逻辑\",{\"1\":{\"491\":1}}],[\"你可以分别给第一个\",{\"1\":{\"359\":2}}],[\"你可以跳转到任意\",{\"1\":{\"351\":1}}],[\"你可以拿走十张\",{\"1\":{\"342\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"864\":1}}],[\"你可以使用一趟扫描完成反转吗\",{\"1\":{\"383\":1}}],[\"你可以使用\",{\"1\":{\"321\":1}}],[\"你可以想象内部操作如下\",{\"1\":{\"278\":1}}],[\"你可以假设每个输入\",{\"1\":{\"240\":1}}],[\"你可以假设每种输入只会对应一个答案\",{\"1\":{\"174\":1}}],[\"你可以假设\",{\"1\":{\"227\":1,\"269\":1}}],[\"你可以假设该网格的四条边均被水包围\",{\"1\":{\"225\":1}}],[\"你可以\",{\"1\":{\"208\":1}}],[\"你可以按\",{\"1\":{\"178\":1,\"186\":1,\"194\":1,\"200\":1,\"202\":1,\"206\":1,\"336\":1}}],[\"你可以按任意顺序返回答案\",{\"1\":{\"174\":1}}],[\"你可以对一个单词进行如下三种操作\",{\"1\":{\"151\":1}}],[\"你可以无限次地完成交易\",{\"1\":{\"129\":1}}],[\"你可以尽可能地完成更多的交易\",{\"1\":{\"127\":1}}],[\"你可以决定是否购买和\",{\"1\":{\"121\":1}}],[\"你可以先偷窃\",{\"1\":{\"114\":1}}],[\"你可以重复使用字典中的单词\",{\"1\":{\"110\":1}}],[\"你可以认为每种硬币的数量是无限的\",{\"1\":{\"106\":1}}],[\"你可以获得的最大乘积\",{\"1\":{\"86\":1}}],[\"你可以选择从下标为\",{\"1\":{\"82\":1}}],[\"你可以返回\",{\"1\":{\"65\":1}}],[\"你可以不使用额外的空间吗\",{\"1\":{\"59\":1}}],[\"你可以运用递归和迭代两种方法解决这个问题吗\",{\"1\":{\"32\":1}}],[\"你需要阅读\",{\"1\":{\"866\":1}}],[\"你需要考虑\",{\"1\":{\"598\":1}}],[\"你需要移除两个\",{\"1\":{\"365\":1}}],[\"你需要按照以下要求\",{\"1\":{\"359\":1}}],[\"你需要消耗\",{\"1\":{\"355\":1}}],[\"你需要做以下事情确保你的题解可以被通过\",{\"1\":{\"312\":1}}],[\"你需要\",{\"1\":{\"278\":1}}],[\"你需要反转字符串中每个单词的字符顺序\",{\"1\":{\"246\":1}}],[\"你需要依次检查它们是否为\",{\"1\":{\"145\":1}}],[\"你需要在\",{\"1\":{\"53\":1}}],[\"你需要将这两棵树合并成一棵新二叉树\",{\"1\":{\"52\":1}}],[\"进制间的转换\",{\"0\":{\"551\":1}}],[\"进一步提高性能\",{\"1\":{\"510\":1}}],[\"进一步推导\",{\"1\":{\"99\":1}}],[\"进而引起系统崩溃\",{\"1\":{\"471\":1}}],[\"进而我们可以总结出来\",{\"1\":{\"304\":1}}],[\"进入了自定义网关过滤器mygatewayfilterfactory\",{\"1\":{\"504\":1}}],[\"进入\",{\"1\":{\"429\":1}}],[\"进入熔断状态\",{\"1\":{\"413\":1,\"414\":1,\"415\":1}}],[\"进入熔断状态判断依据\",{\"1\":{\"413\":1}}],[\"进入到\",{\"1\":{\"401\":1}}],[\"进行引用\",{\"1\":{\"885\":1}}],[\"进行读写分离\",{\"1\":{\"818\":1}}],[\"进行\",{\"1\":{\"818\":1}}],[\"进行数据同步的\",{\"1\":{\"820\":1}}],[\"进行数据获取\",{\"1\":{\"799\":1}}],[\"进行数据查找时\",{\"1\":{\"641\":1}}],[\"进行查询重写\",{\"1\":{\"628\":1}}],[\"进行填充\",{\"1\":{\"597\":1}}],[\"进行转移\",{\"1\":{\"529\":1}}],[\"进行熔断\",{\"1\":{\"476\":1}}],[\"进行配置\",{\"1\":{\"475\":1}}],[\"进行限流操作\",{\"1\":{\"409\":2}}],[\"进行交换\",{\"1\":{\"387\":1}}],[\"进行升序\",{\"1\":{\"364\":1,\"366\":1}}],[\"进行升序序\",{\"1\":{\"344\":1}}],[\"进行降序\",{\"1\":{\"362\":1,\"364\":1}}],[\"进行排序\",{\"1\":{\"354\":1,\"710\":1}}],[\"进行排序之后\",{\"1\":{\"165\":1}}],[\"进行反转\",{\"1\":{\"245\":1}}],[\"进行剪枝\",{\"1\":{\"213\":2}}],[\"进行遍历\",{\"1\":{\"207\":1}}],[\"进行判断前后俩个元素是否相等\",{\"1\":{\"205\":1}}],[\"进行回溯\",{\"1\":{\"187\":1,\"195\":2}}],[\"进行去重\",{\"1\":{\"179\":1,\"205\":1,\"207\":1}}],[\"进行递归\",{\"1\":{\"171\":1}}],[\"进行比较\",{\"1\":{\"141\":1,\"568\":1}}],[\"进行层序遍历\",{\"1\":{\"43\":1}}],[\"进行处理\",{\"1\":{\"7\":1,\"416\":1}}],[\"进阶\",{\"1\":{\"23\":1,\"32\":1,\"59\":1,\"67\":1,\"104\":1,\"145\":1,\"315\":1,\"336\":1,\"345\":1,\"347\":1,\"383\":1}}],[\"同步数据\",{\"1\":{\"819\":1}}],[\"同步update\",{\"1\":{\"618\":1}}],[\"同上\",{\"1\":{\"710\":1}}],[\"同no\",{\"1\":{\"618\":1}}],[\"同concat\",{\"1\":{\"552\":1}}],[\"同一返回结果\",{\"0\":{\"444\":1}}],[\"同一字母最多出现在一个片段中\",{\"1\":{\"367\":1}}],[\"同一列\",{\"1\":{\"217\":1}}],[\"同一行\",{\"1\":{\"217\":1}}],[\"同一树枝\",{\"1\":{\"211\":1}}],[\"同一层重复元素的判断\",{\"1\":{\"211\":1}}],[\"同一层\",{\"1\":{\"207\":2,\"211\":1}}],[\"同一层节点由\",{\"1\":{\"23\":1}}],[\"同一个用户的同一条数据\",{\"1\":{\"848\":1}}],[\"同一个表就会多出来几行\",{\"1\":{\"746\":1}}],[\"同一个表可以有多个唯一约束\",{\"1\":{\"615\":1}}],[\"同一个表中\",{\"1\":{\"583\":1,\"612\":1}}],[\"同一个库中\",{\"1\":{\"583\":1}}],[\"同一个mysql软件中\",{\"1\":{\"583\":1}}],[\"同一个\",{\"1\":{\"194\":1}}],[\"同一天\",{\"1\":{\"121\":1}}],[\"同时每个页面包含\",{\"1\":{\"861\":1}}],[\"同时请求到业务系统\",{\"1\":{\"848\":1}}],[\"同时触发成绩表中的\",{\"1\":{\"837\":1}}],[\"同时mysql也提供了安全的手动删除二进制文件的方法\",{\"1\":{\"809\":1}}],[\"同时以多个列的大小作为排序规则\",{\"1\":{\"652\":1}}],[\"同时却会降低更新表的速度\",{\"1\":{\"690\":1}}],[\"同时却会\",{\"1\":{\"642\":1}}],[\"同时也易于机器解析和生成\",{\"1\":{\"608\":1}}],[\"同时保留表的结构\",{\"1\":{\"589\":1}}],[\"同时保持非零元素的相对顺序\",{\"1\":{\"315\":1}}],[\"同时还要调用积分中心的服务为用户增加相应的积分\",{\"1\":{\"425\":1}}],[\"同时还满足\",{\"1\":{\"176\":1}}],[\"同时对\",{\"1\":{\"407\":1}}],[\"同时提供实时的监控功能\",{\"1\":{\"406\":1}}],[\"同时提供分布式的任务执行模型\",{\"1\":{\"399\":1}}],[\"同时要保证队列中的元素保持递减\",{\"1\":{\"334\":1}}],[\"同时将1清0\",{\"1\":{\"308\":1}}],[\"同时将\",{\"1\":{\"279\":1,\"356\":1}}],[\"同时仍保留空格和单词的初始顺序\",{\"1\":{\"246\":1}}],[\"同时被标记的就是都能够到达的坐标\",{\"1\":{\"234\":1}}],[\"同时移动指向较大数的指针\",{\"1\":{\"282\":1}}],[\"同时移动\",{\"1\":{\"177\":1}}],[\"同时删word1\",{\"1\":{\"153\":1}}],[\"同时\",{\"1\":{\"114\":1,\"119\":1,\"406\":1,\"510\":1,\"599\":1,\"642\":1,\"760\":1,\"819\":1}}],[\"同时给定最小边界low\",{\"1\":{\"69\":1}}],[\"同理求出状态3\",{\"1\":{\"124\":1}}],[\"同理\",{\"1\":{\"62\":1,\"70\":1,\"137\":1}}],[\"同理将左孩子放入栈中\",{\"1\":{\"6\":1}}],[\"同样如果系统宕机\",{\"1\":{\"753\":1}}],[\"同样的\",{\"1\":{\"660\":1,\"831\":1}}],[\"同样是符合题意的答案\",{\"1\":{\"260\":1}}],[\"同样是有俩种情况\",{\"1\":{\"92\":1}}],[\"同样\",{\"1\":{\"39\":1,\"570\":1}}],[\"同样我们也可以对以上代码进行改良\",{\"1\":{\"39\":1}}],[\"让mq自动重试\",{\"1\":{\"853\":1}}],[\"让\",{\"1\":{\"819\":1}}],[\"让不同的读请求按照策略均匀地分发到不同的从服务器上\",{\"1\":{\"819\":1}}],[\"让其他事务得以继续执行\",{\"1\":{\"786\":1}}],[\"让两者的分工更加明确\",{\"1\":{\"487\":1}}],[\"让编写web服务客户端变得非常容易\",{\"1\":{\"462\":1}}],[\"让通过的流量缓慢增加\",{\"1\":{\"411\":1}}],[\"让高个子在前面\",{\"1\":{\"362\":1}}],[\"让这个指针指向其下一个右侧节点\",{\"1\":{\"23\":1}}],[\"让我们先看看在二叉树上进行\",{\"1\":{\"12\":1}}],[\"完善的\",{\"1\":{\"406\":2}}],[\"完备的实时监控\",{\"1\":{\"406\":1}}],[\"完成主从服务器的\",{\"1\":{\"813\":1}}],[\"完成了查询优化后\",{\"1\":{\"635\":1}}],[\"完成\",{\"1\":{\"462\":1,\"725\":1}}],[\"完成数据清理即可\",{\"1\":{\"436\":1}}],[\"完成交换\",{\"1\":{\"386\":1}}],[\"完成第三条线\",{\"1\":{\"384\":1}}],[\"完成第二条线\",{\"1\":{\"384\":1}}],[\"完成第一条线\",{\"1\":{\"384\":1}}],[\"完整的访问方法如下\",{\"1\":{\"704\":1}}],[\"完整\",{\"1\":{\"279\":1}}],[\"完整代码\",{\"1\":{\"85\":1,\"87\":1,\"89\":1,\"91\":1,\"92\":1,\"95\":1,\"126\":1,\"128\":1,\"187\":1,\"190\":1,\"195\":1,\"197\":1,\"199\":1,\"201\":1,\"203\":1,\"207\":1,\"209\":1,\"213\":1,\"215\":1,\"217\":1,\"224\":1,\"348\":1,\"372\":1}}],[\"完整代码如下\",{\"1\":{\"60\":1}}],[\"完全展开的参数看起来更像标准的yaml配置\",{\"1\":{\"491\":1}}],[\"完全展开\",{\"1\":{\"491\":1}}],[\"完全垂直\",{\"1\":{\"363\":1}}],[\"完全平方数\",{\"1\":{\"108\":1}}],[\"完全背包中的物品可以无限使用\",{\"1\":{\"93\":1}}],[\"完全背包与01背包的区别\",{\"1\":{\"93\":1}}],[\"完全背包对付面试完全足够了\",{\"1\":{\"90\":1}}],[\"完全背包\",{\"0\":{\"93\":1},\"1\":{\"90\":2}}],[\"完全二叉树\",{\"1\":{\"0\":1,\"34\":3}}],[\"完美二叉树\",{\"1\":{\"23\":1}}],[\"mq消费者读取mq消息\",{\"1\":{\"852\":1}}],[\"mbr\",{\"1\":{\"823\":1}}],[\"mvcc可以解决\",{\"1\":{\"801\":1}}],[\"mvcc是通过\",{\"1\":{\"799\":1}}],[\"mvcc整体操作流程\",{\"0\":{\"799\":1}}],[\"mvcc机制中\",{\"1\":{\"796\":1}}],[\"mvcc实现原理之readview\",{\"0\":{\"795\":1}}],[\"mvcc在mysql\",{\"1\":{\"791\":1}}],[\"mvcc\",{\"0\":{\"789\":1},\"1\":{\"756\":1,\"765\":2,\"790\":2,\"793\":1,\"795\":1,\"801\":2}}],[\"m=3\",{\"1\":{\"660\":1}}],[\"m=整数位+小数位\",{\"1\":{\"600\":1}}],[\"m>2\",{\"1\":{\"660\":1}}],[\"mrg\",{\"1\":{\"635\":1}}],[\"m被称为精度\",{\"1\":{\"600\":1}}],[\"m的取值范围是\",{\"1\":{\"595\":1}}],[\"mgr\",{\"1\":{\"536\":4}}],[\"mm\",{\"1\":{\"444\":6}}],[\"multiversion\",{\"1\":{\"790\":1}}],[\"multiple\",{\"1\":{\"771\":1}}],[\"mutex\",{\"1\":{\"772\":1}}],[\"must\",{\"1\":{\"431\":3,\"617\":1,\"822\":1}}],[\"muc\",{\"1\":{\"212\":3}}],[\"ms\",{\"1\":{\"419\":2,\"503\":1,\"884\":1}}],[\"myi文件\",{\"1\":{\"654\":1}}],[\"myindex\",{\"1\":{\"637\":1}}],[\"myi\",{\"1\":{\"637\":1}}],[\"myisam中维护一个计数器\",{\"1\":{\"704\":1}}],[\"myisam表中只有一条记录\",{\"1\":{\"704\":1}}],[\"myisam适合适合用于非事务场景下\",{\"1\":{\"655\":1}}],[\"myisam索引原理\",{\"0\":{\"654\":1}}],[\"myisam索中的索引方案\",{\"0\":{\"653\":1}}],[\"myisam不需要维护额外的事务日志和事务控制\",{\"1\":{\"637\":1}}],[\"myisam提供了大量的特性\",{\"1\":{\"637\":1}}],[\"myisam引擎使用\",{\"1\":{\"653\":1}}],[\"myisam引擎\",{\"0\":{\"637\":1}}],[\"myisam只缓存索引\",{\"1\":{\"636\":1,\"655\":1}}],[\"myisam数据表\",{\"1\":{\"604\":1}}],[\"myisam\",{\"1\":{\"604\":1,\"635\":2,\"637\":1,\"654\":3,\"704\":1,\"729\":1}}],[\"myd文件\",{\"1\":{\"654\":1}}],[\"myd\",{\"1\":{\"637\":1}}],[\"mydata\",{\"1\":{\"454\":3,\"637\":1}}],[\"my\",{\"1\":{\"635\":1,\"809\":2}}],[\"my=atguigu\",{\"1\":{\"504\":1}}],[\"my=diamonds\",{\"1\":{\"497\":1}}],[\"mygatewayfilterfactory\",{\"1\":{\"504\":4}}],[\"myglobalfilter\",{\"1\":{\"503\":1}}],[\"mypath\",{\"1\":{\"502\":2}}],[\"mycookie\",{\"1\":{\"491\":1}}],[\"mycookievalue\",{\"1\":{\"491\":2}}],[\"mycircuitbreaker\",{\"1\":{\"477\":1}}],[\"mycircuitfallback就是服务降级后的兜底处理方法\",{\"1\":{\"477\":1}}],[\"mycircuitfallback\",{\"1\":{\"477\":3}}],[\"mycircuit\",{\"1\":{\"477\":3}}],[\"myroutepredicatefactory\",{\"1\":{\"497\":4}}],[\"myratelimit\",{\"1\":{\"482\":1}}],[\"myratelimitfallback\",{\"1\":{\"482\":2}}],[\"myretryer\",{\"1\":{\"467\":1}}],[\"myrequestoriginparser\",{\"1\":{\"418\":1}}],[\"mybulkheadthreadpool\",{\"1\":{\"481\":1}}],[\"mybulkheadpoolfallback\",{\"1\":{\"481\":2}}],[\"mybulkhead\",{\"1\":{\"480\":2,\"481\":1,\"482\":1}}],[\"mybulkheadfallback\",{\"1\":{\"480\":3}}],[\"mybatis3simple\",{\"1\":{\"442\":1}}],[\"mybatis<\",{\"1\":{\"432\":1,\"441\":1,\"442\":3,\"443\":1}}],[\"mybatis\",{\"1\":{\"432\":3,\"441\":4,\"442\":11,\"443\":2,\"452\":1}}],[\"mybatis和springboot整合\",{\"1\":{\"432\":1,\"443\":1}}],[\"mybatis一键生成代码\",{\"1\":{\"431\":1}}],[\"mylb\",{\"1\":{\"464\":4}}],[\"mytimeout\",{\"1\":{\"434\":2}}],[\"mysqlbin\",{\"1\":{\"823\":1}}],[\"mysqlbinlog命令路径\",{\"1\":{\"809\":1}}],[\"mysqlbinlog\",{\"1\":{\"809\":5,\"813\":1}}],[\"mysql复制是异步的且串行化的\",{\"1\":{\"820\":1}}],[\"mysql服务器会自动把变更的数据写入binlog中\",{\"1\":{\"853\":1}}],[\"mysql服务器层并没有实现行锁机制\",{\"1\":{\"774\":1}}],[\"mysql服务\",{\"1\":{\"809\":1}}],[\"mysql有不同类型的日志文件\",{\"1\":{\"805\":1}}],[\"mysql有多种表示日期和时间的数据类型\",{\"1\":{\"602\":1}}],[\"mysql采用checkpoint机制保证数据最终会被刷新到磁盘上\",{\"1\":{\"749\":1}}],[\"mysql根据这些操作所执\",{\"1\":{\"742\":1}}],[\"mysql需要为内层查询语句的査询结果\",{\"1\":{\"724\":1}}],[\"mysql很有可能寻求通过建立内部的临时表来执行查询\",{\"1\":{\"710\":1}}],[\"mysql可能会借助临时表来完成一些功能\",{\"1\":{\"710\":1}}],[\"mysql把这种在内存中或者磁盘上进行排序的方式统称为文件排序\",{\"1\":{\"710\":1}}],[\"mysql一般会为\",{\"1\":{\"710\":1}}],[\"mysql为每一个select关键字代表的小査询都定义了一个称之为\",{\"1\":{\"703\":1}}],[\"mysql提供了日志分析工具\",{\"1\":{\"699\":1}}],[\"mysqladmin\",{\"1\":{\"698\":2}}],[\"mysql的二进制文件可以配置自动删除\",{\"1\":{\"809\":1}}],[\"mysql的慢查询日志\",{\"1\":{\"697\":1}}],[\"mysql的索引包括普通索引\",{\"1\":{\"686\":1}}],[\"mysql的主键名总是primary\",{\"1\":{\"616\":1}}],[\"mysql事务日志\",{\"1\":{\"681\":1}}],[\"mysql数据库\",{\"1\":{\"697\":1}}],[\"mysql数据库驱动8\",{\"1\":{\"432\":1,\"441\":1,\"443\":1}}],[\"mysql数据结构选择的合理性\",{\"0\":{\"657\":1}}],[\"mysql>\",{\"1\":{\"643\":1,\"696\":2,\"701\":1,\"702\":1,\"744\":2,\"751\":1,\"767\":2,\"771\":6,\"806\":1,\"807\":1,\"809\":5,\"826\":1,\"832\":2}}],[\"mysql官方对索引的定义为\",{\"1\":{\"642\":1}}],[\"mysql从3\",{\"1\":{\"636\":1}}],[\"mysql内部维持着一些cache和buffer\",{\"1\":{\"630\":1}}],[\"mysql还\",{\"1\":{\"628\":1}}],[\"mysql支持多种方法在单个或多个列上创建索引\",{\"1\":{\"687\":1}}],[\"mysql支持一些变长的数据类型\",{\"1\":{\"678\":1}}],[\"mysql支持dml\",{\"1\":{\"627\":1}}],[\"mysql支持的浮点数类型\",{\"1\":{\"599\":1}}],[\"mysqldump备份默认是不包含存储过程\",{\"1\":{\"831\":1}}],[\"mysqldump\",{\"1\":{\"830\":1,\"831\":10}}],[\"mysqldumpslow\",{\"0\":{\"699\":1},\"1\":{\"699\":7}}],[\"mysqld\",{\"1\":{\"624\":1,\"635\":1,\"698\":1,\"806\":2,\"807\":3,\"809\":1,\"822\":1,\"823\":1}}],[\"mysql架构\",{\"0\":{\"623\":1}}],[\"mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式\",{\"1\":{\"823\":1}}],[\"mysql会自动加上\",{\"1\":{\"773\":1}}],[\"mysql会自动给每个页里加了两个记录\",{\"1\":{\"680\":1}}],[\"mysql会自动删除重复的成员\",{\"1\":{\"607\":1}}],[\"mysql会给唯一约束的列上默认创建一个唯一索引\",{\"1\":{\"615\":1}}],[\"mysql会抛出错误\",{\"1\":{\"607\":1}}],[\"mysql5\",{\"1\":{\"604\":1,\"619\":1,\"773\":1}}],[\"mysql4\",{\"1\":{\"604\":1}}],[\"mysql中可以用\",{\"1\":{\"830\":1}}],[\"mysql中也是一样的道理\",{\"1\":{\"641\":1}}],[\"mysql中提到了存储引擎的概念\",{\"1\":{\"635\":1}}],[\"mysql中的定点数类型只有\",{\"1\":{\"600\":1}}],[\"mysql中的数据类型\",{\"0\":{\"592\":1}}],[\"mysql中的流程处理函数主要包括if\",{\"1\":{\"559\":1}}],[\"mysql中\",{\"1\":{\"552\":1,\"603\":1,\"725\":1}}],[\"mysql就不知道去哪张表里面查了\",{\"1\":{\"533\":1}}],[\"mysql8\",{\"1\":{\"432\":1,\"442\":2,\"443\":1,\"452\":1,\"602\":1,\"634\":2,\"636\":1}}],[\"mysql\",{\"0\":{\"840\":1},\"1\":{\"428\":1,\"429\":3,\"431\":7,\"432\":2,\"441\":2,\"442\":3,\"443\":2,\"452\":2,\"508\":1,\"518\":2,\"599\":4,\"605\":1,\"618\":2,\"624\":1,\"625\":2,\"630\":1,\"631\":1,\"634\":3,\"635\":1,\"699\":5,\"702\":1,\"724\":1,\"725\":1,\"729\":1,\"800\":1,\"805\":1,\"806\":2,\"809\":5,\"811\":1,\"818\":1,\"822\":2,\"825\":1,\"826\":1,\"830\":1,\"832\":4,\"836\":1},\"2\":{\"515\":1,\"544\":1,\"567\":1,\"581\":1,\"591\":1,\"610\":1,\"622\":1,\"639\":1,\"664\":1,\"683\":1,\"692\":1,\"712\":1,\"735\":1,\"739\":1,\"759\":1,\"788\":1,\"803\":1,\"815\":1,\"829\":1,\"834\":1,\"839\":1,\"842\":1,\"855\":1}}],[\"myqueue\",{\"1\":{\"321\":10,\"323\":2}}],[\"memory数据表目前都使用固定长度的数据行存储\",{\"1\":{\"604\":1}}],[\"memory\",{\"1\":{\"604\":1,\"635\":1,\"704\":1}}],[\"mediumtext\",{\"1\":{\"605\":1}}],[\"mediumint\",{\"1\":{\"593\":1,\"595\":1,\"598\":1}}],[\"mediatype\",{\"1\":{\"422\":1,\"423\":1}}],[\"message\",{\"1\":{\"422\":2,\"444\":7}}],[\"meta\",{\"1\":{\"773\":1}}],[\"metadata\",{\"1\":{\"429\":1,\"770\":1}}],[\"method=get\",{\"1\":{\"496\":1}}],[\"methods\",{\"0\":{\"496\":1},\"1\":{\"496\":1}}],[\"method\",{\"1\":{\"416\":1,\"463\":4,\"481\":2,\"496\":1}}],[\"metrics\",{\"1\":{\"399\":1}}],[\"merge\",{\"1\":{\"296\":1,\"704\":3}}],[\"mergetrees\",{\"1\":{\"52\":3}}],[\"mdl\",{\"0\":{\"773\":1},\"1\":{\"770\":1,\"773\":3}}],[\"md5\",{\"1\":{\"650\":1,\"658\":1}}],[\"md\",{\"1\":{\"399\":1,\"475\":1,\"479\":1,\"482\":1,\"869\":1}}],[\"more\",{\"1\":{\"699\":1,\"882\":1}}],[\"mod\",{\"1\":{\"548\":1}}],[\"modules\",{\"1\":{\"475\":1,\"479\":1,\"482\":1}}],[\"modified\",{\"1\":{\"836\":2}}],[\"modified`\",{\"1\":{\"428\":5,\"431\":3}}],[\"modify\",{\"1\":{\"431\":3,\"588\":1,\"614\":1,\"615\":1,\"617\":3,\"620\":1}}],[\"mode对应的值修改为blue\",{\"1\":{\"499\":1}}],[\"modelversion>\",{\"1\":{\"441\":1}}],[\"mode\",{\"1\":{\"422\":2,\"429\":1,\"431\":6,\"432\":1,\"499\":1,\"599\":1,\"767\":1,\"771\":1,\"791\":1}}],[\"monday\",{\"1\":{\"555\":1}}],[\"monthname\",{\"1\":{\"555\":1}}],[\"month\",{\"1\":{\"521\":1,\"555\":1}}],[\"mongodb\",{\"1\":{\"510\":1}}],[\"money=100\",{\"1\":{\"435\":1}}],[\"money\",{\"1\":{\"431\":4,\"434\":9}}],[\"mono\",{\"1\":{\"503\":1}}],[\"mono<void>\",{\"1\":{\"503\":1,\"504\":1}}],[\"mono<serverresponse>\",{\"1\":{\"423\":1}}],[\"monotoneincreasingdigits\",{\"1\":{\"370\":1}}],[\"monitoring\",{\"1\":{\"405\":1}}],[\"movezeroes\",{\"1\":{\"317\":1}}],[\"move\",{\"1\":{\"226\":3,\"228\":3,\"230\":3,\"232\":3,\"234\":3}}],[\"m+1\",{\"1\":{\"304\":1}}],[\"m+n\",{\"1\":{\"304\":2}}],[\"mixed\",{\"1\":{\"823\":1}}],[\"mixed模式\",{\"1\":{\"823\":1}}],[\"micrometer<\",{\"1\":{\"486\":9}}],[\"micrometer\",{\"0\":{\"484\":1},\"1\":{\"484\":1,\"486\":18}}],[\"microservices\",{\"0\":{\"891\":1},\"1\":{\"405\":1}}],[\"mime\",{\"1\":{\"469\":1}}],[\"midindex++\",{\"1\":{\"291\":1,\"292\":1}}],[\"midindex\",{\"1\":{\"291\":2,\"292\":6,\"293\":2}}],[\"mid+1\",{\"1\":{\"275\":1}}],[\"mid出错\",{\"1\":{\"274\":1}}],[\"mid及mid左边的所有位置都不符合题意\",{\"1\":{\"273\":1}}],[\"mid\",{\"1\":{\"273\":21,\"274\":5,\"275\":6,\"276\":12,\"277\":14,\"552\":1}}],[\"middleindex+2\",{\"1\":{\"290\":1}}],[\"middleindex+1\",{\"1\":{\"290\":1}}],[\"middleindex\",{\"1\":{\"290\":7}}],[\"middle\",{\"1\":{\"270\":1,\"271\":28,\"767\":1,\"771\":1}}],[\"middle呢\",{\"1\":{\"270\":1}}],[\"minute\",{\"1\":{\"555\":1,\"557\":1}}],[\"minimumnumberofcalls\",{\"1\":{\"477\":1,\"478\":1}}],[\"minimum\",{\"1\":{\"476\":1}}],[\"minrequestamount\",{\"1\":{\"419\":1}}],[\"mincame\",{\"1\":{\"372\":2}}],[\"mincameracover\",{\"1\":{\"372\":2}}],[\"mincostclimbingstairs\",{\"1\":{\"83\":1}}],[\"minsubarraylen\",{\"1\":{\"286\":1}}],[\"mindistance\",{\"1\":{\"150\":1,\"152\":1}}],[\"mindepth\",{\"1\":{\"28\":1}}],[\"minprice\",{\"1\":{\"120\":5}}],[\"minvalue\",{\"1\":{\"56\":2}}],[\"min\",{\"1\":{\"22\":1,\"58\":1,\"60\":1,\"83\":1,\"107\":3,\"109\":2,\"152\":2,\"153\":1,\"254\":1,\"257\":10,\"259\":1,\"286\":1,\"348\":1,\"366\":1,\"429\":1,\"469\":1,\"562\":4,\"573\":1,\"574\":3,\"578\":3,\"680\":2,\"710\":2}}],[\"m\",{\"0\":{\"595\":1},\"1\":{\"84\":6,\"85\":6,\"100\":5,\"101\":5,\"193\":2,\"225\":2,\"227\":3,\"229\":3,\"230\":2,\"231\":3,\"232\":2,\"233\":4,\"303\":4,\"304\":7,\"305\":8,\"390\":3,\"401\":1,\"549\":1,\"552\":1,\"558\":3,\"595\":1,\"597\":4,\"599\":1,\"600\":2,\"601\":2,\"604\":3,\"605\":2,\"660\":1,\"678\":2,\"737\":2}}],[\"markdown\",{\"0\":{\"864\":1,\"865\":1,\"866\":1,\"867\":1},\"1\":{\"864\":2,\"865\":3,\"866\":1,\"867\":3,\"868\":2,\"869\":1,\"870\":1,\"883\":3,\"884\":1,\"885\":2,\"886\":2},\"2\":{\"881\":1}}],[\"mac地址\",{\"1\":{\"822\":1}}],[\"mac系统\",{\"1\":{\"807\":1}}],[\"master\",{\"1\":{\"809\":4,\"820\":5,\"822\":1,\"823\":1,\"826\":7}}],[\"mask值都是0\",{\"1\":{\"680\":1}}],[\"mask值为1\",{\"1\":{\"680\":1}}],[\"mask\",{\"1\":{\"680\":2}}],[\"maketime\",{\"1\":{\"557\":2}}],[\"makedate\",{\"1\":{\"557\":2}}],[\"may\",{\"1\":{\"429\":2}}],[\"manipulation\",{\"1\":{\"517\":1}}],[\"management\",{\"1\":{\"486\":1}}],[\"manager\",{\"1\":{\"426\":2,\"536\":2,\"573\":7}}],[\"many\",{\"1\":{\"423\":2,\"513\":3}}],[\"maven\",{\"1\":{\"402\":2,\"441\":6,\"442\":2,\"443\":1,\"446\":1,\"489\":1}}],[\"match\",{\"1\":{\"836\":1}}],[\"mat\",{\"1\":{\"303\":6,\"304\":5,\"305\":5}}],[\"matrix\",{\"1\":{\"261\":2,\"287\":1,\"297\":6,\"298\":5,\"299\":70,\"302\":5}}],[\"math\",{\"1\":{\"22\":1,\"37\":4,\"43\":1,\"58\":1,\"83\":1,\"87\":2,\"91\":2,\"92\":1,\"93\":2,\"95\":1,\"97\":1,\"101\":3,\"107\":1,\"109\":1,\"113\":4,\"115\":5,\"117\":3,\"120\":2,\"122\":3,\"124\":4,\"126\":2,\"128\":6,\"130\":3,\"133\":2,\"135\":1,\"139\":1,\"141\":1,\"143\":1,\"150\":1,\"152\":2,\"157\":2,\"228\":2,\"254\":1,\"259\":1,\"286\":1,\"296\":1,\"308\":2,\"348\":2,\"350\":3,\"352\":1,\"354\":2,\"360\":2,\"366\":1,\"368\":1}}],[\"main9527\",{\"1\":{\"489\":2}}],[\"mainopenfeign80\",{\"1\":{\"464\":2}}],[\"main80\",{\"1\":{\"446\":4}}],[\"main8001\",{\"1\":{\"443\":2}}],[\"main3377\",{\"1\":{\"403\":2}}],[\"main\",{\"1\":{\"91\":1,\"403\":1,\"432\":1,\"442\":6,\"443\":1,\"444\":1,\"446\":2,\"463\":1,\"464\":1,\"475\":1,\"479\":1,\"482\":1,\"489\":1}}],[\"mapping\",{\"1\":{\"432\":1,\"488\":2}}],[\"mappers\",{\"1\":{\"442\":1}}],[\"mapperscan\",{\"1\":{\"432\":2,\"443\":1}}],[\"mapperplugin\",{\"1\":{\"442\":1}}],[\"mapper4一键生成\",{\"0\":{\"442\":1}}],[\"mapper\",{\"1\":{\"432\":3,\"441\":2,\"442\":6,\"443\":4,\"452\":2}}],[\"mapper放到对应的文件夹\",{\"1\":{\"432\":1}}],[\"map<string\",{\"1\":{\"423\":1}}],[\"map用key代表数字\",{\"1\":{\"193\":1}}],[\"map中有直接返回\",{\"1\":{\"175\":1}}],[\"maptoint\",{\"1\":{\"168\":1,\"354\":1}}],[\"map\",{\"1\":{\"47\":3,\"49\":3,\"165\":4,\"175\":5,\"193\":25,\"422\":5,\"423\":4,\"424\":4,\"429\":1,\"432\":1,\"443\":1,\"452\":1}}],[\"maxwaitduration\",{\"1\":{\"480\":1}}],[\"maxconcurrentcalls\",{\"1\":{\"480\":1}}],[\"maxcount\",{\"1\":{\"60\":8}}],[\"maxdistance\",{\"1\":{\"368\":3}}],[\"maxdepth\",{\"1\":{\"26\":1}}],[\"maxslidingwindow\",{\"1\":{\"335\":1}}],[\"maxsubarray\",{\"1\":{\"143\":1,\"348\":1}}],[\"maxarea\",{\"1\":{\"228\":8}}],[\"maxareaofislandbfs\",{\"1\":{\"228\":1}}],[\"maxareaofisland\",{\"1\":{\"228\":1}}],[\"maxuncrossedlines\",{\"1\":{\"141\":1}}],[\"maxprofit\",{\"1\":{\"120\":6,\"122\":2,\"124\":1,\"126\":1,\"128\":1,\"130\":1}}],[\"max++\",{\"1\":{\"26\":1}}],[\"max\",{\"1\":{\"22\":1,\"26\":2,\"37\":2,\"43\":1,\"51\":4,\"58\":1,\"87\":2,\"91\":2,\"92\":1,\"93\":2,\"95\":3,\"97\":1,\"101\":3,\"107\":3,\"109\":1,\"113\":4,\"115\":5,\"117\":4,\"120\":5,\"122\":5,\"124\":8,\"126\":8,\"128\":10,\"130\":5,\"133\":3,\"135\":1,\"139\":1,\"141\":1,\"143\":1,\"150\":1,\"157\":2,\"228\":2,\"286\":2,\"296\":1,\"308\":2,\"348\":2,\"350\":3,\"352\":1,\"360\":2,\"368\":1,\"429\":2,\"481\":1,\"562\":4,\"564\":4,\"809\":2,\"823\":1}}],[\"maxvalue\",{\"1\":{\"22\":4}}],[\"没必要写成year\",{\"1\":{\"602\":1}}],[\"没开分组永远不用分组的配置\",{\"1\":{\"477\":1}}],[\"没这么简单\",{\"1\":{\"360\":1}}],[\"没遍历一个元素都要加入集合中去\",{\"1\":{\"203\":1}}],[\"没什么好说的\",{\"1\":{\"155\":1}}],[\"没有找到create相关语句\",{\"1\":{\"831\":1}}],[\"没有找到insert相关语句\",{\"1\":{\"831\":1}}],[\"没有找到删除的结点\",{\"1\":{\"68\":1}}],[\"没有附带条件或者并没有修改很多记录的\",{\"1\":{\"823\":1}}],[\"没有了global级别的设置\",{\"1\":{\"809\":1}}],[\"没有使用到mvcc\",{\"1\":{\"797\":2}}],[\"没有刷新到磁盘\",{\"1\":{\"742\":1}}],[\"没有开启慢查询日志\",{\"1\":{\"697\":1}}],[\"没有增加多少查询时间\",{\"1\":{\"696\":1}}],[\"没有刻意按照主键大小排序\",{\"1\":{\"654\":1}}],[\"没有任何错误或警\",{\"1\":{\"619\":1}}],[\"没有误差\",{\"1\":{\"600\":1}}],[\"没有部门的员工也会查询出来\",{\"1\":{\"541\":1}}],[\"没有部门的员工不会查询出来\",{\"1\":{\"541\":1}}],[\"没有部门\",{\"1\":{\"539\":1}}],[\"没有匹配的行时\",{\"1\":{\"537\":1}}],[\"没有权限访问该资源\",{\"1\":{\"444\":1}}],[\"没有固定规则但要求唯一\",{\"1\":{\"422\":1,\"489\":1}}],[\"没有交点\",{\"1\":{\"390\":1}}],[\"没有交易完成\",{\"1\":{\"119\":1,\"123\":1}}],[\"没有摄像头\",{\"1\":{\"372\":1}}],[\"没有发生重叠\",{\"1\":{\"366\":1}}],[\"没有限制\",{\"1\":{\"363\":1}}],[\"没有身高更高或者相同的人排在他前面\",{\"1\":{\"361\":2}}],[\"没有被包围\",{\"1\":{\"229\":1}}],[\"没有办法进行排序\",{\"1\":{\"218\":1}}],[\"没有\",{\"1\":{\"211\":1,\"689\":1}}],[\"没有有效的组合\",{\"1\":{\"189\":1}}],[\"没有其他符合的组合了\",{\"1\":{\"189\":2}}],[\"没有质因数\",{\"1\":{\"172\":1}}],[\"没有出现过就知道求到\",{\"1\":{\"170\":1}}],[\"没啥好分析的\",{\"1\":{\"22\":1}}],[\"没执行一次\",{\"1\":{\"12\":1}}],[\"8又新增两种支持的日志\",{\"1\":{\"805\":1}}],[\"8步骤的任意一步系统宕机\",{\"1\":{\"757\":1}}],[\"8字节\",{\"1\":{\"668\":1}}],[\"86\",{\"1\":{\"516\":1,\"835\":1}}],[\"866925800+08\",{\"1\":{\"492\":4}}],[\"8<\",{\"1\":{\"441\":1}}],[\"8002\",{\"1\":{\"459\":3,\"460\":4}}],[\"8001+\",{\"1\":{\"460\":1}}],[\"8001\",{\"1\":{\"443\":1,\"446\":1,\"452\":1,\"459\":3,\"460\":3,\"489\":1}}],[\"80\",{\"1\":{\"446\":1,\"451\":1,\"459\":1,\"464\":1,\"565\":1,\"587\":1}}],[\"8091\",{\"1\":{\"429\":1}}],[\"8080\",{\"1\":{\"407\":1,\"408\":1,\"420\":1,\"422\":1}}],[\"8719\",{\"1\":{\"408\":1,\"420\":1}}],[\"8401\",{\"1\":{\"408\":1,\"418\":2}}],[\"8f5e\",{\"1\":{\"404\":1}}],[\"83\",{\"1\":{\"402\":1}}],[\"8848\",{\"1\":{\"401\":1,\"402\":2,\"403\":2,\"404\":4,\"408\":1,\"419\":2,\"420\":1,\"422\":1,\"429\":2,\"432\":2}}],[\"8500\",{\"1\":{\"449\":1,\"450\":1,\"452\":1,\"464\":1,\"489\":1}}],[\"85948a4692e9\",{\"1\":{\"404\":1}}],[\"85\",{\"1\":{\"170\":1}}],[\"89\",{\"1\":{\"170\":2,\"516\":1,\"659\":1,\"835\":1}}],[\"82\",{\"1\":{\"169\":3,\"170\":1}}],[\"8\",{\"0\":{\"624\":1,\"625\":1,\"626\":1,\"631\":1,\"632\":1,\"634\":1,\"635\":1,\"636\":1,\"637\":1,\"656\":1,\"708\":1,\"722\":1,\"729\":1},\"1\":{\"19\":2,\"44\":1,\"61\":2,\"63\":5,\"73\":2,\"74\":1,\"96\":3,\"123\":1,\"129\":5,\"142\":1,\"166\":1,\"170\":1,\"178\":1,\"193\":2,\"194\":1,\"196\":1,\"197\":1,\"210\":1,\"216\":14,\"275\":5,\"287\":1,\"290\":1,\"294\":2,\"295\":2,\"297\":4,\"303\":2,\"345\":4,\"347\":1,\"355\":2,\"363\":3,\"364\":1,\"367\":1,\"390\":7,\"399\":5,\"422\":1,\"423\":2,\"428\":1,\"440\":1,\"441\":2,\"442\":1,\"595\":1,\"597\":1,\"602\":1,\"619\":1,\"630\":1,\"631\":1,\"661\":1,\"676\":4,\"689\":4,\"731\":1,\"757\":1,\"767\":1,\"776\":1,\"809\":2}}],[\"6中新特性\",{\"1\":{\"728\":1}}],[\"66\",{\"1\":{\"548\":2}}],[\"6次访问中当执行方法的失败率达到50\",{\"1\":{\"477\":1}}],[\"65535\",{\"1\":{\"598\":1}}],[\"65\",{\"1\":{\"434\":1}}],[\"6544bafb424a\",{\"1\":{\"440\":1}}],[\"654\",{\"1\":{\"72\":1}}],[\"64\",{\"1\":{\"428\":1}}],[\"6<\",{\"1\":{\"423\":2}}],[\"6处射出箭\",{\"1\":{\"363\":1}}],[\"6>3\",{\"1\":{\"334\":1}}],[\"62\",{\"1\":{\"169\":1}}],[\"68\",{\"1\":{\"169\":1}}],[\"6个回文子串\",{\"1\":{\"154\":1}}],[\"60+秒\",{\"1\":{\"556\":1}}],[\"60s\",{\"1\":{\"435\":2}}],[\"600\",{\"1\":{\"100\":1}}],[\"60\",{\"1\":{\"65\":2,\"189\":1,\"419\":1}}],[\"6\",{\"0\":{\"419\":1,\"446\":1,\"454\":1,\"488\":1,\"489\":1,\"490\":1,\"491\":1,\"497\":1,\"498\":1,\"504\":1,\"593\":1,\"594\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":2,\"604\":2,\"605\":2,\"606\":2,\"607\":2,\"608\":2,\"619\":1,\"653\":1,\"654\":1,\"673\":1,\"706\":1,\"720\":1,\"727\":1,\"747\":1,\"748\":1,\"754\":1,\"801\":1},\"1\":{\"19\":4,\"23\":2,\"27\":1,\"30\":2,\"34\":2,\"42\":1,\"50\":4,\"55\":1,\"57\":1,\"61\":2,\"63\":5,\"67\":6,\"73\":1,\"74\":1,\"82\":3,\"84\":1,\"117\":2,\"119\":5,\"121\":4,\"123\":3,\"125\":4,\"126\":1,\"129\":1,\"132\":2,\"142\":2,\"154\":1,\"172\":2,\"174\":2,\"189\":2,\"193\":2,\"194\":1,\"196\":3,\"197\":3,\"206\":6,\"208\":1,\"216\":14,\"227\":1,\"233\":1,\"240\":2,\"255\":1,\"257\":7,\"273\":3,\"275\":1,\"276\":5,\"277\":8,\"287\":1,\"294\":4,\"297\":4,\"303\":2,\"309\":1,\"330\":6,\"333\":9,\"334\":5,\"345\":5,\"347\":2,\"353\":1,\"355\":2,\"361\":6,\"362\":6,\"363\":3,\"364\":1,\"376\":3,\"390\":2,\"399\":1,\"412\":1,\"421\":1,\"422\":1,\"424\":1,\"428\":2,\"431\":6,\"477\":2,\"481\":1,\"486\":1,\"541\":1,\"565\":1,\"618\":1,\"686\":1,\"689\":1,\"690\":1,\"757\":1,\"771\":1,\"809\":1,\"824\":1}}],[\"每重试一次该字段值+1\",{\"1\":{\"851\":1}}],[\"每台虚拟机上需要安装好mysql\",{\"1\":{\"822\":1}}],[\"每条undo日志也都有一个\",{\"1\":{\"794\":1}}],[\"每条命令以\",{\"1\":{\"518\":1}}],[\"每当我们要对一条记录做改动\",{\"1\":{\"755\":1}}],[\"每当我们插入一条记录\",{\"1\":{\"670\":1}}],[\"每隔1\",{\"1\":{\"753\":1}}],[\"每隔俩个结点就会放一个监控\",{\"1\":{\"372\":1}}],[\"每张表有多少行被优化器查询\",{\"1\":{\"700\":1}}],[\"每访问一次节点就需要进行一次磁盘\",{\"1\":{\"660\":1}}],[\"每建立一个索引都要为它建立一棵b+树\",{\"1\":{\"656\":1}}],[\"每\",{\"1\":{\"598\":1}}],[\"每行返回一个结果\",{\"1\":{\"545\":1}}],[\"每行的第一个元素\",{\"1\":{\"311\":1}}],[\"每1s处理一次\",{\"1\":{\"411\":1}}],[\"每俩个结点的操作是一样的\",{\"1\":{\"386\":1}}],[\"每位顾客只买一杯柠檬水\",{\"1\":{\"357\":1}}],[\"每计数至\",{\"1\":{\"252\":1}}],[\"每遍历一个元素\",{\"1\":{\"203\":2}}],[\"每遍历一个元素都要加入到集合中\",{\"1\":{\"203\":1}}],[\"每进行一次递归都要进行一次回溯\",{\"1\":{\"187\":1}}],[\"每进行一次入栈\",{\"1\":{\"39\":1}}],[\"每步找到最优解\",{\"1\":{\"344\":1}}],[\"每步\",{\"1\":{\"149\":1}}],[\"每比较一次将\",{\"1\":{\"146\":1}}],[\"每笔交易你只需要为支付一次手续费\",{\"1\":{\"129\":1}}],[\"每天与最低价格的利润\",{\"1\":{\"120\":1}}],[\"每栋房子有且只有一个\",{\"1\":{\"116\":1}}],[\"每间房内都藏有一定的现金\",{\"1\":{\"112\":1,\"114\":1}}],[\"每种物品的个数不确定\",{\"1\":{\"90\":1}}],[\"每种物品有无限个\",{\"1\":{\"90\":1}}],[\"每种物品只有一个\",{\"1\":{\"90\":1}}],[\"每种结果都等于\",{\"1\":{\"85\":1}}],[\"每次对记录进行改动\",{\"1\":{\"794\":1}}],[\"每次对某条聚簇索引记录进行改动时\",{\"1\":{\"794\":1}}],[\"每次对表中的数据进行\",{\"1\":{\"656\":1}}],[\"每次一个事务对某条聚簇索引记录进行改动时\",{\"1\":{\"794\":1}}],[\"每次去拿数据的时候都认为别人会修改\",{\"1\":{\"781\":1}}],[\"每次锁定的数据范围越小越好\",{\"1\":{\"768\":1}}],[\"每次都传入子查询进行查\",{\"1\":{\"570\":1}}],[\"每次都从\",{\"1\":{\"254\":1}}],[\"每次服务重启动后rest接口计数从\",{\"1\":{\"460\":1}}],[\"每次启动都会重新生成规则\",{\"1\":{\"423\":1}}],[\"每次交换完\",{\"1\":{\"387\":1}}],[\"每次只记录波峰或波谷\",{\"1\":{\"346\":1}}],[\"每次拿最大的就是局部最优\",{\"1\":{\"342\":1}}],[\"每次移动窗口\",{\"1\":{\"334\":1}}],[\"每次覆盖完\",{\"1\":{\"313\":1}}],[\"每次旋转有什么规律\",{\"1\":{\"298\":1}}],[\"每次循环的开始点\",{\"1\":{\"289\":1}}],[\"每次循环左子树\",{\"1\":{\"49\":1}}],[\"每次向下搜索都是递归的过程\",{\"1\":{\"222\":1}}],[\"每次放置皇后前\",{\"1\":{\"215\":1}}],[\"每次横向遍历时\",{\"1\":{\"190\":1,\"191\":1}}],[\"每次你可以爬\",{\"1\":{\"80\":1}}],[\"每次入栈都要伴随着一次回溯\",{\"1\":{\"45\":1}}],[\"每次递归的元素为\",{\"1\":{\"33\":1}}],[\"每个事务都已经持有锁并且申请新的锁\",{\"1\":{\"786\":1}}],[\"每个层级的锁数量是有限制的\",{\"1\":{\"779\":1}}],[\"每个员工有员工编号\",{\"1\":{\"737\":1}}],[\"每个部门有部门编号\",{\"1\":{\"737\":1}}],[\"每个select关键字代表着一个小的査询语句\",{\"1\":{\"703\":1}}],[\"每个目录项并没有关联起来\",{\"1\":{\"645\":1}}],[\"每个约束可约束多列数据\",{\"1\":{\"613\":1}}],[\"每个约束只约束一列\",{\"1\":{\"613\":1}}],[\"每个汉字3字\",{\"1\":{\"604\":1}}],[\"每个步骤都会产生一个\",{\"1\":{\"565\":1}}],[\"每个表都有一个名字\",{\"1\":{\"511\":1}}],[\"每个滑动窗口周期\",{\"1\":{\"477\":1,\"478\":1}}],[\"每个依赖关系在某些时候将不可避免地失败\",{\"1\":{\"471\":1}}],[\"每个库中增加\",{\"1\":{\"431\":1}}],[\"每个字母的最远距离\",{\"1\":{\"368\":1}}],[\"每个字母最多出现在一个片段中\",{\"1\":{\"367\":1}}],[\"每个气球需要射出一支箭\",{\"1\":{\"363\":1}}],[\"每个\",{\"1\":{\"361\":1,\"820\":3,\"886\":1}}],[\"每个孩子至少分配到\",{\"1\":{\"359\":1}}],[\"每个孩子最多只能给一块饼干\",{\"1\":{\"343\":1}}],[\"每个操作数\",{\"1\":{\"330\":1}}],[\"每个右括号都有一个对应的相同类型的左括号\",{\"1\":{\"324\":1}}],[\"每个数是它左上方和右上方的数的和\",{\"1\":{\"309\":1}}],[\"每个数字的平方\",{\"1\":{\"281\":1}}],[\"每个数字\",{\"1\":{\"189\":1}}],[\"每个数字只能属于一条连线\",{\"1\":{\"140\":1}}],[\"每个元素\",{\"1\":{\"351\":1}}],[\"每个元素的行和列的变化规律\",{\"1\":{\"304\":1}}],[\"每个元素长度为1\",{\"1\":{\"133\":1}}],[\"每个单词后边增加空格\",{\"1\":{\"245\":1}}],[\"每个整数位于\",{\"1\":{\"200\":1}}],[\"每个物品分类讨论的标准是\",{\"1\":{\"101\":1}}],[\"每个值都是需要重复使用的\",{\"1\":{\"92\":1}}],[\"每个节点在被访问时就被标记为已访问\",{\"1\":{\"222\":1}}],[\"每个节点的值都是\",{\"1\":{\"371\":1}}],[\"每个节点的值介于\",{\"1\":{\"73\":1}}],[\"每个节点的左右两个子树的高度差的绝对值不超过\",{\"1\":{\"71\":1}}],[\"每个节点\",{\"1\":{\"37\":1}}],[\"每个父节点都有两个子节点\",{\"1\":{\"23\":1}}],[\"每组子节点都由\",{\"1\":{\"19\":1}}],[\"每一条会修改数据的\",{\"1\":{\"823\":1}}],[\"每一张表都对应着执行计划输出中的一条记录\",{\"1\":{\"703\":1}}],[\"每一棵b+树的每一个节点都是一个数据页\",{\"1\":{\"656\":1}}],[\"每一箭我们都从\",{\"1\":{\"364\":1}}],[\"每一杯柠檬水的售价为\",{\"1\":{\"357\":1}}],[\"每一步的最优解是什么\",{\"1\":{\"344\":1}}],[\"每一行\",{\"1\":{\"311\":1}}],[\"每一行的首元素和尾元素都是1\",{\"1\":{\"310\":1}}],[\"每一边都留下最后一个元素\",{\"1\":{\"288\":1}}],[\"每一种模式的处理方式不同\",{\"1\":{\"772\":1}}],[\"每一种解法包含一个不同的\",{\"1\":{\"214\":1}}],[\"每一种遍历都可以用递归和迭代俩种方法来实现\",{\"1\":{\"0\":1}}],[\"每一段中不能超过255\",{\"1\":{\"201\":2}}],[\"每一段中不能含有非数字\",{\"1\":{\"201\":2}}],[\"每一段起始不能为0\",{\"1\":{\"201\":2}}],[\"每一段不能超过255\",{\"1\":{\"201\":1}}],[\"每一段不能为非数字\",{\"1\":{\"201\":1}}],[\"每一段不能以0开头\",{\"1\":{\"201\":1}}],[\"每一次调用做了什么\",{\"1\":{\"386\":2}}],[\"每一次循环结束\",{\"1\":{\"289\":1}}],[\"每一次将该数替换为它每个位置上的数字的平方和\",{\"1\":{\"169\":1}}],[\"每一次递归结束说明找到了一条路径\",{\"1\":{\"224\":1}}],[\"每一次递归\",{\"1\":{\"39\":1}}],[\"每一个页都有一个单独的页号\",{\"1\":{\"668\":1}}],[\"每一个索引还要占一定的物理空间\",{\"1\":{\"642\":1}}],[\"每一个连接从线程池中获取线程\",{\"1\":{\"625\":1}}],[\"每一个前段请求都会形成一条复杂的分布式服务调用链路\",{\"1\":{\"483\":1}}],[\"每一个都要自己去\",{\"1\":{\"462\":1}}],[\"每一个子问题的处理方式都一样\",{\"1\":{\"386\":1}}],[\"每一个元素都是左上方与右上方的和\",{\"1\":{\"311\":1}}],[\"每一个元素的和都是它左上方元素和右上方元素的和\",{\"1\":{\"310\":1}}],[\"每一个旋转之后的位置就是下一个要旋转的位置\",{\"1\":{\"299\":1}}],[\"每一个i\",{\"1\":{\"133\":1}}],[\"每一个完全平方数可以看做是物品\",{\"1\":{\"109\":1}}],[\"每一回合\",{\"1\":{\"96\":1}}],[\"每一层循环中做的事有\",{\"1\":{\"346\":1}}],[\"每一层其实就是每次递归进行的\",{\"1\":{\"205\":1}}],[\"每一层累加完求平均值即可\",{\"1\":{\"18\":1}}],[\"每一层的最后一个元素放入结果集中即可\",{\"1\":{\"16\":1}}],[\"每一层的元素加集合\",{\"1\":{\"12\":1}}],[\"树节点\",{\"1\":{\"667\":1}}],[\"树\",{\"1\":{\"658\":1}}],[\"树枝\",{\"1\":{\"197\":1,\"207\":2}}],[\"树中的所有值\",{\"1\":{\"73\":1}}],[\"树中的节点数介于\",{\"1\":{\"73\":1}}],[\"树中的节点数将在\",{\"1\":{\"65\":1}}],[\"树中的节点数在范围\",{\"1\":{\"36\":1}}],[\"树中每个节点的值都是\",{\"1\":{\"69\":1}}],[\"树中任意两不同节点值之间的最小差值\",{\"1\":{\"57\":1}}],[\"树中存在两条根节点到叶子节点的路径\",{\"1\":{\"44\":1}}],[\"树中节点孩子的数量就是集合的大小\",{\"1\":{\"185\":1}}],[\"树中节点的数目在范围\",{\"1\":{\"38\":1,\"44\":1,\"59\":1}}],[\"树中节点的数目范围是\",{\"1\":{\"34\":1,\"57\":1}}],[\"树中节点的数量在\",{\"1\":{\"23\":1,\"25\":1}}],[\"树中节点数在范围\",{\"1\":{\"69\":1}}],[\"树中节点数目范围在\",{\"1\":{\"30\":1,\"55\":1}}],[\"树中节点数目在范围\",{\"1\":{\"11\":1,\"13\":1,\"32\":1,\"61\":1}}],[\"树中节点数的范围在\",{\"1\":{\"27\":1}}],[\"树中节点数量在\",{\"1\":{\"17\":1}}],[\"树的中间结点不存储数据\",{\"1\":{\"662\":1}}],[\"树的结构如下图所示\",{\"1\":{\"661\":1}}],[\"树的英文是\",{\"1\":{\"661\":1}}],[\"树的高度就会越矮\",{\"1\":{\"662\":1}}],[\"树的高度越低\",{\"1\":{\"648\":1}}],[\"树的高度\",{\"1\":{\"187\":1}}],[\"树的高度不会超过\",{\"1\":{\"19\":1}}],[\"树的节点数在\",{\"1\":{\"116\":1}}],[\"树的节点总数在\",{\"1\":{\"19\":1}}],[\"树的根节点\",{\"1\":{\"73\":1}}],[\"树的序列化输入是用层序遍历\",{\"1\":{\"19\":1}}],[\"叉树\",{\"1\":{\"19\":1,\"660\":1}}],[\"以外\",{\"1\":{\"835\":1}}],[\"以基本的事务为单位\",{\"1\":{\"812\":1}}],[\"以此实现非锁定读取\",{\"1\":{\"756\":1}}],[\"以此调整left和right\",{\"1\":{\"277\":1}}],[\"以上情况出现\",{\"1\":{\"755\":1}}],[\"以上面的sql为例\",{\"1\":{\"728\":1}}],[\"以内\",{\"1\":{\"726\":1}}],[\"以内的答案可以被接受\",{\"1\":{\"17\":1}}],[\"以提高查询效率\",{\"1\":{\"725\":1}}],[\"以提高数据查询的效\",{\"1\":{\"540\":1}}],[\"以mysql规定explain语句输出的每条记录都对应着某个单表的访问方法\",{\"1\":{\"701\":1}}],[\"以至于一个数据页不足以存放所有的目录项记录\",{\"1\":{\"646\":1}}],[\"以后sql语句的传递和处理就是基于这个结构的\",{\"1\":{\"628\":1}}],[\"以unix时间戳的形式返回当前时间\",{\"1\":{\"554\":1}}],[\"以便\",{\"1\":{\"864\":1}}],[\"以便在数据库发生崩溃时恢复未提交的事务\",{\"1\":{\"811\":1}}],[\"以便在发现错误或达到某种条件时重新尝试其他路径\",{\"1\":{\"183\":1}}],[\"以便于用户理解\",{\"1\":{\"509\":1}}],[\"以host为name\",{\"1\":{\"493\":1}}],[\"以微服务注册进consul或nacos服务列表内\",{\"1\":{\"489\":1}}],[\"以百分比的方式配置\",{\"1\":{\"476\":1}}],[\"以百分比配置失败率峰值\",{\"1\":{\"476\":1}}],[\"以管理员身份运行\",{\"1\":{\"454\":1}}],[\"以管理员身份启动\",{\"1\":{\"454\":1}}],[\"以fallback为准\",{\"1\":{\"416\":1}}],[\"以下是undo+redo事务的简化过程假设有2个数值\",{\"1\":{\"757\":1}}],[\"以下的版本\",{\"1\":{\"634\":1}}],[\"以下三个表示匹配在指定日期之后\",{\"1\":{\"492\":1}}],[\"以下为详细的搭建流程\",{\"1\":{\"440\":1}}],[\"以下为例说明\",{\"1\":{\"411\":1}}],[\"以下标i结尾的字符串s的回文子串个数为\",{\"1\":{\"155\":1}}],[\"以下标\",{\"1\":{\"152\":2}}],[\"以避免服务被瞬时的高并发流量击垮\",{\"1\":{\"409\":1}}],[\"以这种方式修改数组后\",{\"1\":{\"353\":1}}],[\"以这种方法绘制线条\",{\"1\":{\"140\":1}}],[\"以矩阵的四个顶点为例\",{\"1\":{\"299\":1}}],[\"以例二为例\",{\"1\":{\"298\":1}}],[\"以数组\",{\"1\":{\"294\":1}}],[\"以数组的形式返回每一层节点的平均值\",{\"1\":{\"17\":1}}],[\"以长度为\",{\"1\":{\"240\":1}}],[\"以\",{\"1\":{\"141\":1,\"143\":1,\"403\":1,\"493\":1,\"632\":1,\"666\":1,\"809\":3}}],[\"以nums1\",{\"1\":{\"137\":1}}],[\"以及点播恢复等操作\",{\"1\":{\"811\":1}}],[\"以及服务器遇到故障时数据的无损失恢复\",{\"1\":{\"805\":1}}],[\"以及连接发送给数据库服务器的所有指令\",{\"1\":{\"805\":1}}],[\"以及\",{\"1\":{\"273\":2}}],[\"以及一个整数\",{\"1\":{\"106\":1}}],[\"以及下标的含义\",{\"1\":{\"77\":1,\"79\":1,\"81\":1,\"83\":1,\"85\":1}}],[\"以最大值为根结点\",{\"1\":{\"51\":1}}],[\"以该结点为根节点的二叉树是平衡二叉树则返回最大\",{\"1\":{\"37\":1}}],[\"以指向其下一个右侧节点\",{\"1\":{\"23\":1}}],[\"fk\",{\"1\":{\"687\":1}}],[\"free\",{\"0\":{\"670\":1},\"1\":{\"667\":1}}],[\"frm\",{\"1\":{\"636\":1,\"637\":1}}],[\"from就是调用sql\",{\"1\":{\"627\":1}}],[\"fromrunnable\",{\"1\":{\"503\":1}}],[\"fromvalue\",{\"1\":{\"423\":1}}],[\"fromobject\",{\"1\":{\"422\":1}}],[\"from\",{\"1\":{\"321\":1,\"431\":3,\"440\":1,\"520\":5,\"521\":1,\"522\":3,\"523\":1,\"524\":1,\"525\":1,\"529\":1,\"533\":5,\"534\":1,\"536\":1,\"538\":2,\"539\":2,\"540\":2,\"541\":9,\"542\":2,\"548\":2,\"552\":3,\"554\":2,\"555\":2,\"557\":3,\"558\":3,\"559\":1,\"562\":5,\"563\":2,\"564\":2,\"565\":3,\"569\":5,\"573\":7,\"574\":2,\"575\":2,\"578\":13,\"579\":10,\"587\":2,\"607\":1,\"608\":1,\"613\":1,\"615\":2,\"618\":2,\"651\":1,\"687\":1,\"689\":1,\"696\":2,\"701\":1,\"702\":1,\"704\":11,\"705\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":17,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"726\":4,\"728\":1,\"729\":4,\"767\":1,\"771\":4,\"777\":1,\"791\":4,\"800\":2,\"809\":2}}],[\"fromi\",{\"1\":{\"212\":4}}],[\"frontmatter\",{\"1\":{\"858\":1,\"861\":1,\"866\":3,\"883\":1,\"884\":1}}],[\"front\",{\"1\":{\"256\":2,\"321\":1}}],[\"f5\",{\"1\":{\"595\":1}}],[\"f5等\",{\"1\":{\"457\":1}}],[\"f4\",{\"1\":{\"595\":1}}],[\"f3\",{\"1\":{\"595\":1}}],[\"fmt\",{\"1\":{\"558\":4}}],[\"f2\",{\"1\":{\"551\":1,\"595\":1}}],[\"f1\",{\"1\":{\"551\":1,\"595\":1}}],[\"f1=1\",{\"1\":{\"79\":1}}],[\"fun\",{\"1\":{\"831\":1}}],[\"function\",{\"1\":{\"422\":2,\"488\":1,\"563\":1,\"809\":1,\"823\":1}}],[\"fulltext\",{\"1\":{\"687\":4,\"704\":2}}],[\"full\",{\"1\":{\"470\":2}}],[\"federated\",{\"1\":{\"635\":1}}],[\"fetch\",{\"1\":{\"499\":4}}],[\"feignservice\",{\"1\":{\"470\":1}}],[\"feignloggerlevel\",{\"1\":{\"470\":1}}],[\"feign默认配置是不走重试策略的\",{\"1\":{\"467\":1}}],[\"feignconfig\",{\"1\":{\"467\":1}}],[\"feignclient注解的完整带包名的接口名+debug\",{\"1\":{\"470\":1}}],[\"feignclient\",{\"1\":{\"420\":1,\"431\":2,\"462\":1,\"463\":2,\"464\":3}}],[\"feign\",{\"1\":{\"420\":1,\"462\":1,\"464\":4,\"468\":1,\"470\":2,\"477\":4,\"480\":1,\"481\":1,\"482\":1,\"486\":4}}],[\"fee\",{\"1\":{\"129\":4,\"130\":3}}],[\"flush\",{\"1\":{\"698\":2,\"753\":1,\"785\":1,\"825\":1}}],[\"float等数据类型\",{\"1\":{\"614\":1}}],[\"float\",{\"1\":{\"599\":8}}],[\"floor\",{\"1\":{\"548\":1}}],[\"flow热点规则\",{\"1\":{\"419\":1}}],[\"flow流量控制规则\",{\"1\":{\"419\":1}}],[\"flowlimitcontroller\",{\"1\":{\"410\":1}}],[\"flowlimitservice\",{\"1\":{\"410\":5}}],[\"flow\",{\"1\":{\"405\":1,\"419\":1}}],[\"flat\",{\"1\":{\"442\":1}}],[\"flag\",{\"1\":{\"346\":7}}],[\"fatal\",{\"1\":{\"822\":1}}],[\"failureratethreshold\",{\"1\":{\"477\":1,\"478\":1}}],[\"failure\",{\"1\":{\"476\":1}}],[\"failed\",{\"1\":{\"444\":1,\"742\":1}}],[\"fail\",{\"1\":{\"420\":1,\"444\":1,\"445\":1}}],[\"fallbackmethod\",{\"1\":{\"477\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"fallbackmethod兜底方法\",{\"1\":{\"477\":1}}],[\"fallback服务降级o\",{\"1\":{\"420\":1}}],[\"fallback服务降级的情况\",{\"1\":{\"420\":1}}],[\"fallbackclass\",{\"1\":{\"416\":3}}],[\"fallback\",{\"1\":{\"416\":5,\"420\":6,\"422\":2}}],[\"fallback函数可以针对所\",{\"1\":{\"416\":1}}],[\"false\",{\"1\":{\"32\":1,\"33\":5,\"36\":1,\"44\":3,\"45\":3,\"55\":1,\"56\":2,\"94\":1,\"95\":2,\"110\":1,\"145\":1,\"161\":1,\"163\":3,\"169\":2,\"171\":1,\"172\":2,\"173\":1,\"199\":2,\"201\":8,\"211\":7,\"213\":4,\"215\":2,\"217\":5,\"261\":1,\"262\":1,\"266\":2,\"274\":1,\"321\":3,\"324\":1,\"326\":5,\"349\":2,\"350\":3,\"357\":3,\"358\":1,\"410\":1,\"417\":2,\"419\":1,\"497\":2,\"589\":1,\"763\":2}}],[\"fastjson2<\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"fastjson2\",{\"1\":{\"432\":1,\"441\":3,\"443\":1,\"446\":1}}],[\"fast++\",{\"1\":{\"280\":1}}],[\"fast\",{\"1\":{\"279\":5,\"280\":5}}],[\"found\",{\"1\":{\"889\":1}}],[\"foursum\",{\"1\":{\"179\":1}}],[\"force\",{\"1\":{\"836\":1}}],[\"forced\",{\"1\":{\"475\":1}}],[\"form\",{\"1\":{\"737\":1}}],[\"format=row\",{\"1\":{\"823\":1}}],[\"format=statement\",{\"1\":{\"823\":2}}],[\"format=compact\",{\"1\":{\"676\":1}}],[\"format=行格式名称\",{\"1\":{\"676\":2}}],[\"format函数中date\",{\"1\":{\"558\":1}}],[\"format\",{\"1\":{\"444\":1,\"452\":1,\"558\":4,\"643\":1,\"675\":1}}],[\"foreign\",{\"1\":{\"613\":1,\"618\":6,\"687\":1}}],[\"foreach\",{\"1\":{\"165\":1,\"424\":1}}],[\"for循环从0开始\",{\"1\":{\"209\":1}}],[\"for循环就是对\",{\"1\":{\"207\":1}}],[\"for循环就是横向遍历\",{\"1\":{\"187\":1}}],[\"for循环\",{\"1\":{\"205\":1}}],[\"for循环不在以\",{\"1\":{\"193\":1}}],[\"for循环里\",{\"1\":{\"193\":1}}],[\"for循环可以理解是横向遍历\",{\"1\":{\"185\":1}}],[\"for\",{\"1\":{\"12\":2,\"14\":1,\"16\":2,\"18\":2,\"20\":2,\"22\":2,\"24\":2,\"26\":2,\"28\":2,\"31\":2,\"35\":2,\"37\":1,\"43\":1,\"47\":1,\"49\":1,\"51\":1,\"56\":1,\"60\":1,\"79\":1,\"81\":2,\"83\":1,\"85\":4,\"87\":2,\"89\":2,\"91\":5,\"92\":4,\"93\":4,\"95\":2,\"97\":2,\"99\":3,\"101\":4,\"103\":6,\"105\":2,\"107\":2,\"109\":2,\"111\":2,\"113\":1,\"115\":3,\"117\":1,\"120\":2,\"122\":2,\"124\":1,\"126\":5,\"128\":1,\"130\":1,\"133\":2,\"135\":1,\"137\":4,\"139\":2,\"141\":2,\"143\":1,\"146\":2,\"148\":3,\"150\":2,\"152\":6,\"155\":2,\"157\":4,\"163\":2,\"165\":1,\"168\":2,\"175\":3,\"177\":3,\"179\":2,\"185\":2,\"187\":6,\"188\":2,\"190\":2,\"191\":1,\"193\":2,\"195\":2,\"197\":1,\"199\":5,\"201\":4,\"203\":2,\"205\":1,\"207\":2,\"209\":3,\"211\":1,\"213\":1,\"215\":10,\"217\":16,\"222\":1,\"224\":2,\"226\":5,\"228\":5,\"230\":9,\"232\":9,\"234\":5,\"248\":1,\"254\":1,\"259\":1,\"262\":2,\"273\":2,\"275\":2,\"278\":1,\"280\":2,\"283\":1,\"285\":1,\"286\":1,\"289\":4,\"293\":2,\"296\":1,\"298\":4,\"299\":2,\"302\":4,\"305\":1,\"308\":1,\"311\":2,\"312\":1,\"326\":1,\"329\":1,\"332\":1,\"335\":1,\"338\":3,\"344\":1,\"346\":1,\"348\":1,\"350\":3,\"352\":1,\"354\":1,\"356\":1,\"358\":1,\"360\":4,\"362\":1,\"364\":2,\"366\":1,\"368\":2,\"370\":2,\"384\":3,\"405\":1,\"423\":1,\"429\":1,\"431\":6,\"444\":1,\"452\":1,\"464\":1,\"606\":1,\"617\":1,\"625\":1,\"767\":3,\"771\":3,\"777\":1,\"791\":1,\"822\":1}}],[\"f\",{\"1\":{\"78\":16,\"193\":2}}],[\"firewalld\",{\"1\":{\"824\":1}}],[\"firstname\",{\"1\":{\"521\":1}}],[\"first\",{\"1\":{\"520\":1,\"521\":1,\"883\":1}}],[\"firstbadversion\",{\"1\":{\"274\":1}}],[\"field\",{\"1\":{\"552\":1,\"709\":1,\"710\":8}}],[\"fixedthreadpoolbulkhead\",{\"0\":{\"481\":1},\"1\":{\"481\":1}}],[\"fixedthreadpoolbulkhead使用了有界队列和固定大小线程池\",{\"1\":{\"479\":1}}],[\"fil\",{\"1\":{\"668\":7}}],[\"filtered\",{\"0\":{\"709\":1},\"1\":{\"701\":1,\"709\":1}}],[\"filter跳转到http\",{\"1\":{\"502\":1}}],[\"filters\",{\"1\":{\"499\":3,\"500\":1,\"502\":3,\"504\":1}}],[\"filter过滤器\",{\"0\":{\"498\":1}}],[\"filter\",{\"1\":{\"424\":1,\"444\":1,\"488\":1,\"491\":1,\"499\":3,\"500\":1,\"503\":2,\"504\":2,\"807\":1}}],[\"filename|mysql\",{\"1\":{\"809\":1}}],[\"filename为日志文件名\",{\"1\":{\"806\":1,\"807\":1}}],[\"filename\",{\"1\":{\"806\":2,\"807\":1,\"809\":3}}],[\"file=\",{\"1\":{\"806\":2,\"826\":1}}],[\"file的过程并不是真正的刷到磁盘中去\",{\"1\":{\"753\":1}}],[\"file采用追加写的方式\",{\"1\":{\"752\":1}}],[\"filesort\",{\"1\":{\"725\":6}}],[\"filesort`提示\",{\"1\":{\"710\":1}}],[\"fileter\",{\"1\":{\"488\":1}}],[\"file\",{\"1\":{\"403\":6,\"404\":2,\"429\":2,\"667\":2,\"751\":1,\"752\":1,\"753\":2,\"806\":1,\"809\":1}}],[\"fill\",{\"1\":{\"107\":1,\"109\":1,\"133\":1,\"211\":1,\"215\":1,\"360\":1}}],[\"five++\",{\"1\":{\"358\":1}}],[\"five\",{\"1\":{\"358\":5}}],[\"final\",{\"1\":{\"423\":2,\"444\":2,\"446\":1,\"451\":1,\"503\":1}}],[\"finchley\",{\"1\":{\"399\":2}}],[\"finish\",{\"1\":{\"84\":1}}],[\"find\",{\"1\":{\"552\":1}}],[\"findfirst\",{\"1\":{\"444\":1}}],[\"findcontentchildren\",{\"1\":{\"344\":1}}],[\"finddiagonalorder\",{\"1\":{\"305\":1}}],[\"finditinerary\",{\"1\":{\"213\":1}}],[\"findsubsequences\",{\"1\":{\"207\":1}}],[\"findlength\",{\"1\":{\"137\":1}}],[\"findlengthoflcis\",{\"1\":{\"135\":1}}],[\"findtargetsumways\",{\"1\":{\"99\":1}}],[\"findminarrowshots1\",{\"1\":{\"364\":1}}],[\"findminarrowshots\",{\"1\":{\"364\":1}}],[\"findmin1\",{\"1\":{\"276\":1}}],[\"findmiddleindex2\",{\"1\":{\"293\":1}}],[\"findmiddleindex\",{\"1\":{\"292\":1}}],[\"findmode\",{\"1\":{\"60\":1}}],[\"findmaxconsecutiveones\",{\"1\":{\"308\":1}}],[\"findmaxform\",{\"1\":{\"101\":1}}],[\"findmax\",{\"1\":{\"51\":2}}],[\"findbottomleftvalue1\",{\"1\":{\"43\":1}}],[\"findbottomleftvalue\",{\"1\":{\"43\":1}}],[\"fib\",{\"1\":{\"79\":1}}],[\"fig1\",{\"1\":{\"16\":1,\"81\":1}}],[\"给所有的页建立一个目录项\",{\"1\":{\"643\":1}}],[\"给某个字段\",{\"1\":{\"620\":1}}],[\"给这个字段增加自增约束\",{\"1\":{\"617\":1}}],[\"给这些孩子分发糖果\",{\"1\":{\"359\":1}}],[\"给冷系统一个预热的时间\",{\"1\":{\"411\":1}}],[\"给出由小写字母组成的字符串\",{\"1\":{\"327\":1}}],[\"给出数字到字母的映射如下\",{\"1\":{\"192\":1}}],[\"给出二叉\",{\"1\":{\"73\":1}}],[\"给两个整数数组\",{\"1\":{\"136\":1}}],[\"给你单链表的头指针\",{\"1\":{\"383\":1}}],[\"给你单链表的头节点\",{\"1\":{\"380\":1}}],[\"给你\",{\"1\":{\"277\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"390\":1}}],[\"给你两个单词\",{\"1\":{\"151\":1}}],[\"给你两个字符串\",{\"1\":{\"147\":1}}],[\"给你两棵二叉树\",{\"1\":{\"52\":1}}],[\"给你二叉搜索树的根节点\",{\"1\":{\"69\":1}}],[\"给你二叉树的根节点\",{\"1\":{\"11\":1,\"13\":1,\"44\":1}}],[\"给你一份航线列表\",{\"1\":{\"212\":1}}],[\"给你一个链表\",{\"1\":{\"385\":1,\"388\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"376\":1}}],[\"给你一个需要删除的节点\",{\"1\":{\"379\":1}}],[\"给你一个正整数\",{\"1\":{\"287\":1}}],[\"给你一个按\",{\"1\":{\"281\":1}}],[\"给你一个按照非递减顺序排列的整数数组\",{\"1\":{\"275\":1}}],[\"给你一个数组\",{\"1\":{\"278\":1,\"363\":1}}],[\"给你一个数字字母串你得能找到对应的字母\",{\"1\":{\"193\":1}}],[\"给你一个元素值\",{\"1\":{\"276\":1}}],[\"给你一个下标从\",{\"1\":{\"240\":1,\"290\":1}}],[\"给你一个大小为\",{\"1\":{\"227\":1,\"229\":1,\"303\":1}}],[\"给你一个有\",{\"1\":{\"223\":1}}],[\"给你一个字符串数组\",{\"1\":{\"164\":1,\"330\":1}}],[\"给你一个字符串\",{\"1\":{\"110\":1,\"154\":1,\"156\":1,\"198\":1,\"244\":1,\"260\":1,\"367\":1}}],[\"给你一个由\",{\"1\":{\"104\":1,\"178\":1,\"225\":1}}],[\"给你一个二进制字符串数组\",{\"1\":{\"100\":1}}],[\"给你一个二叉搜索树的根节点\",{\"1\":{\"57\":1}}],[\"给你一个二叉树的根节点\",{\"1\":{\"32\":1,\"38\":1,\"55\":1}}],[\"给你一个非负整数数组\",{\"1\":{\"98\":1,\"349\":1}}],[\"给你一个\",{\"1\":{\"94\":1,\"194\":1,\"231\":1,\"312\":1}}],[\"给你一个整数\",{\"1\":{\"88\":1,\"108\":1,\"172\":1,\"214\":1}}],[\"给你一个整数数组\",{\"1\":{\"71\":1,\"82\":1,\"102\":1,\"106\":1,\"121\":1,\"125\":1,\"132\":1,\"142\":1,\"176\":1,\"202\":1,\"204\":1,\"206\":1,\"266\":1,\"333\":1,\"336\":1,\"345\":1,\"347\":1,\"353\":1,\"357\":1,\"359\":1}}],[\"给你一个含重复值的二叉搜索树\",{\"1\":{\"59\":1}}],[\"给你一棵\",{\"1\":{\"34\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"30\":1}}],[\"给定节点的值不应该存在于链表中\",{\"1\":{\"379\":1}}],[\"给定树的节点数的范围是\",{\"1\":{\"371\":1}}],[\"给定长度为\",{\"1\":{\"257\":1}}],[\"给定的数字字符串长度为多少\",{\"1\":{\"193\":1}}],[\"给定的树为二叉搜索树\",{\"1\":{\"73\":1}}],[\"给定字符串\",{\"1\":{\"145\":1}}],[\"给定两个整数\",{\"1\":{\"186\":1}}],[\"给定两个整数数组\",{\"1\":{\"46\":1,\"48\":1,\"355\":1}}],[\"给定两个数组\",{\"1\":{\"166\":1}}],[\"给定两个单词\",{\"1\":{\"149\":1}}],[\"给定两个字符串\",{\"1\":{\"138\":1,\"161\":1}}],[\"给定\",{\"1\":{\"78\":1}}],[\"给定需要删除的节点值是\",{\"1\":{\"67\":1}}],[\"给定如下二叉搜索树\",{\"1\":{\"63\":1}}],[\"给定二叉搜索树\",{\"1\":{\"53\":1,\"65\":1}}],[\"给定二叉树的\",{\"1\":{\"116\":1}}],[\"给定二叉树的根节点\",{\"1\":{\"40\":1}}],[\"给定二叉树如图\",{\"1\":{\"23\":1}}],[\"给定一棵二叉树的根节点\",{\"1\":{\"21\":1}}],[\"给定一个链表的头节点\",{\"1\":{\"393\":1}}],[\"给定一个整数\",{\"1\":{\"369\":1}}],[\"给定一个整数数组\",{\"1\":{\"129\":1,\"174\":1}}],[\"给定一个整数数组prices\",{\"1\":{\"127\":1}}],[\"给定一个区间的集合\",{\"1\":{\"365\":1}}],[\"给定一个长度为\",{\"1\":{\"351\":1}}],[\"给定一个只包括\",{\"1\":{\"324\":1}}],[\"给定一个只包含数字的字符串\",{\"1\":{\"200\":1}}],[\"给定一个非负整数\",{\"1\":{\"309\":1}}],[\"给定一个非空二叉树的根节点\",{\"1\":{\"17\":1}}],[\"给定一个二进制数组\",{\"1\":{\"306\":1}}],[\"给定一个二叉搜索树的根节点\",{\"1\":{\"67\":1}}],[\"给定一个二叉搜索树\",{\"1\":{\"63\":1}}],[\"给定一个二叉树\",{\"1\":{\"25\":1,\"27\":1,\"36\":1,\"61\":1,\"371\":1}}],[\"给定一个二叉树的\",{\"1\":{\"15\":1,\"42\":1}}],[\"给定一个含有\",{\"1\":{\"284\":1}}],[\"给定一个排序数组和一个目标值\",{\"1\":{\"273\":1}}],[\"给定一个字符串\",{\"1\":{\"246\":1,\"252\":1}}],[\"给定一个可包含重复数字的序列\",{\"1\":{\"210\":1}}],[\"给定一个不含重复数字的数组\",{\"1\":{\"208\":1}}],[\"给定一个不重复的整数数组\",{\"1\":{\"50\":1}}],[\"给定一个候选人编号的集合\",{\"1\":{\"196\":1}}],[\"给定一个仅包含数字\",{\"1\":{\"192\":1}}],[\"给定一个未经排序的整数数组\",{\"1\":{\"134\":1}}],[\"给定一个数组\",{\"1\":{\"119\":1,\"123\":1,\"315\":1}}],[\"给定一个代表每个房屋存放金额的非负整数数组\",{\"1\":{\"112\":1,\"114\":1}}],[\"给定一个正整数\",{\"1\":{\"86\":1}}],[\"给定一个\",{\"1\":{\"19\":1,\"23\":1,\"233\":1,\"269\":1,\"297\":1}}],[\"简写为\",{\"1\":{\"831\":2}}],[\"简写为b\",{\"1\":{\"661\":1}}],[\"简化后的行格式示意图\",{\"1\":{\"680\":1}}],[\"简化为\",{\"1\":{\"648\":1}}],[\"简化为三层结构\",{\"1\":{\"633\":1}}],[\"简而言之\",{\"1\":{\"635\":1}}],[\"简洁和清晰的层次结构使得\",{\"1\":{\"608\":1}}],[\"简洁太多了\",{\"1\":{\"12\":1}}],[\"简称mdl锁\",{\"1\":{\"773\":1}}],[\"简称\",{\"1\":{\"399\":1,\"770\":1}}],[\"简介\",{\"0\":{\"399\":1}}],[\"简单易懂\",{\"1\":{\"731\":1}}],[\"简单配置\",{\"0\":{\"489\":1}}],[\"简单的说就是将用户的请求平摊的分配到多个服务上\",{\"1\":{\"457\":1}}],[\"简单的比较前后俩个元素进行去重\",{\"1\":{\"207\":2}}],[\"简单介绍\",{\"0\":{\"183\":1}}],[\"简单来说就是服务器出现问题时\",{\"1\":{\"472\":1}}],[\"简单来说就是版本适配问题\",{\"1\":{\"422\":1}}],[\"简单来说就是找到环的起始节点\",{\"1\":{\"394\":1}}],[\"简单来说就是一个或多个结点的共同父节点\",{\"1\":{\"62\":1}}],[\"简单来说\",{\"1\":{\"187\":1,\"416\":1,\"727\":1}}],[\"简单来说将一个数的因数分解到不能再分解后\",{\"1\":{\"173\":1}}],[\"简单一批\",{\"1\":{\"14\":1}}],[\"即监听binlog\",{\"1\":{\"853\":1}}],[\"即日志文件的个数与mysql服务启动的次数相同\",{\"1\":{\"809\":1}}],[\"即读不阻塞写\",{\"1\":{\"801\":1}}],[\"即并发事务相继对相同的记录做出改动\",{\"1\":{\"763\":1}}],[\"即并发事务相继\",{\"1\":{\"762\":1}}],[\"即一个事务进行读取操作\",{\"1\":{\"764\":1}}],[\"即一个事务内部的操作及使用的数据对\",{\"1\":{\"741\":1}}],[\"即一个在左子树一个在右子树\",{\"1\":{\"62\":1}}],[\"即将使用\",{\"1\":{\"704\":1}}],[\"即为级联更新\",{\"1\":{\"837\":1}}],[\"即为返回前面多少条的数据\",{\"1\":{\"699\":1}}],[\"即为当前环境对应的\",{\"1\":{\"403\":1}}],[\"即需要一条一条地查找记录\",{\"1\":{\"641\":1}}],[\"即多个字段的组合是唯\",{\"1\":{\"615\":1}}],[\"即采用循环的方式\",{\"1\":{\"570\":1}}],[\"即返回正切值为x的值\",{\"1\":{\"549\":1}}],[\"即返回结果\",{\"1\":{\"120\":1,\"122\":1}}],[\"即获取余弦为x的值\",{\"1\":{\"549\":1}}],[\"即获取正弦为x的值\",{\"1\":{\"549\":1}}],[\"即二维表格形式\",{\"1\":{\"509\":1}}],[\"即2^2\",{\"1\":{\"495\":1}}],[\"即使没有过滤条件用到索引\",{\"1\":{\"726\":1}}],[\"即使是一条语句也可能修改许多页面\",{\"1\":{\"749\":1}}],[\"即使是组合字段\",{\"1\":{\"689\":1}}],[\"即使是由相同的字符组成\",{\"1\":{\"154\":1}}],[\"即使多个存储引擎支持同一种类型的索引\",{\"1\":{\"653\":1}}],[\"即使你不\",{\"1\":{\"618\":1}}],[\"即使所有9次调用都失败\",{\"1\":{\"477\":1}}],[\"即使4次都失败了\",{\"1\":{\"476\":1}}],[\"即5次\",{\"1\":{\"476\":1}}],[\"即负载均衡是由服务端实现的\",{\"1\":{\"457\":1}}],[\"即在事务提交之前将事务的修改写入磁盘\",{\"1\":{\"811\":1}}],[\"即在innodb存储引擎中mvcc的实现是通过undo来完成\",{\"1\":{\"756\":1}}],[\"即在\",{\"1\":{\"421\":1}}],[\"即最大的响应时间\",{\"1\":{\"412\":1}}],[\"即最长递增子序列\",{\"1\":{\"133\":1}}],[\"即阀值刚开始为3\",{\"1\":{\"411\":1}}],[\"即请求\",{\"1\":{\"411\":1}}],[\"即预热\",{\"1\":{\"411\":1}}],[\"即突发流量控制在系统容量可以承受的范围\",{\"1\":{\"406\":1}}],[\"即编号为\",{\"1\":{\"361\":4}}],[\"即总共需要的糖果数量\",{\"1\":{\"360\":1}}],[\"即到不了终点\",{\"1\":{\"350\":1}}],[\"即遇到相等元素直接跳过\",{\"1\":{\"346\":1}}],[\"即不加锁的非阻塞读\",{\"1\":{\"791\":1}}],[\"即不存在自环\",{\"1\":{\"223\":1}}],[\"即不需要考虑当前s子串和t子串的最后一位字母\",{\"1\":{\"148\":1,\"153\":1}}],[\"即从大到小排序\",{\"1\":{\"338\":1}}],[\"即从小到大排序\",{\"1\":{\"338\":1}}],[\"即从节点\",{\"1\":{\"223\":1}}],[\"即从左到右\",{\"1\":{\"19\":1}}],[\"即加入到\",{\"1\":{\"199\":1}}],[\"即以下标\",{\"1\":{\"152\":2,\"153\":2}}],[\"即冷冻期为\",{\"1\":{\"127\":1}}],[\"即可完整实现矩阵旋转\",{\"1\":{\"299\":1}}],[\"即可\",{\"1\":{\"111\":1,\"299\":1,\"440\":1,\"441\":1,\"806\":1}}],[\"即可选择向上爬一个或者两个台阶\",{\"1\":{\"82\":1}}],[\"即dp\",{\"1\":{\"107\":1,\"155\":1}}],[\"即表示重量也表示价值\",{\"1\":{\"95\":1}}],[\"即root的右子树最小结点上\",{\"1\":{\"68\":1}}],[\"即没有左右子树\",{\"1\":{\"68\":1}}],[\"即用s\",{\"1\":{\"148\":1,\"153\":1}}],[\"即用\",{\"1\":{\"62\":1}}],[\"即p在q的右子树或者左子树\",{\"1\":{\"62\":1}}],[\"即q在p的左子树或者右子树\",{\"1\":{\"62\":1}}],[\"即保存结点也保存结点和\",{\"1\":{\"45\":1}}],[\"即递归或者迭代\",{\"1\":{\"41\":1}}],[\"即\",{\"1\":{\"33\":1,\"39\":1,\"59\":1,\"62\":1,\"69\":1,\"81\":2,\"92\":1,\"137\":1,\"141\":1,\"148\":2,\"152\":3,\"153\":5,\"157\":3,\"276\":2,\"299\":1,\"304\":2,\"310\":1,\"313\":1,\"344\":1,\"352\":1,\"372\":1,\"377\":1,\"381\":1,\"382\":1,\"385\":1,\"386\":1,\"595\":1,\"624\":1,\"706\":1,\"709\":1,\"771\":1,\"808\":1,\"850\":1}}],[\"即按从叶子节点所在层到根节点所在的层\",{\"1\":{\"13\":1}}],[\"即逐层地\",{\"1\":{\"11\":1}}],[\"终止条件就是上面说的那几种情况\",{\"1\":{\"33\":1}}],[\"终止条件\",{\"1\":{\"12\":1,\"49\":1,\"51\":1,\"54\":2,\"62\":1,\"185\":2,\"187\":2,\"190\":1,\"193\":1,\"195\":1,\"199\":1,\"201\":1,\"203\":1,\"207\":1,\"209\":1,\"213\":1,\"215\":1,\"217\":1,\"222\":1,\"224\":1,\"372\":1,\"386\":2}}],[\"d选项\",{\"1\":{\"831\":1}}],[\"d不是索引的一部分\",{\"1\":{\"725\":1}}],[\"dynamic和compressed行格式\",{\"1\":{\"675\":1}}],[\"dynamicpassword1\",{\"1\":{\"256\":1}}],[\"dynamicpassword\",{\"1\":{\"256\":1}}],[\"dname\",{\"1\":{\"618\":1}}],[\"dns\",{\"1\":{\"449\":1}}],[\"d=小数位\",{\"1\":{\"600\":1}}],[\"d被称为标度\",{\"1\":{\"600\":1}}],[\"dql\",{\"1\":{\"517\":1}}],[\"dcl\",{\"1\":{\"517\":1}}],[\"dcsp\",{\"1\":{\"422\":1}}],[\"dml之增删改\",{\"0\":{\"542\":1}}],[\"dml中的select\",{\"0\":{\"519\":1}}],[\"dml\",{\"1\":{\"517\":2,\"589\":1,\"808\":1}}],[\"d+\",{\"1\":{\"463\":1,\"493\":1,\"494\":1}}],[\"ddl\",{\"1\":{\"517\":1,\"589\":1,\"627\":1,\"770\":1}}],[\"dd\",{\"1\":{\"444\":3}}],[\"dtd\",{\"1\":{\"442\":3}}],[\"drop\",{\"1\":{\"440\":1,\"517\":1,\"586\":1,\"588\":2,\"615\":1,\"616\":1,\"618\":2,\"687\":2,\"770\":1}}],[\"driver===================\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"driverclass=\",{\"1\":{\"442\":1}}],[\"driverclass\",{\"1\":{\"431\":3,\"442\":2}}],[\"driver\",{\"1\":{\"429\":2,\"431\":3,\"432\":2,\"442\":1,\"443\":2,\"452\":2}}],[\"druiddatasource\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"druid\",{\"1\":{\"429\":1,\"432\":2,\"441\":2,\"443\":2,\"452\":2}}],[\"dbname\",{\"1\":{\"832\":1}}],[\"db=需要复制的主数据库名字\",{\"1\":{\"823\":1}}],[\"db=atguigu\",{\"1\":{\"823\":1}}],[\"db=test\",{\"1\":{\"823\":1}}],[\"dba\",{\"1\":{\"727\":1}}],[\"dbms\",{\"1\":{\"508\":2}}],[\"db\",{\"1\":{\"428\":2,\"429\":3,\"431\":1,\"681\":3}}],[\"ds2\",{\"1\":{\"419\":1}}],[\"ds1\",{\"1\":{\"419\":1}}],[\"d请求来访问common资源就不限流\",{\"1\":{\"410\":1}}],[\"dump\",{\"1\":{\"820\":1}}],[\"dummynode\",{\"1\":{\"384\":5}}],[\"dummyhead\",{\"1\":{\"378\":4,\"389\":4}}],[\"dual\",{\"1\":{\"520\":1,\"548\":2,\"557\":1,\"558\":3}}],[\"dual表示伪表\",{\"1\":{\"520\":1}}],[\"duration\",{\"1\":{\"476\":2,\"478\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"durationinsec\",{\"1\":{\"419\":2}}],[\"dubbo\",{\"1\":{\"399\":1,\"406\":1,\"407\":1}}],[\"d<=m<=255\",{\"1\":{\"600\":1}}],[\"d<\",{\"1\":{\"299\":2}}],[\"different\",{\"1\":{\"822\":1}}],[\"did\",{\"1\":{\"618\":2}}],[\"diamonds\",{\"1\":{\"497\":1}}],[\"diagram\",{\"1\":{\"488\":1}}],[\"dirty\",{\"1\":{\"746\":2}}],[\"directory\",{\"0\":{\"673\":1},\"1\":{\"645\":1,\"667\":1}}],[\"directory>\",{\"1\":{\"442\":2}}],[\"dir\",{\"1\":{\"454\":2}}],[\"disable\",{\"1\":{\"475\":1}}],[\"distributed\",{\"1\":{\"429\":4}}],[\"distinct这些查询的语句\",{\"1\":{\"726\":1}}],[\"distinct这些语句较为耗费cpu\",{\"1\":{\"726\":1}}],[\"distinct\",{\"1\":{\"268\":1,\"522\":3,\"565\":2,\"689\":2,\"710\":2}}],[\"discoveryclient\",{\"1\":{\"460\":1}}],[\"discovery<\",{\"1\":{\"402\":2,\"422\":1,\"432\":1,\"450\":2,\"489\":1}}],[\"discovery\",{\"1\":{\"402\":4,\"403\":1,\"404\":2,\"408\":1,\"420\":1,\"422\":2,\"432\":1,\"450\":1,\"452\":2,\"464\":2,\"489\":2}}],[\"ding\",{\"1\":{\"246\":1}}],[\"digits\",{\"1\":{\"192\":5,\"193\":4}}],[\"digit\",{\"1\":{\"171\":6}}],[\"das\",{\"1\":{\"632\":1}}],[\"dashboard控制台服务地址\",{\"1\":{\"408\":1,\"420\":1}}],[\"dashboard\",{\"1\":{\"407\":1,\"408\":1,\"420\":1,\"422\":1}}],[\"days\",{\"1\":{\"557\":4}}],[\"dayofweek\",{\"1\":{\"555\":1}}],[\"dayofmonth\",{\"1\":{\"555\":1}}],[\"dayofyear\",{\"1\":{\"555\":1}}],[\"dayname\",{\"1\":{\"555\":1}}],[\"day\",{\"1\":{\"555\":1,\"557\":4}}],[\"data配置文件\",{\"1\":{\"452\":1}}],[\"data`\",{\"1\":{\"428\":2}}],[\"database=\",{\"1\":{\"809\":1}}],[\"databases参数\",{\"1\":{\"831\":1}}],[\"databases\",{\"1\":{\"586\":1,\"831\":5}}],[\"database\",{\"1\":{\"428\":1,\"431\":6,\"585\":3,\"586\":3,\"618\":1,\"831\":2,\"832\":3}}],[\"datasource\",{\"1\":{\"419\":2,\"429\":1,\"432\":1,\"443\":1,\"452\":1}}],[\"data\",{\"1\":{\"404\":1,\"419\":2,\"428\":3,\"432\":1,\"443\":1,\"444\":4,\"452\":4,\"454\":2,\"517\":3,\"606\":1,\"612\":1,\"687\":1,\"773\":1,\"809\":2,\"831\":4,\"832\":2}}],[\"dataid\",{\"0\":{\"404\":1},\"1\":{\"403\":1,\"419\":3}}],[\"date类型\",{\"1\":{\"602\":1}}],[\"date2的日期间隔天数\",{\"1\":{\"557\":1}}],[\"date2\",{\"1\":{\"557\":1}}],[\"date1\",{\"1\":{\"557\":1}}],[\"datediff\",{\"1\":{\"557\":2}}],[\"datetime类型和timestamp类型\",{\"1\":{\"602\":1}}],[\"datetime\",{\"1\":{\"428\":6,\"431\":12,\"557\":1,\"602\":1,\"836\":1}}],[\"date\",{\"1\":{\"190\":1,\"191\":1,\"215\":1,\"444\":3,\"554\":3,\"555\":14,\"557\":9,\"558\":7,\"587\":3,\"602\":1,\"809\":4}}],[\"dag\",{\"1\":{\"223\":2}}],[\"d互不相同\",{\"1\":{\"178\":1}}],[\"domain\",{\"1\":{\"612\":1}}],[\"domainobjectname=\",{\"1\":{\"431\":3,\"442\":1}}],[\"doctype\",{\"1\":{\"442\":1}}],[\"docs\",{\"1\":{\"426\":1,\"458\":2}}],[\"downloads\",{\"1\":{\"449\":1}}],[\"download\",{\"1\":{\"427\":1}}],[\"doinit\",{\"1\":{\"423\":1}}],[\"doactionblockhandler\",{\"1\":{\"416\":2}}],[\"doactionsentinelresource\",{\"1\":{\"416\":1}}],[\"doaction\",{\"1\":{\"416\":3}}],[\"doactionfallback\",{\"1\":{\"416\":3}}],[\"dog\",{\"1\":{\"110\":1,\"246\":1}}],[\"do\",{\"1\":{\"99\":1,\"823\":2}}],[\"double\",{\"1\":{\"18\":1,\"599\":5}}],[\"d\",{\"1\":{\"97\":8,\"111\":1,\"178\":3,\"193\":2,\"558\":3,\"579\":2,\"600\":2,\"607\":1,\"725\":1,\"832\":2}}],[\"dp公式\",{\"1\":{\"128\":1}}],[\"dp数组\",{\"1\":{\"262\":1}}],[\"dp数组含义\",{\"1\":{\"133\":1}}],[\"dp数组的初始化\",{\"1\":{\"87\":1}}],[\"dp数组的含义\",{\"1\":{\"79\":1,\"92\":1}}],[\"dp数组下标的含义\",{\"1\":{\"87\":1}}],[\"dp数组如何初始化\",{\"1\":{\"77\":1,\"79\":1,\"81\":1,\"85\":1}}],[\"dp\",{\"1\":{\"77\":1,\"79\":15,\"81\":17,\"83\":14,\"85\":15,\"87\":14,\"89\":14,\"91\":16,\"92\":18,\"93\":6,\"95\":15,\"97\":5,\"99\":15,\"101\":12,\"103\":15,\"105\":11,\"107\":17,\"109\":15,\"111\":11,\"113\":20,\"115\":13,\"120\":22,\"122\":25,\"124\":38,\"126\":30,\"128\":36,\"130\":18,\"133\":11,\"137\":11,\"139\":12,\"141\":7,\"143\":11,\"146\":13,\"148\":18,\"150\":7,\"152\":38,\"153\":25,\"155\":17,\"157\":21,\"261\":4,\"262\":4}}],[\"detect\",{\"1\":{\"786\":1}}],[\"detectcycle\",{\"1\":{\"395\":1}}],[\"deadlock\",{\"1\":{\"786\":1}}],[\"dealhandler\",{\"1\":{\"417\":3}}],[\"demo表的行格式示意图\",{\"1\":{\"643\":1}}],[\"demo\",{\"1\":{\"643\":3,\"680\":1}}],[\"degrees\",{\"1\":{\"549\":1}}],[\"degrade熔断降级规则\",{\"1\":{\"419\":1}}],[\"deptid\",{\"1\":{\"618\":2}}],[\"dept80\",{\"1\":{\"587\":3}}],[\"dept\",{\"1\":{\"533\":8,\"538\":5,\"539\":4,\"541\":20,\"578\":2,\"579\":3,\"618\":8,\"687\":8,\"737\":1}}],[\"departments为从表\",{\"1\":{\"539\":1}}],[\"departments\",{\"1\":{\"533\":9,\"538\":2,\"539\":2,\"541\":9,\"575\":1,\"579\":1}}],[\"department\",{\"1\":{\"522\":6,\"523\":1,\"525\":1,\"529\":1,\"533\":15,\"538\":6,\"539\":6,\"541\":32,\"563\":2,\"564\":4,\"573\":7,\"574\":3,\"575\":2,\"578\":9,\"579\":12,\"587\":1}}],[\"dependency\",{\"1\":{\"489\":1}}],[\"dependencymanagement\",{\"1\":{\"441\":3}}],[\"dependencymanagement>\",{\"1\":{\"399\":1,\"441\":1}}],[\"dependency>\",{\"1\":{\"399\":1,\"402\":12,\"403\":2,\"408\":1,\"419\":1,\"422\":4,\"423\":4,\"432\":17,\"441\":13,\"442\":10,\"443\":12,\"446\":6,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"468\":2,\"477\":2,\"480\":1,\"481\":1,\"482\":1,\"486\":11,\"489\":3}}],[\"dependencies\",{\"1\":{\"441\":2}}],[\"dependencies>\",{\"1\":{\"399\":1,\"402\":2,\"422\":1,\"423\":1,\"432\":1,\"441\":1,\"442\":2,\"443\":1,\"446\":1,\"489\":1}}],[\"dependencies<\",{\"1\":{\"399\":1,\"441\":2}}],[\"debug\",{\"1\":{\"470\":1}}],[\"denied\",{\"1\":{\"444\":3,\"625\":1}}],[\"delayed\",{\"1\":{\"836\":1}}],[\"del\",{\"1\":{\"443\":1}}],[\"delete操作\",{\"1\":{\"618\":1}}],[\"delete掉子表的匹配记录\",{\"1\":{\"618\":1}}],[\"delete记录时\",{\"1\":{\"618\":2}}],[\"deletepay\",{\"1\":{\"443\":1}}],[\"deletemapping\",{\"1\":{\"443\":1}}],[\"deletebyprimarykey\",{\"1\":{\"443\":1}}],[\"delete\",{\"0\":{\"589\":1},\"1\":{\"443\":3,\"454\":1,\"463\":2,\"517\":1,\"542\":1,\"589\":2,\"618\":3,\"680\":1,\"689\":1,\"755\":1,\"770\":2,\"786\":1,\"791\":1,\"797\":1,\"823\":2}}],[\"deletecharat\",{\"1\":{\"193\":2}}],[\"deletenode\",{\"1\":{\"68\":3,\"379\":1}}],[\"decrease\",{\"1\":{\"431\":4,\"432\":2,\"433\":7,\"434\":7}}],[\"decimal\",{\"1\":{\"431\":4,\"440\":1,\"599\":1,\"600\":2}}],[\"describe\",{\"1\":{\"700\":3}}],[\"description\",{\"1\":{\"190\":1,\"191\":1,\"215\":1}}],[\"desc\",{\"1\":{\"565\":2,\"687\":4,\"725\":2,\"836\":1}}],[\"destination\",{\"1\":{\"429\":1}}],[\"develop\",{\"1\":{\"428\":1,\"431\":1}}],[\"dev\",{\"1\":{\"403\":2,\"449\":1,\"452\":1}}],[\"deque\",{\"1\":{\"321\":1}}],[\"defined\",{\"1\":{\"612\":1,\"617\":1}}],[\"definition\",{\"1\":{\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"31\":2,\"35\":1,\"37\":1,\"117\":1,\"384\":1,\"517\":1,\"617\":1}}],[\"defense\",{\"1\":{\"431\":3}}],[\"defegde\",{\"1\":{\"367\":1}}],[\"defaults\",{\"1\":{\"809\":2}}],[\"default方式\",{\"1\":{\"618\":1}}],[\"defaultmodeltype=\",{\"1\":{\"442\":1}}],[\"defaultfallback\",{\"1\":{\"416\":2}}],[\"default\",{\"0\":{\"620\":1},\"1\":{\"332\":1,\"416\":10,\"419\":3,\"428\":5,\"429\":2,\"431\":19,\"432\":3,\"440\":6,\"452\":1,\"466\":1,\"467\":1,\"477\":2,\"478\":3,\"480\":3,\"481\":3,\"482\":2,\"588\":1,\"613\":1,\"617\":3,\"620\":3,\"635\":2,\"675\":1}}],[\"def\",{\"1\":{\"138\":1}}],[\"deep++\",{\"1\":{\"12\":1}}],[\"deep\",{\"1\":{\"12\":5}}],[\"deep表示遍历的层次\",{\"1\":{\"12\":1}}],[\"dfs就可以看做是回溯算法\",{\"1\":{\"224\":1}}],[\"dfs版本\",{\"1\":{\"224\":1}}],[\"dfs\",{\"0\":{\"222\":1},\"1\":{\"12\":16,\"29\":1,\"35\":2,\"39\":7,\"41\":6,\"56\":4,\"58\":4,\"60\":4,\"74\":4,\"117\":4,\"222\":7,\"224\":5,\"226\":1,\"228\":2,\"230\":1,\"232\":1,\"234\":1}}],[\"次数\",{\"1\":{\"476\":1}}],[\"次得到的\",{\"1\":{\"276\":1}}],[\"次得到输入数组\",{\"1\":{\"276\":3}}],[\"次旋转\",{\"1\":{\"276\":1}}],[\"次\",{\"1\":{\"12\":1,\"125\":2,\"276\":3,\"321\":1,\"353\":1,\"737\":2}}],[\"无疑是\",{\"1\":{\"731\":1}}],[\"无需进行回表\",{\"1\":{\"719\":1}}],[\"无需长字符串\",{\"1\":{\"690\":1}}],[\"无需更改代码\",{\"1\":{\"422\":1}}],[\"无符号属性\",{\"1\":{\"596\":1}}],[\"无符号类型\",{\"1\":{\"596\":1}}],[\"无\",{\"1\":{\"589\":1,\"596\":1}}],[\"无访问权限\",{\"1\":{\"444\":1}}],[\"无覆盖\",{\"1\":{\"372\":1}}],[\"无法从\",{\"1\":{\"823\":1}}],[\"无法被禁止\",{\"1\":{\"807\":1}}],[\"无法恢复\",{\"1\":{\"749\":1}}],[\"无法使用\",{\"1\":{\"725\":1,\"729\":1}}],[\"无法使用索引\",{\"1\":{\"717\":1}}],[\"无法对单独的一个键或者几个索引键进行查询\",{\"1\":{\"658\":1}}],[\"无法访问\",{\"1\":{\"379\":1}}],[\"无法\",{\"1\":{\"229\":1}}],[\"无法区分队列中的结点来自哪一层\",{\"1\":{\"12\":1}}],[\"无法区分每一层\",{\"1\":{\"12\":1}}],[\"无效\",{\"1\":{\"200\":1,\"533\":1}}],[\"无限制重复被选取\",{\"1\":{\"194\":1}}],[\"无限循环\",{\"1\":{\"169\":1}}],[\"无论是定时任务\",{\"1\":{\"853\":1}}],[\"无论是中序\",{\"1\":{\"47\":1}}],[\"无论这个事务多大\",{\"1\":{\"810\":1}}],[\"无论怎样\",{\"1\":{\"349\":1,\"355\":1}}],[\"无论有没有符号\",{\"1\":{\"599\":1}}],[\"无论有几条\",{\"1\":{\"304\":1}}],[\"无论有多少种方法最后都是0\",{\"1\":{\"99\":1}}],[\"无非就是修改指针\",{\"1\":{\"381\":1}}],[\"无非就是处理方式有一些不一样\",{\"1\":{\"364\":1}}],[\"无非就是一个删除单个结点\",{\"1\":{\"70\":1}}],[\"无非就有俩种情况\",{\"1\":{\"261\":1,\"356\":1}}],[\"无非是改变元素的符号\",{\"1\":{\"97\":1}}],[\"无非有俩种情况\",{\"1\":{\"91\":1}}],[\"无子节点\",{\"1\":{\"50\":3}}],[\"无重复元素\",{\"1\":{\"194\":1,\"273\":3}}],[\"无重复\",{\"1\":{\"48\":1}}],[\"无实际意义\",{\"1\":{\"12\":2}}],[\"<>\",{\"1\":{\"658\":1,\"721\":1}}],[\"<外键约束名称>\",{\"1\":{\"618\":1}}],[\"<zipkin\",{\"1\":{\"486\":1}}],[\"<feign\",{\"1\":{\"486\":1}}],[\"<fastjson2\",{\"1\":{\"441\":1}}],[\"<javaclientgenerator\",{\"1\":{\"442\":1}}],[\"<javamodelgenerator\",{\"1\":{\"442\":1}}],[\"<jdbcconnection\",{\"1\":{\"442\":1}}],[\"<condition>\",{\"1\":{\"542\":1}}],[\"<context\",{\"1\":{\"442\":1}}],[\"<configurationfile>$\",{\"1\":{\"442\":1}}],[\"<configuration>\",{\"1\":{\"442\":2}}],[\"<verbose>true<\",{\"1\":{\"442\":1}}],[\"<version>5\",{\"1\":{\"468\":1}}],[\"<version>4\",{\"1\":{\"442\":1}}],[\"<version>8\",{\"1\":{\"442\":1}}],[\"<version>3\",{\"1\":{\"442\":1}}],[\"<version>$\",{\"1\":{\"441\":13,\"486\":6}}],[\"<version>13\",{\"1\":{\"468\":1}}],[\"<version>1\",{\"1\":{\"402\":2,\"423\":3,\"432\":2,\"441\":1,\"442\":2,\"443\":1}}],[\"<version>2022\",{\"1\":{\"399\":1}}],[\"<overwrite>true<\",{\"1\":{\"442\":1}}],[\"<optional>true<\",{\"1\":{\"402\":1,\"441\":1,\"442\":1,\"446\":1}}],[\"<exclude>\",{\"1\":{\"442\":1}}],[\"<excludes>\",{\"1\":{\"442\":1}}],[\"<exclusion>\",{\"1\":{\"442\":1,\"450\":1}}],[\"<exclusions>\",{\"1\":{\"442\":1,\"450\":1}}],[\"<include>\",{\"1\":{\"442\":1}}],[\"<includes>\",{\"1\":{\"442\":1}}],[\"<resource>\",{\"1\":{\"442\":2}}],[\"<resources>\",{\"1\":{\"442\":1}}],[\"<directory>$\",{\"1\":{\"442\":2}}],[\"<druid\",{\"1\":{\"441\":1}}],[\"<dependency>\",{\"1\":{\"399\":1,\"402\":12,\"403\":2,\"408\":1,\"419\":1,\"422\":4,\"423\":4,\"432\":17,\"441\":13,\"442\":10,\"443\":12,\"446\":6,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"468\":2,\"477\":2,\"480\":1,\"481\":1,\"482\":1,\"486\":11,\"489\":3}}],[\"<dependencymanagement>\",{\"1\":{\"399\":1,\"441\":1}}],[\"<dependencies>\",{\"1\":{\"399\":1,\"402\":2,\"422\":1,\"423\":1,\"432\":1,\"441\":1,\"442\":2,\"443\":1,\"446\":1,\"489\":1}}],[\"<lombok\",{\"1\":{\"441\":1}}],[\"<hutool\",{\"1\":{\"441\":1}}],[\"<micrometer\",{\"1\":{\"486\":2}}],[\"<mapper\",{\"1\":{\"441\":1}}],[\"<maven\",{\"1\":{\"441\":2}}],[\"<mysql\",{\"1\":{\"441\":1}}],[\"<mybatis\",{\"1\":{\"441\":1}}],[\"<modelversion>4\",{\"1\":{\"441\":1}}],[\"<persistence\",{\"1\":{\"441\":1}}],[\"<property\",{\"1\":{\"442\":4}}],[\"<properties\",{\"1\":{\"442\":1}}],[\"<properties>\",{\"1\":{\"441\":1}}],[\"<project\",{\"1\":{\"441\":2}}],[\"<packaging>pom<\",{\"1\":{\"441\":1}}],[\"<plugin\",{\"1\":{\"442\":1}}],[\"<plugin>\",{\"1\":{\"402\":2,\"442\":2,\"443\":1,\"446\":1,\"489\":1}}],[\"<plugins>\",{\"1\":{\"402\":2,\"442\":1,\"443\":1,\"446\":1,\"489\":1}}],[\"<update\",{\"1\":{\"433\":1,\"434\":1}}],[\"<generatorconfiguration>\",{\"1\":{\"442\":1}}],[\"<generatedkey\",{\"1\":{\"431\":3,\"442\":1}}],[\"<groupid>io\",{\"1\":{\"468\":1,\"480\":1,\"481\":1,\"482\":1,\"486\":11}}],[\"<groupid>tk\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"<groupid>mysql<\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"<groupid>javax\",{\"1\":{\"423\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"<groupid>cn\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1,\"446\":1}}],[\"<groupid>commons\",{\"1\":{\"450\":1}}],[\"<groupid>com\",{\"1\":{\"399\":1,\"402\":3,\"403\":1,\"408\":1,\"419\":1,\"422\":3,\"423\":2,\"432\":5,\"441\":4,\"443\":2,\"446\":1}}],[\"<groupid>org\",{\"1\":{\"402\":10,\"403\":1,\"422\":1,\"423\":1,\"432\":8,\"441\":6,\"442\":8,\"443\":7,\"446\":5,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"468\":1,\"477\":2,\"489\":4}}],[\"<sqlmapgenerator\",{\"1\":{\"442\":1}}],[\"<swagger3\",{\"1\":{\"441\":1}}],[\"<spring\",{\"1\":{\"420\":2,\"441\":4}}],[\"<scope>compile<\",{\"1\":{\"423\":1}}],[\"<scope>test<\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"<scope>provided<\",{\"1\":{\"402\":1,\"432\":1,\"443\":1}}],[\"<scope>import<\",{\"1\":{\"399\":1,\"441\":3,\"486\":1}}],[\"<build>\",{\"1\":{\"402\":2,\"442\":1,\"443\":1,\"446\":1,\"489\":1}}],[\"<artifactid>zipkin\",{\"1\":{\"486\":2}}],[\"<artifactid>resilience4j\",{\"1\":{\"480\":1,\"481\":1,\"482\":1}}],[\"<artifactid>feign\",{\"1\":{\"468\":1,\"486\":2}}],[\"<artifactid>fastjson2<\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"<artifactid>httpclient5<\",{\"1\":{\"468\":1}}],[\"<artifactid>hutool\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1,\"446\":1}}],[\"<artifactid>commons\",{\"1\":{\"450\":1}}],[\"<artifactid>cloud2024<\",{\"1\":{\"441\":1}}],[\"<artifactid>cloud\",{\"1\":{\"402\":1,\"432\":1}}],[\"<artifactid>junit\",{\"1\":{\"442\":1}}],[\"<artifactid>javax\",{\"1\":{\"423\":1}}],[\"<artifactid>micrometer\",{\"1\":{\"486\":7}}],[\"<artifactid>mapper<\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"<artifactid>mysql\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"<artifactid>mybatis<\",{\"1\":{\"442\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"<artifactid>persistence\",{\"1\":{\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"<artifactid>druid\",{\"1\":{\"432\":1,\"441\":1,\"443\":1}}],[\"<artifactid>sentinel\",{\"1\":{\"419\":1,\"423\":2}}],[\"<artifactid>springdoc\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"<artifactid>spring\",{\"1\":{\"399\":1,\"402\":10,\"403\":2,\"408\":1,\"422\":4,\"423\":1,\"432\":7,\"441\":4,\"442\":2,\"443\":4,\"446\":3,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"477\":2,\"489\":4}}],[\"<artifactid>lombok<\",{\"1\":{\"402\":2,\"432\":1,\"441\":1,\"442\":2,\"443\":1,\"446\":1}}],[\"<t>\",{\"1\":{\"444\":2}}],[\"<table\",{\"1\":{\"431\":3,\"442\":1}}],[\"<target<=nums\",{\"1\":{\"277\":1}}],[\"<type>pom<\",{\"1\":{\"399\":1,\"441\":3,\"486\":1}}],[\"<0\",{\"1\":{\"226\":1,\"356\":1}}],[\"<\",{\"1\":{\"12\":3,\"14\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"35\":1,\"43\":1,\"47\":1,\"49\":1,\"51\":2,\"54\":2,\"56\":1,\"58\":2,\"60\":1,\"64\":2,\"66\":3,\"68\":1,\"70\":3,\"81\":1,\"85\":4,\"87\":1,\"91\":2,\"92\":2,\"93\":2,\"95\":1,\"97\":1,\"99\":5,\"103\":3,\"105\":1,\"107\":1,\"111\":1,\"113\":1,\"115\":2,\"120\":2,\"122\":2,\"124\":1,\"126\":5,\"128\":2,\"129\":2,\"130\":1,\"133\":2,\"134\":3,\"135\":1,\"137\":2,\"139\":1,\"143\":1,\"148\":3,\"155\":1,\"157\":3,\"163\":1,\"165\":1,\"173\":1,\"175\":3,\"177\":9,\"178\":1,\"179\":6,\"187\":2,\"193\":2,\"195\":2,\"197\":1,\"199\":4,\"201\":4,\"203\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":1,\"213\":1,\"215\":6,\"217\":12,\"223\":1,\"224\":2,\"226\":8,\"228\":9,\"230\":13,\"232\":13,\"234\":7,\"240\":1,\"241\":1,\"242\":2,\"248\":1,\"253\":2,\"254\":2,\"255\":1,\"256\":1,\"259\":1,\"262\":2,\"270\":1,\"271\":5,\"273\":4,\"274\":1,\"275\":2,\"276\":3,\"277\":3,\"278\":1,\"280\":2,\"282\":1,\"283\":2,\"286\":1,\"289\":3,\"292\":3,\"293\":2,\"296\":1,\"298\":4,\"299\":8,\"302\":4,\"304\":3,\"305\":7,\"308\":1,\"311\":1,\"312\":1,\"314\":1,\"317\":1,\"326\":1,\"329\":1,\"334\":1,\"335\":3,\"338\":1,\"346\":2,\"348\":1,\"350\":2,\"351\":1,\"352\":1,\"354\":2,\"356\":4,\"358\":2,\"360\":2,\"361\":1,\"363\":1,\"364\":5,\"365\":1,\"366\":3,\"368\":2,\"370\":1,\"384\":2,\"391\":1,\"399\":3,\"402\":30,\"403\":2,\"408\":2,\"419\":1,\"422\":8,\"423\":6,\"431\":8,\"432\":34,\"433\":1,\"434\":1,\"441\":44,\"442\":42,\"443\":27,\"446\":15,\"450\":4,\"452\":3,\"459\":1,\"463\":2,\"468\":4,\"477\":4,\"480\":2,\"481\":2,\"482\":2,\"486\":28,\"489\":10,\"512\":3,\"569\":1,\"578\":2,\"831\":1,\"832\":3}}],[\"<=8\",{\"1\":{\"777\":1}}],[\"<=>null\",{\"1\":{\"528\":1}}],[\"<=>\",{\"1\":{\"528\":2}}],[\"<=target<nums\",{\"1\":{\"277\":1}}],[\"<==>\",{\"1\":{\"97\":2}}],[\"<=\",{\"1\":{\"11\":2,\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"21\":2,\"23\":2,\"25\":2,\"27\":2,\"30\":2,\"32\":2,\"34\":2,\"36\":2,\"37\":1,\"38\":2,\"40\":2,\"42\":2,\"44\":4,\"46\":4,\"48\":4,\"50\":4,\"52\":2,\"53\":4,\"55\":2,\"56\":2,\"57\":2,\"59\":2,\"61\":2,\"65\":4,\"67\":4,\"69\":5,\"70\":1,\"71\":4,\"78\":2,\"79\":2,\"80\":2,\"81\":2,\"82\":4,\"83\":1,\"84\":2,\"86\":2,\"87\":1,\"88\":2,\"89\":2,\"91\":3,\"93\":2,\"94\":4,\"96\":5,\"98\":8,\"100\":6,\"102\":6,\"103\":3,\"104\":6,\"105\":1,\"106\":6,\"107\":1,\"108\":2,\"109\":2,\"110\":6,\"111\":1,\"112\":4,\"114\":4,\"116\":2,\"119\":4,\"121\":4,\"123\":4,\"125\":6,\"127\":4,\"129\":4,\"132\":4,\"134\":5,\"136\":4,\"137\":2,\"138\":2,\"139\":1,\"140\":4,\"141\":2,\"142\":4,\"145\":4,\"146\":5,\"147\":2,\"149\":2,\"150\":2,\"151\":2,\"152\":6,\"154\":2,\"155\":2,\"156\":2,\"161\":2,\"164\":4,\"166\":4,\"169\":2,\"172\":2,\"174\":6,\"176\":4,\"178\":7,\"186\":4,\"187\":2,\"188\":1,\"189\":4,\"190\":2,\"191\":1,\"192\":2,\"194\":6,\"196\":6,\"198\":2,\"200\":2,\"201\":2,\"202\":4,\"204\":4,\"206\":4,\"208\":4,\"210\":4,\"212\":2,\"214\":2,\"217\":2,\"223\":3,\"225\":2,\"227\":2,\"229\":2,\"231\":2,\"233\":4,\"240\":8,\"244\":2,\"246\":2,\"249\":2,\"251\":1,\"253\":1,\"255\":2,\"257\":4,\"260\":2,\"261\":1,\"270\":1,\"271\":4,\"273\":6,\"274\":3,\"275\":6,\"276\":8,\"277\":11,\"283\":1,\"290\":4,\"294\":5,\"295\":1,\"296\":2,\"297\":4,\"303\":6,\"304\":1,\"306\":2,\"309\":2,\"311\":1,\"312\":4,\"315\":4,\"321\":2,\"324\":2,\"327\":2,\"330\":2,\"333\":6,\"336\":2,\"343\":6,\"345\":4,\"347\":4,\"348\":2,\"349\":4,\"350\":1,\"351\":6,\"353\":6,\"355\":4,\"357\":2,\"359\":4,\"361\":5,\"363\":4,\"365\":4,\"367\":2,\"369\":3,\"376\":4,\"379\":2,\"380\":2,\"383\":8,\"385\":2,\"388\":6,\"390\":8,\"393\":2,\"550\":3,\"578\":1,\"579\":1}}],[\"s型记录锁\",{\"1\":{\"775\":1}}],[\"s锁\",{\"1\":{\"770\":2,\"771\":1}}],[\"smallint\",{\"1\":{\"593\":1,\"595\":1,\"598\":2}}],[\"sms\",{\"1\":{\"399\":1}}],[\"snapshot\",{\"1\":{\"744\":1}}],[\"snapshot<\",{\"1\":{\"402\":1,\"432\":1,\"441\":1}}],[\"sn为一个字符串\",{\"1\":{\"552\":1}}],[\"sn\",{\"1\":{\"552\":4}}],[\"sqrt\",{\"1\":{\"548\":1}}],[\"sql99\",{\"1\":{\"835\":7}}],[\"sql92\",{\"1\":{\"835\":8}}],[\"sql即可恢复单个库\",{\"1\":{\"832\":1}}],[\"sql尽可能通过索引定位更少的行\",{\"1\":{\"786\":1}}],[\"sql标准\",{\"1\":{\"746\":2,\"764\":1}}],[\"sql语句\",{\"1\":{\"823\":1}}],[\"sql语句→查询缓存→解析器→优化器→执行器\",{\"1\":{\"634\":1}}],[\"sql语句在语法解析之后\",{\"1\":{\"629\":1}}],[\"sql执行流程\",{\"0\":{\"634\":1}}],[\"sql接口\",{\"0\":{\"627\":1}}],[\"sql的执行顺序\",{\"1\":{\"565\":1}}],[\"sql的完整结构及执行原理\",{\"0\":{\"565\":1}}],[\"sql的分类\",{\"0\":{\"517\":1}}],[\"sql规范以约束的方式对表数据进行额外的条件限制\",{\"1\":{\"612\":1}}],[\"sql规范\",{\"0\":{\"518\":1}}],[\"sql就是关系型数据库的查询语句\",{\"1\":{\"509\":1}}],[\"sqlstatement=\",{\"1\":{\"431\":3,\"442\":1}}],[\"sql\",{\"0\":{\"516\":1},\"1\":{\"428\":1,\"431\":4,\"436\":6,\"508\":1,\"516\":5,\"518\":2,\"565\":1,\"568\":1,\"599\":3,\"618\":1,\"628\":1,\"629\":1,\"633\":3,\"634\":6,\"696\":1,\"700\":1,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"725\":1,\"728\":1,\"729\":1,\"786\":2,\"806\":1,\"809\":4,\"811\":1,\"820\":1,\"831\":14,\"832\":12,\"835\":16}}],[\"sql来源\",{\"1\":{\"428\":1,\"431\":1}}],[\"shared\",{\"1\":{\"771\":1}}],[\"share\",{\"1\":{\"767\":2,\"771\":1,\"791\":1}}],[\"sha3\",{\"1\":{\"658\":1}}],[\"sha2\",{\"1\":{\"658\":1}}],[\"sha1\",{\"1\":{\"658\":1}}],[\"shanghai\",{\"1\":{\"492\":4}}],[\"short\",{\"1\":{\"636\":1}}],[\"shortcutfieldorder\",{\"1\":{\"497\":2,\"504\":2}}],[\"show等\",{\"1\":{\"808\":1}}],[\"show\",{\"1\":{\"585\":1,\"586\":3,\"615\":1,\"618\":1,\"635\":2,\"687\":1,\"694\":1,\"695\":2,\"696\":2,\"698\":2,\"741\":1,\"745\":1,\"746\":1,\"751\":1,\"806\":1,\"807\":1,\"809\":4,\"822\":1,\"826\":1}}],[\"sysdate\",{\"1\":{\"554\":1}}],[\"systemctl\",{\"1\":{\"635\":1,\"822\":1,\"824\":1}}],[\"system系统保护规则\",{\"1\":{\"419\":1}}],[\"system\",{\"1\":{\"39\":3,\"83\":1,\"91\":2,\"92\":1,\"103\":1,\"105\":1,\"280\":1,\"410\":1,\"419\":1,\"432\":4,\"443\":1,\"444\":4,\"445\":1,\"464\":2,\"481\":2,\"503\":3,\"504\":1,\"704\":4}}],[\"sync\",{\"1\":{\"474\":1,\"810\":1}}],[\"ss\",{\"1\":{\"444\":3}}],[\"src\",{\"1\":{\"442\":6,\"542\":3}}],[\"slave1\",{\"1\":{\"825\":4}}],[\"slave\",{\"1\":{\"820\":6,\"822\":3,\"823\":1,\"825\":2,\"826\":3,\"827\":1}}],[\"slidingwindowsize\",{\"1\":{\"477\":1,\"478\":1}}],[\"slidingwindowtype\",{\"1\":{\"477\":1,\"478\":1}}],[\"sliding\",{\"1\":{\"476\":3}}],[\"sleep\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"slf4j\",{\"1\":{\"432\":1,\"433\":1,\"434\":1,\"445\":1,\"503\":1}}],[\"slowcalldurationthreshold\",{\"1\":{\"476\":1,\"478\":1}}],[\"slowcallratethreshold\",{\"1\":{\"476\":1,\"478\":1}}],[\"slowratiothreshold\",{\"1\":{\"419\":1}}],[\"slow++\",{\"1\":{\"280\":1}}],[\"slow\",{\"1\":{\"279\":3,\"280\":6,\"476\":2,\"698\":5,\"699\":5}}],[\"slow指针\",{\"1\":{\"279\":1}}],[\"svg\",{\"1\":{\"429\":1}}],[\"san等各种存储系统\",{\"1\":{\"632\":1}}],[\"sand\",{\"1\":{\"110\":1}}],[\"sal\",{\"1\":{\"534\":2}}],[\"salary和其department\",{\"1\":{\"579\":2}}],[\"salary>=8000\",{\"1\":{\"559\":1}}],[\"salary>=10000\",{\"1\":{\"559\":1}}],[\"salary>=15000\",{\"1\":{\"559\":1}}],[\"salary\",{\"1\":{\"521\":2,\"522\":5,\"523\":2,\"534\":2,\"559\":1,\"562\":5,\"563\":1,\"564\":4,\"569\":7,\"573\":3,\"574\":3,\"578\":23,\"579\":18,\"587\":2}}],[\"savepoint\",{\"1\":{\"517\":1}}],[\"sampling\",{\"1\":{\"486\":1}}],[\"saga\",{\"1\":{\"426\":1}}],[\"sc\",{\"1\":{\"454\":3}}],[\"schema\",{\"1\":{\"613\":1,\"615\":1,\"618\":1,\"635\":1}}],[\"schema数据库名\",{\"1\":{\"613\":1}}],[\"schemalocation=\",{\"1\":{\"441\":1}}],[\"schedulerx\",{\"1\":{\"399\":2}}],[\"script\",{\"1\":{\"428\":2,\"431\":1}}],[\"scg\",{\"1\":{\"422\":2}}],[\"scope>\",{\"1\":{\"399\":1,\"402\":2,\"423\":1,\"432\":2,\"441\":4,\"442\":1,\"443\":2,\"486\":1}}],[\"specifier\",{\"1\":{\"617\":1}}],[\"specific\",{\"1\":{\"429\":1}}],[\"spatial\",{\"1\":{\"687\":4}}],[\"space部分的空间全部被user\",{\"1\":{\"670\":1}}],[\"space部分\",{\"1\":{\"670\":1}}],[\"space\",{\"0\":{\"670\":1},\"1\":{\"552\":1,\"667\":1,\"668\":2}}],[\"spans\",{\"1\":{\"486\":1}}],[\"span标识发起的请求信息\",{\"1\":{\"484\":1}}],[\"splunk\",{\"1\":{\"510\":1}}],[\"split\",{\"1\":{\"245\":1,\"248\":6}}],[\"spi\",{\"1\":{\"406\":2}}],[\"springmvc\",{\"1\":{\"498\":1}}],[\"springdoc\",{\"1\":{\"491\":1}}],[\"springdoc<\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"springapplication\",{\"1\":{\"403\":1,\"432\":1,\"443\":1,\"446\":2,\"463\":1,\"464\":1,\"489\":1}}],[\"springboot集成mybatis\",{\"1\":{\"441\":1}}],[\"springboot集成druid连接池\",{\"1\":{\"432\":1,\"441\":1,\"443\":1}}],[\"springboot\",{\"1\":{\"420\":1,\"441\":4}}],[\"springbootapplication\",{\"1\":{\"403\":1,\"432\":1,\"443\":1,\"446\":2,\"463\":1,\"464\":1,\"489\":1}}],[\"springboot通用依赖模块\",{\"1\":{\"402\":1,\"443\":1}}],[\"springframework\",{\"1\":{\"402\":8,\"403\":1,\"422\":4,\"423\":1,\"432\":5,\"441\":3,\"442\":2,\"443\":4,\"446\":3,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"477\":2,\"489\":4}}],[\"spring\",{\"1\":{\"399\":24,\"402\":2,\"403\":11,\"404\":2,\"406\":1,\"407\":2,\"408\":1,\"410\":1,\"419\":3,\"420\":3,\"421\":2,\"422\":5,\"423\":2,\"429\":2,\"432\":5,\"441\":12,\"443\":4,\"444\":1,\"450\":2,\"452\":6,\"453\":1,\"458\":3,\"462\":2,\"464\":3,\"466\":2,\"468\":1,\"469\":1,\"477\":1,\"488\":2,\"489\":2,\"491\":5,\"492\":3,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":3,\"504\":1}}],[\"springcloud版本太高\",{\"1\":{\"420\":1}}],[\"springcloud\",{\"0\":{\"398\":1,\"439\":1},\"1\":{\"408\":1,\"441\":2,\"452\":1,\"454\":2,\"457\":1},\"2\":{\"438\":1,\"506\":1}}],[\"sz\",{\"1\":{\"388\":3}}],[\"s的索引\",{\"1\":{\"344\":1}}],[\"swagger测试\",{\"1\":{\"443\":1}}],[\"swagger\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"swagger3\",{\"1\":{\"432\":1,\"441\":3,\"443\":1,\"446\":1}}],[\"swappairs\",{\"1\":{\"387\":3}}],[\"swap\",{\"1\":{\"31\":3}}],[\"switch\",{\"1\":{\"332\":1}}],[\"s3cur1tyc0d3\",{\"1\":{\"255\":1}}],[\"s+\",{\"1\":{\"245\":2,\"248\":1}}],[\"s中可能会存在前导空格\",{\"1\":{\"244\":1}}],[\"s中前\",{\"1\":{\"146\":1}}],[\"sjc\",{\"1\":{\"212\":2}}],[\"sfo\",{\"1\":{\"212\":10}}],[\"sbr缺点\",{\"1\":{\"823\":1}}],[\"sbr优点\",{\"1\":{\"823\":1}}],[\"sbr\",{\"1\":{\"823\":2}}],[\"sb\",{\"1\":{\"193\":12}}],[\"sb保存字母\",{\"1\":{\"193\":2}}],[\"s串的末尾\",{\"1\":{\"201\":1}}],[\"s串的末尾时\",{\"1\":{\"199\":1}}],[\"s串的分割点\",{\"1\":{\"111\":1}}],[\"s串中出现字符的次数累加\",{\"1\":{\"163\":1}}],[\"sign\",{\"1\":{\"548\":1}}],[\"site\",{\"1\":{\"499\":2}}],[\"silver\",{\"1\":{\"497\":1}}],[\"simpleuuid\",{\"1\":{\"477\":1}}],[\"simple\",{\"1\":{\"423\":1,\"701\":2}}],[\"sink\",{\"1\":{\"807\":1}}],[\"sin\",{\"1\":{\"549\":1}}],[\"singletonlist\",{\"1\":{\"497\":1}}],[\"singly\",{\"1\":{\"384\":1}}],[\"sindex++\",{\"1\":{\"146\":1}}],[\"sindex后移\",{\"1\":{\"146\":1}}],[\"sindex\",{\"1\":{\"146\":6}}],[\"sindex指向\",{\"1\":{\"146\":1}}],[\"size=200m\",{\"1\":{\"823\":1}}],[\"size=100m\",{\"1\":{\"809\":1}}],[\"size$\",{\"1\":{\"188\":1}}],[\"size\",{\"1\":{\"12\":3,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":3,\"28\":3,\"33\":1,\"35\":3,\"43\":1,\"56\":1,\"60\":2,\"99\":7,\"103\":1,\"137\":2,\"187\":2,\"188\":8,\"190\":2,\"191\":3,\"193\":2,\"195\":2,\"197\":1,\"199\":2,\"201\":6,\"203\":2,\"205\":1,\"207\":6,\"209\":4,\"211\":2,\"213\":6,\"224\":2,\"296\":4,\"321\":1,\"469\":1,\"476\":2,\"481\":2,\"751\":2,\"809\":2}}],[\"skipb\",{\"1\":{\"390\":6}}],[\"skipa\",{\"1\":{\"390\":6}}],[\"sky\",{\"1\":{\"244\":2}}],[\"sk\",{\"1\":{\"145\":1}}],[\"s1表中key1字段真实存在的数据\",{\"1\":{\"710\":1}}],[\"s1\",{\"1\":{\"145\":1,\"163\":2,\"552\":10,\"701\":2,\"702\":1,\"704\":12,\"705\":1,\"707\":2,\"708\":1,\"709\":3,\"710\":19}}],[\"s2的ascii码值的大小\",{\"1\":{\"552\":1}}],[\"s2\",{\"1\":{\"111\":1,\"145\":1,\"163\":2,\"552\":8,\"701\":2,\"702\":1,\"704\":4,\"707\":2,\"709\":2,\"710\":5}}],[\"s2为\",{\"1\":{\"111\":1}}],[\"subquery是针对在一些包含in子查询的查询语句中\",{\"1\":{\"704\":1}}],[\"subquery的查询可能会被执行多次\",{\"1\":{\"703\":1}}],[\"subquery\",{\"1\":{\"703\":1,\"704\":6}}],[\"subtime\",{\"1\":{\"557\":3}}],[\"subdate\",{\"1\":{\"557\":1}}],[\"sub\",{\"1\":{\"557\":2}}],[\"substr\",{\"1\":{\"552\":4}}],[\"substring\",{\"1\":{\"111\":5,\"199\":7,\"201\":6,\"245\":1,\"256\":4,\"262\":1}}],[\"subsetswithdup\",{\"1\":{\"205\":1}}],[\"subsets\",{\"1\":{\"203\":1}}],[\"sunday\",{\"1\":{\"555\":1}}],[\"suppression\",{\"1\":{\"807\":1}}],[\"supplyasync\",{\"1\":{\"481\":2}}],[\"supremum\",{\"0\":{\"672\":1}}],[\"super\",{\"1\":{\"497\":1,\"504\":1}}],[\"success\",{\"1\":{\"432\":1,\"433\":1,\"434\":1,\"444\":2,\"454\":1}}],[\"such\",{\"1\":{\"431\":3}}],[\"sum++\",{\"1\":{\"346\":2}}],[\"sum+=1\",{\"1\":{\"35\":1}}],[\"sum值用于记录摆动的个数\",{\"1\":{\"346\":1}}],[\"sum=\",{\"1\":{\"177\":1}}],[\"sum将无法满足\",{\"1\":{\"99\":1}}],[\"sum已知\",{\"1\":{\"99\":1}}],[\"sumofleftleaves\",{\"1\":{\"41\":2}}],[\"sum\",{\"1\":{\"18\":3,\"35\":2,\"41\":6,\"44\":1,\"45\":4,\"73\":2,\"95\":4,\"97\":9,\"98\":1,\"99\":9,\"171\":11,\"175\":2,\"177\":3,\"190\":13,\"191\":7,\"195\":16,\"197\":6,\"259\":3,\"286\":5,\"293\":5,\"346\":2,\"354\":1,\"360\":1,\"562\":3}}],[\"s\",{\"1\":{\"110\":7,\"111\":10,\"145\":6,\"146\":13,\"147\":8,\"148\":16,\"153\":12,\"154\":5,\"155\":12,\"156\":5,\"157\":13,\"161\":8,\"162\":1,\"163\":7,\"193\":2,\"198\":7,\"199\":20,\"200\":8,\"201\":24,\"244\":8,\"245\":11,\"246\":10,\"248\":2,\"249\":5,\"251\":6,\"252\":3,\"254\":3,\"260\":6,\"261\":11,\"262\":5,\"324\":6,\"326\":5,\"327\":4,\"329\":4,\"343\":6,\"344\":5,\"367\":6,\"368\":2,\"370\":3,\"552\":19,\"558\":2,\"599\":1,\"607\":4,\"624\":1,\"694\":1,\"699\":6,\"767\":1,\"771\":1}}],[\"song\",{\"1\":{\"680\":1}}],[\"songhk\",{\"1\":{\"608\":1,\"676\":1}}],[\"software\",{\"1\":{\"429\":1,\"454\":2}}],[\"sources\",{\"1\":{\"495\":1}}],[\"sourceencoding>\",{\"1\":{\"441\":1}}],[\"sourceencoding>utf\",{\"1\":{\"441\":1}}],[\"source>\",{\"1\":{\"441\":1}}],[\"source>17<\",{\"1\":{\"441\":1}}],[\"source\",{\"1\":{\"424\":2,\"432\":1,\"832\":2}}],[\"sol语句\",{\"1\":{\"624\":1}}],[\"solr\",{\"1\":{\"510\":1}}],[\"solve\",{\"1\":{\"232\":2}}],[\"solvesudoku\",{\"1\":{\"217\":1}}],[\"solvenqueens\",{\"1\":{\"215\":1}}],[\"solution\",{\"1\":{\"12\":2,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"31\":2,\"35\":1,\"37\":1,\"39\":1,\"41\":2,\"49\":1,\"87\":1,\"89\":1,\"95\":1,\"101\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":2,\"117\":1,\"120\":1,\"122\":1,\"124\":1,\"126\":1,\"128\":1,\"135\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":1,\"155\":1,\"157\":1,\"217\":1,\"224\":1,\"226\":1,\"230\":2,\"232\":2,\"234\":1,\"275\":1,\"277\":1,\"299\":1,\"305\":1,\"314\":1,\"335\":1,\"344\":1,\"346\":1,\"368\":1,\"372\":1,\"384\":1}}],[\"sorted\",{\"1\":{\"354\":1}}],[\"sortedsquares\",{\"1\":{\"283\":2}}],[\"sortedarraytobst\",{\"1\":{\"72\":1}}],[\"sort\",{\"1\":{\"163\":2,\"165\":1,\"177\":2,\"179\":1,\"197\":1,\"205\":1,\"211\":1,\"213\":1,\"259\":1,\"283\":1,\"296\":1,\"344\":2,\"362\":1,\"364\":2,\"366\":1,\"704\":1,\"710\":1}}],[\"sed\",{\"1\":{\"832\":2}}],[\"session级别\",{\"1\":{\"809\":1}}],[\"session\",{\"1\":{\"746\":10,\"809\":1}}],[\"self\",{\"1\":{\"513\":1}}],[\"selectall\",{\"1\":{\"443\":1}}],[\"selectbyprimarykey\",{\"1\":{\"432\":1,\"443\":1}}],[\"selectone\",{\"1\":{\"432\":1}}],[\"select\",{\"0\":{\"703\":1},\"1\":{\"117\":4,\"431\":3,\"440\":1,\"517\":1,\"520\":5,\"521\":1,\"522\":3,\"523\":1,\"524\":1,\"525\":1,\"527\":1,\"528\":2,\"529\":1,\"533\":5,\"534\":1,\"536\":1,\"538\":2,\"539\":2,\"540\":2,\"541\":9,\"542\":1,\"548\":2,\"554\":2,\"557\":3,\"558\":3,\"559\":3,\"562\":5,\"563\":2,\"564\":2,\"565\":4,\"568\":1,\"569\":5,\"573\":7,\"574\":2,\"575\":2,\"578\":13,\"579\":10,\"587\":2,\"607\":1,\"608\":1,\"613\":1,\"615\":1,\"618\":1,\"634\":1,\"651\":1,\"675\":1,\"689\":1,\"696\":2,\"700\":4,\"701\":2,\"702\":2,\"703\":3,\"704\":11,\"705\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":18,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"726\":4,\"727\":1,\"728\":1,\"729\":4,\"746\":1,\"767\":4,\"771\":4,\"772\":1,\"777\":1,\"791\":4,\"799\":3,\"800\":2,\"819\":1,\"823\":1}}],[\"segment也会被系统回收\",{\"1\":{\"794\":1}}],[\"segment\",{\"1\":{\"502\":2}}],[\"semaphore\",{\"1\":{\"480\":3}}],[\"semaphorebulkhead\",{\"0\":{\"480\":1}}],[\"semaphorebulkhead使用了信号量\",{\"1\":{\"479\":1}}],[\"separator\",{\"1\":{\"452\":2}}],[\"ser\",{\"1\":{\"731\":1}}],[\"serializable\",{\"1\":{\"443\":1,\"746\":3,\"797\":1}}],[\"serialization\",{\"1\":{\"431\":3}}],[\"servlet中的过滤器一个意思\",{\"1\":{\"498\":1}}],[\"server的uuid相同\",{\"1\":{\"822\":1}}],[\"server层\",{\"1\":{\"770\":1}}],[\"serverhttprequest\",{\"1\":{\"504\":1}}],[\"servertimezone=gmt\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"servers\",{\"1\":{\"429\":1}}],[\"servercodecconfigurer\",{\"1\":{\"423\":7}}],[\"serverwebexchange\",{\"1\":{\"422\":1,\"423\":1,\"497\":3,\"503\":1,\"504\":1}}],[\"serverresponse\",{\"1\":{\"422\":2,\"423\":1}}],[\"serverresponse$bodybuilder\",{\"1\":{\"422\":1}}],[\"servername=test1\",{\"1\":{\"418\":1}}],[\"servername=test2\",{\"1\":{\"418\":1}}],[\"servername\",{\"1\":{\"418\":2}}],[\"serverurl\",{\"1\":{\"402\":2}}],[\"serverport\",{\"1\":{\"402\":3}}],[\"server\",{\"1\":{\"402\":5,\"403\":4,\"404\":4,\"408\":2,\"419\":2,\"420\":1,\"422\":4,\"427\":1,\"428\":1,\"429\":8,\"431\":3,\"432\":4,\"443\":1,\"445\":1,\"446\":1,\"452\":1,\"454\":1,\"464\":1,\"485\":1,\"489\":1,\"508\":1,\"624\":1,\"634\":1,\"635\":2,\"809\":2,\"822\":2,\"823\":1,\"824\":1}}],[\"services\",{\"1\":{\"807\":1}}],[\"service2003\",{\"1\":{\"435\":1}}],[\"service中扣减账户余额结束\",{\"1\":{\"434\":1}}],[\"service中扣减账户余额开始\",{\"1\":{\"434\":1}}],[\"service中扣减库存结束\",{\"1\":{\"433\":1}}],[\"service中扣减库存开始\",{\"1\":{\"433\":1}}],[\"serviceimpl\",{\"1\":{\"432\":1}}],[\"service\",{\"1\":{\"399\":1,\"402\":4,\"408\":1,\"410\":1,\"428\":1,\"429\":1,\"431\":2,\"432\":5,\"433\":1,\"434\":1,\"443\":1,\"450\":2,\"451\":2,\"452\":3,\"459\":1,\"460\":1,\"464\":3,\"466\":1,\"477\":2,\"478\":1,\"480\":2,\"481\":2,\"482\":2,\"489\":3,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":1,\"635\":1,\"824\":2}}],[\"sec\",{\"1\":{\"556\":2,\"701\":1,\"745\":1,\"767\":2,\"771\":4,\"806\":1,\"807\":1,\"809\":1,\"832\":2}}],[\"secondary\",{\"1\":{\"728\":1}}],[\"second\",{\"1\":{\"555\":1,\"557\":1}}],[\"seconds=6000\",{\"1\":{\"823\":1}}],[\"seconds=600\",{\"1\":{\"809\":1}}],[\"seconds\",{\"1\":{\"434\":1,\"477\":1,\"481\":1,\"556\":2}}],[\"secretkey\",{\"1\":{\"429\":1}}],[\"security\",{\"1\":{\"429\":1}}],[\"see\",{\"1\":{\"429\":1}}],[\"sentinelproperties\",{\"1\":{\"424\":3}}],[\"sentinelpersistenceconfig\",{\"1\":{\"424\":3}}],[\"sentinelgatewayfilter\",{\"1\":{\"423\":2}}],[\"sentinelgatewayblockexceptionhandler\",{\"1\":{\"423\":3}}],[\"sentinelguard\",{\"1\":{\"405\":1}}],[\"sentinel+gataway整合case\",{\"1\":{\"422\":1,\"423\":1}}],[\"sentinel的依赖\",{\"1\":{\"422\":1}}],[\"sentinel的授权规则能够根据请求的来源判断是否允许本次请求通过\",{\"1\":{\"418\":1}}],[\"sentinel整合gateway第二种方式\",{\"1\":{\"423\":1}}],[\"sentinel整合gateway\",{\"0\":{\"421\":1}}],[\"sentinel上的流控规则持续有效\",{\"1\":{\"419\":1}}],[\"sentinel规则将消失\",{\"1\":{\"419\":1}}],[\"sentinel授权规则\",{\"1\":{\"418\":1}}],[\"sentinel配置自定义限流了\",{\"1\":{\"416\":2}}],[\"sentinelresource\",{\"0\":{\"416\":1},\"1\":{\"410\":1,\"416\":5,\"417\":1}}],[\"sentinel能够对流量进行控制\",{\"1\":{\"409\":1}}],[\"sentinel<\",{\"1\":{\"408\":1,\"422\":1}}],[\"sentinel\",{\"0\":{\"405\":1,\"420\":1},\"1\":{\"399\":1,\"405\":2,\"406\":7,\"407\":3,\"408\":4,\"410\":1,\"419\":1,\"420\":4,\"421\":3,\"422\":9},\"2\":{\"438\":1}}],[\"season\",{\"1\":{\"606\":2}}],[\"seataordermainapp2001\",{\"1\":{\"432\":2}}],[\"seata<\",{\"1\":{\"432\":1}}],[\"seatasecretkey0c382ef121d778043159209298fd40bf3850a017\",{\"1\":{\"429\":1}}],[\"seata就会帮我们管理分布式事务\",{\"1\":{\"426\":1}}],[\"seata\",{\"0\":{\"425\":1,\"436\":1},\"1\":{\"399\":1,\"426\":5,\"427\":2,\"428\":3,\"429\":11,\"431\":21,\"432\":7,\"435\":1,\"436\":2},\"2\":{\"438\":1}}],[\"sea\",{\"1\":{\"149\":2,\"150\":1}}],[\"searchrange\",{\"1\":{\"275\":2}}],[\"searchinsert\",{\"1\":{\"273\":2}}],[\"search\",{\"1\":{\"73\":1,\"271\":2,\"277\":1}}],[\"searchbst3\",{\"1\":{\"54\":1}}],[\"searchbst2\",{\"1\":{\"54\":3}}],[\"searchbst1\",{\"1\":{\"54\":3}}],[\"searchbst\",{\"1\":{\"54\":1}}],[\"set类型在选取成员时\",{\"1\":{\"607\":1}}],[\"set类型在存储数据时成员个数越多\",{\"1\":{\"607\":1}}],[\"setpath=\",{\"1\":{\"502\":1}}],[\"setpath\",{\"1\":{\"502\":2}}],[\"setresponseheader\",{\"1\":{\"501\":1}}],[\"setrequestheader=sec\",{\"1\":{\"499\":1}}],[\"setrequestheader\",{\"1\":{\"499\":1}}],[\"setter\",{\"1\":{\"497\":1,\"504\":1}}],[\"setdata\",{\"1\":{\"444\":1}}],[\"setmessage\",{\"1\":{\"444\":2}}],[\"setcomplete\",{\"1\":{\"504\":1}}],[\"setcode\",{\"1\":{\"444\":2}}],[\"setcount\",{\"1\":{\"423\":1}}],[\"setstatuscode\",{\"1\":{\"504\":1}}],[\"setstatus\",{\"1\":{\"432\":2}}],[\"setintervalsec\",{\"1\":{\"423\":1}}],[\"setblockhandler\",{\"1\":{\"422\":1,\"423\":1}}],[\"setzeroes\",{\"1\":{\"302\":1}}],[\"set集合\",{\"1\":{\"218\":1}}],[\"set<gatewayflowrule>>\",{\"1\":{\"424\":1}}],[\"set<gatewayflowrule>\",{\"1\":{\"423\":1}}],[\"set<list<integer>>\",{\"1\":{\"177\":1}}],[\"set<integer>\",{\"1\":{\"168\":2,\"171\":2}}],[\"set2\",{\"1\":{\"168\":3}}],[\"set1\",{\"1\":{\"168\":4}}],[\"set\",{\"0\":{\"607\":1},\"1\":{\"111\":2,\"167\":1,\"170\":2,\"171\":6,\"175\":1,\"177\":1,\"207\":6,\"267\":2,\"433\":1,\"434\":1,\"542\":1,\"552\":1,\"585\":1,\"586\":1,\"589\":1,\"599\":1,\"603\":1,\"607\":6,\"618\":2,\"635\":1,\"698\":3,\"701\":1,\"745\":2,\"746\":2,\"767\":1,\"771\":2,\"791\":1,\"806\":3,\"807\":1,\"809\":4}}],[\"sequence\",{\"1\":{\"39\":2,\"668\":1}}],[\"stu\",{\"1\":{\"831\":2}}],[\"student\",{\"1\":{\"618\":1,\"689\":1,\"696\":4,\"715\":6,\"716\":1,\"717\":3,\"718\":6,\"719\":4,\"720\":4,\"721\":4,\"726\":4,\"728\":3,\"777\":1,\"791\":5,\"800\":5,\"831\":4,\"837\":4}}],[\"stops\",{\"1\":{\"822\":1}}],[\"stop\",{\"1\":{\"809\":5,\"824\":2,\"827\":1}}],[\"storeid\",{\"1\":{\"463\":5}}],[\"storeclient\",{\"1\":{\"463\":1}}],[\"stores\",{\"1\":{\"463\":6}}],[\"store\",{\"1\":{\"428\":3,\"429\":1,\"463\":3}}],[\"storemode\",{\"1\":{\"428\":1}}],[\"storagecontroller\",{\"1\":{\"433\":2}}],[\"storageserviceimpl\",{\"1\":{\"433\":2}}],[\"storageservice\",{\"1\":{\"433\":6}}],[\"storagemapper\",{\"1\":{\"433\":4}}],[\"storagefeignapi\",{\"1\":{\"431\":1,\"432\":3}}],[\"storage\",{\"0\":{\"433\":1},\"1\":{\"399\":1,\"431\":11,\"433\":2,\"631\":1,\"635\":3}}],[\"stones\",{\"1\":{\"96\":6,\"97\":9}}],[\"step++\",{\"1\":{\"352\":1}}],[\"step\",{\"1\":{\"352\":3}}],[\"standalone\",{\"1\":{\"401\":1}}],[\"statement无法完成主从复制的操作\",{\"1\":{\"823\":1}}],[\"statement\",{\"1\":{\"823\":1}}],[\"statement模式\",{\"1\":{\"823\":1}}],[\"state\",{\"1\":{\"476\":2}}],[\"statintervalms\",{\"1\":{\"419\":1}}],[\"static\",{\"1\":{\"51\":1,\"91\":2,\"92\":1,\"163\":2,\"168\":1,\"171\":4,\"175\":2,\"177\":2,\"179\":1,\"242\":1,\"245\":2,\"251\":1,\"254\":2,\"256\":3,\"259\":1,\"268\":1,\"271\":2,\"273\":1,\"280\":1,\"283\":2,\"286\":1,\"289\":1,\"293\":1,\"296\":1,\"298\":1,\"302\":1,\"308\":1,\"311\":1,\"326\":1,\"329\":1,\"332\":1,\"338\":1,\"378\":1,\"382\":1,\"387\":1,\"389\":1,\"392\":1,\"395\":1,\"403\":1,\"432\":1,\"434\":1,\"443\":1,\"444\":5,\"446\":3,\"451\":1,\"463\":1,\"464\":1,\"489\":1,\"497\":1,\"503\":1,\"504\":1}}],[\"status语句语法如下\",{\"1\":{\"695\":1}}],[\"status语句查询一些mysql数据库服务器的\",{\"1\":{\"695\":1}}],[\"status`\",{\"1\":{\"428\":1,\"431\":3}}],[\"status\",{\"1\":{\"117\":3,\"422\":3,\"423\":1,\"428\":1,\"431\":6,\"432\":1,\"502\":2,\"504\":3,\"694\":1,\"695\":1,\"696\":2,\"822\":1,\"826\":1}}],[\"start=\",{\"1\":{\"454\":1}}],[\"starter<\",{\"1\":{\"432\":2,\"441\":2,\"443\":2}}],[\"starter\",{\"1\":{\"402\":8,\"403\":2,\"408\":1,\"422\":3,\"423\":1,\"432\":8,\"441\":4,\"442\":1,\"443\":4,\"446\":3,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"477\":2,\"489\":4}}],[\"startup\",{\"1\":{\"401\":1}}],[\"starti\",{\"1\":{\"294\":2,\"365\":2}}],[\"startindex为每次回溯的起点\",{\"1\":{\"187\":1}}],[\"startindex\",{\"1\":{\"187\":5,\"188\":1,\"190\":6,\"191\":3,\"193\":9,\"195\":7,\"197\":4,\"199\":16,\"201\":12,\"203\":8,\"205\":6,\"207\":4,\"209\":2,\"211\":1}}],[\"start++\",{\"1\":{\"289\":1}}],[\"startcol\",{\"1\":{\"217\":6}}],[\"startrow+3\",{\"1\":{\"217\":2}}],[\"startrow\",{\"1\":{\"217\":4}}],[\"start\",{\"1\":{\"84\":1,\"199\":4,\"201\":12,\"275\":6,\"289\":8,\"356\":6,\"364\":6,\"366\":1,\"370\":3,\"384\":7,\"454\":3,\"744\":2,\"745\":1,\"757\":1,\"809\":5,\"826\":1}}],[\"stack<character>\",{\"1\":{\"326\":1,\"329\":1}}],[\"stack<integer>\",{\"1\":{\"323\":2,\"332\":1}}],[\"stack<object>\",{\"1\":{\"39\":1,\"45\":1}}],[\"stack<>\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"39\":2,\"41\":1,\"45\":1,\"323\":2,\"326\":1,\"329\":1,\"332\":1}}],[\"stack<treenode>\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"39\":1,\"41\":1}}],[\"stack\",{\"1\":{\"6\":6,\"7\":4,\"8\":6,\"39\":16,\"41\":6,\"45\":10,\"326\":5,\"329\":7,\"332\":15}}],[\"strcmp\",{\"1\":{\"552\":1}}],[\"strategy\",{\"1\":{\"419\":2}}],[\"str\",{\"1\":{\"101\":2,\"552\":10,\"558\":5}}],[\"strs\",{\"1\":{\"100\":7,\"101\":2,\"164\":6,\"165\":4}}],[\"stream流\",{\"1\":{\"267\":1}}],[\"stream\",{\"1\":{\"95\":1,\"97\":1,\"168\":1,\"268\":1,\"354\":2,\"360\":1,\"399\":1,\"424\":1,\"444\":1}}],[\"stringutil\",{\"1\":{\"497\":1}}],[\"string>\",{\"1\":{\"423\":1}}],[\"strings\",{\"1\":{\"215\":4}}],[\"stringbuilder\",{\"1\":{\"193\":3,\"248\":1,\"329\":2}}],[\"string\",{\"1\":{\"39\":5,\"91\":1,\"101\":2,\"111\":1,\"139\":2,\"146\":4,\"148\":2,\"150\":2,\"152\":2,\"155\":1,\"157\":1,\"163\":8,\"165\":3,\"193\":1,\"199\":7,\"201\":9,\"215\":1,\"245\":6,\"248\":4,\"254\":3,\"256\":7,\"262\":3,\"326\":1,\"329\":2,\"332\":2,\"368\":1,\"370\":3,\"402\":6,\"403\":3,\"410\":2,\"416\":7,\"417\":6,\"418\":2,\"419\":2,\"420\":2,\"432\":3,\"443\":5,\"444\":11,\"446\":3,\"451\":1,\"459\":2,\"463\":1,\"464\":3,\"477\":4,\"480\":2,\"482\":2,\"489\":1,\"497\":2,\"503\":1,\"504\":1}}],[\"structure\",{\"1\":{\"832\":2}}],[\"structured\",{\"1\":{\"516\":1}}],[\"struct\",{\"1\":{\"23\":1}}],[\"也正是在这两个标准发布之\",{\"1\":{\"835\":1}}],[\"也分别叫做\",{\"1\":{\"835\":1}}],[\"也减少了对后端数据库的\",{\"1\":{\"818\":1}}],[\"也要确保一次性写入\",{\"1\":{\"810\":1}}],[\"也要想办法通过应用层面的附加逻辑\",{\"1\":{\"618\":1}}],[\"也叫作变更日志\",{\"1\":{\"808\":1}}],[\"也只锁定必要的行\",{\"1\":{\"801\":1}}],[\"也能做到\",{\"1\":{\"791\":1}}],[\"也想对这条记录进行改动\",{\"1\":{\"763\":1}}],[\"也更加复杂\",{\"1\":{\"760\":1}}],[\"也需要更新索引\",{\"1\":{\"690\":1}}],[\"也必须建成唯一索引\",{\"1\":{\"689\":1}}],[\"也称为记录锁\",{\"1\":{\"774\":1}}],[\"也称为\",{\"1\":{\"767\":2}}],[\"也称为集合比较子查询\",{\"1\":{\"576\":1}}],[\"也称全文检索\",{\"1\":{\"686\":1}}],[\"也支持不使用文件系统直接管理裸设\",{\"1\":{\"632\":1}}],[\"也即是让请求以均匀的速度通过\",{\"1\":{\"411\":1}}],[\"也将不存在\",{\"1\":{\"403\":1}}],[\"也将被视为正确答案\",{\"1\":{\"71\":1}}],[\"也不可以继续获取x型记录锁\",{\"1\":{\"775\":1}}],[\"也不允许出现空值\",{\"1\":{\"616\":1}}],[\"也不会进入fallback逻辑\",{\"1\":{\"416\":1}}],[\"也不使用当前元素\",{\"1\":{\"207\":2}}],[\"也不符合递增\",{\"1\":{\"207\":2}}],[\"也加入到结果集当中\",{\"1\":{\"203\":1}}],[\"也会导致缓存和数据库的数据不一致\",{\"1\":{\"850\":1}}],[\"也会让孩子得到满足\",{\"1\":{\"344\":1}}],[\"也会被视作正确答案\",{\"1\":{\"278\":1}}],[\"也会被视作不同的子串\",{\"1\":{\"154\":1}}],[\"也会符合条件\",{\"1\":{\"201\":1}}],[\"也决定了有多少次循环\",{\"1\":{\"187\":1}}],[\"也就说对数据库读取数据的压力比较大\",{\"1\":{\"818\":1}}],[\"也就意味着这个页使用完了\",{\"1\":{\"670\":1}}],[\"也就\",{\"1\":{\"651\":1}}],[\"也就可以判断\",{\"1\":{\"211\":1}}],[\"也就找到了满足条件的一条答案\",{\"1\":{\"185\":1}}],[\"也就是所谓的\",{\"1\":{\"848\":1}}],[\"也就是所有可能中间位置下标最小的一个\",{\"1\":{\"290\":1}}],[\"也就是当服务器出现\",{\"1\":{\"819\":1}}],[\"也就是当前树的深度\",{\"1\":{\"193\":1}}],[\"也就是该undo日志占用的undo页面链表要么被重用\",{\"1\":{\"794\":1}}],[\"也就是不采用数据库自身的锁机制\",{\"1\":{\"782\":1}}],[\"也就是不考虑第i个元素\",{\"1\":{\"146\":1}}],[\"也就是避免了脏读现象\",{\"1\":{\"765\":1}}],[\"也就是事务\",{\"1\":{\"799\":1}}],[\"也就是事务需要等待\",{\"1\":{\"763\":1}}],[\"也就是事务可以继续执行操作\",{\"1\":{\"763\":1}}],[\"也就是事务中的操作要么全部完成\",{\"1\":{\"755\":1}}],[\"也就是undo\",{\"1\":{\"755\":1}}],[\"也就是属于该事务的数据库操作既可以读取数据\",{\"1\":{\"744\":1}}],[\"也就是属于该事务的数据库操作只能读取数据\",{\"1\":{\"744\":1}}],[\"也就是数据库恢复到了执行事务之前的状态\",{\"1\":{\"742\":1}}],[\"也就是先筛选出\",{\"1\":{\"728\":1}}],[\"也就是回表操作\",{\"1\":{\"728\":1}}],[\"也就是回溯\",{\"1\":{\"190\":2,\"191\":1}}],[\"也就是我们所讲的`基于块的嵌套循环算法`\",{\"1\":{\"710\":1}}],[\"也就是在statement和row之间选择一种\",{\"1\":{\"823\":1}}],[\"也就是在主库正常运行的情况下进行的备份\",{\"1\":{\"819\":1}}],[\"也就是在可以\",{\"1\":{\"710\":1}}],[\"也就是在同步的时候有没有发生只同步一半的尴尬情况\",{\"1\":{\"668\":1}}],[\"也就是尚未使用的存储空间中申请一个记录大小的空间划分到user\",{\"1\":{\"670\":1}}],[\"也就是一次最少从磁盘中读取16kb的内容到内存中\",{\"1\":{\"666\":1}}],[\"也就是一个节点度不能超过2\",{\"1\":{\"659\":1}}],[\"也就是聚簇索引的那棵b+树的叶子节点中已经把所有完整的用户记录都包含了而\",{\"1\":{\"654\":1}}],[\"也就是同时为多个列建立索引\",{\"1\":{\"652\":1}}],[\"也就是只相当于\",{\"1\":{\"599\":1}}],[\"也就是只有1个用于存放用户记录的节点\",{\"1\":{\"648\":1}}],[\"也就是只有\",{\"1\":{\"321\":1}}],[\"也就是department表中有16个部门没有员工\",{\"1\":{\"539\":1}}],[\"也就是第一个对象来自于\",{\"1\":{\"532\":1}}],[\"也就是调用方\",{\"1\":{\"477\":1}}],[\"也就是调用者\",{\"1\":{\"420\":1}}],[\"也就是实现这些方法的模块\",{\"1\":{\"463\":1}}],[\"也就是被调用者\",{\"1\":{\"420\":1}}],[\"也就是通过访问路径\",{\"1\":{\"416\":1}}],[\"也就是左右节点至少存在\",{\"1\":{\"372\":1}}],[\"也就是最小的值进行反转\",{\"1\":{\"354\":1}}],[\"也就是最后一行\",{\"1\":{\"304\":1}}],[\"也就是较小元素和较小元素组合\",{\"1\":{\"258\":1}}],[\"也就是o变成另外一个字符\",{\"1\":{\"232\":1}}],[\"也就是for循环中\",{\"1\":{\"209\":1}}],[\"也就是从每一层的第二个元素开始\",{\"1\":{\"205\":1}}],[\"也就是会陷入循环当中\",{\"1\":{\"170\":1}}],[\"也就是说一开始是没有锁结构和记录进行关联的\",{\"1\":{\"763\":1}}],[\"也就是说数据表中每个字段的值为\",{\"1\":{\"737\":1}}],[\"也就是说它们的位置最靠前\",{\"1\":{\"680\":1}}],[\"也就是说会将从表中不符合条件的行也查询出来\",{\"1\":{\"541\":1}}],[\"也就是说会将主表中不符合条件的行也查询出来\",{\"1\":{\"541\":1}}],[\"也就是说只能处理\",{\"1\":{\"411\":1}}],[\"也就是说净交易是每位顾客向你支付\",{\"1\":{\"357\":1}}],[\"也就是说无论从\",{\"1\":{\"356\":1}}],[\"也就是说转换之前的列\",{\"1\":{\"298\":1}}],[\"也就是说当\",{\"1\":{\"199\":1}}],[\"也就是说树的深度与数组字符串的长度相等\",{\"1\":{\"193\":1}}],[\"也就是说\",{\"1\":{\"125\":1,\"273\":2,\"278\":1,\"350\":1,\"597\":1,\"618\":1,\"666\":2,\"689\":1,\"737\":1}}],[\"也就是把\",{\"1\":{\"99\":1}}],[\"也就是\",{\"1\":{\"78\":1,\"261\":1,\"277\":2,\"384\":1,\"487\":1,\"539\":1,\"650\":1,\"661\":1,\"686\":1}}],[\"也就是这一层的结点数量\",{\"1\":{\"12\":1}}],[\"也可能会失败\",{\"1\":{\"853\":1}}],[\"也可能会有\",{\"1\":{\"737\":1}}],[\"也可能访问非叶子结点得到结果\",{\"1\":{\"662\":1}}],[\"也可能是某个集\",{\"1\":{\"568\":1}}],[\"也可能是mid前面版本出错\",{\"1\":{\"274\":1}}],[\"也可能是\",{\"1\":{\"169\":1}}],[\"也可以加写锁\",{\"1\":{\"767\":1}}],[\"也可以加在行上\",{\"1\":{\"767\":1}}],[\"也可以选择继续完成事务提交\",{\"1\":{\"757\":1}}],[\"也可以选择跳2步\",{\"1\":{\"350\":1}}],[\"也可以修改数据\",{\"1\":{\"744\":1}}],[\"也可以非常容易地通过接口进行数据的爬取\",{\"1\":{\"731\":1}}],[\"也可以直接\",{\"1\":{\"726\":1}}],[\"也可以指定外键约束名\",{\"1\":{\"618\":1}}],[\"也可以是唯一性索\",{\"1\":{\"686\":1}}],[\"也可以是多个字段\",{\"1\":{\"616\":1}}],[\"也可以是复杂的对象\",{\"1\":{\"510\":1}}],[\"也可以在表级别上创建\",{\"1\":{\"616\":1}}],[\"也可以在遍历过程中\",{\"1\":{\"58\":1}}],[\"也可以自定义唯一性约束名\",{\"1\":{\"615\":1}}],[\"也可以多个列组合的值唯一\",{\"1\":{\"615\":1}}],[\"也可以省略\",{\"1\":{\"520\":1}}],[\"也可以一起使用以构建全方位的服务网格\",{\"1\":{\"449\":1}}],[\"也可以通过配置项\",{\"1\":{\"403\":1}}],[\"也可以依据次序计算出正确结果\",{\"1\":{\"330\":1}}],[\"也可以先对数组进行排序\",{\"1\":{\"267\":1}}],[\"也可以视作递增序列的一种特殊情况\",{\"1\":{\"206\":1}}],[\"也可以用数组表示\",{\"1\":{\"193\":2}}],[\"也可以用优化的一维数组\",{\"1\":{\"91\":1}}],[\"也可以实现此算法\",{\"1\":{\"171\":1}}],[\"也可以将word1删除一个c\",{\"1\":{\"152\":1,\"153\":1}}],[\"也可以不删除\",{\"1\":{\"145\":1,\"345\":1}}],[\"也可以不删除任何字符\",{\"1\":{\"138\":1}}],[\"也可以使用bfs层序遍历实现\",{\"1\":{\"39\":1}}],[\"也没有用到\",{\"1\":{\"54\":1}}],[\"也没有返回false\",{\"1\":{\"33\":1}}],[\"也是有限的\",{\"1\":{\"646\":1}}],[\"也是最为重要的\",{\"1\":{\"517\":1}}],[\"也是最复杂的情况\",{\"1\":{\"68\":1}}],[\"也是冲突的\",{\"1\":{\"366\":1}}],[\"也是较为不好理解的代码\",{\"1\":{\"211\":1}}],[\"也是一个候选\",{\"1\":{\"194\":1}}],[\"也是可通过的\",{\"1\":{\"166\":1}}],[\"也是回文子串\",{\"1\":{\"155\":1,\"261\":1}}],[\"也是升序的子序列\",{\"1\":{\"134\":1}}],[\"也是要注意回溯的时机\",{\"1\":{\"39\":1}}],[\"也是从根结点开始处理\",{\"1\":{\"7\":1}}],[\"而实现重试机制有很多种方式\",{\"1\":{\"850\":1}}],[\"而缓存中是请求c更新的旧值\",{\"1\":{\"848\":1}}],[\"而我们在客户端读取数据的时候\",{\"1\":{\"819\":1}}],[\"而后面所有的\",{\"1\":{\"799\":1}}],[\"而readview帮我们判断是否可以读取\",{\"1\":{\"799\":1}}],[\"而非\",{\"1\":{\"791\":1}}],[\"而执行期间另一个线程对这个\",{\"1\":{\"773\":1}}],[\"而意向锁就是其中的一种\",{\"1\":{\"771\":1}}],[\"而大部分采用第一种方案效率会更高\",{\"1\":{\"765\":1}}],[\"而事务的原子性\",{\"1\":{\"747\":1}}],[\"而无法继续执行\",{\"1\":{\"742\":1}}],[\"而第二范式则确定每一张表都是独立的\",{\"1\":{\"737\":1}}],[\"而每个select关键字的from子句中都可以包含若干张表\",{\"1\":{\"703\":1}}],[\"而最小记录和最大记录的record\",{\"1\":{\"680\":1}}],[\"而binlog只有在提交事务时才写入\",{\"1\":{\"812\":1}}],[\"而b树的中间节点也有可能存储数据\",{\"1\":{\"662\":1}}],[\"而bfs\",{\"1\":{\"12\":1}}],[\"而树型的\",{\"1\":{\"658\":1}}],[\"而增\",{\"1\":{\"656\":1}}],[\"而mvcc本质是采用乐观锁思想的一种方式\",{\"1\":{\"791\":1}}],[\"而myisam是非聚簇索引\",{\"1\":{\"655\":1}}],[\"而myisam支持表级锁\",{\"1\":{\"655\":1}}],[\"而myisam支持\",{\"1\":{\"655\":1}}],[\"而myisam不支持\",{\"1\":{\"655\":2}}],[\"而myisam不支持事物\",{\"1\":{\"655\":1}}],[\"而myisam并不支持聚簇索引\",{\"1\":{\"650\":1}}],[\"而memory默认的索引是hash索引\",{\"1\":{\"653\":1}}],[\"而二级索引中只包含\",{\"1\":{\"651\":1}}],[\"而普通的用户记录的列是用户自己定义的\",{\"1\":{\"645\":1}}],[\"而普通用户记录的\",{\"1\":{\"645\":1}}],[\"而这个读指的就是\",{\"1\":{\"791\":1}}],[\"而这些对于char来说是不需要的\",{\"1\":{\"604\":1}}],[\"而这道题则是基于二叉树的动态规划\",{\"1\":{\"117\":1}}],[\"而这道题则是有多少种方式能够将背包装满\",{\"1\":{\"99\":1}}],[\"而内连接只能查询符合条件的行\",{\"1\":{\"539\":1}}],[\"而消费者\",{\"1\":{\"420\":1}}],[\"而heada相交结点前的结点个数为a\",{\"1\":{\"391\":1}}],[\"而应该是链表中的一个实际节点\",{\"1\":{\"379\":1}}],[\"而单链表中的头结点就不行了\",{\"1\":{\"377\":1}}],[\"而5元则比较万能\",{\"1\":{\"358\":1}}],[\"而它的列坐标相较于前一条对角线\",{\"1\":{\"304\":1}}],[\"而它的列坐标不变\",{\"1\":{\"304\":1}}],[\"而转换之后的列要根据转换之前的行计算\",{\"1\":{\"298\":1}}],[\"而来\",{\"1\":{\"261\":1}}],[\"而且重启后从\",{\"1\":{\"820\":1}}],[\"而且如果对一条记录加了gap锁\",{\"1\":{\"776\":1}}],[\"而且锁结构的\",{\"1\":{\"763\":1}}],[\"而且所有非主键字段\",{\"1\":{\"737\":1}}],[\"而且那个列又是不允许存储`null`值的\",{\"1\":{\"710\":1}}],[\"而且子查询可以使用到主键进行等值匹配的话\",{\"1\":{\"704\":1}}],[\"而且我们规定了c1列为主键\",{\"1\":{\"643\":1}}],[\"而且内存大小对性能有决定性的影响\",{\"1\":{\"636\":1,\"655\":1}}],[\"而且text和blob类型的数据删除后容易导致\",{\"1\":{\"605\":1}}],[\"而且主要影响性能的因素\",{\"1\":{\"604\":1}}],[\"而且还要占个长度信息\",{\"1\":{\"604\":1}}],[\"而且\",{\"1\":{\"598\":1,\"807\":1}}],[\"而且不建议省略as\",{\"1\":{\"518\":1}}],[\"而且你\",{\"1\":{\"240\":1}}],[\"而且两层的结点在队列中紧挨在一起\",{\"1\":{\"12\":1}}],[\"而在binlog订阅者中做缓存删除工作\",{\"1\":{\"853\":1}}],[\"而在\",{\"1\":{\"729\":1}}],[\"而在此之前\",{\"1\":{\"539\":1}}],[\"而在子工程中不需要写另外的版本号\",{\"1\":{\"441\":1}}],[\"而在回溯时会将标记清除\",{\"1\":{\"222\":1}}],[\"而在这道题中是尽可能接近\",{\"1\":{\"97\":1}}],[\"而迭代遍历就是\",{\"1\":{\"222\":1}}],[\"而当\",{\"1\":{\"217\":1}}],[\"而宽度\",{\"1\":{\"215\":1}}],[\"而去重操作其实在\",{\"1\":{\"205\":1}}],[\"而for循环遍历的是字母\",{\"1\":{\"193\":1}}],[\"而对于全排列问题和递增子序列问题\",{\"1\":{\"218\":1}}],[\"而对于以上的问题\",{\"1\":{\"218\":1}}],[\"而对于同一个树枝是允许有重复元素的\",{\"1\":{\"205\":1}}],[\"而对于排列来说就是俩种集合\",{\"1\":{\"183\":1}}],[\"而对于完全背包来说\",{\"1\":{\"93\":1}}],[\"而排列则强调元素的顺序\",{\"1\":{\"183\":1}}],[\"而有了冷冻期之后\",{\"1\":{\"128\":1}}],[\"而不仅仅用于复制\",{\"1\":{\"823\":1}}],[\"而不能看到这个时间点之后事务提交的更新结果\",{\"1\":{\"801\":1}}],[\"而不能修改数据\",{\"1\":{\"744\":1}}],[\"而不能一个为\",{\"1\":{\"689\":1}}],[\"而不建议用无序的id\",{\"1\":{\"650\":1}}],[\"而不是历史版本的数据\",{\"1\":{\"791\":1}}],[\"而不是全局唯一\",{\"1\":{\"731\":1}}],[\"而不是指向数据行的指针\",{\"1\":{\"650\":1}}],[\"而不是简单地将它们分成几个固定的类别\",{\"1\":{\"495\":1}}],[\"而不是\",{\"1\":{\"276\":1}}],[\"而不是i和j\",{\"1\":{\"137\":1}}],[\"而不是从\",{\"1\":{\"122\":1}}],[\"而不会出现\",{\"1\":{\"103\":1}}],[\"而dp\",{\"1\":{\"113\":1}}],[\"而\",{\"1\":{\"108\":1,\"122\":1,\"145\":1,\"199\":1,\"205\":1,\"211\":1,\"222\":1,\"233\":1,\"278\":1,\"390\":1,\"391\":1,\"462\":1,\"474\":1,\"747\":1,\"823\":1,\"835\":2}}],[\"而问题的关键就是在nums中求出\",{\"1\":{\"99\":1}}],[\"而想要\",{\"1\":{\"97\":1}}],[\"而重量为\",{\"1\":{\"96\":1}}],[\"而根节点左边为左子树\",{\"1\":{\"72\":1}}],[\"而另一些不会\",{\"1\":{\"52\":1}}],[\"而是通过程序来实现\",{\"1\":{\"782\":1}}],[\"而是锁的\",{\"1\":{\"780\":1}}],[\"而是使用较为轻量的\",{\"1\":{\"772\":1}}],[\"而是另一个数据表\",{\"1\":{\"736\":1}}],[\"而是逻辑上的连续\",{\"1\":{\"668\":1}}],[\"而是一种数据存储方式\",{\"1\":{\"650\":1}}],[\"而是自动产生一个外键名\",{\"1\":{\"618\":1}}],[\"而是单独定义\",{\"1\":{\"613\":1}}],[\"而是声明\",{\"1\":{\"441\":1}}],[\"而是原样抛出\",{\"1\":{\"416\":1}}],[\"而是要判断结点的内存地址\",{\"1\":{\"391\":1}}],[\"而是要考虑儿子的儿子结点\",{\"1\":{\"117\":1}}],[\"而是从首端\",{\"1\":{\"364\":1}}],[\"而是应该具体问题具体分析\",{\"1\":{\"273\":1}}],[\"而是每次for循环都从0开始\",{\"1\":{\"209\":1}}],[\"而是\",{\"1\":{\"179\":1,\"654\":1}}],[\"而是找最大值\",{\"1\":{\"51\":1}}],[\"而是将叶子结点的路径保存起来\",{\"1\":{\"39\":1}}],[\"而自上而下需要处理该结点下的每颗子树\",{\"1\":{\"37\":1}}],[\"第3个作用\",{\"1\":{\"819\":1}}],[\"第3步\",{\"1\":{\"752\":1}}],[\"第4步\",{\"1\":{\"752\":1}}],[\"第2个作用\",{\"1\":{\"819\":1}}],[\"第2步\",{\"1\":{\"752\":1}}],[\"第2版\",{\"1\":{\"503\":1}}],[\"第1个作用\",{\"1\":{\"819\":1}}],[\"第1步\",{\"1\":{\"752\":1}}],[\"第10号\",{\"1\":{\"749\":1}}],[\"第14章\",{\"1\":{\"681\":1}}],[\"第n行有n个元素\",{\"1\":{\"310\":1}}],[\"第j个元素\",{\"1\":{\"298\":1}}],[\"第四范式\",{\"1\":{\"736\":1}}],[\"第四层\",{\"0\":{\"632\":1}}],[\"第四行依次类推\",{\"1\":{\"298\":1}}],[\"第四种情况\",{\"1\":{\"68\":2,\"70\":1}}],[\"第i天第二次不持有股票所获得的最大利润\",{\"1\":{\"124\":1}}],[\"第i天第二次持有股票所获得的最大利润\",{\"1\":{\"124\":1}}],[\"第i天第一次不持有股票所获得的最大利润\",{\"1\":{\"124\":1}}],[\"第i天第一次持有股票所获得的最大利润\",{\"1\":{\"124\":1}}],[\"第i天不操作所获得的最大利润\",{\"1\":{\"124\":1}}],[\"第i天交易完手里有股票的最大利润\",{\"1\":{\"120\":1,\"122\":1,\"128\":1,\"130\":1}}],[\"第i天交易完手里没有股票的最大利润\",{\"1\":{\"120\":1,\"122\":1,\"128\":1,\"130\":1}}],[\"第三范式是在第二范式的基础上\",{\"1\":{\"737\":1}}],[\"第三范式\",{\"1\":{\"736\":1,\"737\":1}}],[\"第三层\",{\"0\":{\"631\":1}}],[\"第三层为\",{\"1\":{\"452\":1}}],[\"第三个孩子只得到\",{\"1\":{\"359\":1}}],[\"第三个孩子分发\",{\"1\":{\"359\":2}}],[\"第三行\",{\"1\":{\"298\":1}}],[\"第三次反转\",{\"1\":{\"256\":1}}],[\"第三次反转整个字符串\",{\"1\":{\"256\":1}}],[\"第三次持有股票\",{\"1\":{\"126\":2}}],[\"第三次取a\",{\"1\":{\"97\":1}}],[\"第三种情况\",{\"1\":{\"68\":2,\"70\":1}}],[\"第二范式要求\",{\"1\":{\"737\":1}}],[\"第二范式\",{\"1\":{\"736\":1,\"737\":1}}],[\"第二步查看索引名和删除索引\",{\"1\":{\"618\":1}}],[\"第二步\",{\"1\":{\"464\":1}}],[\"第二步将\",{\"1\":{\"149\":1}}],[\"第二阶段\",{\"1\":{\"436\":1}}],[\"第二个对象来自于\",{\"1\":{\"532\":1}}],[\"第二个主机地址是\",{\"1\":{\"495\":1}}],[\"第二个\",{\"1\":{\"359\":2}}],[\"第二个序列是因为它的最后一个差值为零\",{\"1\":{\"345\":1}}],[\"第二层含义\",{\"1\":{\"690\":1}}],[\"第二层\",{\"0\":{\"626\":1}}],[\"第二层为\",{\"1\":{\"452\":1}}],[\"第二层循环是以符合条件的终止位置\",{\"1\":{\"285\":1}}],[\"第二层有俩种方法\",{\"1\":{\"81\":1}}],[\"第二类\",{\"1\":{\"277\":1}}],[\"第二次查询出\",{\"1\":{\"800\":1}}],[\"第二次筛选\",{\"1\":{\"728\":2}}],[\"第二次根据主键值找到行数据\",{\"1\":{\"650\":1}}],[\"第二次遍历找到被删除结点的前一个结点\",{\"1\":{\"389\":1}}],[\"第二次遍历找到最后一个相等元素的下标\",{\"1\":{\"275\":1}}],[\"第二次遍历从后往前\",{\"1\":{\"360\":1}}],[\"第二次遍历\",{\"1\":{\"302\":1,\"389\":1}}],[\"第二次反转\",{\"1\":{\"256\":2}}],[\"第二次卖出\",{\"1\":{\"124\":1}}],[\"第二次买入\",{\"1\":{\"124\":1}}],[\"第二次不持有股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"第二次持有股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"第二次取c\",{\"1\":{\"97\":1}}],[\"第二种方式\",{\"1\":{\"579\":1}}],[\"第二种方法不使用额外的矩阵\",{\"1\":{\"299\":1}}],[\"第二种方法\",{\"0\":{\"299\":1},\"1\":{\"33\":1,\"56\":1,\"162\":1,\"163\":1,\"175\":1,\"245\":1,\"275\":1}}],[\"第二种选择\",{\"1\":{\"360\":1}}],[\"第二种是奇数的情况\",{\"1\":{\"288\":1}}],[\"第二种思路\",{\"1\":{\"273\":1}}],[\"第二种\",{\"1\":{\"271\":1}}],[\"第二种情况\",{\"1\":{\"68\":2,\"70\":1}}],[\"第一范式是确定字段是原子性的\",{\"1\":{\"737\":1}}],[\"第一范式主要是确保数据表中每个家段的值必须具有\",{\"1\":{\"737\":1}}],[\"第一范式\",{\"1\":{\"736\":1,\"737\":1}}],[\"第一条记录的next\",{\"1\":{\"680\":1}}],[\"第一条记录的地址是什么\",{\"1\":{\"674\":1}}],[\"第一棵树就属于平衡二叉搜索树\",{\"1\":{\"660\":1}}],[\"第一箭从第一个气球的首端开始\",{\"1\":{\"364\":1}}],[\"第一箭从第一个气球的尾端开始\",{\"1\":{\"364\":1}}],[\"第一个主机地址是\",{\"1\":{\"495\":1}}],[\"第一个节点\",{\"1\":{\"379\":1}}],[\"第一个下标\",{\"1\":{\"349\":1}}],[\"第一个序列是因为它的前两个差值都是正数\",{\"1\":{\"345\":1}}],[\"第一个差\",{\"1\":{\"345\":1}}],[\"第一个元素就是最大值\",{\"1\":{\"335\":1}}],[\"第一个元素与最后一个元素\",{\"1\":{\"115\":1}}],[\"第一个行第二个元素\",{\"1\":{\"298\":1}}],[\"第一个行第一个元素\",{\"1\":{\"298\":1}}],[\"第一层含义\",{\"1\":{\"690\":1}}],[\"第一层\",{\"0\":{\"625\":1}}],[\"第一层为\",{\"1\":{\"452\":1}}],[\"第一层循环是以某个元素为起始位置\",{\"1\":{\"285\":1}}],[\"第一层只有一种方法\",{\"1\":{\"81\":1}}],[\"第一类\",{\"1\":{\"277\":1}}],[\"第一步先查看约束名和删除外键约束\",{\"1\":{\"618\":1}}],[\"第一步\",{\"1\":{\"464\":1}}],[\"第一步将\",{\"1\":{\"149\":1}}],[\"第一步不需要花费\",{\"1\":{\"83\":1}}],[\"第一次查询出\",{\"1\":{\"800\":1}}],[\"第一次执行select操作\",{\"1\":{\"765\":1}}],[\"第一次筛选\",{\"1\":{\"728\":2}}],[\"第一次找到主键值\",{\"1\":{\"650\":1}}],[\"第一次遍历记录链表的长度\",{\"1\":{\"389\":1}}],[\"第一次遍历\",{\"1\":{\"389\":1}}],[\"第一次遍历从前往后\",{\"1\":{\"360\":1}}],[\"第一次遍历找到所有0元素的行和列\",{\"1\":{\"302\":1}}],[\"第一次遍历找到第一个相等的元素下标\",{\"1\":{\"275\":1}}],[\"第一次反转\",{\"1\":{\"256\":2}}],[\"第一次卖出\",{\"1\":{\"124\":1}}],[\"第一次买入\",{\"1\":{\"124\":1}}],[\"第一次不持有股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"第一次持有股票\",{\"1\":{\"124\":1,\"126\":1}}],[\"第一次取a\",{\"1\":{\"97\":1}}],[\"第一天无法产生利润\",{\"1\":{\"122\":1}}],[\"第一天买入股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"第一天没有股票\",{\"1\":{\"120\":1,\"122\":1}}],[\"第一行为物品0的价值\",{\"1\":{\"91\":1}}],[\"第一行和第一列初始化为1\",{\"1\":{\"85\":1}}],[\"第一种方式\",{\"1\":{\"579\":1}}],[\"第一种方法\",{\"0\":{\"298\":1},\"1\":{\"33\":1,\"56\":1,\"162\":1,\"163\":1,\"275\":1}}],[\"第一种选择\",{\"1\":{\"360\":1}}],[\"第一种是偶数的情况\",{\"1\":{\"288\":1}}],[\"第一种写法\",{\"1\":{\"271\":1}}],[\"第一种情况\",{\"1\":{\"68\":2,\"70\":1}}],[\"第\",{\"1\":{\"12\":2,\"17\":3,\"81\":1,\"122\":1,\"126\":1,\"295\":2,\"357\":2}}],[\"层节点都是按照索引列的值\",{\"1\":{\"656\":1}}],[\"层是不需要花费体力的\",{\"1\":{\"83\":1}}],[\"层上来\",{\"1\":{\"81\":1}}],[\"层序自己选一个喜欢的就行\",{\"1\":{\"54\":1}}],[\"层序遍历均可以实现\",{\"1\":{\"31\":1}}],[\"层序遍历\",{\"1\":{\"11\":1,\"12\":2,\"31\":1,\"43\":1,\"54\":1}}],[\"层的方法\",{\"1\":{\"81\":2}}],[\"层的平均值为\",{\"1\":{\"17\":3}}],[\"层的结点就进来了\",{\"1\":{\"12\":1}}],[\"层的结点还没出完\",{\"1\":{\"12\":1}}],[\"层次加一\",{\"1\":{\"12\":1}}],[\"层\",{\"1\":{\"12\":1,\"34\":1,\"81\":2,\"197\":1,\"633\":1}}],[\"层和第\",{\"1\":{\"12\":1}}],[\"5引入了\",{\"1\":{\"773\":1}}],[\"5nf\",{\"1\":{\"736\":1}}],[\"5之后\",{\"1\":{\"636\":1}}],[\"545\",{\"1\":{\"529\":1}}],[\"5<\",{\"1\":{\"441\":1,\"486\":1}}],[\"5s\",{\"1\":{\"413\":1,\"477\":1,\"478\":1}}],[\"5s过后的所有请求都会抛弃\",{\"1\":{\"411\":1}}],[\"5个请求\",{\"1\":{\"411\":1}}],[\"5元直接收下\",{\"1\":{\"358\":1}}],[\"55s\",{\"1\":{\"453\":1}}],[\"5555\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"55\",{\"1\":{\"352\":1}}],[\"5>\",{\"1\":{\"334\":1}}],[\"59\",{\"0\":{\"287\":1}}],[\"51\",{\"1\":{\"215\":1}}],[\"518\",{\"1\":{\"105\":1}}],[\"5就说明这个数是丑数\",{\"1\":{\"173\":1}}],[\"52\",{\"1\":{\"170\":1}}],[\"5=1+1+1+1+1\",{\"1\":{\"102\":1}}],[\"5=2+1+1+1\",{\"1\":{\"102\":1}}],[\"5=2+2+1\",{\"1\":{\"102\":1}}],[\"5=5\",{\"1\":{\"102\":1}}],[\"58\",{\"1\":{\"86\":1,\"170\":1}}],[\"5+6+7+8\",{\"1\":{\"74\":1}}],[\"500\",{\"1\":{\"140\":1,\"149\":1,\"151\":1,\"229\":1,\"367\":1,\"383\":3,\"406\":1,\"444\":1,\"835\":1}}],[\"5000\",{\"1\":{\"36\":1,\"44\":1,\"53\":1,\"102\":2,\"127\":1,\"276\":3,\"277\":1,\"380\":3,\"429\":1,\"466\":4}}],[\"50000\",{\"1\":{\"17\":2}}],[\"50\",{\"1\":{\"65\":2,\"196\":1,\"227\":1,\"376\":2,\"440\":2,\"477\":2,\"478\":1,\"574\":1,\"618\":1}}],[\"5\",{\"0\":{\"418\":1,\"421\":1,\"445\":1,\"453\":1,\"470\":1,\"484\":1,\"485\":1,\"486\":1,\"496\":1,\"503\":1,\"537\":1,\"551\":1,\"558\":1,\"583\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"589\":2,\"602\":1,\"608\":1,\"618\":1,\"649\":1,\"650\":1,\"651\":1,\"652\":1,\"662\":1,\"672\":1,\"701\":1,\"702\":1,\"703\":1,\"704\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"719\":1,\"726\":1,\"746\":1,\"753\":1,\"800\":1,\"813\":1,\"826\":1,\"827\":1},\"1\":{\"12\":1,\"15\":1,\"17\":3,\"19\":4,\"21\":1,\"23\":2,\"27\":2,\"34\":3,\"38\":1,\"42\":1,\"44\":3,\"50\":6,\"52\":3,\"53\":1,\"55\":2,\"61\":8,\"63\":3,\"65\":4,\"67\":6,\"71\":3,\"73\":1,\"74\":1,\"85\":1,\"88\":1,\"94\":5,\"95\":2,\"96\":1,\"98\":2,\"99\":1,\"100\":2,\"102\":2,\"103\":6,\"106\":3,\"112\":1,\"116\":2,\"119\":4,\"121\":8,\"123\":5,\"124\":2,\"125\":2,\"126\":1,\"129\":5,\"132\":1,\"134\":4,\"136\":1,\"140\":6,\"142\":2,\"143\":1,\"147\":2,\"151\":1,\"161\":1,\"166\":1,\"170\":1,\"172\":2,\"173\":4,\"188\":4,\"189\":2,\"193\":2,\"194\":2,\"196\":5,\"197\":1,\"201\":2,\"216\":12,\"222\":1,\"233\":4,\"246\":1,\"257\":3,\"269\":2,\"273\":4,\"274\":2,\"275\":2,\"276\":7,\"277\":8,\"278\":2,\"287\":1,\"290\":1,\"294\":3,\"295\":1,\"297\":4,\"300\":3,\"303\":2,\"309\":1,\"312\":2,\"330\":9,\"333\":11,\"334\":11,\"345\":10,\"347\":2,\"353\":3,\"355\":5,\"357\":15,\"358\":1,\"359\":1,\"361\":11,\"362\":9,\"363\":3,\"365\":2,\"376\":2,\"379\":6,\"380\":2,\"383\":4,\"388\":2,\"390\":8,\"412\":1,\"413\":1,\"419\":2,\"442\":1,\"477\":1,\"486\":2,\"541\":1,\"565\":1,\"593\":1,\"595\":1,\"602\":1,\"617\":1,\"618\":2,\"630\":1,\"634\":1,\"659\":1,\"677\":1,\"680\":1,\"686\":1,\"689\":4,\"690\":1,\"728\":1,\"757\":1,\"799\":1,\"825\":3}}],[\"4nf\",{\"1\":{\"736\":1}}],[\"4字节\",{\"1\":{\"668\":4}}],[\"47\",{\"1\":{\"558\":1}}],[\"42000\",{\"1\":{\"617\":2}}],[\"42\",{\"1\":{\"492\":1}}],[\"4cd2\",{\"1\":{\"404\":1}}],[\"4处射出箭\",{\"1\":{\"363\":1}}],[\"46\",{\"1\":{\"211\":1}}],[\"4的公式为\",{\"1\":{\"124\":1}}],[\"416\",{\"1\":{\"97\":2}}],[\"4560\",{\"1\":{\"429\":1}}],[\"452\",{\"1\":{\"366\":1}}],[\"45\",{\"1\":{\"80\":1}}],[\"450\",{\"1\":{\"70\":1}}],[\"4+5+6+7+8=30\",{\"1\":{\"74\":1}}],[\"404页面找不到的异常\",{\"1\":{\"444\":1}}],[\"404\",{\"1\":{\"444\":1,\"889\":1}}],[\"401\",{\"1\":{\"444\":1}}],[\"403\",{\"1\":{\"444\":1}}],[\"40<\",{\"1\":{\"441\":1}}],[\"400\",{\"1\":{\"112\":1,\"680\":1}}],[\"40\",{\"1\":{\"65\":2,\"96\":1,\"194\":2,\"197\":1,\"205\":1,\"207\":2}}],[\"49\",{\"1\":{\"57\":1,\"281\":1}}],[\"48\",{\"1\":{\"57\":1}}],[\"4\",{\"0\":{\"417\":1,\"420\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"436\":2,\"444\":1,\"452\":1,\"460\":1,\"465\":1,\"469\":1,\"472\":1,\"473\":1,\"474\":1,\"475\":1,\"479\":1,\"482\":2,\"495\":1,\"502\":1,\"524\":1,\"532\":1,\"536\":1,\"542\":1,\"550\":1,\"557\":1,\"559\":1,\"565\":1,\"569\":1,\"570\":1,\"571\":1,\"575\":1,\"576\":1,\"579\":1,\"588\":1,\"601\":1,\"607\":1,\"617\":1,\"632\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":2,\"661\":1,\"671\":1,\"697\":1,\"698\":1,\"699\":1,\"704\":1,\"718\":1,\"725\":1,\"743\":1,\"744\":1,\"745\":1,\"752\":1,\"765\":1,\"784\":1,\"795\":1,\"796\":1,\"797\":1,\"798\":1,\"799\":2,\"808\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":2,\"825\":1},\"1\":{\"12\":1,\"15\":2,\"19\":4,\"23\":2,\"27\":1,\"30\":2,\"32\":2,\"34\":1,\"36\":2,\"42\":1,\"44\":3,\"47\":1,\"49\":1,\"52\":3,\"53\":2,\"55\":2,\"57\":1,\"61\":4,\"63\":5,\"65\":4,\"67\":6,\"69\":1,\"73\":4,\"74\":1,\"78\":2,\"82\":1,\"84\":1,\"85\":1,\"86\":2,\"91\":3,\"96\":2,\"99\":1,\"100\":3,\"102\":1,\"104\":1,\"108\":5,\"112\":2,\"114\":2,\"116\":2,\"117\":1,\"119\":2,\"121\":9,\"123\":9,\"124\":7,\"125\":4,\"126\":1,\"129\":4,\"132\":3,\"134\":2,\"136\":1,\"137\":1,\"140\":2,\"141\":3,\"142\":4,\"143\":2,\"149\":1,\"156\":1,\"166\":5,\"174\":1,\"176\":3,\"179\":2,\"186\":4,\"188\":2,\"189\":5,\"192\":1,\"193\":2,\"201\":4,\"206\":10,\"214\":2,\"216\":11,\"223\":8,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"233\":8,\"234\":1,\"240\":2,\"255\":1,\"257\":10,\"266\":3,\"269\":2,\"273\":1,\"274\":4,\"275\":1,\"276\":10,\"277\":8,\"278\":3,\"281\":2,\"284\":5,\"287\":1,\"290\":6,\"294\":4,\"295\":2,\"297\":4,\"299\":2,\"300\":2,\"303\":4,\"309\":2,\"312\":3,\"330\":5,\"334\":1,\"345\":5,\"346\":2,\"347\":4,\"349\":2,\"351\":2,\"353\":5,\"355\":15,\"357\":1,\"359\":1,\"361\":13,\"362\":6,\"363\":6,\"365\":1,\"366\":1,\"376\":2,\"379\":6,\"380\":2,\"383\":3,\"385\":2,\"388\":1,\"390\":12,\"393\":1,\"399\":1,\"412\":1,\"432\":1,\"440\":1,\"441\":3,\"442\":2,\"452\":1,\"454\":1,\"460\":1,\"477\":3,\"481\":1,\"486\":2,\"489\":1,\"495\":1,\"497\":1,\"541\":1,\"565\":1,\"568\":1,\"582\":1,\"597\":2,\"602\":2,\"617\":1,\"618\":1,\"634\":1,\"642\":1,\"672\":1,\"680\":2,\"686\":2,\"689\":1,\"690\":1,\"715\":2,\"716\":1,\"725\":1,\"729\":1,\"746\":1,\"757\":2,\"767\":2,\"771\":2,\"786\":1,\"797\":2,\"799\":1,\"807\":1}}],[\"但如果只是按照图中的方案进行删除缓存\",{\"1\":{\"853\":1}}],[\"但如果当最大距离大于数组的长度了\",{\"1\":{\"350\":1}}],[\"但删除缓存失败了\",{\"1\":{\"851\":1,\"852\":1}}],[\"但随之请求d就删除了\",{\"1\":{\"849\":1}}],[\"但可读性更强\",{\"1\":{\"835\":1}}],[\"但占用空\",{\"1\":{\"830\":1}}],[\"但占用空间比\",{\"1\":{\"830\":1}}],[\"但并不是所有的应用都需要对数据库进行主从架构的设置\",{\"1\":{\"818\":1}}],[\"但累积n个事务后才fsync\",{\"1\":{\"810\":1}}],[\"但同时数据的并发度也下降了\",{\"1\":{\"779\":1}}],[\"但这样的浪费最多也就是一个页上的数据行\",{\"1\":{\"779\":1}}],[\"但有时候事务执行到一半\",{\"1\":{\"755\":1}}],[\"但通常来说暴力方法都是不可取的\",{\"1\":{\"749\":1}}],[\"但性能十分低下\",{\"1\":{\"746\":1}}],[\"但幻读问题仍\",{\"1\":{\"746\":1}}],[\"但不会影响当前正在执行的事务\",{\"1\":{\"746\":1}}],[\"但不可以继续获取x型记录锁\",{\"1\":{\"775\":1}}],[\"但不可\",{\"1\":{\"746\":1}}],[\"但不是mysql默认的\",{\"1\":{\"746\":1}}],[\"但不至于像for循环那样绝望~~\",{\"1\":{\"187\":1}}],[\"但由于操作都在内存中执行\",{\"1\":{\"742\":1}}],[\"但总的来说\",{\"1\":{\"725\":1}}],[\"但却不能使用到索引\",{\"1\":{\"710\":1}}],[\"但需要扫描全部的索引记录时\",{\"1\":{\"704\":1}}],[\"但该列的基数却是3\",{\"1\":{\"689\":1}}],[\"但该下标的最大跳跃长度是\",{\"1\":{\"349\":1}}],[\"但提高查找速度是明显的\",{\"1\":{\"689\":1}}],[\"但允许有空值\",{\"1\":{\"686\":1}}],[\"但myisam不支持事务\",{\"1\":{\"637\":1}}],[\"但现代文件系统的实现使得这样做没有必要了\",{\"1\":{\"632\":1}}],[\"但check约束对数据验证没有任何作用\",{\"1\":{\"619\":1}}],[\"但innodb不能识别\",{\"1\":{\"618\":1}}],[\"但好于具体的count\",{\"1\":{\"562\":1}}],[\"但实际上在mysql中\",{\"1\":{\"793\":1}}],[\"但实际上在mysql中并不是这么操作的\",{\"1\":{\"728\":1}}],[\"但实际上一个项目中可能有多处需要调用\",{\"1\":{\"462\":1}}],[\"但实际上应该pre先移动\",{\"1\":{\"381\":1}}],[\"但在还原前要首先要校验脏写\",{\"1\":{\"436\":1}}],[\"但此时更新的是旧值\",{\"1\":{\"848\":1}}],[\"但此时的\",{\"1\":{\"299\":1}}],[\"但此时我们需要注意使用迭代的方式\",{\"1\":{\"39\":1}}],[\"但输出的答案是数组呢\",{\"1\":{\"278\":1}}],[\"但前提是\",{\"1\":{\"273\":2}}],[\"但大于或等于\",{\"1\":{\"252\":1}}],[\"但具体是怎么一圈一圈来搜呢\",{\"1\":{\"222\":1}}],[\"但始终变不到\",{\"1\":{\"169\":1}}],[\"但整体思路是不变的\",{\"1\":{\"153\":1}}],[\"但无法画出第三条不相交的直线\",{\"1\":{\"140\":1}}],[\"但\",{\"1\":{\"138\":1,\"589\":1}}],[\"但它不是连续的\",{\"1\":{\"134\":1}}],[\"但它们遍历结点的顺序不同\",{\"1\":{\"12\":1}}],[\"但对于这种求组合的问题\",{\"1\":{\"103\":1}}],[\"但是又带来了一个新问题\",{\"1\":{\"847\":1}}],[\"但是写的\",{\"1\":{\"835\":1}}],[\"但是写操作只能加写锁\",{\"1\":{\"767\":1}}],[\"但是某些表数据量很大或者与业务关联不大\",{\"1\":{\"831\":1}}],[\"但是机器宕机\",{\"1\":{\"810\":1}}],[\"但是现在在等待\",{\"1\":{\"778\":1}}],[\"但是innodb规定事务在等待的时候也需要在内存中生成一个锁结构\",{\"1\":{\"778\":1}}],[\"但是弊端就是\",{\"1\":{\"772\":1}}],[\"但是他会与普通的\",{\"1\":{\"771\":1}}],[\"但是他们的实现原理也是不同的\",{\"1\":{\"653\":1}}],[\"但是他们的复杂度\",{\"1\":{\"337\":1}}],[\"但是管理锁是很\",{\"1\":{\"768\":1}}],[\"但是此时\",{\"1\":{\"763\":1}}],[\"但是此时我们发现\",{\"1\":{\"299\":1}}],[\"但是由于binlog没写完就异常\",{\"1\":{\"812\":1}}],[\"但是由于\",{\"1\":{\"749\":1}}],[\"但是假设在刷新的过程中出现了宕机等异常\",{\"1\":{\"747\":1}}],[\"但是b账户因为各种意外\",{\"1\":{\"741\":1}}],[\"但是仓库名和管理员名之间存在依赖关系\",{\"1\":{\"737\":1}}],[\"但是卡号可能会出现注销\",{\"1\":{\"732\":1}}],[\"但是它们起到的作用是相同的\",{\"1\":{\"776\":1}}],[\"但是它会使用更多的空\",{\"1\":{\"725\":1}}],[\"但是它字典排序更大更靠后\",{\"1\":{\"212\":1}}],[\"但是为什么在\",{\"1\":{\"725\":1}}],[\"但是并没有符合`where`子句中\",{\"1\":{\"710\":1}}],[\"但是并不代表\",{\"1\":{\"60\":1}}],[\"但是查询的效率并没有明显的变化\",{\"1\":{\"696\":1}}],[\"但是只有查询条件中使用了这些字段中的第一个字段时才会被使用\",{\"1\":{\"686\":1}}],[\"但是检索效率不高\",{\"1\":{\"673\":1}}],[\"但是树的深度也同样高\",{\"1\":{\"660\":1}}],[\"但是存在特殊的情况\",{\"1\":{\"659\":1}}],[\"但是却\",{\"1\":{\"654\":1}}],[\"但是却不能保证数据不会超出范围\",{\"1\":{\"598\":1}}],[\"但是没创建一颗\",{\"1\":{\"651\":1}}],[\"但是没有意义\",{\"1\":{\"522\":1,\"564\":1}}],[\"但是mysql\",{\"1\":{\"619\":1}}],[\"但是要注意子\",{\"1\":{\"618\":1}}],[\"但是要保证唯一\",{\"1\":{\"409\":1}}],[\"但是数据类型必须一样\",{\"1\":{\"618\":1}}],[\"但是精准\",{\"1\":{\"600\":1}}],[\"但是将条件放在havign中\",{\"1\":{\"565\":1}}],[\"但是建议放在where中\",{\"1\":{\"564\":1}}],[\"但是每个字符串之间要加上x\",{\"1\":{\"552\":1}}],[\"但是每组结果里面的元素是可以重复的\",{\"1\":{\"177\":1}}],[\"但是多行的insert语句\",{\"1\":{\"542\":1}}],[\"但是也查询出来了\",{\"1\":{\"539\":1}}],[\"但是部门id在俩张表中都存在\",{\"1\":{\"533\":1}}],[\"但是尽量别用\",{\"1\":{\"521\":1}}],[\"但是针对全文索引效率却较低\",{\"1\":{\"510\":1}}],[\"但是有俩点需要注意\",{\"1\":{\"424\":1}}],[\"但是有一个小坑\",{\"1\":{\"274\":1}}],[\"但是通过缓冲池的机制\",{\"1\":{\"696\":1}}],[\"但是通过feign接口调用的又方法各自不同\",{\"1\":{\"420\":1}}],[\"但是通过下图我们也可以看见\",{\"1\":{\"299\":1}}],[\"但是获取上一个结点就不容易了\",{\"1\":{\"382\":1}}],[\"但是头结点就无法获取\",{\"1\":{\"378\":1}}],[\"但是你的油箱只有\",{\"1\":{\"355\":1}}],[\"但是你每笔交易都需要付手续费\",{\"1\":{\"129\":1}}],[\"但是仍然存在被覆盖的问题\",{\"1\":{\"299\":1}}],[\"但是仍然可能会有一些疑问\",{\"1\":{\"211\":1}}],[\"但是需要注意的是\",{\"1\":{\"377\":1}}],[\"但是需要多考虑一些情况\",{\"1\":{\"276\":1}}],[\"但是需要考虑的是\",{\"1\":{\"31\":1}}],[\"但是不包含没有修改任何数据的语句\",{\"1\":{\"808\":1}}],[\"但是不论怎么说一个页只有\",{\"1\":{\"646\":1}}],[\"但是不精准\",{\"1\":{\"600\":1}}],[\"但是不管旋转几次\",{\"1\":{\"276\":1}}],[\"但是不能包含重复的组合\",{\"1\":{\"197\":1}}],[\"但是经常会将\",{\"1\":{\"270\":1}}],[\"但是一个非常经典的搜索算法\",{\"1\":{\"270\":1}}],[\"但是对于单链表来说\",{\"1\":{\"382\":1}}],[\"但是对于该题来说\",{\"1\":{\"213\":1}}],[\"但是对于全排列问题\",{\"1\":{\"211\":1}}],[\"但是对于leetcode某些题\",{\"1\":{\"93\":1}}],[\"但是还仍然有个问题\",{\"1\":{\"209\":1}}],[\"但是当该段只有一个字符时\",{\"1\":{\"201\":1}}],[\"但是效率仍然不高\",{\"1\":{\"183\":1}}],[\"但是题目中有个很关键的条件\",{\"1\":{\"177\":1}}],[\"但是\",{\"1\":{\"174\":1,\"200\":1,\"322\":1,\"343\":1,\"724\":1}}],[\"但是顺序可能不同\",{\"1\":{\"165\":1}}],[\"但是我们有的是整个实例的备份\",{\"1\":{\"832\":1}}],[\"但是我们仔细看一下\",{\"1\":{\"155\":1}}],[\"但是我们大可不必这么麻烦\",{\"1\":{\"70\":1}}],[\"但是比\",{\"1\":{\"153\":1}}],[\"但是字符串s也可以不用s\",{\"1\":{\"148\":1,\"153\":1}}],[\"但是是俩种排列\",{\"1\":{\"103\":1}}],[\"但是回溯算法的时间复杂度为\",{\"1\":{\"99\":1}}],[\"但是毫无疑问\",{\"1\":{\"95\":1}}],[\"但是问题来了\",{\"1\":{\"60\":1}}],[\"但是这个方案有一个解决方法\",{\"1\":{\"848\":1}}],[\"但是这时还没有确定参加的球员都有谁\",{\"1\":{\"737\":1}}],[\"但是这就失去了这道题的意义\",{\"1\":{\"60\":1}}],[\"但是这样写就违背这道题的初衷了\",{\"1\":{\"54\":1}}],[\"但是右子节点的值是\",{\"1\":{\"55\":1}}],[\"但是与bfs不同的是\",{\"1\":{\"12\":1}}],[\"但是处理的结点却是左边最底部的结点\",{\"1\":{\"7\":1}}],[\"但是在更新的时候会判断一下在此期间别人有没有去更新这个数据\",{\"1\":{\"782\":1}}],[\"但是在对某个表执行一些诸如\",{\"1\":{\"770\":1}}],[\"但是在一开始生成页的时候\",{\"1\":{\"670\":1}}],[\"但是在一维数组中\",{\"1\":{\"92\":1}}],[\"但是在同步了一半的时候断电了\",{\"1\":{\"668\":1}}],[\"但是在账户上却没有扣减\",{\"1\":{\"435\":1}}],[\"但是在\",{\"1\":{\"271\":1}}],[\"但是在代码中如何展示呢\",{\"1\":{\"366\":1}}],[\"但是在代码中\",{\"1\":{\"195\":1}}],[\"但是在中序遍历中\",{\"1\":{\"7\":1}}],[\"但是在迭代中\",{\"1\":{\"7\":1}}],[\"都必须保证读到\",{\"1\":{\"797\":1}}],[\"都必须完全依赖主键\",{\"1\":{\"737\":1}}],[\"都需要阻塞挂起\",{\"1\":{\"781\":1}}],[\"都需要\",{\"1\":{\"755\":1}}],[\"都需要去修改各个b+树索引\",{\"1\":{\"656\":1}}],[\"都需要进行回溯\",{\"1\":{\"45\":1}}],[\"都会被查询出来\",{\"1\":{\"800\":1}}],[\"都会复用这个\",{\"1\":{\"799\":1}}],[\"都会记录一条undo日志\",{\"1\":{\"794\":1}}],[\"都会把旧的版本写入到\",{\"1\":{\"794\":1}}],[\"都会把该事务的\",{\"1\":{\"794\":1}}],[\"都会持有这么一个特殊的表锁\",{\"1\":{\"772\":1}}],[\"都会从free\",{\"1\":{\"670\":1}}],[\"都会为主键值生成\",{\"1\":{\"645\":1}}],[\"都会触发降级\",{\"1\":{\"472\":1}}],[\"都将依\",{\"1\":{\"625\":1}}],[\"都为null\",{\"1\":{\"528\":1}}],[\"都为0\",{\"1\":{\"95\":1}}],[\"都不会使用\",{\"1\":{\"772\":1}}],[\"都不会被填充为\",{\"1\":{\"231\":1}}],[\"都不行\",{\"1\":{\"217\":2}}],[\"都在边界上或可以到达边界\",{\"1\":{\"229\":1}}],[\"都在同一层上\",{\"1\":{\"0\":1}}],[\"都算是一个子集\",{\"1\":{\"203\":2}}],[\"都构成的树的深度\",{\"1\":{\"184\":1}}],[\"都没有什么关系\",{\"1\":{\"155\":1}}],[\"都相同了指定要匹配啊\",{\"1\":{\"148\":1,\"153\":1}}],[\"都有一个尺寸\",{\"1\":{\"343\":1}}],[\"都有一个胃口值\",{\"1\":{\"343\":1}}],[\"都有\",{\"1\":{\"134\":1}}],[\"都由\",{\"1\":{\"46\":1}}],[\"都是在做操作之前先上锁\",{\"1\":{\"781\":1}}],[\"都是在pop\",{\"1\":{\"334\":1}}],[\"都是可唯一标识的\",{\"1\":{\"737\":1}}],[\"都是超键\",{\"1\":{\"736\":1}}],[\"都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的\",{\"1\":{\"672\":1}}],[\"都是存在\",{\"1\":{\"632\":1}}],[\"都是立即检查外键约束\",{\"1\":{\"618\":1}}],[\"都是非自连接\",{\"1\":{\"535\":1}}],[\"都是通过来个纬度来确定\",{\"1\":{\"362\":1}}],[\"都是完全平方数\",{\"1\":{\"108\":1}}],[\"都是经过\",{\"1\":{\"103\":1}}],[\"都是背包最大容量下能够装多少\",{\"1\":{\"99\":1}}],[\"都是\",{\"1\":{\"95\":1,\"249\":1}}],[\"都是高度平衡二叉搜索树\",{\"1\":{\"71\":1}}],[\"都是先push路径\",{\"1\":{\"39\":1}}],[\"都是将这些行所在的页进行加载\",{\"1\":{\"666\":1}}],[\"都是将当前层的所有结点出队列\",{\"1\":{\"12\":1}}],[\"都是将二叉树的所有结点遍历了一遍\",{\"1\":{\"12\":1}}],[\"都要判断当前截取的字符是否为回文串\",{\"1\":{\"199\":1}}],[\"都要进行一次回溯\",{\"1\":{\"39\":2}}],[\"都要将当前结点的值添加到路径中\",{\"1\":{\"39\":1}}],[\"都可以实现对表中的所有数据进行删除\",{\"1\":{\"589\":1}}],[\"都可以通过\",{\"1\":{\"377\":1}}],[\"都可以是一个整数或者另一个表达式\",{\"1\":{\"330\":1}}],[\"都可以抽象成一颗二叉树\",{\"1\":{\"199\":1}}],[\"都可以使用回溯方法来做\",{\"1\":{\"199\":1}}],[\"都可以\",{\"1\":{\"35\":1}}],[\"虽然性能得到提升\",{\"1\":{\"810\":1}}],[\"虽然有\",{\"1\":{\"776\":1}}],[\"虽然有9条记录\",{\"1\":{\"689\":1}}],[\"虽然整个系统宕机的概率还是比较小的\",{\"1\":{\"753\":1}}],[\"虽然提高了查询速度\",{\"1\":{\"690\":1}}],[\"虽然平衡二叉树的效率高\",{\"1\":{\"660\":1}}],[\"虽然说\",{\"1\":{\"646\":1}}],[\"虽然索引大大提高了查询速度\",{\"1\":{\"642\":1}}],[\"虽然占用字节数比\",{\"1\":{\"598\":1}}],[\"虽然关系型数据库采用了索引提升检索效率\",{\"1\":{\"510\":1}}],[\"虽然你有两块小饼干\",{\"1\":{\"343\":1}}],[\"虽然递归也算是暴力法\",{\"1\":{\"187\":1}}],[\"虽然可以通过剪枝操作来提高效一些效率\",{\"1\":{\"183\":1}}],[\"虽然也只涉及到了删除操作\",{\"1\":{\"153\":1}}],[\"虽然\",{\"1\":{\"12\":1,\"696\":1}}],[\"栈为先进后出\",{\"1\":{\"322\":1}}],[\"栈和队列\",{\"0\":{\"320\":1}}],[\"栈\",{\"1\":{\"12\":1},\"2\":{\"341\":1}}],[\"栈的原则为先进后出\",{\"1\":{\"8\":1}}],[\"这套方案中业务接口确实简化了一些流程\",{\"1\":{\"853\":1}}],[\"这么多标准\",{\"1\":{\"835\":1}}],[\"这么一听貌似是组合问题\",{\"1\":{\"99\":1}}],[\"这会导致频繁发生\",{\"1\":{\"823\":1}}],[\"这会大大的耗费资源和时间\",{\"1\":{\"729\":1}}],[\"这对复制来说是最\",{\"1\":{\"823\":1}}],[\"这仅仅是mysql中定义的标准\",{\"1\":{\"793\":1}}],[\"这项技术使得在innodb的事务隔离级别下执行\",{\"1\":{\"790\":1}}],[\"这其实是影响了并发度的\",{\"1\":{\"776\":1}}],[\"这无疑是浪费时间的\",{\"1\":{\"771\":1}}],[\"这类的\",{\"1\":{\"770\":1}}],[\"这类索引可以创建在\",{\"1\":{\"686\":1}}],[\"这\",{\"1\":{\"737\":1,\"755\":1}}],[\"这需要多一次的网络交亘\",{\"1\":{\"731\":1}}],[\"这叫做\",{\"1\":{\"658\":1}}],[\"这包括三个方面的含义\",{\"1\":{\"650\":1}}],[\"这可以使\",{\"1\":{\"637\":1}}],[\"这两个伪记录一个代表最小记录\",{\"1\":{\"680\":1}}],[\"这两个链表不相交\",{\"1\":{\"390\":1}}],[\"这两种数据类型的区别是啥呢\",{\"1\":{\"599\":1}}],[\"这一点非常重要\",{\"1\":{\"771\":1}}],[\"这一点与enum类型不同\",{\"1\":{\"607\":1}}],[\"这一点和\",{\"1\":{\"605\":1}}],[\"这一系列的行和列被\",{\"1\":{\"509\":1}}],[\"这一类问题\",{\"1\":{\"148\":1}}],[\"这四个ip地址包括网络地址\",{\"1\":{\"495\":1}}],[\"这显然是很愚蠢的行为~\",{\"1\":{\"420\":1}}],[\"这不乱套了~~\",{\"1\":{\"382\":1}}],[\"这要干嘛\",{\"1\":{\"364\":1}}],[\"这满足题面中的两个条件\",{\"1\":{\"359\":1}}],[\"这区间内的加油站都不能作为起始点\",{\"1\":{\"356\":1}}],[\"这几个公式为一个循环\",{\"1\":{\"299\":1}}],[\"这几道题可谓是循序渐进\",{\"1\":{\"153\":1}}],[\"这意味着你可以在\",{\"1\":{\"886\":1}}],[\"这意味着你需要直接修改输入的二维矩阵\",{\"1\":{\"297\":1}}],[\"这意味着在函数里修改输入数组对于调用者是可见的\",{\"1\":{\"278\":1}}],[\"这意味着第一个房屋和最后一个房屋是紧挨着的\",{\"1\":{\"114\":1}}],[\"这就造成了数据库时请求d更新的新值\",{\"1\":{\"848\":1}}],[\"这就意味着在将某个事务修改的bufer\",{\"1\":{\"749\":1}}],[\"这就意味着磁盘\",{\"1\":{\"660\":1}}],[\"这就导致可能放到叶子结点获取结果\",{\"1\":{\"662\":1}}],[\"这就决定了它一定是精准的\",{\"1\":{\"600\":1}}],[\"这就决定了我们如何写\",{\"1\":{\"271\":1}}],[\"这就会消耗大量的计算\",{\"1\":{\"510\":1}}],[\"这就没有保证数据一致性的问题\",{\"1\":{\"435\":1}}],[\"这就需要加上前面聊过的重试机制了\",{\"1\":{\"853\":1}}],[\"这就需要去掉2个区间了\",{\"1\":{\"366\":1}}],[\"这就需要我们使用到双指针的思想\",{\"1\":{\"250\":1}}],[\"这就是我们要说的刷盘策略\",{\"1\":{\"753\":1}}],[\"这就是覆盖索引\",{\"1\":{\"727\":1}}],[\"这就是定点数\",{\"1\":{\"599\":1}}],[\"这就是相关子查询\",{\"1\":{\"579\":1}}],[\"这就是满外连接\",{\"1\":{\"539\":1}}],[\"这就是所谓的\",{\"1\":{\"471\":1}}],[\"这就是最优值\",{\"1\":{\"96\":1}}],[\"这就是本文要介绍的两个场景\",{\"1\":{\"12\":1}}],[\"这9个数字都试过来之后\",{\"1\":{\"217\":1}}],[\"这段代码也就是我们去重的代码\",{\"1\":{\"211\":1}}],[\"这些历史快照保存在\",{\"1\":{\"796\":1}}],[\"这些问题呢\",{\"1\":{\"765\":1}}],[\"这些问题有轻重缓急之分\",{\"1\":{\"746\":1}}],[\"这些表用来做连接査询\",{\"1\":{\"703\":1}}],[\"这些数据类型修饰列称为变长字段\",{\"1\":{\"678\":1}}],[\"这些数据结构以某种方式指向数据\",{\"1\":{\"642\":1}}],[\"这些记录在磁盘上的存放方式也被称为行格式或者记录格式\",{\"1\":{\"675\":1}}],[\"这些节点也被称为\",{\"1\":{\"648\":1}}],[\"这些并不涉及真实数据存储的功能划分为mysql\",{\"1\":{\"635\":1}}],[\"这些步骤隐含在\",{\"1\":{\"565\":1}}],[\"这些语句定义了不同的数据库\",{\"1\":{\"517\":1}}],[\"这些特性定义了数据在表中如何存储\",{\"1\":{\"511\":1}}],[\"这些都是关系型数据库\",{\"1\":{\"508\":1}}],[\"这些是\",{\"1\":{\"488\":1}}],[\"这些功能中的每一个都可以根据需要单独使用\",{\"1\":{\"449\":1}}],[\"这些地址可以通过在\",{\"1\":{\"200\":1}}],[\"这些直线需要同时满足满足\",{\"1\":{\"140\":1}}],[\"这回我们不知道要设几种状态\",{\"1\":{\"126\":1}}],[\"这俩个就是候选键\",{\"1\":{\"736\":1}}],[\"这俩个列\",{\"1\":{\"727\":1}}],[\"这俩步就是我们局部最优解\",{\"1\":{\"354\":1}}],[\"这俩道题\",{\"1\":{\"195\":1}}],[\"这俩种状态取最大值\",{\"1\":{\"124\":2,\"126\":2}}],[\"这俩堆的总和尽可能的接近\",{\"1\":{\"97\":1}}],[\"这时请求a的旧值就覆盖了请求b的新值\",{\"1\":{\"847\":1}}],[\"这时\",{\"1\":{\"847\":1}}],[\"这时就可以使用\",{\"1\":{\"831\":1}}],[\"这时就需要用到\",{\"1\":{\"796\":1}}],[\"这时从库的\",{\"1\":{\"820\":1}}],[\"这时我们大概需要进行\",{\"1\":{\"696\":1}}],[\"这时我们就可以采用双指针的方法\",{\"1\":{\"381\":1}}],[\"这时可以通过文件尾的校验和\",{\"1\":{\"668\":1}}],[\"这时会将查询结果进行缓存\",{\"1\":{\"634\":1}}],[\"这时你就会掉入了一个误区\",{\"1\":{\"279\":1}}],[\"这时不用编辑\",{\"1\":{\"152\":1,\"153\":1}}],[\"这时股票就应该有五种状态\",{\"1\":{\"124\":1}}],[\"这时候binlog里面没有对应的修改记录\",{\"1\":{\"812\":1}}],[\"这时候要卖入股票\",{\"1\":{\"122\":1}}],[\"这时候要卖出股票\",{\"1\":{\"122\":1}}],[\"这时候买入股票\",{\"1\":{\"120\":1}}],[\"这时候卖出股票\",{\"1\":{\"120\":1}}],[\"这题相较于前面俩道题难了不少\",{\"1\":{\"124\":1}}],[\"这题要求的是\",{\"1\":{\"105\":1}}],[\"这笔交易所能获得利润\",{\"1\":{\"121\":3,\"123\":3,\"125\":3}}],[\"这里要注意是系统中的事务id\",{\"1\":{\"797\":1}}],[\"这里把思考的流程整理成下面这张图\",{\"1\":{\"694\":1}}],[\"这里说一下\",{\"1\":{\"660\":1}}],[\"这里再次强调\",{\"1\":{\"645\":1}}],[\"这里只记录在\",{\"1\":{\"643\":1}}],[\"这里只讨论heada与headb长度不相等的情况\",{\"1\":{\"391\":1}}],[\"这里只能使用nums\",{\"1\":{\"177\":1}}],[\"这里一定要先移动\",{\"1\":{\"382\":1}}],[\"这里一定要new一个集合\",{\"1\":{\"187\":2}}],[\"这里我们简化了index\",{\"1\":{\"643\":1}}],[\"这里我们创建三个服务\",{\"1\":{\"430\":1}}],[\"这里我们要尽量取得end值小的\",{\"1\":{\"366\":1}}],[\"这里我用used表示\",{\"1\":{\"211\":1}}],[\"这里在进行比较是为了\",{\"1\":{\"308\":1}}],[\"这里\",{\"1\":{\"276\":1,\"601\":1}}],[\"这里为什么是\",{\"1\":{\"276\":1}}],[\"这里为什么要减\",{\"1\":{\"163\":1}}],[\"这里如果单纯的使用\",{\"1\":{\"274\":1}}],[\"这里使用\",{\"1\":{\"271\":3}}],[\"这里的一定频率怎么看待呢\",{\"1\":{\"753\":1}}],[\"这里的一笔交易指买入持有并卖出股票的整个过程\",{\"1\":{\"129\":1}}],[\"这里的b\",{\"1\":{\"653\":1}}],[\"这里的意思是\",{\"1\":{\"379\":1}}],[\"这里的\",{\"1\":{\"211\":2,\"227\":1,\"755\":1}}],[\"这里不要return\",{\"1\":{\"207\":2}}],[\"这里不要\",{\"1\":{\"207\":1}}],[\"这里用\",{\"1\":{\"197\":1}}],[\"这里对\",{\"1\":{\"141\":1}}],[\"这里是容错处理逻辑\",{\"1\":{\"477\":1}}],[\"这里是\",{\"1\":{\"137\":1}}],[\"这里也是和121\",{\"1\":{\"122\":1}}],[\"这里画图将每一个节点选或者不选的最大值标出来就清晰了\",{\"1\":{\"117\":1}}],[\"这里可能有一个疑问\",{\"1\":{\"117\":1}}],[\"这里直接都初始化成0是可以的\",{\"1\":{\"92\":1}}],[\"这颗子树最大和是多少\",{\"1\":{\"117\":2}}],[\"这写起来就比较复杂\",{\"1\":{\"117\":1}}],[\"这种简单的\",{\"1\":{\"772\":1}}],[\"这种现象称为幻读\",{\"1\":{\"746\":1}}],[\"这种状态\",{\"1\":{\"741\":1}}],[\"这种就不符合第二范式\",{\"1\":{\"737\":1}}],[\"这种通过在字段上声明\",{\"1\":{\"687\":1}}],[\"这种嵌套的执行方式就称为相关子查询\",{\"1\":{\"570\":1}}],[\"这种引擎内部有一计数器在维护着行数\",{\"1\":{\"562\":1}}],[\"这种连接称为左\",{\"1\":{\"537\":1}}],[\"这种类型的数据库是\",{\"1\":{\"509\":1}}],[\"这种牺牲局部\",{\"1\":{\"472\":1}}],[\"这种方案其实是比较推荐的\",{\"1\":{\"849\":1}}],[\"这种方案仍然会出现新值被覆盖的问题\",{\"1\":{\"848\":1}}],[\"这种方案貌似解决了上面脏数据\",{\"1\":{\"847\":1}}],[\"这种方案是最不可取的\",{\"1\":{\"846\":1}}],[\"这种方式简单有效\",{\"1\":{\"818\":1}}],[\"这种方式可以在代码中配置\",{\"1\":{\"423\":1}}],[\"这种方法的耗时较高\",{\"1\":{\"177\":1}}],[\"这种方法对于每个结点只会处理一次\",{\"1\":{\"37\":1}}],[\"这种顺序\",{\"1\":{\"325\":1}}],[\"这种\",{\"1\":{\"277\":2}}],[\"这种保存结果的数组\",{\"1\":{\"222\":1}}],[\"这种情况就需要使用\",{\"1\":{\"850\":1}}],[\"这种情况就叫做\",{\"1\":{\"651\":1}}],[\"这种情况由于在查询时\",{\"1\":{\"718\":1}}],[\"这种情况也不对\",{\"1\":{\"372\":1}}],[\"这种情况是不对的\",{\"1\":{\"372\":1}}],[\"这种情况下可能发生\",{\"1\":{\"764\":1}}],[\"这种情况下\",{\"1\":{\"277\":2}}],[\"这种情况时\",{\"1\":{\"153\":1}}],[\"这种情况\",{\"1\":{\"103\":1,\"177\":1}}],[\"这是就需要记录给相关人员手工处理了\",{\"1\":{\"850\":1}}],[\"这是默认的binlog格式\",{\"1\":{\"823\":1}}],[\"这是readview要解决的主要问题\",{\"1\":{\"797\":1}}],[\"这是现代操作系统为了提高文件写入效率做的一个优化\",{\"1\":{\"753\":1}}],[\"这是mysql的默认隔离级别\",{\"1\":{\"746\":1}}],[\"这是大多数数据库系统的默认隔离级别\",{\"1\":{\"746\":1}}],[\"这是满足前面三个范式的\",{\"1\":{\"737\":1}}],[\"这是业务\",{\"1\":{\"727\":1}}],[\"这是由主键索引的物理实现方式决定的\",{\"1\":{\"686\":1}}],[\"这是一个查询语\",{\"1\":{\"634\":1}}],[\"这是一个java正则表达式\",{\"1\":{\"494\":1}}],[\"这是为了尽可能覆盖多的气球\",{\"1\":{\"364\":1}}],[\"这是为了初始化时的简便\",{\"1\":{\"137\":1}}],[\"这是能让孩子们满足胃口的饼干的最小尺寸\",{\"1\":{\"343\":1}}],[\"这是此时唯一可以执行删除操作的重复项\",{\"1\":{\"327\":1}}],[\"这是使用辅助矩阵\",{\"1\":{\"299\":1}}],[\"这是因为一个事务只在第一次\",{\"1\":{\"799\":1}}],[\"这是因为undo\",{\"1\":{\"755\":1}}],[\"这是因为所有关键字都存储在叶子结点中\",{\"1\":{\"662\":1}}],[\"这是因为b+树的中间结点不存储数据\",{\"1\":{\"662\":1}}],[\"这是因为遇到\",{\"1\":{\"658\":1}}],[\"这是因为\",{\"1\":{\"451\":1,\"637\":1,\"719\":1,\"801\":1}}],[\"这是因为项目环境是jdk17\",{\"1\":{\"422\":1}}],[\"这是因为10元只能找给20元\",{\"1\":{\"358\":1}}],[\"这是因为题目中要求保持相对顺序\",{\"1\":{\"313\":1}}],[\"这是因为mid一定不是最小的\",{\"1\":{\"276\":1}}],[\"这是因为我们在回溯的过程中\",{\"1\":{\"211\":1}}],[\"这是因为我们使用的是一维数组\",{\"1\":{\"92\":1}}],[\"这是因为递归的方式隐含地使用了系统的\",{\"1\":{\"12\":1}}],[\"这是利用了二叉搜索树的性质\",{\"1\":{\"89\":1}}],[\"这样同样可以提升数据库的并发处理能力\",{\"1\":{\"818\":1}}],[\"这样可以提高吞吐量\",{\"1\":{\"782\":1}}],[\"这样可能不好理解\",{\"1\":{\"74\":1}}],[\"这样别人想拿这个数据就会\",{\"1\":{\"781\":1}}],[\"这样做的好处是占用的锁空间降低了\",{\"1\":{\"779\":1}}],[\"这样一来\",{\"1\":{\"772\":1}}],[\"这样一来可以保证单个语句内生成的自增值是连续的\",{\"1\":{\"772\":1}}],[\"这样也就避免了不可重复读和幻读的问题\",{\"1\":{\"765\":1}}],[\"这样之后回滚时再把这条记录\",{\"1\":{\"755\":1}}],[\"这样之后回滚时再把由这些内容组成的记录\",{\"1\":{\"755\":1}}],[\"这样\",{\"1\":{\"733\":1}}],[\"这样会加快查询速度\",{\"1\":{\"729\":1}}],[\"这样会消耗过多的cpu和i0资源\",{\"1\":{\"724\":1}}],[\"这样通过建立一个双向链表把许许多多的页就都串联起来了\",{\"1\":{\"668\":1}}],[\"这样有什么好处呢\",{\"1\":{\"662\":1}}],[\"这样有什么问题\",{\"1\":{\"447\":1}}],[\"这样节省空间\",{\"1\":{\"604\":1}}],[\"这样使得整个表静态化\",{\"1\":{\"604\":1}}],[\"这样很短的信息应该用char\",{\"1\":{\"604\":1}}],[\"这样不断迭代\",{\"1\":{\"598\":1}}],[\"这样的说法\",{\"1\":{\"776\":1}}],[\"这样的接口\",{\"1\":{\"731\":1}}],[\"这样的子查询就称之为\",{\"1\":{\"579\":1}}],[\"这样的划分是错误的\",{\"1\":{\"367\":1}}],[\"这样虽然不报错\",{\"1\":{\"522\":1}}],[\"这样在访问某条记录时\",{\"1\":{\"798\":1}}],[\"这样在本次事务提交或者回\",{\"1\":{\"745\":1}}],[\"这样在检\",{\"1\":{\"510\":1}}],[\"这样在处理的过程中就不会乱\",{\"1\":{\"288\":1}}],[\"这样写是错误的\",{\"1\":{\"464\":1}}],[\"这样头结点和其他结点的操作都一致了\",{\"1\":{\"377\":1}}],[\"这样能尽可能的监控多个结点\",{\"1\":{\"372\":1}}],[\"这样才能拼接更多的区间\",{\"1\":{\"366\":1}}],[\"这样才能保证\",{\"1\":{\"360\":1}}],[\"这样即不会浪费饼干\",{\"1\":{\"344\":1}}],[\"这样每个节点都只会被访问一次\",{\"1\":{\"222\":1}}],[\"这样遍历不用考虑遍历顺序的问题\",{\"1\":{\"222\":1}}],[\"这样是不行的\",{\"1\":{\"197\":1}}],[\"这样就\",{\"1\":{\"818\":1}}],[\"这样就产生了\",{\"1\":{\"768\":1}}],[\"这样就能确保在给定的时间里\",{\"1\":{\"767\":1}}],[\"这样就可以提升事务并发处理能力\",{\"1\":{\"801\":1}}],[\"这样就可以造成一个假象\",{\"1\":{\"755\":1}}],[\"这样就可以在这些数据结构的基础上实现\",{\"1\":{\"642\":1}}],[\"这样就不满足bcnf\",{\"1\":{\"737\":1}}],[\"这样就大大减少了回表操作\",{\"1\":{\"728\":1}}],[\"这样就降低了数据的维护速度\",{\"1\":{\"642\":1}}],[\"这样就避免了遍历过程中的重复计数的情况\",{\"1\":{\"226\":1}}],[\"这样就把这棵树全遍历完了\",{\"1\":{\"185\":1}}],[\"这样就只需要考虑儿子节点了\",{\"1\":{\"117\":1}}],[\"这样就实现了层序遍历\",{\"1\":{\"12\":1}}],[\"这样需要最多考虑四个节点\",{\"1\":{\"117\":1}}],[\"这个方案\",{\"1\":{\"849\":1}}],[\"这个间隔多长时间根据你具体的业务去考虑\",{\"1\":{\"848\":1}}],[\"这个从服务器本地的日志文件就叫\",{\"1\":{\"813\":1}}],[\"这个命令可以这样理解\",{\"1\":{\"809\":1}}],[\"这个超时时间可以通过参数innodb\",{\"1\":{\"786\":1}}],[\"这个区间的记录都不允许增加\",{\"1\":{\"776\":1}}],[\"这个区间的新记录是不允许立即插入的\",{\"1\":{\"776\":1}}],[\"这个过程其实是通过在\",{\"1\":{\"770\":1}}],[\"这个过程称之为\",{\"1\":{\"755\":1}}],[\"这个过程称为\",{\"1\":{\"651\":1}}],[\"这个readview中主要包含4个比较重要的内容\",{\"1\":{\"797\":1}}],[\"这个readview\",{\"1\":{\"765\":1}}],[\"这个所谓\",{\"1\":{\"763\":1}}],[\"这个排队的过程其实是通过锁来实现的\",{\"1\":{\"763\":1}}],[\"这个事务对数据库中所做的更改也不能丢失\",{\"1\":{\"749\":1}}],[\"这个问题直到最新版本的mysql\",{\"1\":{\"731\":1}}],[\"这个filtered列的值没什么意义\",{\"1\":{\"709\":1}}],[\"这个列的基数指标非常重要\",{\"1\":{\"689\":1}}],[\"这个速度损耗可以忽略\",{\"1\":{\"689\":1}}],[\"这个属性表示当前记录在本页中的位置\",{\"1\":{\"680\":1}}],[\"这个属性表示当前记录的类型\",{\"1\":{\"680\":1}}],[\"这个属性标记着当前记录是否被删除\",{\"1\":{\"680\":1}}],[\"这个部分占用固定的56个字节\",{\"1\":{\"674\":1}}],[\"这个部分也是为了校验页的完整性的\",{\"1\":{\"669\":1}}],[\"这个部分是和file\",{\"1\":{\"669\":1}}],[\"这个比较短的值就称为校验和\",{\"1\":{\"668\":1}}],[\"这个代表当前页的类型\",{\"1\":{\"668\":1}}],[\"这个文件并不划分为若干个数据页\",{\"1\":{\"654\":1}}],[\"这个包含两层含义\",{\"1\":{\"652\":1}}],[\"这个目录有一个别名\",{\"1\":{\"643\":1}}],[\"这个表使用\",{\"1\":{\"643\":1}}],[\"这个新建的\",{\"1\":{\"643\":1}}],[\"这个关键字识别出来\",{\"1\":{\"634\":1}}],[\"这个查询缓存可以在\",{\"1\":{\"630\":1}}],[\"这个缓存机制是由一系列小缓存组成的\",{\"1\":{\"630\":1}}],[\"这个执行计划表明应该\",{\"1\":{\"629\":1}}],[\"这个1位\",{\"1\":{\"601\":1}}],[\"这个本部门是要使用到主查询中的部门id\",{\"1\":{\"579\":1}}],[\"这个特性从mysql\",{\"1\":{\"568\":1}}],[\"这个操作就非常耗时了\",{\"1\":{\"565\":1}}],[\"这个操作是为了确保我们在每一步都选择能够使下一步覆盖的范围最大化的位置\",{\"1\":{\"352\":1}}],[\"这个谓词匹配符合该pattern的host\",{\"1\":{\"493\":1}}],[\"这个和juc\",{\"1\":{\"481\":1}}],[\"这个和juc中的\",{\"1\":{\"480\":1}}],[\"这个和是否出现过\",{\"1\":{\"170\":1}}],[\"这个是基于异常数量\",{\"1\":{\"415\":1}}],[\"这个调用叫做慢调用\",{\"1\":{\"412\":1}}],[\"这个虚拟头结点指向头结点\",{\"1\":{\"377\":1}}],[\"这个序列包含几个长度为\",{\"1\":{\"345\":1}}],[\"这个孩子会得到满足\",{\"1\":{\"343\":1}}],[\"这个四步其实过于理论化了\",{\"1\":{\"342\":1}}],[\"这个题目其实和\",{\"1\":{\"328\":1}}],[\"这个无需考虑\",{\"1\":{\"261\":1}}],[\"这个岛被分割成一个由若干方形单元格组成的网格\",{\"1\":{\"233\":1}}],[\"这个容器可以使用栈\",{\"1\":{\"222\":1}}],[\"这个地方的所有房屋的排列类似于一棵二叉树\",{\"1\":{\"116\":1}}],[\"这个地方所有的房屋都\",{\"1\":{\"114\":1}}],[\"这个地区只有一个入口\",{\"1\":{\"116\":1}}],[\"这个\",{\"1\":{\"97\":1,\"207\":1}}],[\"这个节点\",{\"1\":{\"67\":1}}],[\"这个时候我们可以从全量备份中分离出单个库的备份\",{\"1\":{\"832\":1}}],[\"这个时候可以考虑排除掉这些\",{\"1\":{\"831\":1}}],[\"这个时候\",{\"1\":{\"12\":1}}],[\"这句话背下来\",{\"1\":{\"60\":1}}],[\"这句话怎么理解呢\",{\"1\":{\"33\":1}}],[\"这道题的大体思路就是从下到上将叶子结点的父节点放上监控\",{\"1\":{\"372\":1}}],[\"这道题相较于\",{\"1\":{\"352\":1}}],[\"这道题key存储元素\",{\"1\":{\"337\":1}}],[\"这道题无需使用\",{\"1\":{\"230\":1}}],[\"这道题是判断是否是有效ip地址\",{\"1\":{\"201\":1}}],[\"这道题思路分析\",{\"1\":{\"201\":1}}],[\"这道题仍然需要一个\",{\"1\":{\"199\":1}}],[\"这道题就比较容易了\",{\"1\":{\"190\":1}}],[\"这道题在\",{\"1\":{\"143\":1}}],[\"这道题说要完成k次交易\",{\"1\":{\"126\":1}}],[\"这道题目可能我们只会想\",{\"1\":{\"122\":1}}],[\"这道题与\",{\"1\":{\"117\":1,\"207\":1}}],[\"这道题与198\",{\"1\":{\"115\":1}}],[\"这道题与上面的动态规划题有些不一样\",{\"1\":{\"99\":1}}],[\"这道题由俩个纬度\",{\"1\":{\"101\":1}}],[\"这道题我们可以把\",{\"1\":{\"101\":1}}],[\"这道题我们也可以转换为\",{\"1\":{\"95\":1}}],[\"这道题大概一看\",{\"1\":{\"95\":1}}],[\"这道题其实我们仔细找一下规律和杨辉三角非常的像\",{\"1\":{\"85\":1}}],[\"这道题其实和\",{\"1\":{\"70\":1,\"139\":1}}],[\"这道题也可以这样做\",{\"1\":{\"60\":1}}],[\"这道题和135\",{\"1\":{\"362\":1}}],[\"这道题和\",{\"1\":{\"45\":1,\"105\":1,\"120\":1,\"366\":1}}],[\"这条路径上所有节点值相加等于目标和\",{\"1\":{\"44\":1}}],[\"这也就意味着这4条记录是从小到大依次递增\",{\"1\":{\"672\":1}}],[\"这也就说明了为什么要在消费端引入\",{\"1\":{\"402\":1}}],[\"这也是常用的4种\",{\"1\":{\"805\":1}}],[\"这也是三种锁模式中扩展性最好的一种\",{\"1\":{\"772\":1}}],[\"这也是创建索引最主\",{\"1\":{\"642\":1}}],[\"这也是贪心的局部最优解\",{\"1\":{\"358\":1}}],[\"这也是没有终止条件而不陷入无线循环的原因\",{\"1\":{\"217\":1}}],[\"这也是隐藏的回溯\",{\"1\":{\"39\":1}}],[\"这也没进行回溯啊\",{\"1\":{\"39\":1}}],[\"是主键\",{\"1\":{\"837\":1}}],[\"是经典的\",{\"1\":{\"835\":1}}],[\"是具有高可用性\",{\"1\":{\"819\":1}}],[\"是日志文件名\",{\"1\":{\"809\":1}}],[\"是系统最大的事务id值\",{\"1\":{\"797\":1}}],[\"是悲观锁的实现\",{\"1\":{\"791\":1}}],[\"是通过数据行的多个版本管理来实现数据库的\",{\"1\":{\"790\":1}}],[\"是通过计算\",{\"1\":{\"261\":1}}],[\"是持久的\",{\"1\":{\"751\":1}}],[\"是易失的\",{\"1\":{\"751\":1}}],[\"是定期刷新\",{\"1\":{\"749\":1}}],[\"是语义上的而不是语法上的\",{\"1\":{\"741\":1}}],[\"是防止主键的某一列会依赖于主键的其他列\",{\"1\":{\"737\":1}}],[\"是张三使用\",{\"1\":{\"732\":1}}],[\"是mysql\",{\"1\":{\"728\":1}}],[\"是较为重要的一个指标\",{\"1\":{\"704\":1}}],[\"是表示按照何种方式排序\",{\"1\":{\"699\":1}}],[\"是表示二进制的\",{\"1\":{\"601\":1}}],[\"是目前\",{\"1\":{\"686\":1}}],[\"是根据c2列的值查询一条完整的用户记录需要使用到2棵b+树\",{\"1\":{\"651\":1}}],[\"是帮助mysql高效获取数据的数据结构\",{\"1\":{\"642\":1}}],[\"是典型的\",{\"1\":{\"624\":1}}],[\"是复合主键\",{\"1\":{\"616\":1}}],[\"是数据行使用的存储总量\",{\"1\":{\"604\":1}}],[\"是数组大小\",{\"1\":{\"336\":1}}],[\"是数组中的一个连续部分\",{\"1\":{\"142\":1,\"347\":1}}],[\"是数组\",{\"1\":{\"132\":1}}],[\"是占用\",{\"1\":{\"597\":1}}],[\"是每个字符串中字符的ansi编码是否相等\",{\"1\":{\"528\":1}}],[\"是忽略大小写的\",{\"1\":{\"518\":1}}],[\"是sql中最基础的\",{\"1\":{\"517\":1}}],[\"是使用关系模型的数据库应用语言\",{\"1\":{\"516\":1}}],[\"是最流行的文档型数据库\",{\"1\":{\"510\":1}}],[\"是熔断机制的一种实现方式\",{\"1\":{\"475\":1}}],[\"是feign的日志打印问题\",{\"1\":{\"467\":1}}],[\"是用来管理版本依赖版本号的\",{\"1\":{\"441\":1}}],[\"是面向分布式\",{\"1\":{\"406\":1}}],[\"是阿里云提供的海量\",{\"1\":{\"399\":1}}],[\"是重新构造后的队列\",{\"1\":{\"361\":1}}],[\"是排在队列前面的人\",{\"1\":{\"361\":1}}],[\"是队列中第\",{\"1\":{\"361\":1}}],[\"是从前往后比较当前孩子>左孩子得到的\",{\"1\":{\"360\":2}}],[\"是从楼梯第\",{\"1\":{\"82\":1}}],[\"是第\",{\"1\":{\"357\":1}}],[\"是第一个错误的版本\",{\"1\":{\"274\":1}}],[\"是正负交替出现的\",{\"1\":{\"345\":1}}],[\"是正着读和反着读都一样的字符串\",{\"1\":{\"198\":1}}],[\"是正着读和倒过来读一样的字符串\",{\"1\":{\"154\":1}}],[\"是什么\",{\"1\":{\"342\":1,\"399\":1,\"404\":1,\"406\":1,\"457\":1}}],[\"是转换之后的行\",{\"1\":{\"298\":1}}],[\"是满足\",{\"1\":{\"290\":1}}],[\"是该条件下的长度最小的子数组\",{\"1\":{\"284\":1}}],[\"是无法删除的\",{\"1\":{\"279\":1}}],[\"是无效的\",{\"1\":{\"201\":1}}],[\"是以\",{\"1\":{\"278\":1}}],[\"是不能直接读取最新版本的记录的\",{\"1\":{\"797\":1}}],[\"是不成立的\",{\"1\":{\"271\":1}}],[\"是不是快乐数\",{\"1\":{\"169\":1}}],[\"是不是\",{\"1\":{\"12\":1}}],[\"是没有意义的\",{\"1\":{\"271\":1}}],[\"是有意义的\",{\"1\":{\"271\":2}}],[\"是有效的\",{\"1\":{\"201\":1}}],[\"是回文子串的俩种情况\",{\"1\":{\"262\":1}}],[\"是回文子串\",{\"1\":{\"261\":1}}],[\"是相辅相成的\",{\"1\":{\"222\":1}}],[\"是相同的\",{\"1\":{\"148\":1,\"153\":1}}],[\"是合法的\",{\"1\":{\"201\":2}}],[\"是合法的二叉搜索树\",{\"1\":{\"67\":1}}],[\"是因为\",{\"1\":{\"271\":1}}],[\"是因为去重主要是对同一层进行去重\",{\"1\":{\"197\":1}}],[\"是因为我们要逐渐累加头结点为\",{\"1\":{\"89\":1}}],[\"是范围\",{\"1\":{\"192\":1}}],[\"是很正常的\",{\"1\":{\"184\":1}}],[\"是丑数\",{\"1\":{\"173\":1}}],[\"是由非空格字符组成的字符串\",{\"1\":{\"244\":1}}],[\"是由一些相邻的\",{\"1\":{\"227\":1}}],[\"是由\",{\"1\":{\"211\":1}}],[\"是由重新排列源单词的所有字母得到的一个新单词\",{\"1\":{\"164\":1}}],[\"是由数组派生而来的序列\",{\"1\":{\"132\":1}}],[\"是字符串中的由连续字符组成的一个序列\",{\"1\":{\"154\":1}}],[\"是这两个字符串所共同拥有的子序列\",{\"1\":{\"138\":1}}],[\"是某支给定的股票在第\",{\"1\":{\"125\":1}}],[\"是否启用自动从开启状态过渡到半开状态\",{\"1\":{\"477\":1}}],[\"是否集群模式\",{\"1\":{\"419\":1}}],[\"是否集群\",{\"1\":{\"409\":1,\"419\":1}}],[\"是否在单元测试中出错\",{\"1\":{\"274\":1}}],[\"是否有冲突\",{\"1\":{\"215\":2}}],[\"是否满足上述形式\",{\"1\":{\"173\":1}}],[\"是否是\",{\"1\":{\"161\":1}}],[\"是否是回文子串了\",{\"1\":{\"261\":1}}],[\"是否是回文子串\",{\"1\":{\"155\":1}}],[\"是否是合法的\",{\"1\":{\"111\":1}}],[\"是否相等即可\",{\"1\":{\"146\":1}}],[\"是否为回文子串\",{\"1\":{\"262\":1}}],[\"是否为\",{\"1\":{\"145\":1,\"172\":1}}],[\"是否合法\",{\"1\":{\"111\":1}}],[\"是否出现在\",{\"1\":{\"111\":1}}],[\"是否能够为空格拆分\",{\"1\":{\"111\":1}}],[\"是否和上一个结点相同\",{\"1\":{\"60\":1}}],[\"是一种在存储引擎层使用索引过滤数据的一种优\",{\"1\":{\"728\":1}}],[\"是一种轻量级的\",{\"1\":{\"608\":1}}],[\"是一种组合\",{\"1\":{\"103\":1}}],[\"是一套开源的分布式服务发现和\",{\"1\":{\"449\":1}}],[\"是一款开源的分布式事务解决方案\",{\"1\":{\"426\":1}}],[\"是一个主库线程\",{\"1\":{\"820\":1}}],[\"是一个子网掩码\",{\"1\":{\"495\":1}}],[\"是一个ip地址\",{\"1\":{\"495\":1}}],[\"是一个用于帮助构建弹性和容错性应用程序的\",{\"1\":{\"474\":1}}],[\"是一个声明式的web服务客户端\",{\"1\":{\"462\":1}}],[\"是一个数组\",{\"1\":{\"419\":1}}],[\"是一个流量防卫防护组件注解\",{\"1\":{\"416\":1}}],[\"是一个\",{\"1\":{\"345\":1}}],[\"是一个算符\",{\"1\":{\"330\":1}}],[\"是一个非递减数组\",{\"1\":{\"275\":1}}],[\"是一个升序数组\",{\"1\":{\"241\":1}}],[\"是一个从节点\",{\"1\":{\"223\":1}}],[\"是一个整数\",{\"1\":{\"108\":1}}],[\"是一位数字或者\",{\"1\":{\"216\":1}}],[\"是一样的\",{\"1\":{\"12\":1,\"201\":1}}],[\"是集合\",{\"1\":{\"100\":1}}],[\"是\",{\"1\":{\"61\":1,\"63\":1,\"65\":1,\"97\":1,\"138\":1,\"145\":1,\"155\":1,\"162\":1,\"169\":1,\"200\":2,\"379\":1,\"393\":1,\"557\":1,\"599\":1,\"710\":1,\"717\":1,\"785\":1,\"811\":3,\"866\":1}}],[\"是二叉搜索树\",{\"1\":{\"53\":1}}],[\"是二叉树的先序遍历\",{\"1\":{\"48\":1}}],[\"是二叉树的中序遍历\",{\"1\":{\"46\":1}}],[\"是同一棵树的中序遍历\",{\"1\":{\"48\":1}}],[\"是同一棵树的后序遍历\",{\"1\":{\"46\":1}}],[\"是指数据的精确性\",{\"1\":{\"612\":1}}],[\"是指从一个陆地单元格走到另一个相邻\",{\"1\":{\"229\":1}}],[\"是指从根节点到最远叶子节点的最长路径上的节点数\",{\"1\":{\"25\":1}}],[\"是指在同一个父结点下\",{\"1\":{\"207\":1}}],[\"是指这样一个新的字符串\",{\"1\":{\"138\":1}}],[\"是指没有子节点的节点\",{\"1\":{\"38\":1,\"44\":1}}],[\"是比较两段代码的话\",{\"1\":{\"12\":1}}],[\"vue\",{\"1\":{\"886\":2}}],[\"vuepress\",{\"0\":{\"868\":1},\"1\":{\"864\":2,\"866\":2,\"867\":1,\"868\":2,\"869\":1,\"885\":1}}],[\"vv\",{\"1\":{\"809\":1}}],[\"v2\",{\"1\":{\"486\":1}}],[\"vs\",{\"0\":{\"537\":1},\"1\":{\"457\":1,\"600\":1}}],[\"verbosity\",{\"1\":{\"807\":1}}],[\"verbose>\",{\"1\":{\"442\":1}}],[\"version=\",{\"1\":{\"441\":1,\"442\":1}}],[\"version>4\",{\"1\":{\"441\":1}}],[\"version>2023\",{\"1\":{\"441\":1}}],[\"version>2022\",{\"1\":{\"420\":1,\"441\":1}}],[\"version>2\",{\"1\":{\"441\":2,\"486\":1}}],[\"version>8\",{\"1\":{\"441\":1}}],[\"version>12\",{\"1\":{\"486\":1}}],[\"version>1\",{\"1\":{\"441\":3,\"486\":2}}],[\"version>5\",{\"1\":{\"441\":1}}],[\"version>3\",{\"1\":{\"420\":1,\"441\":3}}],[\"version>\",{\"1\":{\"399\":1,\"402\":2,\"420\":2,\"423\":3,\"432\":2,\"441\":27,\"442\":5,\"443\":1,\"468\":2,\"486\":10}}],[\"version\",{\"1\":{\"274\":2,\"429\":1,\"441\":14,\"449\":1,\"486\":6}}],[\"vgroup\",{\"1\":{\"432\":1}}],[\"v1\",{\"1\":{\"429\":2,\"809\":1}}],[\"var\",{\"1\":{\"699\":5,\"806\":1,\"807\":1,\"822\":1}}],[\"variable\",{\"1\":{\"696\":2,\"745\":1,\"751\":1,\"806\":1,\"807\":1,\"809\":3,\"870\":1}}],[\"variables\",{\"1\":{\"585\":1,\"635\":1,\"698\":2,\"745\":1,\"746\":1,\"751\":1,\"806\":1,\"807\":1,\"809\":1}}],[\"varbinary\",{\"1\":{\"678\":1}}],[\"varchar来代替\",{\"1\":{\"605\":1}}],[\"varchar动态根据长度的特性就消失了\",{\"1\":{\"604\":1}}],[\"varchar类型相同\",{\"1\":{\"605\":1}}],[\"varchar类型的字段所占用的存储空间\",{\"1\":{\"604\":1}}],[\"varchar类型\",{\"1\":{\"604\":1,\"717\":1}}],[\"varchar\",{\"0\":{\"604\":1},\"1\":{\"428\":17,\"431\":6,\"440\":2,\"603\":1,\"604\":5,\"605\":1,\"617\":2,\"618\":7,\"619\":1,\"676\":3,\"687\":2,\"689\":1}}],[\"validated\",{\"1\":{\"497\":1}}],[\"val的元素\",{\"1\":{\"280\":2}}],[\"val比最大值还大\",{\"1\":{\"70\":1}}],[\"val互不相同\",{\"1\":{\"61\":1}}],[\"valuen\",{\"1\":{\"542\":7}}],[\"value2\",{\"1\":{\"542\":8,\"552\":1,\"559\":2}}],[\"value1\",{\"1\":{\"542\":8,\"552\":2,\"559\":2}}],[\"value增加回应头\",{\"1\":{\"501\":1}}],[\"value符合\",{\"1\":{\"493\":1}}],[\"value=\",{\"1\":{\"442\":4}}],[\"values\",{\"1\":{\"428\":4,\"431\":2,\"440\":1,\"444\":2,\"542\":4,\"606\":5,\"607\":3,\"608\":1,\"676\":1,\"680\":1,\"704\":1,\"791\":1,\"800\":2}}],[\"value`\",{\"1\":{\"428\":1}}],[\"value存储每个元素出现的次数\",{\"1\":{\"337\":1}}],[\"value存储下标\",{\"1\":{\"175\":1}}],[\"value代表值\",{\"1\":{\"193\":1}}],[\"valueof\",{\"1\":{\"165\":2,\"332\":1,\"370\":2}}],[\"value\",{\"1\":{\"22\":1,\"58\":1,\"60\":1,\"65\":1,\"91\":5,\"92\":4,\"93\":2,\"95\":2,\"101\":1,\"107\":3,\"109\":1,\"120\":1,\"165\":2,\"286\":2,\"337\":1,\"348\":1,\"402\":3,\"403\":1,\"410\":1,\"416\":2,\"417\":3,\"418\":1,\"420\":1,\"428\":4,\"431\":2,\"443\":4,\"449\":1,\"452\":1,\"459\":1,\"463\":4,\"464\":2,\"477\":3,\"480\":1,\"481\":1,\"482\":1,\"499\":3,\"500\":1,\"501\":1,\"510\":2,\"559\":1,\"696\":2,\"745\":1,\"751\":1,\"806\":1,\"807\":1,\"809\":1}}],[\"val\",{\"1\":{\"2\":8,\"3\":1,\"4\":1,\"6\":1,\"7\":1,\"8\":1,\"11\":1,\"12\":2,\"13\":1,\"14\":1,\"15\":1,\"16\":8,\"17\":1,\"18\":8,\"20\":8,\"21\":1,\"22\":8,\"23\":2,\"24\":7,\"25\":1,\"26\":7,\"27\":1,\"28\":7,\"30\":1,\"31\":14,\"32\":1,\"33\":4,\"34\":1,\"35\":7,\"36\":1,\"37\":7,\"38\":1,\"39\":13,\"40\":1,\"41\":2,\"42\":1,\"43\":2,\"44\":1,\"45\":7,\"47\":1,\"49\":1,\"52\":3,\"53\":6,\"54\":22,\"55\":1,\"56\":3,\"57\":1,\"58\":2,\"59\":1,\"60\":5,\"61\":1,\"64\":11,\"65\":6,\"66\":16,\"67\":1,\"68\":3,\"69\":1,\"70\":7,\"73\":1,\"74\":2,\"116\":1,\"117\":8,\"163\":2,\"278\":5,\"279\":1,\"280\":2,\"376\":8,\"378\":3,\"379\":3,\"380\":1,\"383\":1,\"384\":7,\"385\":1,\"388\":1,\"390\":1,\"393\":1}}],[\"vim\",{\"1\":{\"822\":1}}],[\"view\",{\"1\":{\"795\":1,\"797\":1,\"799\":3}}],[\"viewresolversprovider\",{\"1\":{\"423\":2}}],[\"viewresolvers\",{\"1\":{\"423\":3}}],[\"visit\",{\"1\":{\"503\":4}}],[\"visited\",{\"1\":{\"226\":6,\"228\":6,\"230\":1}}],[\"vintage\",{\"1\":{\"442\":1}}],[\"vintage<\",{\"1\":{\"442\":1}}],[\"vm\",{\"1\":{\"422\":1}}],[\"v\",{\"1\":{\"91\":3,\"193\":2,\"500\":1,\"809\":2}}],[\"void\",{\"1\":{\"12\":4,\"29\":1,\"31\":1,\"39\":4,\"41\":1,\"56\":1,\"58\":1,\"60\":1,\"74\":1,\"91\":2,\"92\":1,\"185\":2,\"187\":2,\"190\":3,\"191\":2,\"193\":2,\"195\":2,\"197\":1,\"199\":2,\"201\":2,\"203\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":1,\"215\":3,\"217\":1,\"222\":1,\"224\":2,\"226\":2,\"228\":2,\"230\":2,\"232\":4,\"234\":1,\"251\":1,\"254\":1,\"256\":1,\"298\":1,\"299\":1,\"302\":1,\"317\":1,\"321\":1,\"323\":2,\"379\":1,\"403\":1,\"410\":1,\"422\":1,\"423\":2,\"424\":1,\"432\":3,\"433\":2,\"434\":3,\"443\":1,\"444\":1,\"446\":2,\"463\":2,\"464\":1,\"489\":1}}],[\"与之关联\",{\"1\":{\"763\":1}}],[\"与之右相等\",{\"1\":{\"211\":1}}],[\"与主属性相对\",{\"1\":{\"736\":1}}],[\"与索引列进行等值匹配的对象信息\",{\"1\":{\"707\":1}}],[\"与文件头的校验和做比对\",{\"1\":{\"668\":1}}],[\"与数据库文件打交道\",{\"1\":{\"633\":1}}],[\"与数据库文件的存储方式无关\",{\"1\":{\"633\":1}}],[\"与数据直\",{\"1\":{\"516\":1}}],[\"与具有给定名称且其值与正则表达式相匹配的\",{\"1\":{\"493\":1}}],[\"与阿里巴巴的sentinel不兼容\",{\"1\":{\"420\":1}}],[\"与阈值类型组合使用\",{\"1\":{\"409\":1}}],[\"与其说贪心算法是一种算法\",{\"1\":{\"344\":1}}],[\"与最后一个元素都是1\",{\"1\":{\"311\":1}}],[\"与电话按键相同\",{\"1\":{\"192\":1}}],[\"与以下标\",{\"1\":{\"152\":2,\"153\":2}}],[\"与上一步没有关系\",{\"1\":{\"77\":1}}],[\"与后序遍历+中序遍历不同的是\",{\"1\":{\"49\":1}}],[\"与后序遍历不同的是\",{\"1\":{\"49\":1}}],[\"与实际答案相差\",{\"1\":{\"17\":1}}],[\"与\",{\"0\":{\"589\":1,\"604\":1},\"1\":{\"12\":3,\"137\":2,\"139\":2,\"146\":2,\"148\":4,\"153\":9,\"212\":1,\"233\":1,\"240\":3,\"261\":1,\"273\":1,\"291\":1,\"313\":1,\"399\":7,\"450\":1,\"528\":1,\"687\":1,\"690\":1,\"870\":1}}],[\"最新数据\",{\"1\":{\"791\":1}}],[\"最暴力的一个办法就是\",{\"1\":{\"749\":1}}],[\"最佳左前缀法则\",{\"0\":{\"716\":1}}],[\"最左前缀集合\",{\"1\":{\"686\":1}}],[\"最左边的值\",{\"1\":{\"277\":1}}],[\"最左边\",{\"1\":{\"42\":1,\"290\":2}}],[\"最差的情况下需要遍历链表上的所有节点才能完成检索\",{\"1\":{\"673\":1}}],[\"最好为列的基数大的列建立索引\",{\"1\":{\"689\":1}}],[\"最好是采用\",{\"1\":{\"618\":1}}],[\"最好使用固定长度\",{\"1\":{\"604\":1}}],[\"最接近于x的整数\",{\"1\":{\"548\":1}}],[\"最古老\",{\"1\":{\"509\":1}}],[\"最外层的namespace是可以用于区分部署环境的\",{\"1\":{\"404\":1}}],[\"最低支持\",{\"1\":{\"399\":7}}],[\"最远距离仍然不能覆盖整个数组\",{\"1\":{\"350\":1}}],[\"最远位置超过了数组长度\",{\"1\":{\"350\":1}}],[\"最重要的一点\",{\"1\":{\"731\":1}}],[\"最重要的是学到了\",{\"1\":{\"339\":1}}],[\"最重要的就是该步\",{\"1\":{\"337\":1}}],[\"最优的分法为\",{\"1\":{\"257\":1}}],[\"最容易想到的无疑是暴力法\",{\"1\":{\"175\":1}}],[\"最终得到数据\",{\"1\":{\"725\":1}}],[\"最终只执行了6次请求\",{\"1\":{\"411\":1}}],[\"最终一定会相遇\",{\"1\":{\"391\":1}}],[\"最终pa和pb相遇的位置就是相交的结点\",{\"1\":{\"391\":1}}],[\"最终结果就是拿走最大数额的钱\",{\"1\":{\"342\":1}}],[\"最终返回有效数组的长度为\",{\"1\":{\"313\":1}}],[\"最终都会被填充为\",{\"1\":{\"231\":1}}],[\"最终dp数组如下图所示\",{\"1\":{\"137\":1}}],[\"最终我们得到的题解代码为\",{\"1\":{\"12\":1}}],[\"最长子序列的长度\",{\"1\":{\"345\":1}}],[\"最长重复子数组\",{\"1\":{\"139\":1,\"146\":1}}],[\"最长公共子序列是\",{\"1\":{\"138\":2}}],[\"最长公共前缀为\",{\"1\":{\"137\":1}}],[\"最长连续递增序列是\",{\"1\":{\"134\":2}}],[\"最长递增子序列是\",{\"1\":{\"132\":1}}],[\"最少糖果数目\",{\"1\":{\"359\":1}}],[\"最少操作次数为dp\",{\"1\":{\"153\":2}}],[\"最少编辑距离\",{\"1\":{\"152\":4,\"153\":2}}],[\"最少得编辑距离为\",{\"1\":{\"152\":1}}],[\"最少需要dp\",{\"1\":{\"107\":2,\"109\":1}}],[\"最少的硬币个数\",{\"1\":{\"106\":1}}],[\"最多只有一个\",{\"1\":{\"686\":1}}],[\"最多只会剩下一块\",{\"1\":{\"96\":1}}],[\"最多能存放1000x1800x1000x100=1000\",{\"1\":{\"648\":1}}],[\"最多能存放1000x1000x100=1\",{\"1\":{\"648\":1}}],[\"最多能存放1000x100=10\",{\"1\":{\"648\":1}}],[\"最多能存放100条记录\",{\"1\":{\"648\":1}}],[\"最多调用\",{\"1\":{\"321\":1}}],[\"最多在剪枝一下\",{\"1\":{\"218\":1}}],[\"最多使用一次\",{\"1\":{\"189\":1}}],[\"最多有\",{\"1\":{\"100\":1}}],[\"最多\",{\"1\":{\"100\":1,\"121\":1}}],[\"最小记录和最大记录的heap\",{\"1\":{\"680\":1}}],[\"最小最大记录\",{\"0\":{\"672\":1}}],[\"最小值为1m\",{\"1\":{\"751\":1}}],[\"最小值\",{\"1\":{\"562\":1}}],[\"最小长度为1\",{\"1\":{\"495\":1}}],[\"最小触发压缩的大小\",{\"1\":{\"469\":1}}],[\"最小请求数\",{\"1\":{\"412\":1}}],[\"最小\",{\"1\":{\"363\":1}}],[\"最小元素\",{\"1\":{\"276\":1}}],[\"最小的可能重量\",{\"1\":{\"96\":1}}],[\"最小深度是\",{\"1\":{\"28\":1}}],[\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量\",{\"1\":{\"27\":1}}],[\"最近公共祖先表示为一个结点\",{\"1\":{\"63\":1}}],[\"最近公共祖先表示为一个节点\",{\"1\":{\"61\":1}}],[\"最近的公共祖先在右子树上\",{\"1\":{\"62\":1}}],[\"最直观的方法其实就是按照普通二叉树去挨个结点遍历\",{\"1\":{\"54\":1}}],[\"最直观的感受就是\",{\"1\":{\"12\":1}}],[\"最大页目录\",{\"1\":{\"667\":1}}],[\"最大索引数\",{\"1\":{\"642\":1}}],[\"最大跨度不超过32\",{\"1\":{\"495\":1}}],[\"最大线程数\",{\"1\":{\"481\":2}}],[\"最大请求次数为3\",{\"1\":{\"467\":1}}],[\"最大请求次数3次\",{\"1\":{\"467\":1}}],[\"最大rt\",{\"1\":{\"412\":1}}],[\"最大子数组\",{\"1\":{\"348\":1}}],[\"最大的和\",{\"1\":{\"348\":1}}],[\"最大的子集是\",{\"1\":{\"100\":1}}],[\"最大值是4096m\",{\"1\":{\"751\":1}}],[\"最大值为64\",{\"1\":{\"601\":1}}],[\"最大值为3\",{\"1\":{\"117\":1}}],[\"最大值\",{\"1\":{\"333\":1,\"562\":1}}],[\"最大总和\",{\"1\":{\"257\":1}}],[\"最大和并不是最后一个元素\",{\"1\":{\"143\":1}}],[\"最大和为0\",{\"1\":{\"117\":1}}],[\"最大\",{\"1\":{\"121\":1}}],[\"最大利润为\",{\"1\":{\"121\":1}}],[\"最大利润\",{\"1\":{\"119\":1}}],[\"最大乘积就是\",{\"1\":{\"87\":1}}],[\"最大二叉树\",{\"1\":{\"50\":2,\"72\":1}}],[\"最大深度\",{\"1\":{\"25\":1}}],[\"最底层\",{\"1\":{\"42\":1}}],[\"最短路径\",{\"1\":{\"12\":1}}],[\"最后才是对数据库采用\",{\"1\":{\"818\":1}}],[\"最后还有一种折中方式\",{\"1\":{\"810\":1}}],[\"最后返回符合规则的数据\",{\"1\":{\"799\":1}}],[\"最后在进行回表\",{\"1\":{\"728\":1}}],[\"最后在订单服务中修改订单状态为已完成\",{\"1\":{\"430\":1}}],[\"最后假设就筛选出\",{\"1\":{\"728\":1}}],[\"最后根据主键关联回原表查询所需要的其他列内容\",{\"1\":{\"726\":1}}],[\"最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询\",{\"1\":{\"629\":1}}],[\"最后实现的效果都是\",{\"1\":{\"624\":1}}],[\"最后调用服务端提供的服务接口\",{\"1\":{\"464\":1}}],[\"最后使用postman\",{\"1\":{\"443\":1}}],[\"最后生成行锁\",{\"1\":{\"436\":1}}],[\"最后得\",{\"1\":{\"370\":1}}],[\"最后得出\",{\"1\":{\"188\":1}}],[\"最后统计\",{\"1\":{\"360\":1}}],[\"最后求和\",{\"1\":{\"354\":1}}],[\"最后求出最小步数为2\",{\"1\":{\"150\":1}}],[\"最后拿走最大数额的钱就是推出全局最优\",{\"1\":{\"342\":1}}],[\"最后stack中剩下的就是不重复的元素\",{\"1\":{\"328\":1}}],[\"最后不要忘记\",{\"1\":{\"203\":1}}],[\"最后肯定会得到一个相等的数\",{\"1\":{\"170\":1}}],[\"最后加在一起\",{\"1\":{\"117\":1}}],[\"最后取最大值\",{\"1\":{\"117\":1}}],[\"最后取出频率最高的结点即可\",{\"1\":{\"60\":1}}],[\"最后形成一个扁平化的\",{\"1\":{\"97\":1}}],[\"最后\",{\"1\":{\"96\":1,\"689\":1}}],[\"最后一个访问的就是最左侧的结点\",{\"1\":{\"43\":1}}],[\"最后一个结点不就是最左侧的结点吗\",{\"1\":{\"43\":1}}],[\"最后一层的结点\",{\"1\":{\"0\":1}}],[\"最后遍历另一个链表的结点\",{\"1\":{\"391\":1}}],[\"最后遍历根节点\",{\"1\":{\"4\":2}}],[\"最后遍历右子树\",{\"1\":{\"2\":1,\"3\":1}}],[\"空闲空间\",{\"0\":{\"670\":1},\"1\":{\"667\":1}}],[\"空字符串\",{\"1\":{\"614\":1}}],[\"空洞\",{\"1\":{\"605\":1}}],[\"空值\",{\"1\":{\"523\":1}}],[\"空值参与运算\",{\"0\":{\"523\":1}}],[\"空参构造器\",{\"1\":{\"497\":2,\"504\":1}}],[\"空节点默认为\",{\"1\":{\"372\":1}}],[\"空节点\",{\"1\":{\"372\":1}}],[\"空白格用\",{\"1\":{\"216\":1}}],[\"空集合也算是一个子集\",{\"1\":{\"203\":1}}],[\"空间上的代价\",{\"1\":{\"656\":1}}],[\"空间函数\",{\"1\":{\"637\":1}}],[\"空间非常的高\",{\"1\":{\"177\":1}}],[\"空间复杂度更低的\",{\"1\":{\"12\":1}}],[\"空树也算二叉搜索树\",{\"1\":{\"89\":1}}],[\"空数组\",{\"1\":{\"50\":3}}],[\"空结点不放入栈中\",{\"1\":{\"6\":1}}],[\"的策略\",{\"1\":{\"848\":1}}],[\"的类型均为\",{\"1\":{\"836\":1}}],[\"的标准有\",{\"1\":{\"835\":1}}],[\"的并发写问题\",{\"1\":{\"823\":1}}],[\"的缺点\",{\"1\":{\"823\":1}}],[\"的优点\",{\"1\":{\"823\":1}}],[\"的优势\",{\"1\":{\"462\":1}}],[\"的读取\",{\"1\":{\"819\":1}}],[\"的影响\",{\"1\":{\"819\":1}}],[\"的需求\",{\"1\":{\"819\":1}}],[\"的缓存架构是高并发架构中非常重要的一环\",{\"1\":{\"818\":1}}],[\"的上限\",{\"1\":{\"809\":1}}],[\"的设置\",{\"1\":{\"809\":1}}],[\"的设计\",{\"1\":{\"511\":1}}],[\"的内容如下\",{\"1\":{\"800\":1}}],[\"的不一样\",{\"1\":{\"799\":1}}],[\"的不同组合数少于\",{\"1\":{\"194\":1}}],[\"的不同\",{\"1\":{\"98\":1}}],[\"的id\",{\"1\":{\"796\":1}}],[\"的实现依赖于\",{\"1\":{\"795\":1}}],[\"的实例\",{\"1\":{\"488\":1}}],[\"的事务\",{\"1\":{\"797\":1,\"800\":2}}],[\"的事务对这条记录进行\",{\"1\":{\"794\":1}}],[\"的事情\",{\"1\":{\"768\":1}}],[\"的冲突\",{\"1\":{\"783\":1}}],[\"的场景\",{\"1\":{\"783\":2}}],[\"的作用是\",{\"1\":{\"773\":1}}],[\"的锁\",{\"1\":{\"777\":1}}],[\"的锁并存\",{\"1\":{\"771\":1}}],[\"的锁其实是一个\",{\"1\":{\"763\":1}}],[\"的概念\",{\"1\":{\"768\":1}}],[\"的支持都可能不一样\",{\"1\":{\"764\":1}}],[\"的问题\",{\"1\":{\"764\":1,\"847\":1}}],[\"的各个隔离级别提供了保证\",{\"1\":{\"760\":1}}],[\"的各元素为起始点执行以上旋转操作\",{\"1\":{\"299\":1}}],[\"的争用以外\",{\"1\":{\"760\":1}}],[\"的改变\",{\"1\":{\"746\":1}}],[\"的任何属性的任何值\",{\"1\":{\"737\":1}}],[\"的外键\",{\"1\":{\"736\":1}}],[\"的函数才能知道刚才插入的自增值\",{\"1\":{\"731\":1}}],[\"的一项重要的功能\",{\"1\":{\"724\":1}}],[\"的一个数字\",{\"1\":{\"192\":1}}],[\"的一个子序列\",{\"1\":{\"145\":1}}],[\"的搜索条件的记录时\",{\"1\":{\"710\":1}}],[\"的属性\",{\"1\":{\"703\":1}}],[\"的语句\",{\"1\":{\"697\":2}}],[\"的记录\",{\"1\":{\"696\":1,\"726\":1,\"728\":1}}],[\"的部分代表观察\",{\"1\":{\"694\":1}}],[\"的列适合作为索引\",{\"1\":{\"689\":1}}],[\"的列\",{\"1\":{\"679\":1,\"689\":1}}],[\"的差异\",{\"1\":{\"662\":1}}],[\"的三叉树来进行存储\",{\"1\":{\"660\":1}}],[\"的高效率\",{\"1\":{\"658\":1}}],[\"的另一个文件中\",{\"1\":{\"654\":1}}],[\"的索引方案虽然也使用树形结构\",{\"1\":{\"654\":1}}],[\"的大小进行排序\",{\"1\":{\"652\":1}}],[\"的大小不重要\",{\"1\":{\"312\":1}}],[\"的查询效率很高\",{\"1\":{\"637\":1}}],[\"的完整提交\",{\"1\":{\"636\":1}}],[\"的完全平方数的最少数量\",{\"1\":{\"108\":1}}],[\"的浮\",{\"1\":{\"599\":1}}],[\"的存储过程\",{\"1\":{\"823\":1}}],[\"的存储空间\",{\"1\":{\"597\":1}}],[\"的存储方式\",{\"1\":{\"449\":1}}],[\"的宽度值\",{\"1\":{\"595\":1}}],[\"的department\",{\"1\":{\"575\":1}}],[\"的执行过程中\",{\"1\":{\"565\":1}}],[\"的执行效率会比放在\",{\"1\":{\"564\":1}}],[\"的取值\",{\"1\":{\"557\":1}}],[\"的取值范围是\",{\"1\":{\"336\":1}}],[\"的七种\",{\"1\":{\"539\":1}}],[\"的关键字\",{\"1\":{\"539\":1}}],[\"的所有可能\",{\"1\":{\"532\":2}}],[\"的所有元素\",{\"1\":{\"194\":1,\"278\":1}}],[\"的所有元素也是\",{\"1\":{\"100\":1}}],[\"的笛卡尔积就是\",{\"1\":{\"532\":1}}],[\"的员工\",{\"1\":{\"529\":1}}],[\"的判断\",{\"1\":{\"528\":1}}],[\"的主键设计就更为考验架构师的水平了\",{\"1\":{\"733\":1}}],[\"的主键\",{\"1\":{\"513\":1,\"736\":2}}],[\"的主流\",{\"1\":{\"508\":1}}],[\"的回应头\",{\"1\":{\"501\":1}}],[\"的名称\",{\"1\":{\"501\":1}}],[\"的调用失败时打开断路器\",{\"1\":{\"477\":1,\"478\":1}}],[\"的例子\",{\"1\":{\"477\":3,\"478\":1,\"480\":1}}],[\"的请求超过n秒\",{\"1\":{\"476\":1}}],[\"的出现正解决了这一难题\",{\"1\":{\"462\":1}}],[\"的负载均衡\",{\"1\":{\"459\":1}}],[\"的功能\",{\"1\":{\"452\":1,\"635\":1}}],[\"的maven工程\",{\"1\":{\"442\":1}}],[\"的全局提交或回滚决议\",{\"1\":{\"426\":1}}],[\"的适配模块\",{\"1\":{\"421\":1}}],[\"的接口\",{\"1\":{\"420\":1}}],[\"的整合\",{\"1\":{\"406\":1}}],[\"的整数类型可以节省存储空间\",{\"1\":{\"598\":1}}],[\"的整数矩阵\",{\"1\":{\"233\":1}}],[\"的整数数组\",{\"1\":{\"194\":1,\"240\":1,\"257\":1}}],[\"的常用场景之一是不同环境的配置的区分隔离\",{\"1\":{\"404\":1}}],[\"的配置\",{\"1\":{\"404\":1}}],[\"的拼接格式变成\",{\"1\":{\"403\":1}}],[\"的移动次数为\",{\"1\":{\"391\":1}}],[\"的方式表示高精度小数\",{\"1\":{\"600\":1}}],[\"的方式\",{\"1\":{\"389\":1,\"424\":1,\"539\":1,\"618\":1,\"765\":1}}],[\"的方案\",{\"1\":{\"147\":2}}],[\"的链表节点\",{\"1\":{\"383\":1,\"393\":2}}],[\"的第三个节点\",{\"1\":{\"379\":1}}],[\"的第二个节点\",{\"1\":{\"379\":1}}],[\"的人身高为\",{\"1\":{\"361\":6}}],[\"的人\",{\"1\":{\"361\":5}}],[\"的糖果数量\",{\"1\":{\"360\":1}}],[\"的糖果+1\",{\"1\":{\"360\":1}}],[\"的评分\",{\"1\":{\"360\":1}}],[\"的加油站\",{\"1\":{\"356\":1}}],[\"的难点就是要统计\",{\"1\":{\"352\":1}}],[\"的解析\",{\"1\":{\"510\":1}}],[\"的解法\",{\"1\":{\"347\":1}}],[\"的解决方案\",{\"1\":{\"214\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"333\":1}}],[\"的其余元素与\",{\"1\":{\"312\":1}}],[\"的唯一元素的数量为\",{\"1\":{\"312\":1}}],[\"的唯一区别\",{\"1\":{\"122\":1}}],[\"的前一个结点\",{\"1\":{\"389\":1}}],[\"的前面\",{\"1\":{\"384\":1}}],[\"的前五个元素被修改为\",{\"1\":{\"312\":1}}],[\"的前两个元素被修改为\",{\"1\":{\"312\":1}}],[\"的前\",{\"1\":{\"309\":1,\"312\":1}}],[\"的前提条件\",{\"1\":{\"155\":1}}],[\"的个数是\",{\"1\":{\"306\":1}}],[\"的个数\",{\"1\":{\"306\":1}}],[\"的起点元素\",{\"1\":{\"304\":1}}],[\"的中间位置\",{\"1\":{\"290\":1}}],[\"的原则\",{\"1\":{\"288\":1}}],[\"的原因是因为我们要逐渐累加左右子树的二叉搜索树的数量\",{\"1\":{\"89\":1}}],[\"的时间复杂度\",{\"1\":{\"277\":1}}],[\"的时候会获取一次\",{\"1\":{\"799\":1}}],[\"的时候\",{\"1\":{\"322\":1,\"785\":1,\"820\":1,\"835\":1}}],[\"的时候卖出\",{\"1\":{\"119\":1,\"121\":3,\"123\":3,\"125\":3}}],[\"的时候买入\",{\"1\":{\"119\":1,\"121\":3,\"123\":3,\"125\":3}}],[\"的时候远远多于\",{\"1\":{\"12\":1}}],[\"的结果为数组\",{\"1\":{\"276\":1}}],[\"的数据\",{\"1\":{\"728\":1,\"749\":1,\"800\":2}}],[\"的数据页\",{\"1\":{\"648\":2}}],[\"的数据列\",{\"1\":{\"604\":1}}],[\"的数据列代替可变长\",{\"1\":{\"604\":1}}],[\"的数据库类型\",{\"1\":{\"509\":1}}],[\"的数组下标\",{\"1\":{\"290\":1}}],[\"的数组\",{\"1\":{\"276\":2,\"277\":1,\"312\":1}}],[\"的数目\",{\"1\":{\"98\":1,\"154\":1}}],[\"的次数\",{\"1\":{\"274\":1}}],[\"的算法解决此问题\",{\"1\":{\"275\":1,\"276\":1,\"277\":1}}],[\"的算法\",{\"1\":{\"273\":1}}],[\"的变化\",{\"1\":{\"271\":1,\"273\":1}}],[\"的每个元素都将在\",{\"1\":{\"269\":1}}],[\"的下标开始\",{\"1\":{\"254\":1}}],[\"的额外空间解决这一问题\",{\"1\":{\"249\":1}}],[\"的形式关联起来\",{\"1\":{\"645\":1}}],[\"的形式存储数据\",{\"1\":{\"509\":1}}],[\"的形式给出\",{\"1\":{\"249\":1}}],[\"的形式返回这两个整数的下标\",{\"1\":{\"240\":1}}],[\"的顺序\",{\"1\":{\"244\":1}}],[\"的矩形岛屿\",{\"1\":{\"233\":1}}],[\"的矩阵\",{\"1\":{\"231\":1,\"303\":1}}],[\"的边界\",{\"1\":{\"229\":1}}],[\"的陆地单元格或跨过\",{\"1\":{\"229\":1}}],[\"的单元格的数目\",{\"1\":{\"227\":1}}],[\"的四个边缘都被\",{\"1\":{\"227\":1}}],[\"的二维矩阵\",{\"1\":{\"297\":1}}],[\"的二进制矩阵\",{\"1\":{\"227\":1,\"229\":1}}],[\"的二叉树\",{\"1\":{\"71\":1}}],[\"的棋子放置方案\",{\"1\":{\"214\":1}}],[\"的棋盘上\",{\"1\":{\"214\":1}}],[\"的位置\",{\"1\":{\"201\":1,\"349\":1,\"351\":1}}],[\"的位置上\",{\"1\":{\"177\":1}}],[\"的组合\",{\"1\":{\"196\":1,\"654\":1}}],[\"的k=2\",{\"1\":{\"187\":1}}],[\"的那个事务提交\",{\"1\":{\"778\":1}}],[\"的那\",{\"1\":{\"174\":1}}],[\"的空集\",{\"1\":{\"172\":1}}],[\"的正整数\",{\"1\":{\"172\":1}}],[\"的字段\",{\"1\":{\"565\":1}}],[\"的字符串分别是什么\",{\"1\":{\"634\":1}}],[\"的字符串\",{\"1\":{\"192\":1,\"324\":1}}],[\"的字符相等\",{\"1\":{\"155\":1}}],[\"的字母异位词\",{\"1\":{\"161\":1}}],[\"的递推关系式\",{\"1\":{\"155\":1}}],[\"的直线相交\",{\"1\":{\"140\":1}}],[\"的直线将与从\",{\"1\":{\"140\":1}}],[\"的直线\",{\"1\":{\"140\":1}}],[\"的长度最小的\",{\"1\":{\"284\":1}}],[\"的长度即可\",{\"1\":{\"253\":1}}],[\"的长度\",{\"1\":{\"138\":1}}],[\"的子序列\",{\"1\":{\"132\":1,\"138\":2,\"145\":2}}],[\"的区分\",{\"1\":{\"729\":1}}],[\"的区别\",{\"0\":{\"222\":1},\"1\":{\"441\":1}}],[\"的区别就是\",{\"1\":{\"120\":1,\"207\":1}}],[\"的区间之内\",{\"1\":{\"64\":1}}],[\"的状态由\",{\"1\":{\"117\":1}}],[\"的计算\",{\"1\":{\"103\":1}}],[\"的情况下使用的数据库锁\",{\"1\":{\"777\":1}}],[\"的情况下\",{\"1\":{\"435\":2,\"658\":1,\"819\":1}}],[\"的情况\",{\"1\":{\"103\":1,\"348\":1,\"502\":1}}],[\"的硬币不能凑成总金额\",{\"1\":{\"102\":1}}],[\"的元素位置\",{\"1\":{\"273\":1}}],[\"的元素组合的个数\",{\"1\":{\"104\":1}}],[\"的元素\",{\"1\":{\"100\":1,\"278\":1,\"279\":2,\"313\":1,\"348\":1}}],[\"的话\",{\"1\":{\"99\":5,\"276\":1,\"362\":2,\"382\":1}}],[\"的集合\",{\"1\":{\"99\":1}}],[\"的石头新重量为\",{\"1\":{\"96\":1}}],[\"的石头将会完全粉碎\",{\"1\":{\"96\":1}}],[\"的容量的最大价值\",{\"1\":{\"92\":1}}],[\"的价值\",{\"1\":{\"91\":1}}],[\"的最小数据单元\",{\"1\":{\"737\":1}}],[\"的最小跳跃次数\",{\"1\":{\"351\":1}}],[\"的最左前缀匹配特性\",{\"1\":{\"716\":1}}],[\"的最长公共子序列的长度\",{\"1\":{\"146\":1}}],[\"的最长公共子序列\",{\"1\":{\"139\":1}}],[\"的最少个数为dp\",{\"1\":{\"107\":1}}],[\"的最大数字\",{\"1\":{\"369\":1}}],[\"的最大和为dp\",{\"1\":{\"143\":2}}],[\"的最大值\",{\"1\":{\"133\":1,\"139\":1}}],[\"的最大子集是\",{\"1\":{\"100\":1}}],[\"的最大子集的长度\",{\"1\":{\"100\":1}}],[\"的最大价值\",{\"1\":{\"91\":1}}],[\"的最大乘积\",{\"1\":{\"87\":1}}],[\"的最近公共祖先是\",{\"1\":{\"63\":2}}],[\"的最近公共祖先是节点\",{\"1\":{\"61\":2}}],[\"的和最大\",{\"1\":{\"142\":1,\"347\":1}}],[\"的和\",{\"1\":{\"86\":1}}],[\"的台阶\",{\"1\":{\"82\":5}}],[\"的台阶开始\",{\"1\":{\"82\":2}}],[\"的台阶开始爬楼梯\",{\"1\":{\"82\":1}}],[\"的值设置为\",{\"1\":{\"745\":1}}],[\"的值跟\",{\"1\":{\"597\":1}}],[\"的值进行插入\",{\"1\":{\"362\":1}}],[\"的值为\",{\"1\":{\"225\":1,\"229\":1,\"393\":1}}],[\"的值\",{\"1\":{\"100\":1,\"273\":2,\"403\":1,\"651\":1}}],[\"的值之和\",{\"1\":{\"73\":1}}],[\"的值组成\",{\"1\":{\"46\":1}}],[\"的新值等于原树中大于或等于\",{\"1\":{\"73\":1}}],[\"的右子树的最左侧结点的左子树上\",{\"1\":{\"68\":1}}],[\"的右子树上\",{\"1\":{\"64\":1}}],[\"的范围内是否是回文子串\",{\"1\":{\"155\":1}}],[\"的范围内\",{\"1\":{\"65\":1}}],[\"的左子树移动到\",{\"1\":{\"68\":1}}],[\"的左子树上\",{\"1\":{\"64\":1}}],[\"的左右两个子树的高度差的绝对值不超过\",{\"1\":{\"36\":1,\"37\":1}}],[\"的两个数\",{\"1\":{\"240\":1}}],[\"的两个结点\",{\"1\":{\"63\":1}}],[\"的两个节点\",{\"1\":{\"61\":1}}],[\"的深度尽可能大\",{\"1\":{\"61\":1,\"63\":1}}],[\"的祖先且\",{\"1\":{\"61\":1,\"63\":1}}],[\"的节点称为\",{\"1\":{\"648\":1}}],[\"的节点将直接作为新二叉树的节点\",{\"1\":{\"52\":1}}],[\"的节点\",{\"1\":{\"50\":2,\"53\":1,\"67\":1,\"376\":1}}],[\"的路径并输出\",{\"1\":{\"223\":1}}],[\"的路径\",{\"1\":{\"44\":1,\"454\":1}}],[\"的定义如下\",{\"1\":{\"34\":1}}],[\"的根节点的引用\",{\"1\":{\"67\":1}}],[\"的根节点到叶子节点的路径\",{\"1\":{\"44\":1}}],[\"的根节点\",{\"1\":{\"34\":1,\"53\":1,\"59\":1,\"65\":1}}],[\"的\",{\"1\":{\"12\":1,\"29\":1,\"50\":2,\"65\":1,\"69\":1,\"94\":1,\"100\":1,\"147\":1,\"166\":1,\"189\":1,\"194\":1,\"231\":1,\"233\":1,\"257\":1,\"267\":1,\"273\":1,\"290\":1,\"345\":1,\"351\":1,\"355\":1,\"379\":1,\"457\":1,\"539\":1,\"616\":1,\"689\":1,\"807\":1,\"820\":1,\"823\":1,\"835\":1,\"874\":1,\"883\":1,\"884\":1}}],[\"的能力没什么差别\",{\"1\":{\"12\":1}}],[\"如一些函数\",{\"1\":{\"823\":1}}],[\"如数据查询语句select\",{\"1\":{\"808\":1}}],[\"如cpu\",{\"1\":{\"760\":1}}],[\"如用户的尾号\",{\"1\":{\"733\":1}}],[\"如警告\",{\"1\":{\"733\":1}}],[\"如301\",{\"1\":{\"502\":1}}],[\"如正常将进入关闭close闭合状态恢复正常处理请求\",{\"1\":{\"477\":1}}],[\"如还是异常circuitbreaker\",{\"1\":{\"477\":1}}],[\"如此类推\",{\"1\":{\"460\":1}}],[\"如配置\",{\"1\":{\"404\":1}}],[\"如网格任务\",{\"1\":{\"399\":1}}],[\"如\",{\"1\":{\"330\":1,\"419\":1,\"460\":1,\"495\":1,\"552\":1,\"836\":1}}],[\"如比\",{\"1\":{\"218\":1}}],[\"如出现两个整数相等\",{\"1\":{\"206\":1}}],[\"如例题中\",{\"1\":{\"187\":1}}],[\"如上图所示\",{\"1\":{\"140\":1,\"214\":1,\"299\":1}}],[\"如何解决这个问题呢\",{\"1\":{\"853\":1}}],[\"如何解决幻读\",{\"0\":{\"800\":1}}],[\"如何保证数据库和缓存双写一致性\",{\"1\":{\"845\":1}}],[\"如何保障分布式事务一致性\",{\"1\":{\"425\":1}}],[\"如何提升数据库的并发能力\",{\"0\":{\"818\":1}}],[\"如何避免死锁\",{\"1\":{\"786\":1}}],[\"如何理解undo日志\",{\"0\":{\"755\":1}}],[\"如何理解回溯\",{\"0\":{\"184\":1}}],[\"如何将\",{\"1\":{\"753\":1}}],[\"如何尽可能精确的分析系统的存储瓶颈与容量规划\",{\"1\":{\"483\":1}}],[\"如何尽可能精确的分析整个系统调用链路的性能与瓶颈点\",{\"1\":{\"483\":1}}],[\"如何尽可能精确的梳理出服务之间的依赖关系\",{\"1\":{\"483\":1}}],[\"如何尽可能精确的判断故障对系统的影响范围与影响程度\",{\"1\":{\"483\":1}}],[\"如何快速发现并定位到问题\",{\"1\":{\"483\":1}}],[\"如何实时观测系统的整体调用链路情况\",{\"1\":{\"483\":1}}],[\"如何使用事务\",{\"0\":{\"743\":1}}],[\"如何使用\",{\"0\":{\"408\":1,\"458\":1,\"463\":1},\"1\":{\"480\":1,\"481\":1}}],[\"如何隔两个节点放一个摄像头\",{\"1\":{\"372\":2}}],[\"如何截取呢\",{\"1\":{\"199\":1}}],[\"如何判断回文串\",{\"1\":{\"199\":1}}],[\"如何进行切割\",{\"1\":{\"199\":1}}],[\"如何去重呢\",{\"1\":{\"177\":1}}],[\"如何分解呢\",{\"1\":{\"122\":1}}],[\"如何转换成01\",{\"1\":{\"97\":1}}],[\"如何利用二叉搜索树的性质解决这道题呢\",{\"1\":{\"60\":1}}],[\"如下表所示\",{\"1\":{\"799\":1}}],[\"如下所示\",{\"1\":{\"147\":2,\"832\":1}}],[\"如下\",{\"1\":{\"39\":1,\"54\":1,\"592\":1}}],[\"如下图所示\",{\"1\":{\"67\":1,\"193\":1,\"197\":1,\"199\":1,\"205\":1,\"261\":1,\"276\":1,\"313\":1,\"522\":1,\"533\":1,\"645\":1,\"658\":1,\"800\":1,\"848\":1,\"851\":1}}],[\"如下图\",{\"1\":{\"8\":1,\"810\":1}}],[\"如图\",{\"1\":{\"23\":1,\"95\":1,\"122\":1}}],[\"如图所示\",{\"1\":{\"16\":1,\"68\":1,\"83\":1,\"364\":1,\"371\":1,\"672\":1}}],[\"如果重试了5次\",{\"1\":{\"851\":1,\"852\":1}}],[\"如果缓存删除失败了\",{\"1\":{\"850\":1}}],[\"如果更新学\",{\"1\":{\"837\":1}}],[\"如果备份文件中包含了创建数据库的语句\",{\"1\":{\"832\":1}}],[\"如果停止从服务器复制功能\",{\"1\":{\"827\":1}}],[\"如果报错\",{\"1\":{\"826\":1}}],[\"如果日志长度超过了\",{\"1\":{\"809\":1}}],[\"如果俩次\",{\"1\":{\"799\":1}}],[\"如果俩个字符串长度不相等\",{\"1\":{\"163\":1}}],[\"如果被访问版本的trx\",{\"1\":{\"798\":4}}],[\"如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的\",{\"1\":{\"704\":1}}],[\"如果另一个事务\",{\"1\":{\"772\":1}}],[\"如果交给系统来同\",{\"1\":{\"753\":1}}],[\"如果事务执行完\",{\"1\":{\"812\":1}}],[\"如果事务执行了一部分而变为\",{\"1\":{\"742\":1}}],[\"如果事务session\",{\"1\":{\"746\":1}}],[\"如果我要删除某个球员编号\",{\"1\":{\"737\":1}}],[\"如果我们现在有昨天的全量备份\",{\"1\":{\"832\":1}}],[\"如果我们的目的在于提升数据库高并发访问的效率\",{\"1\":{\"818\":1}}],[\"如果我们给某一行数据加上了排它锁\",{\"1\":{\"771\":1}}],[\"如果我们想备份某个库\",{\"1\":{\"831\":1}}],[\"如果我们想关闭这种\",{\"1\":{\"745\":1}}],[\"如果我们想要添加一场新的比赛\",{\"1\":{\"737\":1}}],[\"如果我们想要查询\",{\"1\":{\"696\":2}}],[\"如果我们想要原地修改即\",{\"1\":{\"299\":1}}],[\"如果我们想要判断\",{\"1\":{\"155\":1}}],[\"如果我们调整了某个比赛的时间\",{\"1\":{\"737\":1}}],[\"如果我们把二叉树改成\",{\"1\":{\"660\":1}}],[\"如果我们能让索引的数据结构尽量减少硬盘的\",{\"1\":{\"657\":1}}],[\"如果我们改成这样\",{\"1\":{\"522\":1}}],[\"如果我们将\",{\"1\":{\"366\":1}}],[\"如果我们先确定\",{\"1\":{\"362\":1}}],[\"如果我们使用\",{\"1\":{\"12\":1}}],[\"如果知道主键的所有属性的值\",{\"1\":{\"737\":1}}],[\"如果超键不包括多余的属性\",{\"1\":{\"736\":1}}],[\"如果超过m位\",{\"1\":{\"597\":1}}],[\"如果where条件的字段不在索引列中\",{\"1\":{\"728\":1}}],[\"如果待排结果较大\",{\"1\":{\"725\":1}}],[\"如果待排序的列有多\",{\"1\":{\"689\":1}}],[\"如果查询中使用索引的话\",{\"1\":{\"724\":1}}],[\"如果查询中使用到了内部的临时表\",{\"1\":{\"710\":1}}],[\"如果查询优化器决定将in子查询\",{\"1\":{\"704\":1}}],[\"如果某个查询需要使用文件排序的方式执行查询\",{\"1\":{\"710\":1}}],[\"如果某列是zerofill\",{\"1\":{\"597\":1}}],[\"如果出现了`using\",{\"1\":{\"710\":1}}],[\"如果执行计划的`extra`列出现了`using\",{\"1\":{\"710\":1}}],[\"如果`where`子句中包含要求被驱动表的某个列等于`null`值的搜索条件\",{\"1\":{\"710\":1}}],[\"如果该主键或者唯一二级索引是联合索引的话\",{\"1\":{\"704\":1}}],[\"如果该页中的数据在内存中被修改了\",{\"1\":{\"668\":1}}],[\"如果各个小查询都依赖于外层查询的话\",{\"1\":{\"703\":1}}],[\"如果包含子查询的查询语句不能够转为对应的semi\",{\"1\":{\"703\":2}}],[\"如果包含2\",{\"1\":{\"173\":1}}],[\"如果索引太多\",{\"1\":{\"690\":1}}],[\"如果建立索引\",{\"1\":{\"690\":1}}],[\"如果连unique键都没有定义的话\",{\"1\":{\"681\":1}}],[\"如果连续数字之间的差严格地在正数和负数之间交替\",{\"1\":{\"345\":1}}],[\"如果表中没有允许存储\",{\"1\":{\"679\":1}}],[\"如果还有新的记录插入的话\",{\"1\":{\"670\":1}}],[\"如果首部和尾部的lsn值校验不成功的话\",{\"1\":{\"669\":1}}],[\"如果校验和都不一样\",{\"1\":{\"668\":1}}],[\"如果进行范围査询\",{\"1\":{\"658\":1}}],[\"如果进行合并的话\",{\"1\":{\"295\":1}}],[\"如果将完整的用户记录都放到叶子结点中\",{\"1\":{\"651\":1}}],[\"如果b+树有4层\",{\"1\":{\"648\":1}}],[\"如果b+树有3层\",{\"1\":{\"648\":1}}],[\"如果b+树有2层\",{\"1\":{\"648\":1}}],[\"如果b+树只有1层\",{\"1\":{\"648\":1}}],[\"如果具备权限\",{\"1\":{\"634\":1}}],[\"如果能够在其中找到对应的查询结果\",{\"1\":{\"630\":1}}],[\"如果能跳到最后就说明成功了\",{\"1\":{\"350\":1}}],[\"如果在\",{\"1\":{\"798\":1}}],[\"如果在8\",{\"1\":{\"757\":1}}],[\"如果在事务之间执行\",{\"1\":{\"746\":1}}],[\"如果在员工信息表中在增加\",{\"1\":{\"737\":1}}],[\"如果在数据量非常大的情况下\",{\"1\":{\"689\":1}}],[\"如果在查询缓存中发现了这条\",{\"1\":{\"634\":1}}],[\"如果在分解构成中遇到错\",{\"1\":{\"628\":1}}],[\"如果在此范围内\",{\"1\":{\"350\":1}}],[\"如果此字段没有显式赋值\",{\"1\":{\"620\":1}}],[\"如果子表有对应的数据\",{\"1\":{\"618\":1}}],[\"如果子表中有匹配的记录\",{\"1\":{\"618\":1}}],[\"如果子查询的执行依赖于外部查询\",{\"1\":{\"579\":1}}],[\"如果子查询需要执行多次\",{\"1\":{\"570\":1}}],[\"如果类\",{\"1\":{\"618\":1}}],[\"如果自增列手动指定了具体值\",{\"1\":{\"617\":1}}],[\"如果自增列指定了\",{\"1\":{\"617\":1}}],[\"如果修改了主键的\",{\"1\":{\"616\":1}}],[\"如果创建唯一约束时未指定名称\",{\"1\":{\"615\":1}}],[\"如果一个事务想要查询这个行记录\",{\"1\":{\"796\":1}}],[\"如果一个查询正在遍历一个表中的数据\",{\"1\":{\"773\":1}}],[\"如果一个球员可以参加\",{\"1\":{\"737\":1}}],[\"如果一个\",{\"1\":{\"604\":1}}],[\"如果存放utf8汉字时\",{\"1\":{\"604\":1}}],[\"如果存在就直接取出\",{\"1\":{\"818\":1}}],[\"如果存在意向锁\",{\"1\":{\"771\":1}}],[\"如果存在则删除数据库\",{\"1\":{\"586\":1}}],[\"如果存在解\",{\"1\":{\"355\":1}}],[\"如果存在的话\",{\"1\":{\"345\":1}}],[\"如果存在多种有效的行程\",{\"1\":{\"212\":1}}],[\"如果存在\",{\"1\":{\"44\":1}}],[\"如果保存时\",{\"1\":{\"604\":1}}],[\"如果用到浮点数\",{\"1\":{\"599\":1}}],[\"如果使用的是mysql8\",{\"1\":{\"825\":1}}],[\"如果使用索引获取某些范围区间的记录\",{\"1\":{\"704\":1}}],[\"如果使用\",{\"1\":{\"598\":1}}],[\"如果使用暴力法\",{\"1\":{\"177\":1}}],[\"如果整\",{\"1\":{\"597\":1}}],[\"如果指定\",{\"1\":{\"831\":1}}],[\"如果指定列为索引的列则不会失效\",{\"1\":{\"721\":1}}],[\"如果指\",{\"1\":{\"597\":1}}],[\"如果需要制定文件名\",{\"1\":{\"807\":1}}],[\"如果需要在mysql数据库中保存非负整数值时\",{\"1\":{\"596\":1}}],[\"如果需要新的版本号在子工程中重新指明\",{\"1\":{\"441\":1}}],[\"如果设置了查询缓存\",{\"1\":{\"634\":1}}],[\"如果设置了显示宽度\",{\"1\":{\"595\":1}}],[\"如果设置\",{\"1\":{\"596\":1}}],[\"如果设这两个数分别是\",{\"1\":{\"240\":1}}],[\"如果坚持使用\",{\"1\":{\"583\":1}}],[\"如果单独使用having\",{\"1\":{\"564\":1}}],[\"如果要手工分析日志\",{\"1\":{\"699\":1}}],[\"如果要删除数据\",{\"1\":{\"618\":1}}],[\"如果要启用\",{\"1\":{\"599\":1}}],[\"如果要使用\",{\"1\":{\"564\":1}}],[\"如果要求空间复杂度为o\",{\"1\":{\"256\":1}}],[\"如果要求只能在源字符串上进行修改呢\",{\"1\":{\"256\":1}}],[\"如果过滤条件中使用到啊了聚合函数\",{\"1\":{\"564\":1}}],[\"如果value1不为null\",{\"1\":{\"559\":1}}],[\"如果value1与value2相等\",{\"1\":{\"552\":1}}],[\"如果value的值为true\",{\"1\":{\"559\":1}}],[\"如果m=2\",{\"1\":{\"552\":1}}],[\"如果m=1\",{\"1\":{\"552\":1}}],[\"如果minimumnumberofcalls为10\",{\"1\":{\"477\":1}}],[\"如果x的值不在\",{\"1\":{\"549\":2}}],[\"如果种子相同的话\",{\"1\":{\"548\":1}}],[\"如果明确知道合并数据后的结果数据\",{\"1\":{\"540\":1}}],[\"如果现在我想把左表\",{\"1\":{\"539\":1}}],[\"如果涉及到一个字段在多个表中都存在时\",{\"1\":{\"533\":1}}],[\"如果等号两边的值一个是整数\",{\"1\":{\"528\":1}}],[\"如果等号两边的值\",{\"1\":{\"528\":2}}],[\"如果等于0\",{\"1\":{\"190\":1}}],[\"如果等于\",{\"1\":{\"95\":1}}],[\"如果数据比较多\",{\"1\":{\"771\":1}}],[\"如果数据表\",{\"1\":{\"736\":1}}],[\"如果数据表已经对字段建立了唯一索引\",{\"1\":{\"729\":1}}],[\"如果数据分散到多个不连续的页中存储的话需要把这些页关联起来\",{\"1\":{\"668\":1}}],[\"如果数值和字符串类型进行计算\",{\"1\":{\"527\":1}}],[\"如果数组中不存在目标值\",{\"1\":{\"275\":1}}],[\"如果数组中每个元素互不相同\",{\"1\":{\"266\":1}}],[\"如果空值参与运算\",{\"1\":{\"523\":1}}],[\"如果空结点是无覆盖\",{\"1\":{\"372\":1}}],[\"如果请求与断言相匹配则进行路由\",{\"1\":{\"488\":1}}],[\"如果断言为true则匹配该路由\",{\"1\":{\"488\":1}}],[\"如果其中有任意一次成功了\",{\"1\":{\"851\":1,\"852\":1}}],[\"如果其中有任何一个请求失败\",{\"1\":{\"477\":1}}],[\"如果其中一个结点为空\",{\"1\":{\"33\":1}}],[\"如果启用\",{\"1\":{\"477\":1}}],[\"如果故障或慢速调用仍然高于阈值\",{\"1\":{\"476\":1}}],[\"如果失败率超过阈值\",{\"1\":{\"475\":1}}],[\"如果扇出的链路上某个微服务的调用响应时间过长或者不可用\",{\"1\":{\"471\":1}}],[\"如果每个微服务使用的技术栈都是相同的\",{\"1\":{\"452\":1}}],[\"如果每个不同方法都加一个fallback配对方法\",{\"1\":{\"420\":1}}],[\"如果系统需要支持更高的并发\",{\"1\":{\"447\":1}}],[\"如果系统中提供了多个订单微服务和支付微服务\",{\"1\":{\"447\":1}}],[\"如果订单微服务和支付微服务的ip地址或者端口号发生了变化\",{\"1\":{\"447\":1}}],[\"如果命名空间不是默认的\",{\"1\":{\"419\":1}}],[\"如果接下来的一个请求响应时间小于设置的慢调用\",{\"1\":{\"412\":1}}],[\"如果阈值类型选择的是并发线程数\",{\"1\":{\"409\":1}}],[\"如果阈值类型选择的是qps\",{\"1\":{\"409\":1}}],[\"如果达到指定的阈值时\",{\"1\":{\"409\":1}}],[\"如果链表中有某个节点\",{\"1\":{\"393\":1}}],[\"如果链表无环\",{\"1\":{\"393\":1}}],[\"如果hash表中包含该结点\",{\"1\":{\"391\":1}}],[\"如果pb指针为null\",{\"1\":{\"391\":1}}],[\"如果pa指针为null\",{\"1\":{\"391\":1}}],[\"如果先移动\",{\"1\":{\"382\":1}}],[\"如果删除缓存失败\",{\"1\":{\"853\":1}}],[\"如果删除主键约束了\",{\"1\":{\"616\":1}}],[\"如果删除头结点是和其他结点不一样的\",{\"1\":{\"378\":1}}],[\"如果删除的是头结点\",{\"1\":{\"377\":1}}],[\"如果气球的尾端\",{\"1\":{\"364\":2}}],[\"如果i为起始点\",{\"1\":{\"356\":1}}],[\"如果i到了当前位置的最大范围\",{\"1\":{\"352\":1}}],[\"如果推导出全局最优\",{\"1\":{\"342\":1}}],[\"如果想要简单得进行如下查询\",{\"1\":{\"533\":1}}],[\"如果想达到最大的金额\",{\"1\":{\"342\":1}}],[\"如果想到其实最终利润是可以分解的\",{\"1\":{\"122\":1}}],[\"如果遇到右括号\",{\"1\":{\"325\":1}}],[\"如果遇到左括号\",{\"1\":{\"325\":1}}],[\"如果队列为空\",{\"1\":{\"321\":1}}],[\"如果所有断言都通过\",{\"1\":{\"312\":1}}],[\"如果第二个区间的第一个元素\",{\"1\":{\"296\":1}}],[\"如果中间值小于最大值\",{\"1\":{\"276\":1}}],[\"如果目标值不存在于数组中\",{\"1\":{\"273\":1}}],[\"如果目标值存在返回下标\",{\"1\":{\"269\":1}}],[\"如果任一值在数组中出现\",{\"1\":{\"266\":1}}],[\"如果任何硬币组合都无法凑出总金额\",{\"1\":{\"102\":1}}],[\"如果字符串的反序与原始字符串相同\",{\"1\":{\"260\":1}}],[\"如果字母出现次数都一样的话\",{\"1\":{\"163\":1}}],[\"如果长度满足k个长度\",{\"1\":{\"254\":1}}],[\"如果长度不足k则全部翻转\",{\"1\":{\"254\":1}}],[\"如果剩余字符小于\",{\"1\":{\"252\":1}}],[\"如果剩余字符少于\",{\"1\":{\"252\":1}}],[\"如果相等\",{\"1\":{\"391\":1}}],[\"如果相等返回\",{\"1\":{\"292\":1}}],[\"如果相等我们就记录次数\",{\"1\":{\"60\":1}}],[\"如果相连的单元格高度小于当前单元格高度\",{\"1\":{\"234\":1}}],[\"如果相邻单元格的高度\",{\"1\":{\"233\":1}}],[\"如果遍历的行数等于皇后数说明已经放置完毕\",{\"1\":{\"215\":2}}],[\"如果至少一个数字的被选数量不同\",{\"1\":{\"194\":1}}],[\"如果当前count为负数了\",{\"1\":{\"348\":1}}],[\"如果当前值为1\",{\"1\":{\"226\":1}}],[\"如果当前航班和上一个航班相同\",{\"1\":{\"213\":2}}],[\"如果当前元素和前一个元素相等\",{\"1\":{\"211\":1}}],[\"如果当前和都已经大于n了\",{\"1\":{\"191\":1}}],[\"如果当前节点值为空\",{\"1\":{\"66\":1}}],[\"如果n不等于1\",{\"1\":{\"171\":1}}],[\"如果nums1\",{\"1\":{\"137\":1}}],[\"如果这个数据结果只执行一次\",{\"1\":{\"570\":1}}],[\"如果这个过程\",{\"1\":{\"169\":1}}],[\"如果这次请求成功\",{\"1\":{\"475\":1}}],[\"如果这样认为的话\",{\"1\":{\"207\":1}}],[\"如果这样定义的话\",{\"1\":{\"155\":1}}],[\"如果这俩个子串都合法\",{\"1\":{\"111\":1}}],[\"如果对于每个\",{\"1\":{\"134\":1}}],[\"如果你是一个新手\",{\"1\":{\"865\":1}}],[\"如果你可以确定结果集只有一条\",{\"1\":{\"729\":1}}],[\"如果你可以按顺序绕环路行驶一周\",{\"1\":{\"355\":1}}],[\"如果你把\",{\"1\":{\"599\":1}}],[\"如果你的表名\",{\"1\":{\"524\":1}}],[\"如果你不了解它\",{\"1\":{\"866\":1}}],[\"如果你不知道去哪里找数据\",{\"1\":{\"510\":1}}],[\"如果你不能获取任何利润\",{\"1\":{\"119\":1}}],[\"如果你能给每位顾客正确找零\",{\"1\":{\"357\":1}}],[\"如果你在\",{\"1\":{\"351\":1}}],[\"如果你已经实现复杂度为\",{\"1\":{\"347\":1}}],[\"如果你已经购买了一个股票\",{\"1\":{\"129\":1}}],[\"如果选择node节点\",{\"1\":{\"117\":1}}],[\"如果应用的树形dp上\",{\"1\":{\"117\":1}}],[\"如果两份数据完全一致就说明没有脏写\",{\"1\":{\"436\":1}}],[\"如果两间相邻的房屋在同一晚上被小偷闯入\",{\"1\":{\"112\":1,\"114\":1}}],[\"如果两个值不相等则证明页的传输有问题\",{\"1\":{\"668\":1}}],[\"如果两个链表相交则不能为\",{\"1\":{\"390\":2}}],[\"如果两个链表没有交点\",{\"1\":{\"390\":1}}],[\"如果两个单词间有多余的空格\",{\"1\":{\"244\":1}}],[\"如果两个元素在水平或垂直方向相邻\",{\"1\":{\"231\":1}}],[\"如果两个节点重叠\",{\"1\":{\"52\":1}}],[\"如果两个结点的值不相等\",{\"1\":{\"33\":1}}],[\"如果两个结点都为空\",{\"1\":{\"33\":1}}],[\"如果有的话\",{\"1\":{\"778\":1}}],[\"如果有大量的索引\",{\"1\":{\"642\":1}}],[\"如果有大量输入的\",{\"1\":{\"145\":1}}],[\"如果有几十个controller\",{\"1\":{\"420\":1}}],[\"如果有重复的就无需在使用当前元素\",{\"1\":{\"207\":2}}],[\"如果有直接返回下标即可\",{\"1\":{\"175\":1}}],[\"如果有超过2间的房屋\",{\"1\":{\"115\":1}}],[\"如果有俩间房屋就偷较大金额的房屋\",{\"1\":{\"115\":1}}],[\"如果有一间房屋\",{\"1\":{\"115\":1}}],[\"如果有一个结点为空\",{\"1\":{\"33\":1}}],[\"如果有\",{\"1\":{\"111\":1}}],[\"如果可以\",{\"1\":{\"349\":1}}],[\"如果可以利用字典中出现的一个或多个单词拼接出\",{\"1\":{\"110\":1}}],[\"如果可以分割等和子集\",{\"1\":{\"95\":1}}],[\"如果允许负数出现\",{\"1\":{\"104\":1}}],[\"如果给定的数组中含有负数会发生什么\",{\"1\":{\"104\":1}}],[\"如果target过大\",{\"1\":{\"99\":1}}],[\"如果=0的话\",{\"1\":{\"99\":1}}],[\"如果正序遍历\",{\"1\":{\"92\":1}}],[\"如果物品0的重量为3\",{\"1\":{\"91\":1}}],[\"如果没有意向锁的存在\",{\"1\":{\"771\":1}}],[\"如果没有单独保存比赛表的话\",{\"1\":{\"737\":1}}],[\"如果没有这样的索引\",{\"1\":{\"650\":1}}],[\"如果没有定义主键\",{\"1\":{\"650\":1}}],[\"如果没有\",{\"1\":{\"634\":2}}],[\"如果没有指定等级\",{\"1\":{\"618\":1}}],[\"如果没有指定\",{\"1\":{\"601\":1}}],[\"如果没有where子句\",{\"1\":{\"542\":1}}],[\"如果没有10\",{\"1\":{\"358\":1}}],[\"如果没有岛屿\",{\"1\":{\"227\":1}}],[\"如果没有冷冻期\",{\"1\":{\"128\":1}}],[\"如果没有任何一种硬币组合能组成总金额\",{\"1\":{\"106\":1}}],[\"如果没有石头剩下\",{\"1\":{\"96\":1}}],[\"如果没有被移除\",{\"1\":{\"69\":1}}],[\"如果没有就是叶子结点\",{\"1\":{\"41\":1}}],[\"如果找到了\",{\"1\":{\"67\":1}}],[\"如果找不到下一个右侧节点\",{\"1\":{\"23\":1}}],[\"如果不希望通过修改配置文件并重启的方式设置二进制日志的话\",{\"1\":{\"809\":1}}],[\"如果不符合\",{\"1\":{\"799\":1}}],[\"如果不符合则需要\",{\"1\":{\"641\":1}}],[\"如果不在\",{\"1\":{\"798\":1}}],[\"如果不指明\",{\"1\":{\"744\":1}}],[\"如果不指定参数\",{\"1\":{\"831\":1}}],[\"如果不指定\",{\"1\":{\"595\":1,\"604\":1,\"687\":1}}],[\"如果不同就使用联合索引\",{\"1\":{\"725\":1}}],[\"如果不使用\",{\"1\":{\"719\":1}}],[\"如果不能有效利用索引来完成\",{\"1\":{\"710\":1}}],[\"如果不给外键约束命名\",{\"1\":{\"618\":1}}],[\"如果不给唯一约束命名\",{\"1\":{\"615\":1}}],[\"如果不想要数据\",{\"1\":{\"587\":1}}],[\"如果不做特殊配置\",{\"1\":{\"468\":1}}],[\"如果不一致就说明有脏写\",{\"1\":{\"436\":1}}],[\"如果不包含\",{\"1\":{\"392\":1}}],[\"如果不是调优需要的话\",{\"1\":{\"697\":1}}],[\"如果不是直接弹出队首元素\",{\"1\":{\"334\":1}}],[\"如果不是2的倍数\",{\"1\":{\"326\":1}}],[\"如果不清楚\",{\"1\":{\"288\":1}}],[\"如果不要求空间复杂度的话\",{\"1\":{\"256\":1}}],[\"如果不加会超时\",{\"1\":{\"213\":2}}],[\"如果不存在再访问数据库\",{\"1\":{\"818\":1}}],[\"如果不存在就存入默认值\",{\"1\":{\"338\":1}}],[\"如果不存在这样的中间位置\",{\"1\":{\"290\":1}}],[\"如果不存在符合条件的子数组\",{\"1\":{\"284\":1}}],[\"如果不存在\",{\"1\":{\"138\":1}}],[\"如果不为空\",{\"1\":{\"66\":1}}],[\"如果不相等\",{\"1\":{\"60\":1,\"308\":1,\"314\":1}}],[\"如果小于val\",{\"1\":{\"66\":1}}],[\"如果小于或者等于\",{\"1\":{\"56\":2}}],[\"如果左边的值未确定\",{\"1\":{\"716\":1}}],[\"如果左右节点都覆盖了的话\",{\"1\":{\"372\":1}}],[\"如果左右子树的高度差大于1\",{\"1\":{\"37\":1}}],[\"如果左子树为空\",{\"1\":{\"62\":1}}],[\"如果count\",{\"1\":{\"60\":1}}],[\"如果\",{\"1\":{\"60\":1,\"62\":2,\"64\":6,\"96\":2,\"100\":1,\"111\":1,\"116\":1,\"146\":1,\"169\":1,\"187\":1,\"241\":1,\"253\":2,\"273\":3,\"277\":1,\"279\":2,\"290\":2,\"343\":1,\"348\":1,\"360\":1,\"390\":2,\"391\":1,\"393\":1,\"410\":1,\"488\":1,\"725\":1,\"746\":1,\"772\":1}}],[\"如果树中有不止一个众数\",{\"1\":{\"59\":1}}],[\"如果它的左右子树不为空\",{\"1\":{\"54\":1}}],[\"如果节点不存在\",{\"1\":{\"53\":1}}],[\"如果是多个字段的话\",{\"1\":{\"616\":1}}],[\"如果是多列组合的复合主键约束\",{\"1\":{\"616\":1}}],[\"如果是组合列\",{\"1\":{\"615\":1}}],[\"如果是单列\",{\"1\":{\"615\":1}}],[\"如果是两个或更多个字段\",{\"1\":{\"615\":1}}],[\"如果是右外连接\",{\"1\":{\"537\":1}}],[\"如果是左外连接\",{\"1\":{\"537\":1}}],[\"如果是左闭右闭区间\",{\"1\":{\"51\":1}}],[\"如果是从前往后遍历的话\",{\"1\":{\"370\":1}}],[\"如果是从上到下\",{\"1\":{\"155\":1}}],[\"如果是字符\",{\"1\":{\"332\":1}}],[\"如果是有效的字符串的话\",{\"1\":{\"325\":1}}],[\"如果是奇数\",{\"1\":{\"288\":1}}],[\"如果是并且\",{\"1\":{\"155\":1}}],[\"如果是\",{\"1\":{\"137\":1,\"155\":1,\"172\":1,\"276\":1}}],[\"如果是普通二叉树\",{\"1\":{\"60\":1}}],[\"如果是搜索树\",{\"1\":{\"56\":1}}],[\"如果是搜索树那么中序遍历一定是从小到大排列\",{\"1\":{\"56\":1}}],[\"如果是叶子结点\",{\"1\":{\"39\":1}}],[\"如果sum和等于targetsum并且该结点为叶子结点\",{\"1\":{\"45\":1}}],[\"如果循环结束\",{\"1\":{\"33\":1}}],[\"如果只记录了9次调用\",{\"1\":{\"477\":1}}],[\"如果只记录了4次\",{\"1\":{\"476\":1}}],[\"如果只有一个结点\",{\"1\":{\"33\":1}}],[\"如果只是简单地将二叉树遍历一遍\",{\"1\":{\"12\":1}}],[\"如果下一个结点为空\",{\"1\":{\"24\":1}}],[\"如果下一个结点不为空\",{\"1\":{\"24\":1}}],[\"然存在\",{\"1\":{\"746\":1}}],[\"然而在实际使用中\",{\"1\":{\"12\":1}}],[\"然后删除缓存\",{\"1\":{\"853\":1}}],[\"然后删除它\",{\"1\":{\"67\":1}}],[\"然后做缓存\",{\"1\":{\"844\":1}}],[\"然后重试5次\",{\"1\":{\"851\":1}}],[\"然后重新执行\",{\"1\":{\"826\":1}}],[\"然后重复这个过程直到这个数变为\",{\"1\":{\"169\":1}}],[\"然后使用mysql命令将这些内容恢复到数据库中\",{\"1\":{\"809\":1}}],[\"然后使用map统计二叉树出现的次数\",{\"1\":{\"60\":1}}],[\"然后根据readview判断哪个版本可以被访问\",{\"1\":{\"800\":1}}],[\"然后根据readview判断是否可以被访问\",{\"1\":{\"800\":1}}],[\"然后与\",{\"1\":{\"799\":1}}],[\"然后与这个数据结果\",{\"1\":{\"568\":1}}],[\"然后这个隐藏列就相当于一个指针\",{\"1\":{\"794\":1}}],[\"然后这个数据结果作为主查询的条\",{\"1\":{\"570\":1}}],[\"然后调用刷盘操作\",{\"1\":{\"753\":1}}],[\"然后拿着这10万条数据进行回表\",{\"1\":{\"728\":1}}],[\"然后拿着筛选出的记录的主键去\",{\"1\":{\"728\":1}}],[\"然后扫描排序后的列表进行输\",{\"1\":{\"725\":1}}],[\"然后扫描已经排序好的列表\",{\"1\":{\"725\":1}}],[\"然后外层査询语句从临时表中查询记录\",{\"1\":{\"724\":1}}],[\"然后执行上面的三条sql\",{\"1\":{\"715\":1}}],[\"然后看下查询成本\",{\"1\":{\"696\":1}}],[\"然后按照一定的算法规则智能地筛选出我们想要的搜索结果\",{\"1\":{\"686\":1}}],[\"然后对表中的数据进行提取或写入操作\",{\"1\":{\"635\":1}}],[\"然后才可以删除主表的数据\",{\"1\":{\"618\":1}}],[\"然后才能计算失败率\",{\"1\":{\"477\":1}}],[\"然后就可以在网络或者程序之间轻\",{\"1\":{\"608\":1}}],[\"然后是用逗号\",{\"1\":{\"491\":1}}],[\"然后由nginx实现转发请求\",{\"1\":{\"457\":1}}],[\"然后通过读写分离提高数据库并发处理能\",{\"1\":{\"819\":1}}],[\"然后通过远程调用库存服务来扣减下单商品的库存\",{\"1\":{\"430\":1}}],[\"然后通过递归将每一个字母加到\",{\"1\":{\"193\":1}}],[\"然后过了5秒后阀值才慢慢升高恢复到10\",{\"1\":{\"411\":1}}],[\"然后指向\",{\"1\":{\"391\":1}}],[\"然后同时更新pa\",{\"1\":{\"391\":1}}],[\"然后每隔俩个结点放一个监控\",{\"1\":{\"372\":1}}],[\"然后每俩个元素组合在一起\",{\"1\":{\"258\":1}}],[\"然后\",{\"1\":{\"370\":1,\"746\":2,\"813\":1}}],[\"然后从后往前\",{\"1\":{\"362\":1}}],[\"然后返还\",{\"1\":{\"357\":1}}],[\"然后返回\",{\"1\":{\"312\":1,\"488\":1}}],[\"然后向你付\",{\"1\":{\"357\":1}}],[\"然后跳\",{\"1\":{\"351\":1}}],[\"然后记录它所在的行和列\",{\"1\":{\"301\":1}}],[\"然后收集去重后的数据\",{\"1\":{\"267\":1}}],[\"然后截取字符串\",{\"1\":{\"245\":1}}],[\"然后再进行查找\",{\"1\":{\"696\":1}}],[\"然后再看下查询优化器的成本\",{\"1\":{\"696\":2}}],[\"然后再将结果反馈给外部\",{\"1\":{\"570\":1}}],[\"然后再由网关决定进入根据判定到哪个真实的web\",{\"1\":{\"487\":1}}],[\"然后再从下标\",{\"1\":{\"349\":1}}],[\"然后再从大西洋出发找到能够到达的坐标\",{\"1\":{\"234\":1}}],[\"然后再把5加入计算\",{\"1\":{\"103\":1}}],[\"然后继续遍历下一个节点\",{\"1\":{\"222\":1}}],[\"然后继续根据上面的三个条件进行比较\",{\"1\":{\"33\":1}}],[\"然后利用前后元素比较进行去重\",{\"1\":{\"218\":1}}],[\"然后加到集合中\",{\"1\":{\"203\":1}}],[\"然后尝试获取\",{\"1\":{\"177\":1}}],[\"然后判断是否出现过\",{\"1\":{\"170\":1}}],[\"然后求交集\",{\"1\":{\"167\":1}}],[\"然后比较是否相等\",{\"1\":{\"162\":1}}],[\"然后在执行上面的恢复命令\",{\"1\":{\"809\":1}}],[\"然后在将这些记录进行二次筛选\",{\"1\":{\"728\":1}}],[\"然后在确定另一个纬度\",{\"1\":{\"362\":1}}],[\"然后在第一个元素所能覆盖的范围内\",{\"1\":{\"350\":1}}],[\"然后在统计陆地单元格的数量\",{\"1\":{\"230\":1}}],[\"然后在遍历与下一个节点相连接的所有节点\",{\"1\":{\"222\":1}}],[\"然后在\",{\"1\":{\"121\":1}}],[\"然后在反转\",{\"1\":{\"8\":1}}],[\"然后取最大值即可\",{\"1\":{\"115\":1}}],[\"然后偷窃\",{\"1\":{\"112\":1,\"114\":2}}],[\"然后串联起来得到表达式\",{\"1\":{\"98\":1}}],[\"然后串联起所有整数\",{\"1\":{\"98\":1}}],[\"然后将a修改为3\",{\"1\":{\"757\":1}}],[\"然后将这个虚拟表传入下一个步\",{\"1\":{\"565\":1}}],[\"然后将数组排序\",{\"1\":{\"282\":1}}],[\"然后将指向的元素交换并移动\",{\"1\":{\"250\":1}}],[\"然后将俩个字符串的长度\",{\"1\":{\"150\":1}}],[\"然后将它们一起粉碎\",{\"1\":{\"96\":1}}],[\"然后将map按照出现的次数升序\",{\"1\":{\"60\":1}}],[\"然后遍历集合求相邻俩个结点的差\",{\"1\":{\"58\":1}}],[\"然后一口气处理完这一层的\",{\"1\":{\"12\":1}}],[\"然后弹栈\",{\"1\":{\"6\":1}}],[\"提出的标准规范\",{\"1\":{\"835\":1}}],[\"提出需求并解决\",{\"0\":{\"569\":1}}],[\"提升读取的效率\",{\"1\":{\"818\":1}}],[\"提升了读取的效率\",{\"1\":{\"818\":1}}],[\"提升效率\",{\"1\":{\"673\":1}}],[\"提高了效率\",{\"1\":{\"728\":1}}],[\"提高数据检索的效率\",{\"1\":{\"642\":1}}],[\"提高效率\",{\"1\":{\"111\":1}}],[\"提交的事务id有\",{\"1\":{\"797\":1}}],[\"提交的\",{\"1\":{\"742\":1}}],[\"提交\",{\"1\":{\"436\":1}}],[\"提交事务\",{\"1\":{\"426\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"869\":1}}],[\"提供再写入操作\",{\"1\":{\"747\":1}}],[\"提供服务端暴露的接口清单\",{\"1\":{\"464\":1}}],[\"提供的\",{\"1\":{\"421\":1}}],[\"提供了一套完整的服务跟踪的解决方案\",{\"1\":{\"484\":1}}],[\"提供了日志打印功能\",{\"1\":{\"470\":1}}],[\"提供了微服务系统中的服务治理\",{\"1\":{\"449\":1}}],[\"提供了\",{\"1\":{\"418\":1,\"421\":1}}],[\"提供简单易用\",{\"1\":{\"406\":1}}],[\"提供\",{\"1\":{\"406\":1,\"449\":1}}],[\"提供开箱即用的与其它开源框架\",{\"1\":{\"406\":1}}],[\"提供低延时的\",{\"1\":{\"399\":1}}],[\"提供秒级\",{\"1\":{\"399\":2}}],[\"提前对数组进行排序\",{\"1\":{\"205\":1}}],[\"提醒一下\",{\"1\":{\"73\":1}}],[\"提到一个总是想起另一个\",{\"1\":{\"12\":1}}],[\"提示容器\",{\"0\":{\"870\":1},\"1\":{\"870\":1}}],[\"提示\",{\"1\":{\"11\":1,\"13\":1,\"15\":1,\"17\":1,\"19\":1,\"21\":1,\"23\":1,\"25\":1,\"27\":1,\"30\":1,\"32\":1,\"34\":1,\"36\":1,\"38\":1,\"40\":1,\"42\":1,\"44\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"53\":1,\"55\":1,\"57\":1,\"59\":1,\"61\":1,\"65\":1,\"67\":1,\"69\":1,\"71\":1,\"73\":1,\"78\":1,\"80\":1,\"82\":1,\"84\":1,\"86\":1,\"88\":1,\"94\":1,\"96\":1,\"98\":1,\"100\":1,\"102\":1,\"104\":1,\"106\":1,\"108\":1,\"110\":1,\"112\":1,\"114\":1,\"116\":1,\"119\":1,\"121\":1,\"123\":1,\"125\":1,\"127\":1,\"129\":1,\"132\":1,\"134\":1,\"136\":1,\"138\":1,\"140\":1,\"142\":1,\"145\":1,\"147\":1,\"149\":1,\"151\":1,\"154\":1,\"156\":1,\"161\":1,\"164\":1,\"166\":1,\"169\":1,\"172\":1,\"174\":1,\"176\":1,\"178\":1,\"186\":1,\"189\":1,\"192\":1,\"194\":1,\"196\":1,\"198\":1,\"200\":1,\"202\":1,\"204\":1,\"206\":1,\"208\":1,\"210\":1,\"212\":1,\"214\":1,\"216\":1,\"223\":1,\"225\":1,\"227\":1,\"229\":1,\"231\":1,\"233\":1,\"240\":1,\"244\":1,\"246\":1,\"249\":1,\"255\":1,\"257\":1,\"260\":1,\"269\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"290\":1,\"294\":1,\"297\":1,\"303\":1,\"306\":1,\"309\":1,\"312\":1,\"315\":1,\"321\":1,\"324\":1,\"327\":1,\"330\":1,\"333\":1,\"336\":1,\"343\":1,\"345\":1,\"347\":1,\"349\":1,\"351\":1,\"353\":1,\"355\":1,\"357\":1,\"359\":1,\"361\":1,\"363\":1,\"365\":1,\"367\":1,\"369\":1,\"371\":1,\"376\":1,\"379\":1,\"380\":1,\"383\":1,\"385\":1,\"388\":1,\"390\":1,\"393\":1,\"398\":1,\"439\":1,\"467\":1}}],[\"就直接走缓存\",{\"1\":{\"844\":1}}],[\"就一定会有数据一致性的问题\",{\"1\":{\"843\":1}}],[\"就如同redo\",{\"1\":{\"810\":1}}],[\"就避免了不可重复读\",{\"1\":{\"799\":1}}],[\"就好比我们使用\",{\"1\":{\"835\":1}}],[\"就好比一本教课书的目录部分\",{\"1\":{\"641\":1}}],[\"就好了\",{\"1\":{\"755\":2}}],[\"就多一次性能上的开销\",{\"1\":{\"731\":1}}],[\"就知道了这个\",{\"1\":{\"703\":1}}],[\"就无需使用临时表\",{\"1\":{\"702\":1}}],[\"就无需+1\",{\"1\":{\"195\":2}}],[\"就算是比较高效的索引了\",{\"1\":{\"689\":1}}],[\"就算自己命名了主键约束名也没用\",{\"1\":{\"616\":1}}],[\"就跟你的身份证号码一样\",{\"1\":{\"668\":1}}],[\"就执行\",{\"1\":{\"634\":1}}],[\"就进入到解析器阶段\",{\"1\":{\"634\":1}}],[\"就进行合并\",{\"1\":{\"296\":1}}],[\"就根据主键查询\",{\"1\":{\"616\":1}}],[\"就默认和列名相同\",{\"1\":{\"615\":2}}],[\"就认为\",{\"1\":{\"599\":1}}],[\"就能确保有足够大的取值范围\",{\"1\":{\"598\":1}}],[\"就可能涉及到\",{\"1\":{\"843\":1}}],[\"就可能引起\",{\"1\":{\"598\":1}}],[\"就可以检索到任\",{\"1\":{\"737\":1}}],[\"就可以终止了\",{\"1\":{\"386\":1}}],[\"就可以考虑使用一种数据结构进行标记\",{\"1\":{\"218\":1}}],[\"就可以说明该二叉树是对称的\",{\"1\":{\"33\":1}}],[\"就按照实际位数存储\",{\"1\":{\"597\":1}}],[\"就相当于restrict方式\",{\"1\":{\"618\":1}}],[\"就相当于键值数据库所存放的\",{\"1\":{\"510\":1}}],[\"就相当于是暴力搜索\",{\"1\":{\"218\":1}}],[\"就走降级逻辑\",{\"1\":{\"478\":1}}],[\"就拿数据库配置来说吧\",{\"1\":{\"452\":1}}],[\"就下来就学习\",{\"1\":{\"447\":1}}],[\"就写default\",{\"1\":{\"429\":2}}],[\"就写出第三种方式的代码\",{\"1\":{\"268\":1}}],[\"就限流自己\",{\"1\":{\"410\":1}}],[\"就会回滚该事务\",{\"1\":{\"812\":1}}],[\"就会创建一个新的日志文件\",{\"1\":{\"809\":1}}],[\"就会把\",{\"1\":{\"753\":1}}],[\"就会同时把比赛信息删\",{\"1\":{\"737\":1}}],[\"就会在执行计划的`extra`列中显示`using\",{\"1\":{\"710\":1}}],[\"就会为它分配一个唯一的id\",{\"1\":{\"702\":1}}],[\"就会返回权限错误\",{\"1\":{\"634\":1}}],[\"就会直接将结果返回给客户端\",{\"1\":{\"634\":1}}],[\"就会直接报错\",{\"1\":{\"410\":1}}],[\"就会出现错误\",{\"1\":{\"618\":1}}],[\"就会产生\",{\"1\":{\"533\":1}}],[\"就会开启断路器\",{\"1\":{\"477\":1}}],[\"就会报错\",{\"1\":{\"435\":1}}],[\"就会进行\",{\"1\":{\"779\":1}}],[\"就会进行限流\",{\"1\":{\"417\":1}}],[\"就会进入熔断状态\",{\"1\":{\"413\":1}}],[\"就会限流\",{\"1\":{\"410\":1}}],[\"就会被流量进行控制\",{\"1\":{\"409\":1}}],[\"就会导致一个物品被重复装入的可能\",{\"1\":{\"92\":1}}],[\"就移动到heada的头结点\",{\"1\":{\"391\":1}}],[\"就移动到headb的头结点\",{\"1\":{\"391\":1}}],[\"就让当前数字\",{\"1\":{\"370\":1}}],[\"就符合条件了\",{\"1\":{\"370\":1}}],[\"就说名此时俩个区间重叠了\",{\"1\":{\"366\":1}}],[\"就说明同步过程出现了问题\",{\"1\":{\"669\":1}}],[\"就说明该结点就是环的起始点\",{\"1\":{\"394\":1}}],[\"就说明该元素是需要被替换的元素\",{\"1\":{\"279\":1}}],[\"就说明该元素是输出元素\",{\"1\":{\"279\":1}}],[\"就说明到了一个切割点\",{\"1\":{\"368\":1}}],[\"就说明已经走到当前位置能够覆盖的最远距离了\",{\"1\":{\"352\":1}}],[\"就说明可以合并\",{\"1\":{\"295\":1}}],[\"就说明可以分割成俩个元素相等的子集\",{\"1\":{\"95\":1}}],[\"就说明找到一条路径\",{\"1\":{\"224\":1}}],[\"就说明\",{\"1\":{\"162\":1}}],[\"就说明s串是合法的\",{\"1\":{\"111\":1}}],[\"就说明当前结点比上一个结点出现的频率要高\",{\"1\":{\"60\":1}}],[\"就使用3张5元\",{\"1\":{\"358\":1}}],[\"就立马舍弃\",{\"1\":{\"348\":1}}],[\"就反转n个字符\",{\"1\":{\"253\":1}}],[\"就反转\",{\"1\":{\"253\":1}}],[\"就反转这\",{\"1\":{\"252\":1}}],[\"就像这样\",{\"1\":{\"745\":1}}],[\"就像是不到黄河不回头\",{\"1\":{\"222\":1}}],[\"就像孪生兄弟\",{\"1\":{\"12\":1}}],[\"就跳过当前航班\",{\"1\":{\"213\":2}}],[\"就有可能导致幻读\",{\"1\":{\"799\":1}}],[\"就有可能会破坏数据的完整性\",{\"1\":{\"616\":1}}],[\"就有可能将元素重复放到\",{\"1\":{\"209\":1}}],[\"就有dp\",{\"1\":{\"99\":1}}],[\"就没有必要在继续尝试了\",{\"1\":{\"350\":2}}],[\"就没有必须在选取了\",{\"1\":{\"195\":1}}],[\"就没有什么用呢\",{\"1\":{\"12\":1}}],[\"就收集起来\",{\"1\":{\"190\":1}}],[\"就得用三层for循环\",{\"1\":{\"187\":1}}],[\"就要遍历所有的键\",{\"1\":{\"510\":1}}],[\"就要保证当前孩子获得的糖果比左右俩边的孩子都要多\",{\"1\":{\"360\":1}}],[\"就要初始为1\",{\"1\":{\"137\":1}}],[\"就要知道\",{\"1\":{\"91\":1}}],[\"就需要从\",{\"1\":{\"799\":1}}],[\"就需要从儿子的儿子转移过来\",{\"1\":{\"117\":1}}],[\"就需要生成一个\",{\"1\":{\"763\":1}}],[\"就需要\",{\"1\":{\"689\":1}}],[\"就需要去申请新的页了\",{\"1\":{\"670\":1}}],[\"就需要回滚一阶段已经执行的\",{\"1\":{\"436\":1}}],[\"就需要回溯换另一个方向继续遍历\",{\"1\":{\"222\":1}}],[\"就需要重新射一箭\",{\"1\":{\"364\":1}}],[\"就需要判断\",{\"1\":{\"261\":1}}],[\"就需要用\",{\"1\":{\"195\":1}}],[\"就需要考虑dp数组首个元素的初始化\",{\"1\":{\"137\":1}}],[\"就只需要考虑儿子了呢\",{\"1\":{\"117\":1}}],[\"就将该元素加入到path中\",{\"1\":{\"203\":2}}],[\"就将\",{\"1\":{\"117\":1}}],[\"就将次数count\",{\"1\":{\"60\":1}}],[\"就不管了\",{\"1\":{\"853\":1}}],[\"就不会使用自增锁\",{\"1\":{\"772\":1}}],[\"就不需要加\",{\"1\":{\"729\":1}}],[\"就不需要用\",{\"1\":{\"195\":1}}],[\"就不允许删除\",{\"1\":{\"618\":1}}],[\"就不知道\",{\"1\":{\"155\":1}}],[\"就不能无所谓了\",{\"1\":{\"103\":1}}],[\"就不是一颗二叉搜索树\",{\"1\":{\"56\":1}}],[\"就返回false\",{\"1\":{\"217\":2}}],[\"就返回了\",{\"1\":{\"179\":1}}],[\"就返回\",{\"1\":{\"96\":1,\"169\":1,\"217\":1}}],[\"就是数据备份\",{\"1\":{\"819\":1}}],[\"就是事务a在使用mvcc机制进行快照读操作时产生的读视图\",{\"1\":{\"796\":1}}],[\"就是锁住某一行\",{\"1\":{\"774\":1}}],[\"就是生成一个readview\",{\"1\":{\"765\":1}}],[\"就是说对于一个已经提交的事务\",{\"1\":{\"749\":1}}],[\"就是要撤销失败事务对当前数据库造成的影响\",{\"1\":{\"742\":1}}],[\"就是要判断\",{\"1\":{\"170\":1}}],[\"就是你\",{\"1\":{\"727\":1}}],[\"就是单路排序\",{\"1\":{\"725\":1}}],[\"就是单纯的状态转移\",{\"1\":{\"372\":1}}],[\"就是临时表\",{\"1\":{\"703\":1}}],[\"就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中\",{\"1\":{\"696\":1}}],[\"就是对于一个很长的字节串来说\",{\"1\":{\"668\":1}}],[\"就是有时候二叉树的深度非常大\",{\"1\":{\"659\":1}}],[\"就是索引列的重复值如果很多\",{\"1\":{\"658\":1}}],[\"就是指这个记录中存储了所有列的值\",{\"1\":{\"650\":1}}],[\"就是当主表更新时\",{\"1\":{\"618\":1}}],[\"就是字符串数据\",{\"1\":{\"603\":1}}],[\"就是为null的列\",{\"1\":{\"523\":1}}],[\"就是最大子数组的和呢\",{\"1\":{\"348\":1}}],[\"就是最后一位\",{\"1\":{\"282\":1}}],[\"就是尽量将尺寸大的饼干分配给胃口最大的孩子\",{\"1\":{\"344\":1}}],[\"就是删除数组中\",{\"1\":{\"313\":1}}],[\"就是新数组的长度\",{\"1\":{\"280\":1}}],[\"就是与node所有相连的节点列表\",{\"1\":{\"224\":1}}],[\"就是回溯的过程\",{\"1\":{\"222\":1}}],[\"就是回文子串\",{\"1\":{\"155\":1}}],[\"就是在请求d写数据库完之后\",{\"1\":{\"848\":1}}],[\"就是在同一\",{\"1\":{\"197\":1}}],[\"就是在一个\",{\"1\":{\"197\":1}}],[\"就是选取的元素可以无限重复\",{\"1\":{\"195\":1}}],[\"就是纵向遍历\",{\"1\":{\"185\":1}}],[\"就是只包含质因数\",{\"1\":{\"172\":1}}],[\"就是模拟在s中删除这个元素\",{\"1\":{\"148\":1,\"153\":1}}],[\"就是连续递增子序列\",{\"1\":{\"134\":1}}],[\"就是我们背包的容量\",{\"1\":{\"99\":1}}],[\"就是\",{\"1\":{\"74\":1,\"306\":1,\"357\":1,\"426\":1,\"727\":1,\"819\":1,\"835\":1}}],[\"就是公共祖先\",{\"1\":{\"62\":1}}],[\"就去左子树搜索\",{\"1\":{\"66\":1}}],[\"就去右子树搜索\",{\"1\":{\"66\":2}}],[\"就变成中右左的遍历顺序\",{\"1\":{\"8\":1}}],[\"b=\",{\"1\":{\"757\":1}}],[\"b=2\",{\"1\":{\"757\":1}}],[\"b修改为4\",{\"1\":{\"757\":1}}],[\"bcnf\",{\"1\":{\"736\":1,\"737\":1}}],[\"b表大\",{\"1\":{\"729\":1}}],[\"b表小\",{\"1\":{\"729\":1}}],[\"b+存储的数据就更多\",{\"1\":{\"662\":1}}],[\"b+\",{\"0\":{\"662\":1},\"1\":{\"662\":2,\"667\":1}}],[\"b+树每\",{\"1\":{\"656\":1}}],[\"b+树都要拷贝一份用户完整的记录\",{\"1\":{\"651\":1}}],[\"b+树的每层非叶子节点中的最小记录都会添加该标记\",{\"1\":{\"680\":1}}],[\"b+树的效率也比b树高\",{\"1\":{\"662\":1}}],[\"b+树的查询效率更高\",{\"1\":{\"662\":1}}],[\"b+树的查询效率更加稳定\",{\"1\":{\"662\":1}}],[\"b+树的\",{\"1\":{\"650\":1}}],[\"b+tree的数据结构\",{\"1\":{\"648\":1}}],[\"b+tree\",{\"0\":{\"648\":1},\"1\":{\"653\":1}}],[\"b+c\",{\"1\":{\"97\":2}}],[\"b的交集去掉\",{\"1\":{\"541\":2}}],[\"b可以用departments表表示\",{\"1\":{\"541\":1}}],[\"buffer刷盘到redo\",{\"1\":{\"753\":1}}],[\"buffer中的内容刷新到\",{\"1\":{\"752\":1}}],[\"buffer`的内存块来加快查询速度\",{\"1\":{\"710\":1}}],[\"buffer\",{\"1\":{\"701\":1,\"751\":4,\"752\":1,\"753\":4}}],[\"buffers\",{\"0\":{\"630\":1}}],[\"bulkhead<\",{\"1\":{\"480\":1,\"481\":1}}],[\"bulkheading\",{\"1\":{\"474\":1}}],[\"bulkhead\",{\"1\":{\"474\":1,\"479\":1,\"480\":8,\"481\":10}}],[\"business\",{\"1\":{\"431\":3,\"444\":1}}],[\"build\",{\"1\":{\"441\":2}}],[\"build>\",{\"1\":{\"402\":2,\"442\":1,\"443\":1,\"446\":1,\"489\":1}}],[\"buildtree\",{\"1\":{\"49\":1}}],[\"buildtree1\",{\"1\":{\"47\":1}}],[\"by一致\",{\"1\":{\"726\":1}}],[\"by列在buffer对它们进行排序\",{\"1\":{\"725\":1}}],[\"by列\",{\"1\":{\"725\":1}}],[\"by`\",{\"1\":{\"710\":1}}],[\"byte用于存储信息长度\",{\"1\":{\"604\":1}}],[\"bytes\",{\"1\":{\"597\":1}}],[\"by搭配使用\",{\"1\":{\"564\":1}}],[\"by子句中的字段可以不出现在select后\",{\"1\":{\"563\":1}}],[\"by子句中\",{\"1\":{\"563\":1}}],[\"by子句将表中的数据分成若干组\",{\"1\":{\"563\":1}}],[\"by\",{\"0\":{\"563\":1,\"726\":1},\"1\":{\"429\":1,\"563\":4,\"564\":3,\"565\":6,\"574\":1,\"578\":7,\"579\":4,\"658\":1,\"689\":4,\"710\":4,\"725\":10,\"726\":10,\"825\":3}}],[\"byurl\",{\"1\":{\"419\":1}}],[\"bridge\",{\"1\":{\"486\":4}}],[\"brave<\",{\"1\":{\"486\":4}}],[\"brave适配zipkin的桥接包\",{\"1\":{\"486\":2}}],[\"brave\",{\"1\":{\"486\":5}}],[\"branch\",{\"1\":{\"428\":1,\"429\":2,\"431\":3}}],[\"branchsession\",{\"1\":{\"428\":1}}],[\"breaking\",{\"1\":{\"474\":1}}],[\"breaker\",{\"1\":{\"475\":1}}],[\"breaker的实现\",{\"1\":{\"474\":1}}],[\"breaker提供了跨不同断路器实现的抽象\",{\"1\":{\"474\":1}}],[\"break\",{\"1\":{\"66\":2,\"111\":1,\"175\":1,\"197\":1,\"242\":1,\"275\":2,\"332\":4}}],[\"blackhole\",{\"1\":{\"635\":1}}],[\"blob类型\",{\"1\":{\"678\":1}}],[\"blob\",{\"1\":{\"428\":1,\"431\":1,\"475\":1,\"479\":1,\"482\":1}}],[\"block\",{\"1\":{\"423\":1}}],[\"blockrequesthandler\",{\"1\":{\"422\":1,\"423\":2}}],[\"blockexception\",{\"1\":{\"416\":1,\"417\":1}}],[\"blockhandlerclass\",{\"1\":{\"416\":2}}],[\"blockhandler\",{\"1\":{\"416\":4,\"417\":1,\"420\":2,\"422\":2}}],[\"blue\",{\"1\":{\"244\":2,\"499\":1,\"502\":2}}],[\"b0bf3537\",{\"1\":{\"404\":1}}],[\"b<\",{\"1\":{\"299\":2}}],[\"bit类型\",{\"1\":{\"601\":1}}],[\"bit类型中存储的是二进制值\",{\"1\":{\"601\":1}}],[\"bigdecimal\",{\"1\":{\"443\":1}}],[\"bigint\",{\"1\":{\"428\":7,\"431\":10,\"593\":1,\"595\":1,\"598\":1}}],[\"binglog\",{\"1\":{\"810\":1}}],[\"bin=0\",{\"1\":{\"809\":2}}],[\"bin=atguigu\",{\"1\":{\"809\":1,\"823\":1}}],[\"binlog订阅者获取变更的数据\",{\"1\":{\"853\":1}}],[\"binlog日志\",{\"1\":{\"850\":1}}],[\"binlog可以用于实时的还原\",{\"1\":{\"823\":1}}],[\"binlog中包含了所有数据库更改信息\",{\"1\":{\"823\":1}}],[\"binlog格式设置\",{\"1\":{\"823\":1}}],[\"binlog的写入时机也非常简单\",{\"1\":{\"810\":1}}],[\"binlog主要应用场景\",{\"1\":{\"808\":1}}],[\"binlog\",{\"0\":{\"811\":1,\"853\":1},\"1\":{\"808\":1,\"809\":5,\"810\":5,\"811\":2,\"820\":7,\"823\":13}}],[\"bind=127\",{\"1\":{\"454\":1}}],[\"binpath=\",{\"1\":{\"454\":1}}],[\"binpath\",{\"1\":{\"454\":1}}],[\"bin\",{\"0\":{\"808\":1},\"1\":{\"401\":1,\"551\":1,\"809\":13,\"813\":2,\"823\":1,\"826\":1}}],[\"binarytreepaths\",{\"1\":{\"39\":1}}],[\"binary\",{\"1\":{\"12\":1,\"16\":1,\"18\":1,\"22\":1,\"26\":1,\"28\":1,\"31\":2,\"35\":1,\"37\":1,\"73\":1,\"117\":1,\"660\":1,\"808\":1,\"809\":3,\"820\":1}}],[\"bills\",{\"1\":{\"357\":7,\"358\":4}}],[\"bi\",{\"1\":{\"257\":1}}],[\"bn\",{\"1\":{\"257\":1}}],[\"b2\",{\"1\":{\"257\":1}}],[\"b1\",{\"1\":{\"257\":1}}],[\"bovce\",{\"1\":{\"737\":1}}],[\"bom<\",{\"1\":{\"486\":1}}],[\"bom导入链路追踪版本中心\",{\"1\":{\"486\":1}}],[\"bodyinserters\",{\"1\":{\"422\":1,\"423\":1}}],[\"body\",{\"1\":{\"422\":2,\"423\":1}}],[\"bootstrap<\",{\"1\":{\"403\":1,\"452\":1}}],[\"bootstrap\",{\"1\":{\"403\":3,\"429\":1,\"452\":2,\"454\":1}}],[\"boot<\",{\"1\":{\"402\":7,\"432\":4,\"441\":3,\"442\":2,\"443\":5,\"446\":3,\"477\":1,\"489\":2}}],[\"boot\",{\"1\":{\"399\":7,\"402\":7,\"407\":1,\"420\":2,\"432\":5,\"441\":11,\"442\":2,\"443\":6,\"446\":3,\"477\":1,\"489\":3,\"586\":1}}],[\"bool\",{\"1\":{\"274\":1}}],[\"boolean类型的二维数组\",{\"1\":{\"155\":1}}],[\"boolean\",{\"1\":{\"33\":3,\"37\":2,\"45\":2,\"56\":4,\"95\":1,\"111\":3,\"146\":2,\"155\":2,\"163\":2,\"171\":2,\"173\":1,\"199\":2,\"201\":2,\"211\":4,\"213\":5,\"215\":2,\"217\":4,\"226\":2,\"228\":2,\"234\":5,\"262\":2,\"268\":1,\"302\":4,\"321\":1,\"323\":1,\"326\":1,\"350\":3,\"358\":1,\"497\":1}}],[\"boxed\",{\"1\":{\"354\":1}}],[\"board\",{\"1\":{\"216\":4,\"217\":24,\"231\":6,\"232\":34}}],[\"bf\",{\"1\":{\"192\":1}}],[\"bfs做的步骤就是\",{\"1\":{\"222\":1}}],[\"bfs是一圈一圈的搜索过程\",{\"1\":{\"222\":1}}],[\"bfs层序遍历\",{\"1\":{\"39\":1}}],[\"bfs应用场景\",{\"1\":{\"12\":1}}],[\"bfs\",{\"0\":{\"222\":1},\"1\":{\"12\":21,\"29\":3,\"31\":1,\"35\":2,\"41\":2,\"222\":5,\"226\":2,\"228\":2,\"230\":1,\"232\":1}}],[\"because\",{\"1\":{\"822\":1}}],[\"beijing\",{\"1\":{\"608\":2}}],[\"between=2024\",{\"1\":{\"492\":1}}],[\"between\",{\"0\":{\"492\":1},\"1\":{\"492\":1,\"534\":1,\"696\":1}}],[\"before=2024\",{\"1\":{\"492\":1}}],[\"before\",{\"0\":{\"492\":1},\"1\":{\"436\":2,\"492\":1,\"809\":1}}],[\"behavior\",{\"1\":{\"411\":2}}],[\"beanutils\",{\"1\":{\"443\":1}}],[\"bean\",{\"1\":{\"402\":1,\"423\":2,\"424\":1,\"458\":1,\"467\":1,\"470\":1}}],[\"be\",{\"1\":{\"192\":1,\"617\":2,\"809\":1,\"822\":1,\"883\":1}}],[\"beginvisittime\",{\"1\":{\"503\":3}}],[\"beginningdelimiter\",{\"1\":{\"442\":1}}],[\"begin>end\",{\"1\":{\"51\":1}}],[\"begin\",{\"1\":{\"51\":9,\"261\":1,\"299\":8,\"503\":4,\"744\":2,\"745\":1,\"767\":1,\"771\":2}}],[\"bd\",{\"1\":{\"192\":1}}],[\"bbbb\",{\"1\":{\"156\":1}}],[\"bbbab\",{\"1\":{\"156\":1}}],[\"bb\",{\"1\":{\"155\":1,\"156\":1,\"260\":1,\"327\":1}}],[\"bak\",{\"1\":{\"831\":8}}],[\"balanced\",{\"1\":{\"660\":1}}],[\"balance\",{\"1\":{\"457\":1,\"661\":1}}],[\"basic\",{\"1\":{\"470\":2}}],[\"basis\",{\"1\":{\"429\":1}}],[\"base64\",{\"1\":{\"809\":1}}],[\"basename\",{\"1\":{\"809\":1}}],[\"baseconfig\",{\"1\":{\"477\":1,\"478\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"based表示2秒\",{\"1\":{\"478\":1}}],[\"based表示6秒\",{\"1\":{\"477\":1}}],[\"based表示6个请求\",{\"1\":{\"477\":1}}],[\"based则\",{\"1\":{\"476\":1}}],[\"based\",{\"1\":{\"476\":4,\"477\":2,\"478\":2,\"823\":3}}],[\"basedir\",{\"1\":{\"442\":3}}],[\"base\",{\"1\":{\"440\":1}}],[\"baidu\",{\"1\":{\"422\":1}}],[\"bab\",{\"1\":{\"260\":1}}],[\"babad\",{\"1\":{\"260\":1}}],[\"babgbag\",{\"1\":{\"147\":6}}],[\"backup\",{\"1\":{\"832\":1}}],[\"backtracking\",{\"1\":{\"185\":5,\"187\":5,\"188\":1,\"190\":5,\"191\":3,\"193\":5,\"195\":5,\"197\":3,\"199\":5,\"201\":5,\"203\":5,\"205\":3,\"207\":5,\"209\":5,\"211\":3,\"213\":5,\"215\":5,\"217\":5}}],[\"bacd\",{\"1\":{\"252\":1}}],[\"bacdfeg\",{\"1\":{\"252\":1}}],[\"bat\",{\"1\":{\"164\":2,\"429\":1,\"454\":2}}],[\"bagg\",{\"1\":{\"148\":1,\"153\":1}}],[\"bag\",{\"1\":{\"147\":2,\"148\":1,\"153\":1}}],[\"bagsize\",{\"1\":{\"91\":5,\"92\":4,\"93\":2}}],[\"bad\",{\"1\":{\"128\":1,\"274\":3,\"504\":1}}],[\"bst\",{\"1\":{\"53\":2,\"59\":3,\"65\":1}}],[\"b\",{\"0\":{\"661\":1},\"1\":{\"23\":1,\"97\":10,\"154\":1,\"177\":1,\"178\":4,\"192\":1,\"193\":2,\"198\":2,\"213\":2,\"354\":2,\"362\":4,\"364\":4,\"366\":2,\"390\":5,\"391\":3,\"552\":1,\"607\":4,\"661\":1,\"662\":1,\"704\":1,\"716\":1,\"725\":5,\"729\":3,\"746\":4,\"772\":2,\"800\":2,\"831\":1}}],[\"和慢查\",{\"1\":{\"805\":1}}],[\"和上面同理\",{\"1\":{\"800\":1}}],[\"和事务\",{\"1\":{\"800\":1}}],[\"和更新类事务的提交语句\",{\"1\":{\"785\":1}}],[\"和第五范式\",{\"1\":{\"736\":1}}],[\"和业务沟通能不排序就不排序\",{\"1\":{\"726\":1}}],[\"和more\",{\"1\":{\"699\":1}}],[\"和fil\",{\"1\":{\"668\":1}}],[\"和文件尾\",{\"1\":{\"667\":1}}],[\"和c3列\",{\"1\":{\"652\":1}}],[\"和case\",{\"1\":{\"559\":1}}],[\"和非聚簇\",{\"1\":{\"649\":1}}],[\"和普通的\",{\"1\":{\"645\":1}}],[\"和最大索引长度\",{\"1\":{\"642\":1}}],[\"和最大边界\",{\"1\":{\"69\":1}}],[\"和回滚\",{\"1\":{\"636\":1}}],[\"和回溯\",{\"1\":{\"222\":1}}],[\"和可靠性\",{\"1\":{\"612\":1}}],[\"和字符集有关\",{\"1\":{\"552\":1}}],[\"和自定义predicate非常相似\",{\"1\":{\"504\":1}}],[\"和要给出的节点\",{\"1\":{\"379\":1}}],[\"和要插入树中的值\",{\"1\":{\"65\":1}}],[\"和2\",{\"1\":{\"370\":1}}],[\"和200\",{\"1\":{\"228\":1}}],[\"和引爆气球一样\",{\"1\":{\"366\":1}}],[\"和没确定一样\",{\"1\":{\"362\":1}}],[\"和右孩子\",{\"1\":{\"360\":1}}],[\"和word2\",{\"1\":{\"153\":1}}],[\"和空串\",{\"1\":{\"152\":2}}],[\"和两个整数\",{\"1\":{\"100\":1,\"383\":1}}],[\"和01背包一样\",{\"1\":{\"95\":1}}],[\"和节点\",{\"1\":{\"61\":2,\"63\":2}}],[\"和一个可选的\",{\"1\":{\"494\":1}}],[\"和一个目标数\",{\"1\":{\"196\":1}}],[\"和一个目标值\",{\"1\":{\"178\":1,\"269\":1,\"275\":1}}],[\"和一个目标整数\",{\"1\":{\"104\":1,\"194\":1}}],[\"和一个字符串列表\",{\"1\":{\"110\":1}}],[\"和一个整数目标值\",{\"1\":{\"174\":1}}],[\"和一个整数\",{\"1\":{\"98\":1,\"125\":1,\"252\":1,\"277\":1,\"336\":1,\"353\":1,\"376\":1}}],[\"和一个整数值\",{\"1\":{\"53\":1}}],[\"和一个值\",{\"1\":{\"67\":1,\"278\":1}}],[\"和一个表示目标和的整数\",{\"1\":{\"44\":1}}],[\"和为目标值target\",{\"1\":{\"174\":1}}],[\"和为奇数\",{\"1\":{\"95\":1}}],[\"和为\",{\"1\":{\"44\":2,\"108\":1}}],[\"和求平均值一样\",{\"1\":{\"22\":1}}],[\"和\",{\"0\":{\"222\":1,\"508\":1,\"726\":1,\"811\":1},\"1\":{\"12\":2,\"35\":1,\"40\":1,\"41\":1,\"46\":2,\"48\":2,\"52\":1,\"58\":2,\"61\":1,\"62\":3,\"71\":1,\"73\":2,\"78\":1,\"87\":3,\"94\":1,\"95\":1,\"96\":5,\"97\":1,\"100\":5,\"101\":2,\"103\":2,\"108\":2,\"110\":2,\"113\":1,\"115\":1,\"117\":1,\"120\":1,\"134\":2,\"136\":1,\"137\":2,\"138\":2,\"140\":2,\"145\":1,\"147\":2,\"148\":2,\"149\":3,\"151\":2,\"152\":1,\"153\":2,\"155\":1,\"157\":1,\"161\":4,\"162\":1,\"166\":1,\"172\":1,\"176\":1,\"178\":1,\"183\":1,\"186\":1,\"191\":1,\"193\":1,\"194\":1,\"197\":1,\"200\":2,\"212\":1,\"214\":1,\"217\":1,\"223\":1,\"225\":1,\"231\":1,\"232\":1,\"233\":1,\"240\":2,\"261\":2,\"294\":2,\"299\":3,\"313\":1,\"321\":2,\"330\":1,\"334\":1,\"339\":1,\"345\":1,\"355\":1,\"360\":1,\"361\":1,\"362\":2,\"363\":5,\"369\":1,\"383\":1,\"386\":1,\"390\":4,\"399\":1,\"403\":1,\"416\":1,\"420\":2,\"426\":1,\"436\":1,\"441\":1,\"449\":1,\"464\":1,\"487\":1,\"498\":1,\"499\":2,\"500\":1,\"501\":2,\"502\":1,\"508\":1,\"509\":1,\"510\":1,\"522\":1,\"532\":3,\"570\":1,\"579\":1,\"593\":1,\"599\":2,\"605\":1,\"608\":1,\"617\":1,\"618\":1,\"651\":1,\"658\":1,\"662\":1,\"687\":1,\"689\":1,\"694\":1,\"705\":1,\"721\":1,\"725\":2,\"729\":3,\"747\":1,\"772\":1,\"775\":1,\"776\":1,\"781\":1,\"783\":1,\"797\":1,\"798\":1,\"808\":1,\"809\":3,\"835\":8,\"865\":1,\"884\":1}}],[\"和中序遍历代码不相关\",{\"1\":{\"9\":1}}],[\"ohimtdp2\",{\"1\":{\"809\":3}}],[\"o等\",{\"1\":{\"760\":1}}],[\"owned\",{\"1\":{\"680\":2}}],[\"o和数据存储总量比较好\",{\"1\":{\"604\":1}}],[\"oct\",{\"1\":{\"551\":1}}],[\"ocean\",{\"1\":{\"234\":4}}],[\"only=0\",{\"1\":{\"823\":1}}],[\"only\",{\"1\":{\"617\":1,\"744\":1}}],[\"on\",{\"1\":{\"429\":1,\"440\":1,\"538\":5,\"539\":4,\"541\":9,\"565\":4,\"618\":6,\"687\":2,\"698\":1,\"704\":1,\"707\":1,\"709\":1,\"710\":2,\"715\":3,\"718\":2,\"745\":1,\"809\":2,\"825\":2}}],[\"one++\",{\"1\":{\"101\":1}}],[\"one\",{\"1\":{\"101\":4,\"513\":3,\"617\":1}}],[\"observation<\",{\"1\":{\"486\":2}}],[\"observation\",{\"1\":{\"486\":5}}],[\"obtain\",{\"1\":{\"429\":1}}],[\"objectprovider<list<viewresolver>>\",{\"1\":{\"423\":1}}],[\"object\",{\"1\":{\"399\":1,\"419\":2,\"608\":1}}],[\"overwrite>\",{\"1\":{\"442\":1}}],[\"overview\",{\"1\":{\"426\":1}}],[\"override\",{\"1\":{\"418\":1,\"420\":1,\"423\":1,\"432\":1,\"433\":1,\"434\":1,\"443\":5,\"497\":1,\"503\":2,\"504\":3}}],[\"ok\",{\"1\":{\"422\":1,\"454\":1,\"767\":1,\"771\":2,\"809\":1,\"832\":2}}],[\"ordinary\",{\"1\":{\"777\":1}}],[\"ordercircuitcontroller\",{\"1\":{\"477\":1}}],[\"ordercontroller\",{\"1\":{\"432\":1,\"446\":1,\"451\":1,\"464\":1}}],[\"order80\",{\"1\":{\"464\":2,\"477\":1}}],[\"order83\",{\"1\":{\"402\":2}}],[\"orderfromdb\",{\"1\":{\"432\":12}}],[\"ordermapper\",{\"1\":{\"432\":6}}],[\"orderserviceimpl\",{\"1\":{\"432\":1}}],[\"orderservice\",{\"1\":{\"432\":5}}],[\"ordered\",{\"1\":{\"423\":1,\"503\":1}}],[\"orderno\",{\"1\":{\"420\":4,\"443\":1}}],[\"ordernacoscontroller\",{\"1\":{\"402\":2}}],[\"order\",{\"1\":{\"12\":1,\"402\":1,\"423\":2,\"424\":1,\"431\":10,\"432\":20,\"435\":1,\"440\":1,\"464\":1,\"563\":1,\"565\":3,\"579\":1,\"658\":1,\"689\":2,\"710\":2,\"725\":11,\"726\":2}}],[\"oracle\",{\"1\":{\"508\":1}}],[\"orelse\",{\"1\":{\"444\":1}}],[\"or\",{\"0\":{\"722\":1},\"1\":{\"429\":3,\"444\":1,\"565\":1,\"668\":2,\"704\":6,\"710\":1,\"728\":1}}],[\"org\",{\"1\":{\"422\":3,\"426\":1,\"427\":1,\"429\":1,\"441\":4,\"442\":2,\"491\":2,\"492\":1,\"502\":2,\"504\":1}}],[\"oss\",{\"1\":{\"399\":2}}],[\"optimizer\",{\"0\":{\"629\":1}}],[\"option\",{\"1\":{\"809\":2}}],[\"options\",{\"1\":{\"422\":1,\"700\":2}}],[\"optional>\",{\"1\":{\"402\":1,\"441\":1,\"442\":1,\"446\":1}}],[\"open状态\",{\"1\":{\"477\":1}}],[\"open状态需要等待的时间\",{\"1\":{\"476\":1,\"477\":1,\"478\":1}}],[\"open状态下时进行n次调用\",{\"1\":{\"476\":1}}],[\"open\",{\"1\":{\"475\":3,\"476\":2}}],[\"openapi\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"openfeign默认使用jdk自带的\",{\"1\":{\"468\":1}}],[\"openfeign中http\",{\"1\":{\"468\":1}}],[\"openfeign的默认超时时间为60s\",{\"1\":{\"466\":1}}],[\"openfeign天然支持负载均衡演示\",{\"1\":{\"464\":2}}],[\"openfeign同时还集成springcloud\",{\"1\":{\"462\":1}}],[\"openfeign<\",{\"1\":{\"432\":1,\"463\":1,\"468\":1,\"486\":2}}],[\"openfeign\",{\"0\":{\"461\":1},\"1\":{\"399\":1,\"402\":1,\"420\":4,\"432\":1,\"435\":1,\"462\":3,\"463\":1,\"464\":3,\"466\":2,\"468\":1,\"469\":1,\"477\":1},\"2\":{\"506\":1}}],[\"opens\",{\"1\":{\"0\":2,\"153\":1}}],[\"op2\",{\"1\":{\"332\":2}}],[\"op1\",{\"1\":{\"332\":2}}],[\"office\",{\"1\":{\"835\":1}}],[\"offset\",{\"1\":{\"668\":1,\"809\":2}}],[\"off\",{\"1\":{\"454\":1,\"745\":2,\"806\":2,\"809\":2}}],[\"offer\",{\"1\":{\"226\":2,\"228\":2,\"230\":2,\"232\":2,\"335\":1,\"338\":1}}],[\"of\",{\"1\":{\"321\":1,\"429\":2,\"476\":2}}],[\"o2\",{\"1\":{\"296\":2,\"338\":4}}],[\"o1\",{\"1\":{\"296\":2,\"338\":4}}],[\"o\",{\"1\":{\"67\":1,\"115\":1,\"193\":2,\"231\":11,\"232\":7,\"249\":3,\"256\":1,\"273\":1,\"275\":1,\"276\":1,\"277\":2,\"278\":1,\"336\":1,\"345\":1,\"347\":1,\"420\":1,\"446\":2,\"729\":2,\"820\":2,\"822\":1}}],[\"output=decode\",{\"1\":{\"809\":1}}],[\"outputstack\",{\"1\":{\"323\":7}}],[\"outer\",{\"1\":{\"539\":5,\"541\":3}}],[\"out\",{\"1\":{\"39\":3,\"83\":1,\"91\":2,\"92\":1,\"103\":1,\"105\":1,\"280\":1,\"410\":1,\"416\":2,\"432\":4,\"443\":1,\"444\":3,\"445\":1,\"464\":2,\"481\":2,\"503\":1,\"504\":1}}],[\"内容\",{\"1\":{\"867\":1}}],[\"内容写入\",{\"1\":{\"753\":1}}],[\"内存中的结构\",{\"1\":{\"763\":1}}],[\"内存映射中变更的数据还来不及刷回磁盘\",{\"1\":{\"757\":1}}],[\"内节点\",{\"1\":{\"648\":1}}],[\"内部的行存储格式并没有区\",{\"1\":{\"604\":1}}],[\"内查询返回多行\",{\"1\":{\"576\":1}}],[\"内查询\",{\"1\":{\"569\":1}}],[\"内连接\",{\"0\":{\"537\":1,\"538\":1},\"1\":{\"537\":1,\"541\":1}}],[\"内的一个整数\",{\"1\":{\"330\":1}}],[\"内层循环计算\",{\"1\":{\"89\":1}}],[\"内\",{\"1\":{\"11\":1,\"13\":1,\"27\":1,\"30\":1,\"32\":1,\"36\":1,\"38\":1,\"44\":1,\"52\":1,\"55\":1,\"59\":1,\"61\":1,\"69\":1,\"376\":1,\"385\":1,\"393\":1,\"413\":1,\"414\":1,\"415\":1}}],[\"03\",{\"1\":{\"806\":1}}],[\"0新增语法\",{\"1\":{\"767\":1}}],[\"0才修复\",{\"1\":{\"731\":1}}],[\"0时\",{\"1\":{\"636\":1}}],[\"0中删除\",{\"1\":{\"630\":1}}],[\"0中可以使用check约束了\",{\"1\":{\"619\":1}}],[\"0也不等于null\",{\"1\":{\"614\":1}}],[\"0版本以上\",{\"1\":{\"604\":1}}],[\"0版本以下\",{\"1\":{\"604\":1}}],[\"0版本支持的日期和时间\",{\"1\":{\"602\":1}}],[\"0填充\",{\"1\":{\"597\":1}}],[\"06\",{\"1\":{\"558\":1}}],[\"06t10\",{\"1\":{\"492\":4}}],[\"09\",{\"1\":{\"558\":1}}],[\"0返回0\",{\"1\":{\"548\":1}}],[\"046s\",{\"1\":{\"696\":1}}],[\"042s\",{\"1\":{\"696\":1}}],[\"04\",{\"1\":{\"492\":4,\"558\":1}}],[\"0表示普通记录\",{\"1\":{\"643\":1}}],[\"0表示快速失败\",{\"1\":{\"419\":1}}],[\"0表示直接\",{\"1\":{\"419\":1}}],[\"0表示线程数\",{\"1\":{\"419\":1}}],[\"0<=d<=30\",{\"1\":{\"600\":1}}],[\"0<\",{\"1\":{\"399\":1,\"441\":4,\"486\":3}}],[\"00\",{\"1\":{\"492\":4,\"701\":3,\"767\":2,\"771\":3,\"809\":1,\"832\":1}}],[\"002\",{\"1\":{\"299\":1}}],[\"0000条记录\",{\"1\":{\"648\":3}}],[\"0000\",{\"1\":{\"200\":1,\"557\":1,\"648\":2}}],[\"000002\",{\"1\":{\"809\":1}}],[\"000001\",{\"1\":{\"809\":3}}],[\"000000\",{\"1\":{\"696\":1}}],[\"00000\",{\"1\":{\"17\":4}}],[\"000137\",{\"1\":{\"809\":1}}],[\"0001\",{\"1\":{\"100\":3}}],[\"07\",{\"1\":{\"299\":1}}],[\"01\",{\"1\":{\"201\":1,\"215\":1,\"299\":1,\"557\":1,\"558\":1,\"745\":1,\"807\":1,\"809\":1,\"832\":1}}],[\"011\",{\"1\":{\"200\":1}}],[\"01背包的递推公式为\",{\"1\":{\"95\":1}}],[\"01背包中\",{\"1\":{\"95\":1}}],[\"01背包中的物品只能使用一次\",{\"1\":{\"93\":1}}],[\"01背包问题最重要的一个条件就是物品不能重复使用\",{\"1\":{\"95\":1}}],[\"01背包问题\",{\"1\":{\"95\":1}}],[\"01背包问题中起始就有过说明\",{\"1\":{\"93\":1}}],[\"01背包\",{\"0\":{\"91\":1},\"1\":{\"90\":2}}],[\"02\",{\"1\":{\"169\":2,\"809\":1}}],[\"0~target\",{\"1\":{\"256\":2}}],[\"0~4\",{\"1\":{\"124\":1}}],[\"0~j\",{\"1\":{\"111\":1,\"148\":1}}],[\"0~i\",{\"1\":{\"91\":1,\"111\":1,\"133\":1,\"148\":1}}],[\"0=0\",{\"1\":{\"87\":1}}],[\"0没有意义\",{\"1\":{\"87\":1}}],[\"0\",{\"1\":{\"11\":1,\"12\":3,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"18\":2,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":3,\"27\":1,\"28\":2,\"30\":1,\"33\":1,\"34\":3,\"35\":4,\"36\":1,\"37\":2,\"40\":1,\"41\":3,\"43\":7,\"44\":2,\"45\":1,\"47\":3,\"49\":3,\"50\":8,\"51\":1,\"52\":1,\"57\":2,\"59\":2,\"60\":3,\"61\":2,\"63\":3,\"65\":1,\"67\":4,\"69\":4,\"71\":3,\"72\":1,\"73\":4,\"74\":1,\"78\":6,\"79\":3,\"81\":2,\"82\":3,\"83\":3,\"85\":6,\"87\":2,\"89\":2,\"91\":6,\"92\":2,\"93\":4,\"95\":3,\"96\":2,\"97\":1,\"98\":2,\"99\":11,\"100\":8,\"101\":4,\"102\":3,\"103\":7,\"104\":1,\"105\":4,\"106\":3,\"107\":3,\"109\":4,\"111\":5,\"112\":1,\"113\":10,\"114\":1,\"115\":11,\"116\":1,\"117\":8,\"119\":4,\"120\":20,\"121\":3,\"122\":29,\"123\":8,\"124\":15,\"125\":4,\"126\":9,\"127\":3,\"128\":32,\"129\":2,\"130\":10,\"132\":3,\"133\":1,\"136\":11,\"137\":10,\"138\":3,\"139\":2,\"143\":5,\"145\":2,\"146\":2,\"148\":4,\"151\":1,\"152\":12,\"153\":2,\"155\":2,\"157\":4,\"163\":2,\"164\":1,\"165\":1,\"166\":1,\"168\":1,\"171\":4,\"173\":3,\"174\":4,\"175\":4,\"176\":21,\"177\":12,\"178\":8,\"179\":4,\"187\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"195\":2,\"197\":2,\"199\":1,\"200\":12,\"201\":21,\"202\":2,\"203\":2,\"204\":2,\"205\":1,\"207\":1,\"208\":3,\"209\":2,\"211\":3,\"213\":9,\"215\":9,\"217\":8,\"223\":11,\"224\":4,\"225\":26,\"226\":19,\"227\":91,\"228\":23,\"229\":28,\"230\":31,\"232\":25,\"233\":8,\"234\":15,\"240\":2,\"242\":2,\"245\":2,\"248\":1,\"251\":1,\"254\":1,\"256\":3,\"259\":2,\"269\":2,\"271\":2,\"273\":5,\"275\":4,\"276\":9,\"277\":10,\"278\":9,\"280\":3,\"281\":4,\"283\":2,\"284\":2,\"286\":4,\"289\":2,\"290\":12,\"292\":5,\"293\":4,\"294\":1,\"295\":1,\"296\":4,\"298\":4,\"299\":2,\"300\":16,\"302\":7,\"304\":14,\"305\":6,\"306\":4,\"308\":4,\"311\":3,\"312\":5,\"314\":1,\"315\":7,\"317\":3,\"326\":1,\"329\":1,\"330\":2,\"334\":4,\"335\":3,\"338\":6,\"343\":1,\"344\":4,\"345\":1,\"346\":3,\"348\":5,\"349\":4,\"350\":6,\"351\":6,\"352\":5,\"353\":2,\"354\":3,\"355\":6,\"356\":13,\"358\":5,\"359\":2,\"360\":2,\"361\":18,\"362\":18,\"364\":7,\"365\":1,\"366\":5,\"368\":3,\"369\":1,\"370\":1,\"371\":10,\"372\":14,\"376\":2,\"380\":1,\"385\":2,\"388\":1,\"389\":2,\"390\":12,\"393\":5,\"399\":5,\"401\":1,\"402\":1,\"416\":2,\"417\":1,\"419\":5,\"420\":2,\"421\":1,\"422\":3,\"428\":6,\"429\":10,\"431\":11,\"432\":8,\"434\":1,\"440\":1,\"441\":23,\"442\":6,\"454\":5,\"460\":13,\"486\":2,\"495\":6,\"503\":1,\"528\":1,\"550\":3,\"559\":7,\"583\":1,\"595\":3,\"597\":1,\"600\":1,\"602\":1,\"617\":1,\"631\":1,\"634\":2,\"657\":1,\"660\":1,\"666\":1,\"680\":1,\"696\":2,\"701\":1,\"710\":1,\"745\":1,\"767\":3,\"771\":5,\"806\":1,\"807\":1,\"809\":6,\"810\":1,\"822\":1,\"823\":1,\"832\":3}}],[\"751\",{\"1\":{\"529\":1}}],[\"7>6\",{\"1\":{\"334\":1}}],[\"7可以大致分为两类\",{\"1\":{\"277\":1}}],[\"78\",{\"1\":{\"205\":1}}],[\"77\",{\"1\":{\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"195\":1,\"659\":1}}],[\"718281828459045\",{\"1\":{\"550\":1}}],[\"718\",{\"1\":{\"139\":1}}],[\"7091\",{\"1\":{\"429\":2}}],[\"704\",{\"0\":{\"269\":1}}],[\"70\",{\"1\":{\"65\":2}}],[\"7\",{\"0\":{\"447\":1,\"612\":1,\"613\":1,\"614\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":2,\"655\":1,\"674\":1,\"707\":1,\"721\":1,\"728\":1},\"1\":{\"11\":2,\"13\":2,\"17\":2,\"19\":2,\"23\":2,\"25\":1,\"27\":1,\"30\":2,\"36\":1,\"40\":1,\"42\":2,\"44\":1,\"46\":3,\"48\":3,\"52\":2,\"53\":2,\"61\":2,\"63\":3,\"65\":4,\"67\":6,\"73\":2,\"74\":1,\"82\":1,\"84\":2,\"96\":3,\"104\":1,\"112\":1,\"116\":2,\"117\":3,\"119\":3,\"121\":4,\"123\":2,\"125\":1,\"129\":1,\"132\":11,\"134\":3,\"136\":1,\"137\":1,\"140\":2,\"142\":1,\"147\":1,\"170\":1,\"172\":1,\"174\":1,\"189\":2,\"193\":2,\"194\":7,\"196\":2,\"197\":1,\"206\":13,\"216\":12,\"233\":1,\"240\":2,\"273\":1,\"275\":4,\"276\":6,\"277\":6,\"281\":1,\"284\":1,\"287\":1,\"297\":4,\"303\":2,\"333\":9,\"334\":4,\"345\":10,\"346\":1,\"347\":1,\"355\":2,\"361\":8,\"362\":15,\"363\":3,\"364\":1,\"367\":1,\"376\":5,\"399\":1,\"412\":1,\"541\":1,\"555\":1,\"565\":1,\"618\":1,\"619\":1,\"630\":1,\"689\":1,\"690\":1,\"757\":1,\"824\":1,\"825\":1}}],[\"9之间宕机\",{\"1\":{\"757\":1}}],[\"9895\",{\"1\":{\"701\":2}}],[\"91\",{\"1\":{\"659\":1}}],[\"99\",{\"1\":{\"516\":1,\"835\":1}}],[\"9999\",{\"1\":{\"269\":2,\"477\":1}}],[\"999\",{\"1\":{\"82\":1,\"444\":1}}],[\"9527001\",{\"1\":{\"500\":1}}],[\"9527\",{\"1\":{\"489\":2,\"502\":1}}],[\"9528\",{\"1\":{\"422\":2}}],[\"9<\",{\"1\":{\"420\":1}}],[\"968\",{\"1\":{\"372\":1}}],[\"977\",{\"0\":{\"281\":1}}],[\"97~122\",{\"1\":{\"163\":1}}],[\"9000100\",{\"1\":{\"696\":1}}],[\"900001\",{\"1\":{\"696\":3}}],[\"900100\",{\"1\":{\"696\":1}}],[\"9001\",{\"1\":{\"402\":1,\"422\":1}}],[\"9092\",{\"1\":{\"429\":1}}],[\"90\",{\"1\":{\"207\":2,\"297\":1,\"525\":1}}],[\"92\",{\"1\":{\"169\":1,\"516\":1,\"835\":2}}],[\"9\",{\"0\":{\"641\":1,\"642\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"651\":1,\"652\":1,\"653\":1,\"654\":1,\"655\":1,\"656\":1,\"657\":2,\"709\":1,\"730\":1,\"731\":1,\"732\":1,\"733\":1},\"1\":{\"11\":2,\"13\":2,\"17\":2,\"19\":2,\"21\":2,\"25\":1,\"27\":1,\"30\":2,\"36\":1,\"40\":2,\"46\":3,\"48\":3,\"63\":3,\"71\":3,\"73\":1,\"82\":1,\"104\":1,\"108\":2,\"112\":3,\"116\":2,\"129\":3,\"132\":1,\"140\":1,\"166\":5,\"170\":1,\"174\":2,\"189\":6,\"190\":2,\"191\":2,\"192\":2,\"193\":2,\"201\":2,\"214\":1,\"216\":18,\"217\":6,\"240\":2,\"257\":2,\"269\":4,\"281\":5,\"287\":1,\"297\":4,\"303\":2,\"321\":1,\"330\":4,\"345\":3,\"367\":1,\"369\":1,\"370\":2,\"379\":6,\"390\":2,\"440\":2,\"485\":1,\"583\":1,\"618\":1,\"689\":1,\"757\":1}}],[\"9411\",{\"1\":{\"485\":1,\"486\":1}}],[\"94\",{\"1\":{\"0\":1}}],[\"输出这些相同\",{\"1\":{\"579\":1}}],[\"输出将是调用你函数后的整个链表\",{\"1\":{\"379\":1}}],[\"输出栈\",{\"1\":{\"323\":1}}],[\"输出的是单个值\",{\"1\":{\"561\":1}}],[\"输出的顺序和三元组的顺序并不重要\",{\"1\":{\"176\":1}}],[\"输出的结果顺序就是左右中了\",{\"1\":{\"8\":1}}],[\"输出结果中的每个元素一定是\",{\"1\":{\"166\":1}}],[\"输出\",{\"1\":{\"11\":3,\"13\":3,\"15\":3,\"17\":2,\"19\":2,\"21\":2,\"23\":2,\"25\":2,\"27\":2,\"30\":3,\"32\":2,\"34\":3,\"36\":3,\"38\":2,\"40\":2,\"42\":2,\"44\":3,\"46\":2,\"48\":2,\"50\":2,\"52\":2,\"53\":2,\"55\":2,\"57\":2,\"59\":2,\"61\":3,\"63\":2,\"65\":3,\"67\":3,\"69\":2,\"71\":2,\"73\":4,\"78\":3,\"80\":2,\"82\":2,\"84\":4,\"86\":2,\"88\":2,\"94\":2,\"96\":2,\"98\":2,\"100\":2,\"102\":3,\"104\":2,\"106\":3,\"108\":2,\"110\":3,\"112\":2,\"114\":3,\"116\":2,\"119\":2,\"121\":3,\"123\":4,\"125\":2,\"127\":2,\"129\":2,\"132\":3,\"134\":2,\"136\":2,\"138\":3,\"140\":3,\"142\":3,\"145\":2,\"147\":2,\"149\":2,\"151\":2,\"154\":2,\"156\":2,\"161\":2,\"164\":3,\"166\":2,\"169\":2,\"172\":3,\"174\":3,\"176\":3,\"178\":2,\"186\":2,\"189\":3,\"192\":3,\"194\":3,\"196\":2,\"198\":2,\"200\":3,\"202\":2,\"204\":2,\"206\":2,\"208\":3,\"210\":2,\"212\":2,\"214\":2,\"216\":1,\"223\":2,\"225\":2,\"227\":2,\"229\":2,\"231\":2,\"233\":2,\"240\":3,\"244\":3,\"246\":2,\"249\":2,\"252\":2,\"255\":2,\"257\":2,\"260\":2,\"266\":3,\"269\":2,\"273\":3,\"274\":2,\"275\":3,\"276\":3,\"277\":3,\"278\":2,\"281\":2,\"284\":3,\"287\":2,\"290\":4,\"294\":2,\"297\":2,\"300\":2,\"303\":2,\"306\":2,\"309\":2,\"312\":2,\"315\":2,\"321\":1,\"324\":3,\"327\":1,\"330\":3,\"333\":2,\"336\":2,\"343\":2,\"345\":3,\"347\":3,\"349\":2,\"351\":2,\"353\":3,\"355\":2,\"357\":2,\"359\":2,\"361\":2,\"363\":3,\"365\":3,\"367\":2,\"369\":3,\"371\":2,\"376\":3,\"379\":2,\"380\":3,\"383\":2,\"385\":3,\"388\":3,\"390\":3,\"393\":3}}],[\"输入的是一组数据的集合\",{\"1\":{\"561\":1}}],[\"输入的数独如上图所示\",{\"1\":{\"216\":1}}],[\"输入是一个根据逆波兰表示法表示的算术表达式\",{\"1\":{\"330\":1}}],[\"输入栈\",{\"1\":{\"323\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"249\":1}}],[\"输入字符串\",{\"1\":{\"244\":1}}],[\"输入数组\",{\"1\":{\"312\":1}}],[\"输入数组是以\",{\"1\":{\"278\":1}}],[\"输入数组是一个不重复的升序数组旋转\",{\"1\":{\"276\":1}}],[\"输入数独仅有一个解\",{\"1\":{\"216\":1}}],[\"输入数据\",{\"1\":{\"65\":1}}],[\"输入\",{\"1\":{\"11\":3,\"13\":3,\"15\":3,\"17\":2,\"19\":2,\"21\":2,\"23\":2,\"25\":2,\"27\":2,\"30\":3,\"32\":2,\"34\":3,\"36\":3,\"38\":2,\"40\":2,\"42\":2,\"44\":3,\"46\":2,\"48\":2,\"50\":2,\"52\":2,\"53\":2,\"55\":2,\"57\":2,\"59\":2,\"61\":3,\"63\":2,\"65\":3,\"67\":3,\"69\":2,\"71\":2,\"73\":4,\"78\":3,\"80\":2,\"82\":2,\"84\":4,\"86\":2,\"88\":2,\"94\":2,\"95\":1,\"96\":2,\"98\":2,\"100\":2,\"102\":3,\"104\":2,\"106\":3,\"108\":2,\"110\":3,\"112\":2,\"114\":3,\"116\":2,\"119\":2,\"121\":3,\"123\":4,\"125\":2,\"127\":2,\"129\":2,\"132\":3,\"134\":2,\"136\":2,\"138\":3,\"140\":3,\"142\":3,\"145\":2,\"147\":2,\"149\":2,\"151\":2,\"154\":2,\"156\":2,\"161\":2,\"164\":3,\"166\":2,\"169\":2,\"172\":3,\"174\":3,\"176\":3,\"178\":2,\"186\":2,\"189\":3,\"192\":3,\"194\":3,\"196\":2,\"197\":1,\"198\":2,\"200\":3,\"202\":2,\"204\":2,\"206\":2,\"208\":3,\"210\":2,\"212\":2,\"214\":2,\"216\":1,\"223\":2,\"225\":2,\"227\":2,\"229\":2,\"231\":2,\"233\":2,\"240\":3,\"244\":3,\"246\":2,\"249\":2,\"252\":2,\"255\":2,\"257\":2,\"260\":2,\"266\":3,\"269\":2,\"273\":3,\"274\":2,\"275\":3,\"276\":3,\"277\":3,\"278\":2,\"281\":2,\"284\":3,\"287\":2,\"290\":4,\"294\":2,\"297\":2,\"300\":2,\"303\":2,\"306\":2,\"309\":2,\"312\":2,\"315\":2,\"321\":1,\"324\":3,\"327\":1,\"330\":3,\"333\":2,\"336\":2,\"343\":2,\"345\":3,\"347\":3,\"349\":2,\"351\":2,\"353\":3,\"355\":2,\"357\":2,\"359\":2,\"361\":2,\"363\":3,\"365\":3,\"367\":2,\"369\":3,\"371\":2,\"376\":3,\"379\":2,\"380\":3,\"383\":2,\"385\":3,\"388\":3,\"390\":3,\"393\":3}}],[\"从单库备份中恢复单表\",{\"1\":{\"832\":1}}],[\"从全量备份中恢复单库\",{\"1\":{\"832\":1}}],[\"从机上复制主机的命令\",{\"1\":{\"826\":1}}],[\"从机器数据库ip\",{\"1\":{\"825\":1}}],[\"从机配置文件\",{\"0\":{\"824\":1}}],[\"从机\",{\"0\":{\"826\":1},\"1\":{\"821\":1,\"823\":1}}],[\"从库\",{\"1\":{\"820\":2}}],[\"从服务器唯一id\",{\"1\":{\"824\":1}}],[\"从服务器上采用\",{\"1\":{\"823\":1}}],[\"从服务器上的表如果有主键的话\",{\"1\":{\"823\":1}}],[\"从服务器版本可以比主服务器版本高\",{\"1\":{\"823\":1}}],[\"从服务器名\",{\"1\":{\"813\":2}}],[\"从服务器读取中继日志\",{\"1\":{\"813\":1}}],[\"从服务器为了与主服务器保持一致\",{\"1\":{\"813\":1}}],[\"从服务器通过读取中继日志的内容\",{\"1\":{\"805\":1}}],[\"从服务器用来存放主服务器二进制日志内容的一个中间文件\",{\"1\":{\"805\":1}}],[\"从名字中也可以看出这两种锁是两种看待数据并发的思维方式\",{\"1\":{\"780\":1}}],[\"从对待锁的态度来看锁的话\",{\"1\":{\"780\":1}}],[\"从一个表中读取了一个字段\",{\"1\":{\"746\":1}}],[\"从低到高分别是\",{\"1\":{\"736\":1}}],[\"从磁盘读取查询需要的\",{\"1\":{\"725\":1}}],[\"从磁盘取排序字段\",{\"1\":{\"725\":1}}],[\"从功能逻辑上说\",{\"1\":{\"686\":1}}],[\"从图中我们也可以看出来\",{\"1\":{\"680\":1}}],[\"从图中可以直观的看见\",{\"1\":{\"366\":1}}],[\"从图中可以看出来\",{\"1\":{\"645\":1,\"680\":1}}],[\"从图中可以看出\",{\"1\":{\"143\":1,\"648\":1}}],[\"从小到大的顺序排序而组成了\",{\"1\":{\"656\":1}}],[\"从你输入的\",{\"1\":{\"634\":1}}],[\"从以下四个方面考虑\",{\"1\":{\"612\":1}}],[\"从mysol的角度讲\",{\"1\":{\"657\":1}}],[\"从mysql5\",{\"1\":{\"602\":1}}],[\"从mysql\",{\"1\":{\"595\":1,\"602\":1,\"630\":1}}],[\"从map中找到根结点在中序遍历中的下表\",{\"1\":{\"47\":1}}],[\"从表名\",{\"1\":{\"618\":3}}],[\"从表名称\",{\"1\":{\"618\":1}}],[\"从表的字段\",{\"1\":{\"618\":1}}],[\"从表的某个字段\",{\"1\":{\"618\":1}}],[\"从表的添加和修改数据受约束\",{\"1\":{\"618\":1}}],[\"从表的外键列与主表被参照的列名字可以不相同\",{\"1\":{\"618\":1}}],[\"从表的外键列\",{\"1\":{\"618\":1}}],[\"从表\",{\"1\":{\"537\":2,\"618\":4}}],[\"从open到half\",{\"1\":{\"476\":1,\"477\":1,\"478\":1}}],[\"从官网得知\",{\"1\":{\"458\":1}}],[\"从而对服务器进行维护\",{\"1\":{\"805\":1}}],[\"从而导致恶性循环\",{\"1\":{\"786\":1}}],[\"从而影响效率\",{\"1\":{\"690\":1}}],[\"从而形成一个变长字段长度列表\",{\"1\":{\"678\":1}}],[\"从而在按照主键\",{\"1\":{\"645\":1}}],[\"从而在本地实现rpc远程服务调用技术\",{\"1\":{\"457\":1}}],[\"从而使\",{\"1\":{\"604\":1}}],[\"从而防止故障的传播\",{\"1\":{\"475\":1}}],[\"从而了解\",{\"1\":{\"470\":1}}],[\"从而达到系统的ha\",{\"1\":{\"457\":1}}],[\"从而达到全局的最优\",{\"1\":{\"344\":1}}],[\"从而达到全局最优\",{\"1\":{\"342\":1}}],[\"从流量路由\",{\"1\":{\"406\":1}}],[\"从流量控制\",{\"1\":{\"399\":1}}],[\"从各自的表头开始算起\",{\"1\":{\"390\":3}}],[\"从start开始反转\",{\"1\":{\"384\":1}}],[\"从大到小排列之后\",{\"1\":{\"362\":1}}],[\"从后往前遍历\",{\"1\":{\"360\":2,\"370\":1}}],[\"从前往后遍历\",{\"1\":{\"360\":2}}],[\"从前序与中序遍历序列构造二叉树\",{\"1\":{\"72\":1}}],[\"从前序遍历中找到根结点\",{\"1\":{\"49\":1}}],[\"从头到尾依次进行反转并且k\",{\"1\":{\"354\":1}}],[\"从头开始计算连续子数组的和\",{\"1\":{\"143\":1}}],[\"从数组第二个元素开始遍历\",{\"1\":{\"346\":1}}],[\"从队列的开头移除并返回元素\",{\"1\":{\"321\":1}}],[\"从题目可以得知\",{\"1\":{\"282\":2}}],[\"从题目中可以得知\",{\"1\":{\"213\":1}}],[\"从字符串开头算起\",{\"1\":{\"252\":1}}],[\"从某一个节点开始\",{\"1\":{\"222\":1}}],[\"从\",{\"1\":{\"209\":1,\"222\":1,\"277\":1,\"304\":1,\"355\":1,\"411\":1,\"421\":1}}],[\"从下向上遍历我们可以采用后序遍历\",{\"1\":{\"372\":1}}],[\"从下标为\",{\"1\":{\"351\":1}}],[\"从下标为1开始遍历\",{\"1\":{\"146\":1}}],[\"从下标\",{\"1\":{\"349\":1}}],[\"从下到上\",{\"1\":{\"155\":1,\"157\":1,\"262\":1,\"305\":1}}],[\"从上到下\",{\"1\":{\"305\":1}}],[\"从上到下~~\",{\"1\":{\"152\":1}}],[\"从上面例子中可以看出\",{\"1\":{\"295\":1}}],[\"从上面的动态图中可以看出\",{\"1\":{\"222\":1}}],[\"从上至下\",{\"1\":{\"12\":1}}],[\"从儿子节点返回的状态就可以看出\",{\"1\":{\"117\":1}}],[\"从递推关系式中可以看出\",{\"1\":{\"152\":1}}],[\"从递推关系式上看来\",{\"1\":{\"113\":1}}],[\"从递推公式中可以看出\",{\"1\":{\"137\":1}}],[\"从递推公式可以看出\",{\"1\":{\"85\":1}}],[\"从中选出任意两块石头\",{\"1\":{\"96\":1}}],[\"从中序遍历中找到根结点的位置\",{\"1\":{\"49\":1}}],[\"从中序与后序遍历序列构造二叉树\",{\"1\":{\"49\":1,\"72\":1}}],[\"从1开始\",{\"1\":{\"87\":1,\"111\":1}}],[\"从左上角开始\",{\"1\":{\"84\":1}}],[\"从左到右\",{\"1\":{\"152\":1,\"155\":3,\"157\":1,\"261\":1,\"262\":1}}],[\"从左到右依次访问二叉树的每一个结点\",{\"1\":{\"12\":1}}],[\"从左到右访问所有节点\",{\"1\":{\"11\":1}}],[\"从第一个区间开始\",{\"1\":{\"366\":1}}],[\"从第\",{\"1\":{\"355\":1}}],[\"从第二个气球开始\",{\"1\":{\"364\":1}}],[\"从第二天开始\",{\"1\":{\"122\":1}}],[\"从第二层我们仍然可以选择一次性爬俩步到达楼顶\",{\"1\":{\"83\":1}}],[\"从第0层走到\",{\"1\":{\"83\":1}}],[\"从最大值开始遍历\",{\"1\":{\"74\":1}}],[\"从右子树开始递归\",{\"1\":{\"70\":1}}],[\"从右往左\",{\"1\":{\"43\":1}}],[\"从root\",{\"1\":{\"70\":2}}],[\"从根结点开始访问\",{\"1\":{\"7\":1}}],[\"3nf\",{\"1\":{\"736\":1}}],[\"3表示最大记录\",{\"1\":{\"643\":1}}],[\"34\",{\"1\":{\"659\":1,\"771\":1}}],[\"34a开始就包含innodb存储引擎\",{\"1\":{\"636\":1}}],[\"343\",{\"1\":{\"548\":1}}],[\"38\",{\"1\":{\"492\":4}}],[\"3个5元\",{\"1\":{\"358\":1}}],[\"3个孩子的胃口值分别是\",{\"1\":{\"343\":1}}],[\"3步\",{\"1\":{\"350\":1}}],[\"3<5\",{\"1\":{\"334\":1}}],[\"3<\",{\"1\":{\"334\":1,\"441\":1,\"442\":1,\"468\":1}}],[\"3方格内\",{\"1\":{\"217\":2}}],[\"3方格内均不能有重复的数字\",{\"1\":{\"217\":1}}],[\"3x3\",{\"1\":{\"216\":1}}],[\"3b\",{\"1\":{\"173\":1}}],[\"375\",{\"1\":{\"444\":1}}],[\"37\",{\"1\":{\"170\":1}}],[\"3+3\",{\"1\":{\"117\":1,\"150\":1}}],[\"3+1+3\",{\"1\":{\"117\":1}}],[\"324\",{\"1\":{\"548\":2}}],[\"329\",{\"1\":{\"370\":1}}],[\"32\",{\"1\":{\"102\":1,\"104\":1,\"170\":1,\"330\":1,\"370\":1,\"428\":4}}],[\"312\",{\"1\":{\"200\":1}}],[\"31\",{\"1\":{\"96\":1,\"660\":1}}],[\"33<\",{\"1\":{\"442\":1}}],[\"3306\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"3377\",{\"1\":{\"403\":1}}],[\"332\",{\"1\":{\"369\":1,\"370\":1}}],[\"33\",{\"1\":{\"73\":1,\"96\":1,\"190\":1,\"191\":1,\"548\":1,\"689\":1}}],[\"35\",{\"0\":{\"273\":1},\"1\":{\"73\":1,\"200\":1,\"274\":1}}],[\"366\",{\"1\":{\"557\":1}}],[\"3600+分钟\",{\"1\":{\"556\":1}}],[\"36\",{\"1\":{\"73\":2,\"86\":2,\"428\":1}}],[\"300\",{\"1\":{\"102\":1,\"110\":1,\"212\":1,\"225\":1,\"680\":1}}],[\"3000\",{\"1\":{\"46\":3,\"48\":3,\"176\":1}}],[\"30\",{\"1\":{\"65\":2,\"73\":1,\"78\":1,\"91\":2,\"92\":1,\"96\":1,\"194\":1,\"196\":1,\"309\":1,\"388\":1,\"478\":1,\"495\":2,\"557\":1,\"618\":5,\"728\":1,\"800\":6}}],[\"3\",{\"0\":{\"10\":1,\"403\":1,\"404\":1,\"406\":1,\"407\":1,\"408\":2,\"409\":2,\"412\":2,\"416\":3,\"417\":2,\"418\":2,\"419\":2,\"420\":1,\"421\":1,\"430\":1,\"443\":1,\"451\":1,\"456\":1,\"457\":1,\"458\":1,\"459\":2,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"464\":2,\"465\":1,\"468\":1,\"478\":1,\"479\":1,\"490\":1,\"491\":1,\"494\":1,\"498\":1,\"501\":1,\"519\":1,\"520\":1,\"523\":1,\"525\":1,\"526\":2,\"532\":1,\"535\":1,\"546\":1,\"547\":1,\"552\":1,\"553\":2,\"556\":1,\"559\":1,\"560\":1,\"561\":1,\"564\":1,\"574\":1,\"579\":1,\"587\":1,\"597\":1,\"600\":1,\"606\":1,\"616\":1,\"631\":1,\"635\":1,\"636\":1,\"637\":1,\"643\":1,\"647\":1,\"652\":1,\"660\":1,\"670\":1,\"675\":1,\"676\":1,\"677\":1,\"688\":1,\"696\":1,\"703\":1,\"717\":1,\"724\":1,\"733\":1,\"742\":1,\"751\":1,\"757\":1,\"764\":1,\"779\":1,\"792\":1,\"793\":1,\"794\":1,\"798\":1,\"807\":1,\"811\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":2,\"825\":1,\"826\":1,\"827\":1},\"1\":{\"11\":3,\"12\":1,\"13\":3,\"15\":5,\"17\":6,\"19\":4,\"21\":5,\"23\":2,\"25\":2,\"27\":2,\"30\":5,\"32\":4,\"34\":2,\"36\":4,\"38\":1,\"39\":1,\"40\":1,\"42\":2,\"44\":4,\"46\":3,\"47\":1,\"48\":3,\"49\":1,\"50\":8,\"52\":3,\"53\":3,\"55\":2,\"57\":1,\"61\":5,\"63\":3,\"65\":5,\"67\":7,\"69\":3,\"71\":7,\"73\":5,\"74\":1,\"78\":6,\"80\":3,\"81\":2,\"84\":9,\"85\":1,\"86\":4,\"87\":2,\"88\":1,\"89\":2,\"91\":1,\"94\":1,\"98\":7,\"99\":1,\"100\":3,\"102\":3,\"104\":4,\"106\":3,\"108\":2,\"110\":1,\"112\":6,\"114\":10,\"115\":1,\"116\":7,\"117\":1,\"119\":2,\"121\":10,\"122\":4,\"123\":10,\"124\":9,\"125\":6,\"126\":1,\"127\":2,\"129\":5,\"132\":7,\"134\":4,\"136\":4,\"137\":2,\"138\":5,\"140\":3,\"142\":2,\"143\":1,\"147\":2,\"148\":4,\"151\":1,\"153\":4,\"154\":1,\"164\":1,\"172\":4,\"173\":5,\"174\":4,\"176\":3,\"179\":1,\"183\":2,\"186\":3,\"188\":1,\"189\":7,\"192\":1,\"193\":2,\"194\":9,\"200\":4,\"201\":2,\"202\":5,\"206\":1,\"208\":8,\"210\":7,\"212\":2,\"216\":12,\"217\":11,\"223\":12,\"225\":1,\"229\":1,\"233\":7,\"240\":6,\"244\":1,\"257\":11,\"266\":6,\"269\":2,\"273\":4,\"274\":1,\"275\":2,\"276\":4,\"277\":6,\"278\":8,\"281\":3,\"284\":4,\"287\":2,\"288\":1,\"290\":6,\"294\":2,\"295\":2,\"297\":4,\"300\":3,\"303\":4,\"306\":2,\"309\":2,\"312\":5,\"313\":1,\"315\":2,\"324\":1,\"330\":8,\"333\":26,\"334\":26,\"336\":1,\"343\":5,\"345\":8,\"346\":1,\"347\":2,\"349\":4,\"351\":3,\"353\":8,\"355\":20,\"357\":2,\"358\":1,\"361\":4,\"363\":6,\"365\":6,\"366\":7,\"369\":1,\"370\":2,\"376\":3,\"380\":3,\"383\":2,\"385\":3,\"388\":3,\"390\":9,\"393\":2,\"399\":1,\"401\":1,\"411\":3,\"412\":2,\"416\":3,\"419\":1,\"420\":1,\"422\":1,\"423\":1,\"424\":2,\"432\":1,\"441\":1,\"447\":1,\"452\":1,\"454\":1,\"459\":1,\"460\":1,\"463\":1,\"464\":1,\"467\":1,\"481\":1,\"486\":3,\"489\":1,\"495\":1,\"497\":1,\"520\":2,\"541\":1,\"557\":1,\"559\":1,\"565\":1,\"595\":1,\"597\":1,\"606\":1,\"617\":1,\"618\":1,\"642\":2,\"662\":1,\"672\":1,\"680\":3,\"686\":1,\"689\":2,\"690\":1,\"717\":1,\"729\":1,\"746\":1,\"757\":2,\"767\":2,\"771\":4,\"776\":1,\"777\":1,\"786\":1,\"797\":2,\"799\":1,\"800\":2,\"819\":1,\"820\":1,\"835\":1,\"836\":1}}],[\"其它都是slave从库\",{\"1\":{\"819\":1}}],[\"其它线程阻塞\",{\"1\":{\"781\":1}}],[\"其\",{\"1\":{\"724\":1}}],[\"其分配一块名叫`join\",{\"1\":{\"710\":1}}],[\"其上一页\",{\"1\":{\"668\":1}}],[\"其占用的存储空间越大\",{\"1\":{\"607\":1}}],[\"其所占用的存储空间也是不同的\",{\"1\":{\"607\":1}}],[\"其所有叶子节点都在同一层\",{\"1\":{\"23\":1}}],[\"其默认为decimal\",{\"1\":{\"600\":1}}],[\"其工资范围在\",{\"1\":{\"534\":1}}],[\"其比较的\",{\"1\":{\"528\":1}}],[\"其保存成\",{\"1\":{\"436\":1}}],[\"其尾部连接到第一个节点\",{\"1\":{\"393\":1}}],[\"其尾部连接到第二个节点\",{\"1\":{\"393\":1}}],[\"其他的线程走到这一步拿不到锁就等着\",{\"1\":{\"844\":1}}],[\"其他锁\",{\"0\":{\"784\":1}}],[\"其他事务既不可以继续获取该记录的s型记录锁\",{\"1\":{\"775\":1}}],[\"其他事务也可以继续获取该记录的s型记录锁\",{\"1\":{\"775\":1}}],[\"其他事务对这个表并发执行诸如select\",{\"1\":{\"770\":1}}],[\"其他事务对该表执行插入\",{\"1\":{\"746\":1}}],[\"其他事务是隔离的\",{\"1\":{\"741\":1}}],[\"其他非主键字段不依赖于其他非主键字段\",{\"1\":{\"737\":1}}],[\"其他优化策略\",{\"0\":{\"729\":1}}],[\"其他记录丢弃\",{\"1\":{\"726\":1}}],[\"其他信息\",{\"1\":{\"643\":1}}],[\"其他考虑varchar\",{\"1\":{\"604\":1}}],[\"其他地方都可以使用\",{\"1\":{\"579\":1}}],[\"其他情况则返回null\",{\"1\":{\"528\":1}}],[\"其他结点可以从上一结点获取\",{\"1\":{\"378\":1}}],[\"其他结点可以通过\",{\"1\":{\"377\":1}}],[\"其他满足题意但较小的子集包括\",{\"1\":{\"100\":1}}],[\"其次才是采用\",{\"1\":{\"818\":1}}],[\"其次\",{\"1\":{\"689\":1}}],[\"其次如果是有摄像头的状态\",{\"1\":{\"372\":1}}],[\"其次遍历对角线\",{\"1\":{\"304\":1}}],[\"其次我们需要一个额外的集合\",{\"1\":{\"295\":1}}],[\"其次定义双指针如何移动\",{\"1\":{\"279\":1}}],[\"其次计算\",{\"1\":{\"177\":1}}],[\"其余的小查询的select\",{\"1\":{\"703\":2}}],[\"其余用来存放\",{\"1\":{\"648\":1}}],[\"其余则为\",{\"1\":{\"575\":1}}],[\"其余字符保持原样\",{\"1\":{\"252\":1}}],[\"其余每层节点数都达到最大值\",{\"1\":{\"34\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"249\":1}}],[\"其值是否唯一和非空\",{\"1\":{\"686\":1}}],[\"其值等于一个整数自乘的积\",{\"1\":{\"108\":1}}],[\"其值等于另一个整数的平方\",{\"1\":{\"108\":1}}],[\"其值为\",{\"1\":{\"50\":1}}],[\"其总价值也一定为0\",{\"1\":{\"91\":1}}],[\"其数值等于两值之差的绝对值\",{\"1\":{\"57\":1}}],[\"其模板\",{\"1\":{\"29\":1}}],[\"其中t2试图增加表级锁\",{\"1\":{\"771\":1}}],[\"其中球员编号\",{\"1\":{\"736\":1}}],[\"其中的\",{\"1\":{\"704\":1}}],[\"其中除了最左边的那个小查询以外\",{\"1\":{\"703\":1}}],[\"其中最左边的那个查询的select\",{\"1\":{\"703\":1}}],[\"其中b+树最上边的那个节点也称为\",{\"1\":{\"648\":1}}],[\"其中e是一个常数\",{\"1\":{\"550\":1}}],[\"其中x的值用作种子值\",{\"1\":{\"548\":1}}],[\"其中管理者也在\",{\"1\":{\"536\":1}}],[\"其中使用最多的\",{\"1\":{\"508\":1}}],[\"其中无摄像头就是\",{\"1\":{\"372\":1}}],[\"其中points\",{\"1\":{\"363\":1}}],[\"其中一个是master主库\",{\"1\":{\"819\":1}}],[\"其中一个是\",{\"1\":{\"345\":1}}],[\"其中又只有\",{\"1\":{\"327\":1}}],[\"其中单个区间为\",{\"1\":{\"294\":1}}],[\"其中可能包含重复元素\",{\"1\":{\"204\":1}}],[\"其中第\",{\"1\":{\"127\":1,\"355\":1}}],[\"其中元素已经按\",{\"1\":{\"71\":1}}],[\"其中\",{\"1\":{\"46\":1,\"48\":1,\"78\":1,\"82\":1,\"96\":1,\"121\":1,\"125\":1,\"129\":1,\"145\":1,\"212\":1,\"229\":1,\"233\":1,\"336\":1,\"357\":1,\"361\":1,\"365\":1,\"383\":1,\"495\":1,\"510\":1,\"549\":6,\"552\":1,\"575\":1,\"600\":1,\"703\":1,\"746\":2,\"836\":1}}],[\"其中层序遍历使用\",{\"1\":{\"29\":1}}],[\"其中前序遍历和后序遍历会有一些联系\",{\"1\":{\"9\":1}}],[\"其实先写数据库\",{\"1\":{\"850\":1}}],[\"其实先遍历物品还是先遍历背包容量是无所谓的\",{\"1\":{\"93\":1}}],[\"其实这么说是有些不准确的\",{\"1\":{\"772\":1}}],[\"其实这道题难得是\",{\"1\":{\"97\":1}}],[\"其实有两种可选的解决方案\",{\"1\":{\"765\":1}}],[\"其实有了图之后就很清晰了\",{\"1\":{\"364\":1}}],[\"其实可以拓展替换为候选键\",{\"1\":{\"737\":1}}],[\"其实并没有user\",{\"1\":{\"670\":1}}],[\"其实存储引擎以前叫做表处理器\",{\"1\":{\"635\":1}}],[\"其实\",{\"1\":{\"421\":1,\"562\":1,\"853\":1}}],[\"其实很简单\",{\"1\":{\"416\":1}}],[\"其实都可以\",{\"1\":{\"364\":1}}],[\"其实我觉着这道题最不好理解的就是这句话\",{\"1\":{\"360\":1}}],[\"其实现方式通常由\",{\"1\":{\"337\":1}}],[\"其实也可以发现\",{\"1\":{\"304\":2}}],[\"其实在例题中\",{\"1\":{\"304\":1}}],[\"其实dfs就是回溯\",{\"1\":{\"222\":1}}],[\"其实和\",{\"1\":{\"201\":1,\"424\":1}}],[\"其实从图中可以看出\",{\"1\":{\"187\":1}}],[\"其实增加和删除是一样\",{\"1\":{\"152\":1,\"153\":1}}],[\"其实是很懵b的\",{\"1\":{\"304\":1}}],[\"其实是可以的\",{\"1\":{\"276\":1}}],[\"其实是已经使用过了\",{\"1\":{\"213\":2}}],[\"其实是有步操作\",{\"1\":{\"211\":1}}],[\"其实是有的\",{\"1\":{\"39\":1}}],[\"其实是没有结果的\",{\"1\":{\"99\":1}}],[\"其实就够了\",{\"1\":{\"342\":1}}],[\"其实就掉坑里了\",{\"1\":{\"207\":1}}],[\"其实就没必要再往后面遍历了\",{\"1\":{\"188\":1}}],[\"其实就和\",{\"1\":{\"97\":1}}],[\"其实就是id列的值\",{\"1\":{\"776\":1}}],[\"其实就是b+\",{\"1\":{\"653\":1}}],[\"其实就是有符号数取值范围大于等于\",{\"1\":{\"599\":1}}],[\"其实就是让气球尽可能的重叠\",{\"1\":{\"364\":1}}],[\"其实就是求出在这个数组中的波峰和波谷的数量总和\",{\"1\":{\"346\":1}}],[\"其实就是求俩个字符串公共子序列的长度\",{\"1\":{\"150\":1}}],[\"其实就是求俩个数组的最长公共子序列\",{\"1\":{\"141\":1}}],[\"其实就是双指针\",{\"1\":{\"285\":1}}],[\"其实就是一个递归标注的过程\",{\"1\":{\"226\":1}}],[\"其实就是两个字符串可以都可以删除了\",{\"1\":{\"153\":1}}],[\"其实就是对word2的删除\",{\"1\":{\"152\":1,\"153\":1}}],[\"其实就是从后到前累加节点的和\",{\"1\":{\"74\":1}}],[\"其实就是将每一层的左右孩子结点进行交换即可\",{\"1\":{\"31\":1}}],[\"其实就是将局部变量\",{\"1\":{\"5\":1}}],[\"其实要走四节楼梯才能到达楼顶\",{\"1\":{\"83\":1}}],[\"其实构建二叉树的步骤大家都明白\",{\"1\":{\"47\":1}}],[\"其实乍一看这个遍历顺序和\",{\"1\":{\"12\":1}}],[\"根据约束起的作用\",{\"1\":{\"613\":1}}],[\"根据约束的作用范围\",{\"1\":{\"613\":1}}],[\"根据约束数据列的限制\",{\"1\":{\"613\":1}}],[\"根据name修改成为\",{\"1\":{\"499\":1}}],[\"根据左右节点的情况\",{\"1\":{\"372\":1}}],[\"根据start进行降序\",{\"1\":{\"364\":1}}],[\"根据end进行升序\",{\"1\":{\"364\":1}}],[\"根据身高进行从大到小排序\",{\"1\":{\"362\":1}}],[\"根据k进行升序\",{\"1\":{\"362\":1}}],[\"根据绝对值大小\",{\"1\":{\"354\":1}}],[\"根据你的函数返回的长度\",{\"1\":{\"278\":1}}],[\"根据题目可以得知\",{\"1\":{\"386\":1}}],[\"根据题目可知\",{\"1\":{\"241\":1}}],[\"根据题意我们可以得知\",{\"1\":{\"372\":1}}],[\"根据题意可知\",{\"1\":{\"325\":1}}],[\"根据题意得知\",{\"1\":{\"276\":1}}],[\"根据题意确定\",{\"1\":{\"273\":1}}],[\"根据\",{\"1\":{\"143\":1,\"362\":3}}],[\"根据以上条件\",{\"1\":{\"62\":1}}],[\"根据结点值从map中获取根节点的下标\",{\"1\":{\"49\":1}}],[\"根据下图来说\",{\"1\":{\"33\":1}}],[\"根结点的值不相等\",{\"1\":{\"33\":1}}],[\"根结点值不相等\",{\"1\":{\"33\":1}}],[\"根\",{\"1\":{\"8\":1,\"52\":1,\"56\":2,\"58\":1}}],[\"根节点此时应该放一个摄像头\",{\"1\":{\"372\":1}}],[\"根节点右边为右子树\",{\"1\":{\"72\":1}}],[\"根节点为数组中间的一个\",{\"1\":{\"72\":1}}],[\"根节点为前序遍历中的第一个结点\",{\"1\":{\"49\":1}}],[\"根节点可能会根据给定的边界发生改变\",{\"1\":{\"69\":1}}],[\"根节点的值是\",{\"1\":{\"55\":1}}],[\"根节点到叶子节点\",{\"1\":{\"44\":1}}],[\"根节点root\",{\"1\":{\"15\":1,\"42\":1}}],[\"根节点\",{\"1\":{\"2\":1,\"58\":1,\"648\":1}}],[\"再删缓存的方案\",{\"1\":{\"850\":1}}],[\"再删缓存\",{\"0\":{\"849\":1},\"1\":{\"845\":1}}],[\"再删除主表\",{\"1\":{\"618\":1}}],[\"再写缓存\",{\"0\":{\"847\":1},\"1\":{\"845\":1}}],[\"再写数据库\",{\"0\":{\"846\":1,\"848\":1},\"1\":{\"845\":2}}],[\"再依次导出即可完成恢复\",{\"1\":{\"832\":1}}],[\"再使用需要重新配置主从\",{\"1\":{\"827\":1}}],[\"再把\",{\"1\":{\"810\":1}}],[\"再创建一个以\",{\"1\":{\"809\":1}}],[\"再创建从表\",{\"1\":{\"618\":1}}],[\"再谈隔离级别\",{\"0\":{\"793\":1}}],[\"再从\",{\"1\":{\"725\":1}}],[\"再\",{\"1\":{\"724\":1}}],[\"再去执行sql语句\",{\"1\":{\"718\":1}}],[\"再去考虑如何节省存储空间\",{\"1\":{\"598\":1}}],[\"再去考虑去重\",{\"1\":{\"177\":1}}],[\"再通过指定的\",{\"1\":{\"488\":1}}],[\"再通过远程调用账户服务来扣减用户账户里面的余额\",{\"1\":{\"430\":1}}],[\"再开启addpay支付微服务远程调用\",{\"1\":{\"464\":1}}],[\"再客户端的主启动类上增加\",{\"1\":{\"464\":1}}],[\"再客户端中暴露的接口清单中增加\",{\"1\":{\"463\":1}}],[\"再次读取\",{\"1\":{\"746\":1}}],[\"再次读取同一个字段\",{\"1\":{\"746\":1}}],[\"再次管理员身份运行\",{\"1\":{\"454\":1}}],[\"再次之前背包容量只有一个维度来决定\",{\"1\":{\"101\":1}}],[\"再消费端83使用openfeign远程调用\",{\"1\":{\"420\":1}}],[\"再循环的过程中\",{\"1\":{\"261\":1}}],[\"再来回顾一下回溯算法的代码模板\",{\"1\":{\"222\":1}}],[\"再来看一下这个图\",{\"1\":{\"435\":1}}],[\"再来看一下\",{\"1\":{\"205\":1}}],[\"再来看后序遍历\",{\"1\":{\"8\":1}}],[\"再换另一个方向继续遍历\",{\"1\":{\"222\":1}}],[\"再加上一个删除操作\",{\"1\":{\"152\":2,\"153\":2}}],[\"再选一个低的买入\",{\"1\":{\"122\":1}}],[\"再选个高的卖\",{\"1\":{\"122\":1}}],[\"再将锁释放掉\",{\"1\":{\"820\":1}}],[\"再将下一层的所有结点入队列\",{\"1\":{\"12\":1}}],[\"再将右孩子结点\",{\"1\":{\"6\":1}}],[\"右子节点>=本节点\",{\"1\":{\"659\":1}}],[\"右子树同理\",{\"1\":{\"117\":1}}],[\"右子树不为空\",{\"1\":{\"68\":2,\"70\":1}}],[\"右子树为空\",{\"1\":{\"62\":1,\"66\":1,\"68\":2,\"70\":1}}],[\"右子树上的所有结点的值都大于该结点的值\",{\"1\":{\"54\":1}}],[\"右子树搜索范围\",{\"1\":{\"51\":1}}],[\"右子树的二叉搜索树数量\",{\"1\":{\"89\":1}}],[\"右子树的起始范围不同\",{\"1\":{\"49\":1}}],[\"右子树的所有结点的值均大于根节点的值\",{\"1\":{\"0\":1}}],[\"右子树\",{\"1\":{\"2\":1,\"58\":1}}],[\"右子树均不为空\",{\"1\":{\"0\":1}}],[\"右侧填充空格以达到指定的长\",{\"1\":{\"604\":1}}],[\"右下图\",{\"1\":{\"541\":1}}],[\"右中图的查询结果\",{\"1\":{\"541\":1}}],[\"右中图\",{\"1\":{\"541\":1}}],[\"右上图\",{\"1\":{\"541\":1}}],[\"右表不符合条件的行都查询出来\",{\"1\":{\"539\":1}}],[\"右连接\",{\"1\":{\"539\":1}}],[\"右外连接\",{\"1\":{\"539\":2,\"541\":3}}],[\"右孩子有覆盖\",{\"1\":{\"372\":1}}],[\"右孩子获得的糖果数量都多\",{\"1\":{\"360\":1}}],[\"右孩子\",{\"1\":{\"360\":1,\"362\":1}}],[\"右孩子结点\",{\"1\":{\"58\":1}}],[\"右孩子结点入队\",{\"1\":{\"20\":1}}],[\"右列从上到下\",{\"1\":{\"288\":1}}],[\"右移\",{\"1\":{\"177\":2,\"179\":1}}],[\"右边的表称为\",{\"1\":{\"537\":1}}],[\"右边的和\",{\"1\":{\"291\":1}}],[\"右边孩子糖果数量\",{\"1\":{\"360\":2}}],[\"右边孩子的分数\",{\"1\":{\"360\":2}}],[\"右边部分的和定义为\",{\"1\":{\"290\":1}}],[\"右边部分是\",{\"1\":{\"50\":4}}],[\"右边所有的位置肯定不符合题意\",{\"1\":{\"273\":1}}],[\"右边界\",{\"1\":{\"234\":1}}],[\"右边\",{\"1\":{\"50\":1}}],[\"右边为右子树\",{\"1\":{\"47\":1}}],[\"右先出\",{\"1\":{\"8\":1}}],[\"右\",{\"1\":{\"7\":1,\"8\":1,\"52\":1,\"56\":2,\"58\":1,\"229\":1,\"360\":2,\"372\":1}}],[\"cc=a\",{\"1\":{\"729\":1}}],[\"cc\",{\"1\":{\"729\":4}}],[\"ccw\",{\"1\":{\"299\":1}}],[\"cpu\",{\"1\":{\"725\":1}}],[\"c3\",{\"1\":{\"643\":1,\"651\":1}}],[\"c2也执行读操作访问相同记录\",{\"1\":{\"767\":1}}],[\"c2和c3\",{\"1\":{\"643\":1}}],[\"c2\",{\"1\":{\"643\":1,\"651\":3,\"767\":1,\"771\":1}}],[\"csv\",{\"1\":{\"635\":1}}],[\"css\",{\"1\":{\"429\":1}}],[\"csp<\",{\"1\":{\"419\":1,\"423\":2}}],[\"cj\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"creators\",{\"1\":{\"809\":1}}],[\"creator\",{\"1\":{\"797\":1,\"798\":1,\"800\":1}}],[\"createtime\",{\"1\":{\"444\":1}}],[\"createcriteria\",{\"1\":{\"432\":1}}],[\"created`\",{\"1\":{\"431\":9}}],[\"create`\",{\"1\":{\"428\":3}}],[\"create\",{\"1\":{\"428\":5,\"431\":12,\"432\":6,\"435\":1,\"440\":1,\"444\":1,\"454\":1,\"517\":1,\"585\":3,\"586\":1,\"587\":3,\"595\":1,\"606\":1,\"607\":1,\"608\":1,\"612\":1,\"614\":1,\"615\":2,\"616\":2,\"617\":4,\"618\":8,\"619\":1,\"620\":1,\"643\":1,\"676\":2,\"687\":6,\"696\":2,\"704\":1,\"715\":3,\"718\":2,\"825\":1,\"831\":5,\"832\":1,\"836\":2}}],[\"criteria=wherecondition\",{\"1\":{\"432\":1}}],[\"criteria\",{\"1\":{\"432\":3}}],[\"cron\",{\"1\":{\"399\":2}}],[\"c请求来访问common资源就限流\",{\"1\":{\"410\":1}}],[\"c++\",{\"1\":{\"406\":1}}],[\"c+d\",{\"1\":{\"97\":1}}],[\"cmd\",{\"1\":{\"401\":1,\"449\":1,\"454\":1}}],[\"c1中开启事务\",{\"1\":{\"771\":1}}],[\"c1\",{\"1\":{\"390\":1,\"643\":3,\"651\":1}}],[\"c<\",{\"1\":{\"299\":2}}],[\"city\",{\"1\":{\"533\":1,\"538\":1,\"608\":3}}],[\"cidr\",{\"1\":{\"495\":3}}],[\"circuitbreaker将重新进入开启状态\",{\"1\":{\"477\":1}}],[\"circuitbreaker将允许最多permittednumberofcallsinhalfopenstate个请求通过\",{\"1\":{\"477\":1}}],[\"circuitbreaker将自动从开启状态过渡到半开状态\",{\"1\":{\"477\":1}}],[\"circuitbreaker\",{\"1\":{\"474\":1,\"475\":1,\"477\":9,\"478\":2}}],[\"circuit\",{\"1\":{\"474\":2,\"475\":1,\"477\":7}}],[\"ci\",{\"1\":{\"233\":2}}],[\"cf\",{\"1\":{\"192\":1}}],[\"centos\",{\"1\":{\"822\":1,\"824\":2}}],[\"ceiling\",{\"1\":{\"548\":1}}],[\"ceil\",{\"1\":{\"548\":1}}],[\"ce\",{\"1\":{\"192\":1}}],[\"cd\",{\"1\":{\"192\":1}}],[\"cbbd\",{\"1\":{\"156\":1,\"260\":1}}],[\"cas实现的\",{\"1\":{\"782\":1}}],[\"cas机制\",{\"1\":{\"782\":1}}],[\"cascade\",{\"1\":{\"618\":2}}],[\"cascade方式\",{\"1\":{\"618\":1}}],[\"casesensitive\",{\"1\":{\"442\":1}}],[\"case\",{\"0\":{\"575\":1},\"1\":{\"128\":1,\"332\":4,\"432\":1,\"443\":1,\"452\":1,\"559\":5,\"575\":1,\"832\":1}}],[\"capacity\",{\"1\":{\"481\":1}}],[\"calls\",{\"1\":{\"476\":2}}],[\"call\",{\"1\":{\"476\":2}}],[\"caching\",{\"1\":{\"474\":1}}],[\"cache里面的\",{\"1\":{\"810\":1}}],[\"cache足够大了\",{\"1\":{\"753\":1}}],[\"cache用来缓存一条select语句的执行结\",{\"1\":{\"630\":1}}],[\"caches\",{\"0\":{\"630\":1}}],[\"cache\",{\"1\":{\"474\":1,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"728\":1,\"753\":3,\"810\":3}}],[\"camel\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"ca\",{\"1\":{\"327\":2}}],[\"canal等中间件\",{\"1\":{\"853\":1}}],[\"canada\",{\"1\":{\"575\":2}}],[\"can`t\",{\"1\":{\"809\":1}}],[\"can\",{\"1\":{\"617\":1,\"618\":1}}],[\"candy\",{\"1\":{\"360\":1}}],[\"candies\",{\"1\":{\"360\":17}}],[\"candidates\",{\"1\":{\"194\":9,\"195\":14,\"196\":7,\"197\":13}}],[\"cancompletecircuit\",{\"1\":{\"356\":1}}],[\"canjump1\",{\"1\":{\"350\":1}}],[\"canjump\",{\"1\":{\"350\":2}}],[\"canpartition\",{\"1\":{\"95\":1}}],[\"car\",{\"1\":{\"161\":1}}],[\"catch\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"cat\",{\"1\":{\"110\":1,\"832\":2}}],[\"cats\",{\"1\":{\"110\":1}}],[\"catsandog\",{\"1\":{\"110\":1}}],[\"chksum\",{\"1\":{\"668\":2}}],[\"chen\",{\"1\":{\"676\":1}}],[\"checkpoint\",{\"1\":{\"749\":1}}],[\"checksum\",{\"1\":{\"668\":2}}],[\"check约束\",{\"0\":{\"619\":1}}],[\"check\",{\"1\":{\"613\":1,\"619\":2}}],[\"chessboard\",{\"1\":{\"215\":27}}],[\"chian\",{\"1\":{\"488\":1}}],[\"chinese\",{\"1\":{\"475\":1,\"479\":1,\"482\":1}}],[\"children\",{\"1\":{\"20\":7}}],[\"chain\",{\"1\":{\"444\":1,\"503\":3,\"504\":2}}],[\"change\",{\"1\":{\"103\":1,\"588\":1,\"826\":2}}],[\"char或varchar列都没有关系\",{\"1\":{\"604\":1}}],[\"char类型的字段会去除尾部的空格\",{\"1\":{\"604\":1}}],[\"char类型\",{\"1\":{\"604\":1}}],[\"char和varchar类型都可以存储比较短的字符串\",{\"1\":{\"604\":1}}],[\"characterencoding=utf8\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"character\",{\"1\":{\"326\":1,\"585\":2,\"586\":1}}],[\"charat\",{\"1\":{\"146\":10,\"148\":2,\"150\":2,\"152\":2,\"155\":2,\"157\":2,\"163\":2,\"199\":4,\"201\":8,\"245\":2,\"262\":2,\"326\":2,\"329\":2}}],[\"charset=ascii\",{\"1\":{\"676\":1}}],[\"charset=utf8mb4\",{\"1\":{\"440\":1}}],[\"charset=utf8\",{\"1\":{\"431\":3}}],[\"charset\",{\"1\":{\"428\":4,\"431\":3}}],[\"chars数组以及map集合\",{\"1\":{\"193\":1}}],[\"chars了\",{\"1\":{\"193\":1}}],[\"chars\",{\"1\":{\"165\":4,\"193\":10,\"254\":9,\"368\":5,\"370\":8}}],[\"char2\",{\"1\":{\"139\":5}}],[\"char1\",{\"1\":{\"139\":5}}],[\"char\",{\"0\":{\"604\":1},\"1\":{\"101\":1,\"139\":2,\"165\":1,\"193\":3,\"215\":9,\"217\":9,\"226\":4,\"232\":4,\"251\":2,\"254\":3,\"256\":3,\"326\":1,\"368\":1,\"370\":1,\"428\":1,\"552\":1,\"603\":1,\"604\":2,\"605\":1,\"643\":1,\"676\":1}}],[\"c\",{\"1\":{\"97\":8,\"101\":2,\"151\":1,\"154\":1,\"178\":4,\"192\":1,\"193\":2,\"233\":3,\"326\":7,\"391\":3,\"454\":2,\"607\":3,\"624\":1,\"699\":2,\"704\":1,\"725\":6,\"809\":2}}],[\"close\",{\"1\":{\"475\":1}}],[\"clone\",{\"1\":{\"440\":1}}],[\"cloudalibaba\",{\"1\":{\"402\":4,\"408\":1,\"422\":2}}],[\"cloud<\",{\"1\":{\"399\":1,\"402\":4,\"403\":2,\"408\":1,\"422\":4,\"423\":1,\"432\":5,\"441\":3,\"450\":2,\"452\":2,\"459\":1,\"463\":1,\"477\":1,\"489\":2}}],[\"cloud\",{\"1\":{\"399\":21,\"402\":5,\"403\":6,\"404\":2,\"406\":1,\"407\":1,\"408\":2,\"410\":1,\"419\":1,\"420\":3,\"421\":1,\"422\":10,\"423\":3,\"431\":1,\"432\":8,\"441\":8,\"442\":1,\"443\":3,\"447\":1,\"450\":4,\"451\":1,\"452\":8,\"453\":1,\"458\":2,\"459\":2,\"460\":1,\"462\":2,\"463\":1,\"464\":6,\"466\":3,\"468\":1,\"469\":1,\"470\":1,\"477\":7,\"478\":1,\"480\":2,\"481\":2,\"482\":2,\"488\":2,\"489\":6,\"491\":5,\"492\":5,\"493\":6,\"494\":2,\"495\":2,\"496\":2,\"497\":2,\"499\":6,\"500\":2,\"502\":4,\"504\":1}}],[\"cloud2024\",{\"1\":{\"398\":1,\"439\":1,\"440\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"cluster\",{\"1\":{\"429\":1}}],[\"clustermode\",{\"1\":{\"419\":3}}],[\"client5<\",{\"1\":{\"468\":1}}],[\"client=0\",{\"1\":{\"454\":1}}],[\"client3377\",{\"1\":{\"403\":1}}],[\"client\",{\"1\":{\"399\":1,\"403\":2,\"404\":2,\"431\":1,\"444\":1,\"466\":2,\"468\":1,\"624\":1}}],[\"climbstairs1\",{\"1\":{\"81\":1}}],[\"climbstairs\",{\"1\":{\"81\":1}}],[\"clear\",{\"1\":{\"60\":1}}],[\"classid是范围查询\",{\"1\":{\"718\":1}}],[\"classid>20\",{\"1\":{\"718\":1}}],[\"classid\",{\"1\":{\"715\":7,\"716\":2,\"718\":4,\"719\":1,\"728\":4}}],[\"classpath\",{\"1\":{\"429\":1,\"432\":1,\"443\":1,\"452\":1}}],[\"classtype\",{\"1\":{\"419\":2}}],[\"class<\",{\"1\":{\"416\":4}}],[\"class\",{\"1\":{\"2\":1,\"12\":2,\"16\":2,\"18\":2,\"20\":2,\"22\":2,\"24\":2,\"26\":2,\"28\":2,\"31\":4,\"35\":2,\"37\":2,\"39\":1,\"41\":2,\"49\":1,\"87\":1,\"89\":1,\"91\":1,\"95\":1,\"101\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":2,\"117\":2,\"120\":1,\"122\":1,\"124\":1,\"126\":1,\"128\":1,\"135\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":1,\"155\":1,\"157\":1,\"217\":1,\"224\":1,\"226\":1,\"230\":2,\"232\":2,\"234\":1,\"275\":1,\"277\":1,\"299\":1,\"305\":1,\"314\":1,\"323\":1,\"335\":1,\"344\":1,\"346\":1,\"368\":1,\"372\":1,\"384\":2,\"402\":4,\"403\":3,\"410\":1,\"416\":1,\"418\":2,\"420\":2,\"422\":1,\"423\":1,\"424\":1,\"429\":1,\"432\":8,\"433\":2,\"434\":2,\"443\":6,\"444\":1,\"445\":2,\"446\":7,\"452\":1,\"459\":1,\"463\":2,\"464\":3,\"467\":1,\"477\":2,\"489\":2,\"497\":3,\"503\":1,\"504\":3,\"696\":2,\"832\":4}}],[\"codd\",{\"1\":{\"737\":1}}],[\"code\",{\"0\":{\"890\":1},\"1\":{\"110\":2,\"422\":2,\"440\":1,\"444\":11}}],[\"course\",{\"1\":{\"689\":2}}],[\"count的时间复杂度可能会不同\",{\"1\":{\"729\":1}}],[\"count+=nums\",{\"1\":{\"348\":1}}],[\"count++\",{\"1\":{\"60\":2,\"289\":4,\"308\":1,\"364\":2,\"366\":1}}],[\"countsubstrings\",{\"1\":{\"155\":1}}],[\"count=10\",{\"1\":{\"435\":1}}],[\"count=1\",{\"1\":{\"60\":1}}],[\"count=\",{\"1\":{\"60\":1}}],[\"count\",{\"1\":{\"60\":6,\"268\":3,\"289\":2,\"308\":4,\"348\":8,\"364\":4,\"366\":2,\"419\":7,\"433\":7,\"476\":1,\"477\":2,\"562\":6,\"565\":1,\"579\":1,\"637\":1,\"689\":2,\"704\":2,\"710\":2,\"729\":3,\"809\":2}}],[\"countnodes\",{\"1\":{\"35\":4}}],[\"cot\",{\"1\":{\"549\":1}}],[\"cos\",{\"1\":{\"549\":1}}],[\"cost\",{\"0\":{\"696\":1},\"1\":{\"82\":6,\"83\":10,\"355\":6,\"356\":5,\"696\":5,\"704\":1}}],[\"cookie=username\",{\"1\":{\"493\":1}}],[\"cookie=mycookie\",{\"1\":{\"491\":1}}],[\"cookie\",{\"0\":{\"493\":1},\"1\":{\"491\":1,\"493\":1}}],[\"coordinator\",{\"1\":{\"426\":1}}],[\"core\",{\"1\":{\"475\":1,\"479\":1,\"481\":1,\"482\":1}}],[\"core<\",{\"1\":{\"442\":1}}],[\"cover\",{\"1\":{\"350\":14}}],[\"copyproperties\",{\"1\":{\"443\":1}}],[\"copy\",{\"1\":{\"429\":1}}],[\"copyright\",{\"1\":{\"429\":1}}],[\"copyvalueof\",{\"1\":{\"215\":1}}],[\"copyofrange\",{\"1\":{\"115\":2}}],[\"col4\",{\"1\":{\"676\":2}}],[\"col3\",{\"1\":{\"676\":2}}],[\"col2\",{\"1\":{\"676\":2}}],[\"col1\",{\"1\":{\"676\":2}}],[\"columnn\",{\"1\":{\"542\":4}}],[\"column2\",{\"1\":{\"542\":4}}],[\"column1\",{\"1\":{\"542\":4}}],[\"column\",{\"1\":{\"444\":2,\"509\":1,\"540\":2,\"563\":3,\"588\":4,\"606\":1,\"617\":3,\"771\":2}}],[\"column=\",{\"1\":{\"431\":3,\"442\":1}}],[\"collength\",{\"1\":{\"230\":8,\"232\":8,\"234\":8,\"302\":3}}],[\"collections\",{\"1\":{\"8\":1,\"14\":1,\"245\":1,\"423\":1,\"497\":1}}],[\"col表示列\",{\"1\":{\"217\":1}}],[\"col+1\",{\"1\":{\"215\":2}}],[\"col++\",{\"1\":{\"215\":2,\"217\":2}}],[\"col\",{\"1\":{\"215\":18,\"217\":19,\"302\":4,\"687\":5}}],[\"coinchange\",{\"1\":{\"107\":1}}],[\"coins\",{\"1\":{\"102\":7,\"103\":13,\"106\":6,\"107\":13}}],[\"commission\",{\"1\":{\"523\":3}}],[\"commit提交事务\",{\"1\":{\"753\":1}}],[\"committed和repeatable\",{\"1\":{\"765\":1}}],[\"committed\",{\"1\":{\"742\":2,\"746\":3,\"765\":1,\"797\":1,\"799\":1}}],[\"commit\",{\"1\":{\"517\":2,\"636\":1,\"753\":1,\"757\":1}}],[\"comment=\",{\"1\":{\"440\":1}}],[\"comment\",{\"1\":{\"428\":1,\"431\":38,\"440\":7}}],[\"commons\",{\"1\":{\"431\":1,\"432\":1,\"447\":1,\"450\":1,\"458\":1,\"464\":1,\"477\":1}}],[\"commons<\",{\"1\":{\"402\":1,\"432\":1}}],[\"common\",{\"1\":{\"410\":4,\"442\":1,\"464\":1,\"709\":1,\"710\":8}}],[\"come\",{\"1\":{\"410\":1,\"445\":1}}],[\"compact行格式会把可以为null的列统一管理起来\",{\"1\":{\"679\":1}}],[\"compact行格式\",{\"0\":{\"677\":1}}],[\"compact\",{\"1\":{\"643\":2}}],[\"compare\",{\"1\":{\"296\":1,\"364\":2,\"366\":1}}],[\"compareto\",{\"1\":{\"213\":1}}],[\"completablefuture<string>\",{\"1\":{\"481\":2}}],[\"completablefuture\",{\"1\":{\"481\":3}}],[\"compliance\",{\"1\":{\"429\":1}}],[\"compression\",{\"1\":{\"469\":1}}],[\"compiler\",{\"1\":{\"441\":4}}],[\"component\",{\"1\":{\"405\":1,\"418\":1,\"420\":1,\"497\":1,\"503\":1,\"504\":1}}],[\"comsumer\",{\"1\":{\"402\":2}}],[\"combinationsum2\",{\"1\":{\"197\":1}}],[\"combinationsum\",{\"1\":{\"195\":1}}],[\"combinationsum3\",{\"1\":{\"190\":1,\"191\":1}}],[\"combinationsum4\",{\"1\":{\"105\":1}}],[\"combine\",{\"1\":{\"187\":1}}],[\"com\",{\"1\":{\"73\":1,\"279\":1,\"282\":1,\"398\":1,\"401\":1,\"407\":1,\"422\":1,\"428\":1,\"429\":1,\"431\":4,\"432\":4,\"439\":1,\"440\":1,\"442\":2,\"443\":4,\"452\":3,\"462\":1,\"470\":1,\"475\":1,\"479\":1,\"482\":1,\"493\":2,\"502\":2,\"845\":1}}],[\"concurrency\",{\"1\":{\"790\":1}}],[\"concurrent\",{\"1\":{\"782\":1}}],[\"concat\",{\"1\":{\"552\":2}}],[\"conv\",{\"1\":{\"551\":1}}],[\"convertbst\",{\"1\":{\"74\":1}}],[\"condition\",{\"1\":{\"542\":1,\"563\":1,\"728\":1}}],[\"conditions\",{\"1\":{\"429\":1}}],[\"conn\",{\"1\":{\"429\":2}}],[\"connecttimeout\",{\"1\":{\"466\":1}}],[\"connectionurl=\",{\"1\":{\"442\":1}}],[\"connector\",{\"1\":{\"432\":1,\"441\":1,\"442\":2,\"443\":1}}],[\"connect\",{\"1\":{\"24\":1,\"466\":1}}],[\"conf\",{\"1\":{\"429\":1}}],[\"config>\",{\"1\":{\"497\":1}}],[\"config配置类\",{\"1\":{\"497\":1,\"504\":1}}],[\"configs\",{\"1\":{\"477\":1,\"478\":2,\"480\":2,\"481\":2,\"482\":1}}],[\"configured\",{\"1\":{\"429\":1}}],[\"configurationfile>\",{\"1\":{\"442\":1}}],[\"configuration>\",{\"1\":{\"442\":2}}],[\"configuration\",{\"1\":{\"402\":1,\"422\":1,\"423\":1,\"424\":1,\"432\":1,\"442\":1,\"443\":1,\"452\":1,\"467\":1}}],[\"configinfo\",{\"1\":{\"403\":2}}],[\"config<\",{\"1\":{\"403\":1,\"452\":1}}],[\"config\",{\"1\":{\"403\":9,\"404\":4,\"429\":2,\"431\":1,\"442\":2,\"452\":8,\"453\":1,\"454\":1,\"466\":2,\"497\":5,\"504\":4,\"836\":2}}],[\"consecutive\",{\"1\":{\"772\":1}}],[\"consistent\",{\"1\":{\"744\":1}}],[\"consistency\",{\"1\":{\"741\":1}}],[\"const\",{\"1\":{\"704\":3,\"725\":3,\"870\":1}}],[\"constraint\",{\"1\":{\"615\":1,\"616\":1,\"618\":3,\"687\":1}}],[\"constraints\",{\"1\":{\"613\":1,\"615\":1,\"618\":1}}],[\"constraints表名称\",{\"1\":{\"613\":1}}],[\"constructmaximumbinarytree\",{\"1\":{\"51\":1}}],[\"console\",{\"1\":{\"429\":1}}],[\"consumes\",{\"1\":{\"463\":1}}],[\"consumer\",{\"1\":{\"402\":2,\"446\":2,\"451\":1,\"459\":2,\"464\":3,\"477\":1}}],[\"consul中\",{\"1\":{\"459\":1}}],[\"consul\",{\"0\":{\"448\":1},\"1\":{\"400\":1,\"449\":5,\"450\":3,\"451\":2,\"452\":9,\"453\":2,\"454\":8,\"464\":2,\"489\":2},\"2\":{\"506\":1}}],[\"contenttype\",{\"1\":{\"422\":1,\"423\":1}}],[\"context>\",{\"1\":{\"442\":1}}],[\"context\",{\"1\":{\"410\":1,\"431\":3}}],[\"contest\",{\"1\":{\"246\":1}}],[\"controller\",{\"1\":{\"432\":1,\"446\":1,\"464\":2}}],[\"controller层的方法对service层调用不认为是同一个根链路\",{\"1\":{\"410\":1}}],[\"controlbehavior\",{\"1\":{\"419\":2}}],[\"control\",{\"1\":{\"405\":1,\"411\":2,\"517\":2,\"790\":1}}],[\"containsduplicate\",{\"1\":{\"268\":1}}],[\"containskey\",{\"1\":{\"175\":1,\"504\":1}}],[\"contains\",{\"1\":{\"111\":2,\"171\":2,\"207\":2,\"209\":2,\"392\":1,\"395\":1}}],[\"continue\",{\"1\":{\"33\":1,\"177\":1,\"179\":2,\"197\":1,\"199\":2,\"201\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":2,\"213\":2,\"217\":2,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"234\":1}}],[\"cnf或者my\",{\"1\":{\"806\":1,\"807\":1}}],[\"cnf\",{\"1\":{\"635\":1,\"809\":1,\"822\":1}}],[\"cn\",{\"1\":{\"12\":1,\"73\":1,\"426\":1,\"427\":1,\"491\":1}}],[\"curtime\",{\"1\":{\"554\":2}}],[\"curdate\",{\"1\":{\"554\":3}}],[\"curdistance\",{\"1\":{\"352\":7}}],[\"cur=null\",{\"1\":{\"382\":1}}],[\"cur和\",{\"1\":{\"115\":1}}],[\"currentthread\",{\"1\":{\"481\":2}}],[\"currenttimemillis\",{\"1\":{\"444\":1,\"503\":2}}],[\"current\",{\"1\":{\"440\":3,\"458\":1,\"554\":3,\"832\":2}}],[\"currindex\",{\"1\":{\"368\":4}}],[\"curr\",{\"1\":{\"70\":5}}],[\"cur\",{\"1\":{\"7\":7,\"8\":6,\"66\":11,\"68\":5,\"115\":5,\"372\":3,\"381\":2,\"382\":9}}],[\"只删除了一次\",{\"1\":{\"853\":1}}],[\"只删除指定部分的二进制日志文件\",{\"1\":{\"809\":1}}],[\"只用关心数据库操作即可\",{\"1\":{\"853\":1}}],[\"只用面额\",{\"1\":{\"102\":1}}],[\"只备份数据\",{\"1\":{\"831\":1}}],[\"只备份数据可以使用\",{\"1\":{\"831\":1}}],[\"只备份结构\",{\"1\":{\"831\":1}}],[\"只备份结构的话可以使用\",{\"1\":{\"831\":1}}],[\"只备份结构或只备份数据\",{\"1\":{\"831\":1}}],[\"只会写一次\",{\"1\":{\"823\":1}}],[\"只会存在一个有效答案\",{\"1\":{\"174\":1}}],[\"只把两个比较重要的属性拿了出来\",{\"1\":{\"763\":1}}],[\"只读状态\",{\"1\":{\"785\":1}}],[\"只读事务\",{\"1\":{\"744\":1}}],[\"只读应用或者以读为主的业务\",{\"1\":{\"637\":1}}],[\"只在当前数据库实例中唯一\",{\"1\":{\"731\":1}}],[\"只相当于有符号数取值范围的一半\",{\"1\":{\"599\":1}}],[\"只适用于数值类型的\",{\"1\":{\"562\":1}}],[\"只对执行完该语句之后产生的会话起作用\",{\"1\":{\"746\":1}}],[\"只对一行进行变换\",{\"1\":{\"545\":1}}],[\"只对应唯一的答案\",{\"1\":{\"240\":1}}],[\"只看到结果\",{\"1\":{\"467\":1}}],[\"只比较\",{\"1\":{\"360\":1}}],[\"只出现一次\",{\"1\":{\"312\":1}}],[\"只需按照生成的\",{\"1\":{\"635\":1}}],[\"只需创建一个接口并在接口上添加\",{\"1\":{\"462\":1}}],[\"只需在循环结束后将矩阵中间的位置设置为最大值\",{\"1\":{\"288\":1}}],[\"只需要按照下边的步骤判断记录的某个版本是否可见\",{\"1\":{\"798\":1}}],[\"只需要记录一下被修改数据的偏移量即可\",{\"1\":{\"749\":1}}],[\"只需要使用一个\",{\"1\":{\"426\":1}}],[\"只需要自定义限流返回信息即可\",{\"1\":{\"422\":1}}],[\"只需要移动\",{\"1\":{\"313\":1}}],[\"只需要移动fast指针\",{\"1\":{\"280\":1}}],[\"只需要每次移动\",{\"1\":{\"253\":1}}],[\"只需要在\",{\"1\":{\"175\":1}}],[\"只需要判断队首元素的下标是否大于\",{\"1\":{\"334\":1}}],[\"只需要判断\",{\"1\":{\"155\":1}}],[\"只需要将容量正序遍历即可\",{\"1\":{\"93\":1}}],[\"只需要将每一层\",{\"1\":{\"24\":1}}],[\"只需要将每层的最后一个放到res即可\",{\"1\":{\"16\":1}}],[\"只使用数字1到9\",{\"1\":{\"189\":1}}],[\"只涉及删除操作\",{\"1\":{\"153\":1}}],[\"只包含时\",{\"1\":{\"554\":1}}],[\"只包含年\",{\"1\":{\"554\":1}}],[\"只包含小写英文字母\",{\"1\":{\"149\":1}}],[\"只包含正整数\",{\"1\":{\"94\":1}}],[\"只收集每天的正利润\",{\"1\":{\"122\":1}}],[\"只与\",{\"1\":{\"115\":1}}],[\"只有在对表中的记录做改动时\",{\"1\":{\"797\":1}}],[\"只有在査询条件中使用了字段id时该索引才会被使用\",{\"1\":{\"686\":1}}],[\"只有字符串类型的字段才能指定索引长度\",{\"1\":{\"687\":1}}],[\"只有当你处理特别巨大的整数时才会用到\",{\"1\":{\"598\":1}}],[\"只有当dp\",{\"1\":{\"107\":1}}],[\"只有个别的配置项不同\",{\"1\":{\"452\":1}}],[\"只有俩个或者俩个以上的结点我们才可以交换\",{\"1\":{\"386\":1}}],[\"只有俩种可能\",{\"1\":{\"113\":1}}],[\"只有都表示出来\",{\"1\":{\"381\":1}}],[\"只有一条记录\",{\"1\":{\"704\":1}}],[\"只有一个\",{\"1\":{\"820\":1}}],[\"只有一个事务能执行写入\",{\"1\":{\"767\":1}}],[\"只有一个结点时\",{\"1\":{\"387\":1}}],[\"只有一个或者没有结点的时候\",{\"1\":{\"386\":1}}],[\"只有一个元素\",{\"1\":{\"50\":2}}],[\"只有一部分组成\",{\"1\":{\"148\":1,\"153\":1}}],[\"只能有一个唯一的服务器id\",{\"1\":{\"820\":1}}],[\"只能看到这个时间点之前事务提交更新的结果\",{\"1\":{\"801\":1}}],[\"只能读取其他事物提交过后的数据\",{\"1\":{\"799\":1}}],[\"只能用于二级索引\",{\"1\":{\"728\":1}}],[\"只能用一次\",{\"1\":{\"212\":1}}],[\"只能在内存中\",{\"1\":{\"710\":1}}],[\"只能在买入之后一次卖入股票\",{\"1\":{\"120\":1}}],[\"只能手动删除\",{\"1\":{\"618\":1}}],[\"只能某个列单独限定非空\",{\"1\":{\"614\":1}}],[\"只能作用在一个列上\",{\"1\":{\"613\":1}}],[\"只能存6个\",{\"1\":{\"604\":1}}],[\"只能够使用完全展开的配置方式\",{\"1\":{\"497\":1,\"504\":1}}],[\"只能进行节点交换\",{\"1\":{\"385\":1}}],[\"只能\",{\"1\":{\"321\":1}}],[\"只能将后边的元素往前移覆盖\",{\"1\":{\"279\":1}}],[\"只能买一次\",{\"1\":{\"122\":1}}],[\"只能买入一次股票\",{\"1\":{\"120\":1}}],[\"只能持有\",{\"1\":{\"121\":1}}],[\"只能去一个\",{\"1\":{\"115\":1}}],[\"只能跨1步或者2步\",{\"1\":{\"81\":1}}],[\"只能通过\",{\"1\":{\"81\":1}}],[\"只能使用\",{\"1\":{\"12\":1}}],[\"只可能出现在相邻的结点中\",{\"1\":{\"58\":1}}],[\"只不过在索引的叶子节点中存储的不是完整的用户记录\",{\"1\":{\"654\":1}}],[\"只不过在每次\",{\"1\":{\"228\":1}}],[\"只不过上面是判断是否是回文串\",{\"1\":{\"201\":1}}],[\"只不过最后一个元素需要特殊处理\",{\"1\":{\"115\":1}}],[\"只不过是找根结点和递归的边界有所不同\",{\"1\":{\"72\":1}}],[\"只不过不再是从前序或者后序找根结点\",{\"1\":{\"51\":1}}],[\"只不过该题回溯的是\",{\"1\":{\"45\":1}}],[\"只要是双写\",{\"1\":{\"843\":1}}],[\"只要是标准的栈操作即可\",{\"1\":{\"321\":1}}],[\"只要使用缓存\",{\"1\":{\"843\":1}}],[\"只要保证该索引只对应一个字段即可\",{\"1\":{\"686\":1}}],[\"只要保障前一个价值计算值正确即可\",{\"1\":{\"93\":1}}],[\"只要涉及到多张表进行连接的\",{\"1\":{\"535\":1}}],[\"只要发送请求就会执行\",{\"1\":{\"504\":1}}],[\"只要nacos里面的配置不删除\",{\"1\":{\"419\":1}}],[\"只要区间的start\",{\"1\":{\"366\":1}}],[\"只要将\",{\"1\":{\"366\":1}}],[\"只要将边界的陆地变为海洋即可\",{\"1\":{\"230\":1}}],[\"只要气球的尾端\",{\"1\":{\"364\":1}}],[\"只要不超过数据存储范围即可\",{\"1\":{\"597\":1}}],[\"只要不相等就将糖果数量+1\",{\"1\":{\"360\":1}}],[\"只要不满足就返回false\",{\"1\":{\"33\":1}}],[\"只要想清楚\",{\"1\":{\"342\":1}}],[\"只要弄清楚什么是逆波兰表达式即可\",{\"1\":{\"331\":1}}],[\"只要弄清楚结束条件即可\",{\"1\":{\"1\":1}}],[\"只要分别以矩阵左上角\",{\"1\":{\"299\":1}}],[\"只要某个元素大于target值\",{\"1\":{\"273\":1}}],[\"只要有递归就会有回溯\",{\"1\":{\"218\":1}}],[\"只要搞到nums\",{\"1\":{\"99\":1}}],[\"只要树在插入后仍保持为二叉搜索树即可\",{\"1\":{\"65\":1}}],[\"只要满足以上几种情况\",{\"1\":{\"33\":1}}],[\"只是刷入到\",{\"1\":{\"753\":1}}],[\"只是实现上各自有所不同而已\",{\"1\":{\"731\":1}}],[\"只是用于提高查询效率\",{\"1\":{\"686\":1}}],[\"只是无须再用字符\",{\"1\":{\"597\":1}}],[\"只是在递归的过程中\",{\"1\":{\"47\":1}}],[\"只是为了能够一次性将一层的结点出队\",{\"1\":{\"12\":1}}],[\"只是为了循环\",{\"1\":{\"12\":1}}],[\"只是为了遍历一棵树\",{\"1\":{\"12\":1}}],[\"只是顺序改变了\",{\"1\":{\"7\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"858\":1}}],[\"在页中\",{\"1\":{\"673\":1}}],[\"在业务接口中写数据库之后\",{\"1\":{\"853\":1}}],[\"在业务数据更新之后\",{\"1\":{\"436\":1}}],[\"在业务数据被更新前\",{\"1\":{\"436\":1}}],[\"在定时任务中\",{\"1\":{\"851\":1}}],[\"在请求c更新缓存之后再去删除\",{\"1\":{\"848\":1}}],[\"在请求c更新缓存之后\",{\"1\":{\"848\":1}}],[\"在请求b更新完之后\",{\"1\":{\"847\":1}}],[\"在写数据库时出现卡顿\",{\"1\":{\"848\":1}}],[\"在写入缓存是出现卡顿\",{\"1\":{\"847\":1}}],[\"在写这道题之前\",{\"1\":{\"72\":1}}],[\"在图形检索\",{\"1\":{\"835\":1}}],[\"在正式开始讲连接表的种类时\",{\"1\":{\"835\":1}}],[\"在mixed模式下\",{\"1\":{\"823\":1}}],[\"在mysql数据库中\",{\"1\":{\"807\":1}}],[\"在mysql\",{\"1\":{\"677\":1}}],[\"在mysql中\",{\"1\":{\"605\":1,\"695\":1,\"724\":1,\"728\":1}}],[\"在mysql中使用\",{\"1\":{\"521\":1}}],[\"在开始查询之前\",{\"1\":{\"800\":1}}],[\"在开启状态下\",{\"1\":{\"475\":1}}],[\"在隔离级别为\",{\"1\":{\"799\":1}}],[\"在java中\",{\"1\":{\"782\":1}}],[\"在java中提供了很多对字符串操作的api\",{\"1\":{\"245\":1}}],[\"在程序上\",{\"1\":{\"782\":1}}],[\"在insert操作时产生\",{\"1\":{\"778\":1}}],[\"在锁模式处于连续模式下时\",{\"1\":{\"772\":1}}],[\"在为数据行加共享\",{\"1\":{\"771\":1}}],[\"在c2中开启事务\",{\"1\":{\"771\":1}}],[\"在c1中开始事务并为读操作增加\",{\"1\":{\"767\":1}}],[\"在compact行格式中\",{\"1\":{\"678\":1}}],[\"在更改完之前不允许别的事务进行操作\",{\"1\":{\"765\":1}}],[\"在更新索引的时候也会造成负担\",{\"1\":{\"690\":1}}],[\"在生成readview之前未提交的事务或者之后才开启的事务所做的更改是看不到的\",{\"1\":{\"765\":1}}],[\"在生产环境中\",{\"1\":{\"699\":1}}],[\"在占着锁\",{\"1\":{\"763\":1}}],[\"在1\",{\"1\":{\"757\":1}}],[\"在1s\",{\"1\":{\"414\":1,\"415\":1}}],[\"在事务前面\",{\"1\":{\"786\":1}}],[\"在事务执行前本来是没有锁的\",{\"1\":{\"763\":1}}],[\"在事务中\",{\"1\":{\"754\":1}}],[\"在事务提交后即使系统发生了崩\",{\"1\":{\"749\":1}}],[\"在会话范围影响\",{\"1\":{\"746\":1}}],[\"在全局范围影响\",{\"1\":{\"746\":1}}],[\"在该隔离级别\",{\"1\":{\"746\":1}}],[\"在该表中\",{\"1\":{\"746\":1}}],[\"在了提交的状态\",{\"1\":{\"742\":1}}],[\"在满足第一范式的基础上\",{\"1\":{\"737\":1}}],[\"在满足以下约束条件下\",{\"1\":{\"127\":1}}],[\"在关系型数据库中\",{\"1\":{\"736\":1}}],[\"在当今的互联网环境中\",{\"1\":{\"733\":1}}],[\"在海量并发的系统中\",{\"1\":{\"731\":1}}],[\"在解析的过程中\",{\"1\":{\"729\":1}}],[\"在解析器中对\",{\"1\":{\"628\":1,\"634\":1}}],[\"在表查询中\",{\"1\":{\"729\":1}}],[\"在表中的字段id\",{\"1\":{\"686\":1}}],[\"在表中的单个字段上创建索引\",{\"1\":{\"686\":1}}],[\"在不同的存储引擎中\",{\"1\":{\"729\":1}}],[\"在不触动警报的情况下\",{\"1\":{\"116\":1}}],[\"在不触动警报装置的情况下\",{\"1\":{\"114\":1}}],[\"在建立冗余索引来支持覆盖索引时就需要权衡考虑了\",{\"1\":{\"727\":1}}],[\"在索引上完成排序分页操作\",{\"1\":{\"726\":1}}],[\"在buffer进行排序\",{\"1\":{\"725\":1}}],[\"在bootstrap\",{\"1\":{\"404\":2}}],[\"在执行更新语句过程\",{\"1\":{\"812\":1}}],[\"在执行\",{\"1\":{\"710\":1}}],[\"在执行许多包含`distinct`\",{\"1\":{\"710\":1}}],[\"在执行之前需要判断该用户是否\",{\"1\":{\"634\":1}}],[\"在许多查询的执行过程中\",{\"1\":{\"710\":1}}],[\"在连接查询执行过程中\",{\"1\":{\"710\":1}}],[\"在连接查询时\",{\"1\":{\"704\":1}}],[\"在`extra`列将会提示该额外信息\",{\"1\":{\"710\":1}}],[\"在`extra`列中也会提示上述额外信息\",{\"1\":{\"710\":1}}],[\"在`extra`列中会提示上述额外信息\",{\"1\":{\"710\":1}}],[\"在包含union或者union\",{\"1\":{\"703\":1}}],[\"在学生表的\",{\"1\":{\"690\":1}}],[\"在where中使用不到的字段\",{\"1\":{\"690\":1}}],[\"在多个字段都要创建索引的情况下\",{\"1\":{\"689\":1}}],[\"在多表查询时\",{\"1\":{\"533\":1}}],[\"在记录行数一定的情况下\",{\"1\":{\"689\":1}}],[\"在记录的c2列相同的情况下\",{\"1\":{\"652\":1}}],[\"在使用\",{\"1\":{\"702\":1}}],[\"在使用varchar作为索引时\",{\"1\":{\"689\":1}}],[\"在使用分组和排序子句进行数据查询时\",{\"1\":{\"642\":1}}],[\"在唯一索引的基础上增加了不为空的约束\",{\"1\":{\"686\":1}}],[\"在比较两个很长的字节串之前\",{\"1\":{\"668\":1}}],[\"在范围查询上\",{\"1\":{\"662\":1}}],[\"在拉链法中\",{\"1\":{\"658\":1}}],[\"在输出中通常会有不同的结果\",{\"1\":{\"658\":1}}],[\"在同一层次中的页也是根据页中目录项记录的主键\",{\"1\":{\"650\":1}}],[\"在实现数据的\",{\"1\":{\"642\":1}}],[\"在实际的项目中\",{\"1\":{\"603\":1}}],[\"在实际的开发中应用不多\",{\"1\":{\"513\":1}}],[\"在实际工作中\",{\"1\":{\"598\":1,\"818\":1}}],[\"在查询优化器中\",{\"1\":{\"634\":1}}],[\"在优化器中会确定\",{\"1\":{\"634\":1}}],[\"在优化角度来说\",{\"1\":{\"533\":1}}],[\"在文件系统之下\",{\"1\":{\"632\":1}}],[\"在的\",{\"1\":{\"632\":1}}],[\"在sql命令传递到解析器的时候会被解析器验证和解析\",{\"1\":{\"628\":1}}],[\"在select列表中所有未包含在组函数中的列都应该包含在\",{\"1\":{\"563\":1}}],[\"在sentinel的授权规则中\",{\"1\":{\"418\":1}}],[\"在插入数据时\",{\"1\":{\"620\":1}}],[\"在插入删除时自动保持顺序\",{\"1\":{\"339\":1}}],[\"在可视化工具sqlyog中可能显示空白\",{\"1\":{\"618\":1}}],[\"在父表上update\",{\"1\":{\"618\":2}}],[\"在创建表的定义语句\",{\"1\":{\"687\":1}}],[\"在创建唯一性索引时\",{\"1\":{\"686\":1}}],[\"在创建唯一约束的时候\",{\"1\":{\"615\":1}}],[\"在创建普通索引时\",{\"1\":{\"686\":1}}],[\"在创建外键约束时\",{\"1\":{\"618\":1}}],[\"在部门表中要能找到这个部门\",{\"1\":{\"612\":1}}],[\"在向text类型的字段保存和查询数据时\",{\"1\":{\"605\":1}}],[\"在编程中\",{\"1\":{\"599\":1}}],[\"在评估用哪种整数类型的时候\",{\"1\":{\"598\":1}}],[\"在磁盘上都\",{\"1\":{\"597\":1}}],[\"在命名字段并为其指定数据类型的时候一定要保证一致性\",{\"1\":{\"583\":1}}],[\"在子查询中如果用到聚合函数作为列\",{\"1\":{\"579\":1}}],[\"在主机mysql里执行授权主从复制的命令\",{\"1\":{\"825\":1}}],[\"在主从复制过程中\",{\"1\":{\"820\":1}}],[\"在主查询之前一次执行完成\",{\"1\":{\"569\":1}}],[\"在主启动类上\",{\"1\":{\"453\":1}}],[\"在经历过where之后可能就剩非常少的数据\",{\"1\":{\"565\":1}}],[\"在处理过程中\",{\"1\":{\"542\":1}}],[\"在右外连接的基础上\",{\"1\":{\"541\":1}}],[\"在右边\",{\"1\":{\"277\":1}}],[\"在左外连接的基础上\",{\"1\":{\"541\":1}}],[\"在左边\",{\"1\":{\"277\":1}}],[\"在说慢外连接的前提\",{\"1\":{\"539\":1}}],[\"在从表上建立外键\",{\"1\":{\"618\":1}}],[\"在从表\",{\"1\":{\"513\":1}}],[\"在数据表的场景中\",{\"1\":{\"771\":1}}],[\"在数据库中\",{\"1\":{\"666\":1,\"760\":1}}],[\"在数据库中一般采用\",{\"1\":{\"658\":1}}],[\"在数据库中文档作为处理信息的基本单位\",{\"1\":{\"510\":1}}],[\"在数组中是最大的\",{\"1\":{\"273\":1}}],[\"在数组中找到目标值\",{\"1\":{\"273\":1}}],[\"在进行下行请求之前\",{\"1\":{\"502\":1}}],[\"在进行二叉树遍历时\",{\"1\":{\"20\":1}}],[\"在控制台可以看见自定义的断言工厂\",{\"1\":{\"497\":1}}],[\"在控制器类加入\",{\"1\":{\"403\":1}}],[\"在本案例中也就是\",{\"1\":{\"497\":1}}],[\"在本案例中就是在订单服务中增加\",{\"1\":{\"435\":1}}],[\"在指定时间之前\",{\"1\":{\"492\":1}}],[\"在指定日期之后\",{\"1\":{\"492\":1}}],[\"在大规模分布式与微服务集群下\",{\"1\":{\"483\":6}}],[\"在分布式系统中\",{\"1\":{\"731\":1}}],[\"在分布式系统中提供追踪解决方案并且兼容支持了zipkin\",{\"1\":{\"484\":1}}],[\"在分布式与微服务场景下\",{\"1\":{\"483\":1}}],[\"在分析该题目时\",{\"1\":{\"273\":1}}],[\"在微服务框架中\",{\"1\":{\"483\":1}}],[\"在微服务调用链路的上下文中传播\",{\"1\":{\"426\":1}}],[\"在调用方的controller使用注解\",{\"1\":{\"480\":1,\"481\":1}}],[\"在调用其他微服务接口时候\",{\"1\":{\"457\":1}}],[\"在配置文件中可以配置哪种等级的会员可以访问\",{\"1\":{\"497\":1}}],[\"在配置文件中指明哪个接口需要打印\",{\"1\":{\"470\":1}}],[\"在配置中我们配置了\",{\"1\":{\"477\":1}}],[\"在半开状态下\",{\"1\":{\"477\":1}}],[\"在客户端也就是\",{\"1\":{\"477\":1}}],[\"在客户端的主启动类上增加\",{\"1\":{\"463\":1}}],[\"在计算故障率之前\",{\"1\":{\"476\":1}}],[\"在n秒内\",{\"1\":{\"476\":1}}],[\"在互联网系统中\",{\"1\":{\"472\":1}}],[\"在feignconfig中注册\",{\"1\":{\"470\":1}}],[\"在payfeignapi中通过\",{\"1\":{\"464\":1}}],[\"在push结点\",{\"1\":{\"39\":1}}],[\"在未使用微服务之前\",{\"1\":{\"446\":1}}],[\"在未整合\",{\"1\":{\"402\":1}}],[\"在没有增加\",{\"1\":{\"435\":1}}],[\"在订单支付成功后\",{\"1\":{\"425\":1}}],[\"在某些场景下\",{\"1\":{\"418\":1}}],[\"在统计时长内\",{\"1\":{\"413\":1}}],[\"在探测恢复状态\",{\"1\":{\"412\":1}}],[\"在接下来的熔断时长内请求会自动被熔断\",{\"1\":{\"412\":1}}],[\"在所以调用中\",{\"1\":{\"412\":1}}],[\"在一张数据表里\",{\"1\":{\"686\":1}}],[\"在一些对精确度要求较高的项目中\",{\"1\":{\"599\":1}}],[\"在一次刷新周期内\",{\"1\":{\"482\":1}}],[\"在一阶段已经提交至数据库\",{\"1\":{\"436\":1}}],[\"在一阶段\",{\"1\":{\"436\":1}}],[\"在一定时间内逐渐增加到阈值上限\",{\"1\":{\"411\":1}}],[\"在一条环路上有\",{\"1\":{\"355\":1}}],[\"在判断第二个区间\",{\"1\":{\"366\":1}}],[\"在x\",{\"1\":{\"363\":4}}],[\"在坐标\",{\"1\":{\"363\":1}}],[\"在柠檬水摊上\",{\"1\":{\"357\":1}}],[\"在舍弃之前\",{\"1\":{\"348\":1}}],[\"在队里中存储元素下标更为访问\",{\"1\":{\"334\":1}}],[\"在完成所有重复项删除操作后返回最终的字符串\",{\"1\":{\"327\":1}}],[\"在完全二叉树中\",{\"1\":{\"34\":1}}],[\"在此目录下创建\",{\"1\":{\"454\":1}}],[\"在此范围内保证所有元素的和都\",{\"1\":{\"285\":1}}],[\"在此处卖出\",{\"1\":{\"129\":2}}],[\"在此处买入\",{\"1\":{\"129\":2}}],[\"在初始认为只需要遍历数组\",{\"1\":{\"279\":1}}],[\"在初始化时\",{\"1\":{\"99\":1}}],[\"在函数里修改输入数组对于调用者是可见的\",{\"1\":{\"278\":1}}],[\"在下标\",{\"1\":{\"277\":1}}],[\"在下图中标记为\",{\"1\":{\"84\":1}}],[\"在预先未知的某个下标上进行了旋转\",{\"1\":{\"277\":1}}],[\"在预先未知的某个下标\",{\"1\":{\"277\":1}}],[\"在传递给函数之前\",{\"1\":{\"277\":1}}],[\"在变化后可能得到\",{\"1\":{\"276\":1}}],[\"在找到\",{\"1\":{\"273\":1}}],[\"在区间\",{\"1\":{\"271\":1}}],[\"在组合\",{\"1\":{\"247\":1}}],[\"在组合内是允许有重复元素的\",{\"1\":{\"211\":1}}],[\"在反转\",{\"1\":{\"247\":1}}],[\"在任意次数的移动中离开网格边界的陆地单元格的数量\",{\"1\":{\"229\":1}}],[\"在上面我将超时时间设置了5s\",{\"1\":{\"467\":1}}],[\"在上面我们提到了\",{\"1\":{\"185\":1}}],[\"在上面的配置就会消失\",{\"1\":{\"454\":1}}],[\"在上面已经说过了\",{\"1\":{\"224\":1}}],[\"在回溯章节中\",{\"1\":{\"222\":1}}],[\"在前面说过\",{\"1\":{\"203\":1}}],[\"在前序遍历中\",{\"1\":{\"7\":1}}],[\"在截取每个字符时\",{\"1\":{\"199\":1}}],[\"在我看来\",{\"1\":{\"199\":1,\"344\":1}}],[\"在我们使用左连接时\",{\"1\":{\"539\":1}}],[\"在我们做过的动态背包问题中\",{\"1\":{\"99\":1}}],[\"在我们遍历容量的时候要使用倒序\",{\"1\":{\"93\":1}}],[\"在往后遍历就没有意义了\",{\"1\":{\"191\":1}}],[\"在257\",{\"1\":{\"187\":1}}],[\"在介绍回溯算法时\",{\"1\":{\"187\":1}}],[\"在求下去就没有必要了\",{\"1\":{\"170\":1}}],[\"在求递推公式前\",{\"1\":{\"157\":1}}],[\"在求组合问题时\",{\"1\":{\"103\":1}}],[\"在刚开始看到这道题时\",{\"1\":{\"155\":1}}],[\"在针对\",{\"1\":{\"153\":1}}],[\"在718\",{\"1\":{\"146\":1}}],[\"在两条独立的水平线上按给定的顺序写下\",{\"1\":{\"140\":1}}],[\"在原数组里被\",{\"1\":{\"134\":1}}],[\"在原始bst中不存在\",{\"1\":{\"65\":1}}],[\"在股票\",{\"1\":{\"130\":1}}],[\"在卖出它之前你就不能再继续购买股票了\",{\"1\":{\"129\":1}}],[\"在第一步中\",{\"1\":{\"299\":1}}],[\"在第一行旋转之后\",{\"1\":{\"298\":1}}],[\"在第二行旋转之后\",{\"1\":{\"298\":1}}],[\"在第\",{\"1\":{\"119\":2,\"121\":6,\"123\":6,\"125\":6}}],[\"在之前数组版本的打家劫舍\",{\"1\":{\"117\":1}}],[\"在题目中我们可以得知\",{\"1\":{\"113\":1}}],[\"在对dp数组初始化时\",{\"1\":{\"107\":1}}],[\"在讲完全背包时\",{\"1\":{\"103\":1}}],[\"在容量为\",{\"1\":{\"95\":1}}],[\"在二分查找中一般有俩个常用的区间\",{\"1\":{\"270\":1}}],[\"在二叉树中的递归遍历其实就是\",{\"1\":{\"222\":1}}],[\"在二叉搜索树的插入中\",{\"1\":{\"68\":1}}],[\"在二维数组中我们正序\",{\"1\":{\"92\":1}}],[\"在递归之前\",{\"1\":{\"211\":1}}],[\"在递归遍历的过程中\",{\"1\":{\"58\":1}}],[\"在递归中我们只修改了处理结点的顺序\",{\"1\":{\"7\":1}}],[\"在这些数据在分组\",{\"1\":{\"565\":1}}],[\"在这方面明显优于关系型数据库\",{\"1\":{\"510\":1}}],[\"在这个事务持续期间\",{\"1\":{\"746\":1}}],[\"在这个前提之下\",{\"1\":{\"598\":1}}],[\"在这个情况下\",{\"1\":{\"123\":1}}],[\"在这个二叉树中\",{\"1\":{\"40\":1}}],[\"在这种情况下会发生\",{\"1\":{\"763\":1}}],[\"在这种情况下\",{\"1\":{\"119\":1,\"121\":1,\"145\":1}}],[\"在这道题中我们可以认为\",{\"1\":{\"95\":1}}],[\"在这里其实我们可以利用一个数学公式\",{\"1\":{\"293\":1}}],[\"在这里我使用队列\",{\"1\":{\"222\":1}}],[\"在这里\",{\"1\":{\"39\":1,\"488\":1}}],[\"在每个滑动窗口期样本数\",{\"1\":{\"476\":1}}],[\"在每一个以粗实线分隔的\",{\"1\":{\"216\":1}}],[\"在每一列只能出现一次\",{\"1\":{\"216\":1}}],[\"在每一行只能出现一次\",{\"1\":{\"216\":1}}],[\"在每一天\",{\"1\":{\"121\":1}}],[\"在每一层遍历开始前\",{\"1\":{\"12\":1}}],[\"在每次遍历的过程中\",{\"1\":{\"39\":1}}],[\"在\",{\"1\":{\"12\":1,\"64\":1,\"93\":1,\"97\":1,\"98\":1,\"141\":1,\"148\":1,\"189\":1,\"193\":1,\"207\":1,\"222\":1,\"271\":1,\"309\":1,\"327\":2,\"337\":1,\"390\":4,\"413\":1,\"435\":1,\"451\":2,\"452\":2,\"464\":1,\"477\":1,\"518\":2,\"565\":1,\"597\":1,\"618\":3,\"634\":1,\"658\":1,\"689\":1,\"696\":1,\"725\":3,\"763\":1,\"765\":2,\"796\":1,\"800\":1,\"806\":1}}],[\"在遍历完\",{\"1\":{\"307\":1}}],[\"在遍历完每一层时\",{\"1\":{\"26\":1}}],[\"在遍历s串的时候\",{\"1\":{\"111\":1}}],[\"在遍历物品\",{\"1\":{\"105\":1}}],[\"在遍历容量\",{\"1\":{\"105\":1}}],[\"在遍历的过程需要记录上一个结点的值\",{\"1\":{\"60\":1}}],[\"在遍历结点的过程中\",{\"1\":{\"31\":1}}],[\"在遍历过程中\",{\"1\":{\"12\":1,\"41\":1}}],[\"在遍历右子树\",{\"1\":{\"4\":2}}],[\"在遍历根节点\",{\"1\":{\"3\":1}}],[\"在遍历左子树\",{\"1\":{\"2\":1}}],[\"将改变应用到自己的数据库中\",{\"1\":{\"820\":1}}],[\"将写操作记录到二进制日志\",{\"1\":{\"820\":1}}],[\"将从库中的数据与主库保持同步\",{\"1\":{\"820\":1}}],[\"将参数innodb\",{\"1\":{\"786\":1}}],[\"将持有最少行级排他锁的事务进行回滚\",{\"1\":{\"786\":1}}],[\"将修改前的行放回去\",{\"1\":{\"755\":1}}],[\"将redo\",{\"1\":{\"752\":1,\"757\":1}}],[\"将right左移\",{\"1\":{\"177\":1}}],[\"将right\",{\"1\":{\"177\":1}}],[\"将会提示该额外信息\",{\"1\":{\"710\":2}}],[\"将数据划分为若干个页\",{\"1\":{\"666\":1}}],[\"将数组最后一个元素\",{\"1\":{\"354\":1}}],[\"将散列到同一槽位的元素放在一个链表中\",{\"1\":{\"658\":1}}],[\"将输入转变为输出\",{\"1\":{\"658\":1}}],[\"将输入栈导出到输出栈中\",{\"1\":{\"323\":1}}],[\"将表中的记录\",{\"1\":{\"654\":1}}],[\"将索引和数据分开存储\",{\"1\":{\"654\":1}}],[\"将sql语句分解成数据结构\",{\"1\":{\"628\":1}}],[\"将子表上匹配记录的列设为null\",{\"1\":{\"618\":1}}],[\"将子查询划分为\",{\"1\":{\"570\":1}}],[\"将子查询分为\",{\"1\":{\"570\":1}}],[\"将子查询放在比较条件的右侧\",{\"1\":{\"569\":1}}],[\"将主表与这个新表进行连接\",{\"1\":{\"579\":2}}],[\"将结果作为一张新表\",{\"1\":{\"578\":1}}],[\"将结点放入hash表中\",{\"1\":{\"394\":1}}],[\"将整个查询结果作为一组\",{\"1\":{\"564\":1}}],[\"将给定的小时\",{\"1\":{\"557\":1}}],[\"将unix时间戳的时间转换为普通格式的时间\",{\"1\":{\"554\":1}}],[\"将时间date以unix时间戳的形式返回\",{\"1\":{\"554\":1}}],[\"将字符串s的所有字母转成小写字母\",{\"1\":{\"552\":1}}],[\"将字符串s的所有字母转成大写字母\",{\"1\":{\"552\":1}}],[\"将字符串str从第idx位置开始\",{\"1\":{\"552\":1}}],[\"将弧度转化为角度\",{\"1\":{\"549\":1}}],[\"将角度转化为弧度\",{\"1\":{\"549\":1}}],[\"将查询结果插入到表中\",{\"1\":{\"542\":1}}],[\"将a\",{\"1\":{\"541\":2}}],[\"将a变成o\",{\"1\":{\"232\":1}}],[\"将这两个表的主键都插入到第三个表中\",{\"1\":{\"513\":1}}],[\"将路径设置为\",{\"1\":{\"502\":1}}],[\"将请求头sec\",{\"1\":{\"499\":1}}],[\"将网关模块重新启动\",{\"1\":{\"497\":1}}],[\"将允许处理的最大请求数量重置为limitforperiod\",{\"1\":{\"482\":1}}],[\"将重新进入开启open状态\",{\"1\":{\"477\":1}}],[\"将自动从开启open状态过渡到半开half\",{\"1\":{\"477\":1}}],[\"将自动生成的\",{\"1\":{\"432\":1}}],[\"将服务端提供的接口清单\",{\"1\":{\"464\":1}}],[\"将配置保存在此处\",{\"1\":{\"454\":1}}],[\"将mybatis\",{\"1\":{\"443\":1}}],[\"将midindex继续指向下一个元素\",{\"1\":{\"292\":1}}],[\"将为用户提供了\",{\"1\":{\"426\":1}}],[\"将限流配置规则持久化进nacos保存\",{\"1\":{\"419\":1}}],[\"将所有划分结果按顺序连接\",{\"1\":{\"367\":1}}],[\"将所有的子集都加到集合中\",{\"1\":{\"207\":1}}],[\"将k作为index插入\",{\"1\":{\"362\":1}}],[\"将第一次遍历得到的当前孩子糖果数量作为值\",{\"1\":{\"360\":1}}],[\"将第一列初始化为1\",{\"1\":{\"148\":1}}],[\"将右孩子的糖果数量+1作为\",{\"1\":{\"360\":1}}],[\"将右孩子结点入队\",{\"1\":{\"12\":1,\"16\":1}}],[\"将右孩子结点入栈\",{\"1\":{\"6\":1}}],[\"将最小的数进行反转\",{\"1\":{\"354\":1}}],[\"将绝对值较大的负数进行反转\",{\"1\":{\"354\":1}}],[\"将count进行重置\",{\"1\":{\"348\":1}}],[\"将局部最优解堆叠成全局最优解\",{\"1\":{\"342\":1}}],[\"将问题分解为若干个子问题\",{\"1\":{\"342\":1}}],[\"将队列中比当前元素小的都弹出\",{\"1\":{\"335\":1}}],[\"将不相等的字符入栈\",{\"1\":{\"329\":1}}],[\"将不合并的区间放入进去\",{\"1\":{\"295\":1}}],[\"将元素\",{\"1\":{\"321\":1}}],[\"将元素放入到\",{\"1\":{\"187\":1}}],[\"将0元素的行和列的所有元素都置0\",{\"1\":{\"302\":1}}],[\"将它们合并为\",{\"1\":{\"294\":1}}],[\"将较大的数\",{\"1\":{\"282\":1,\"283\":1}}],[\"将fast指向的元素替换掉slow指向的元素\",{\"1\":{\"280\":1}}],[\"将指定值删除即可\",{\"1\":{\"279\":1}}],[\"将在\",{\"1\":{\"269\":1}}],[\"将俩个指针指向尾部\",{\"1\":{\"245\":1}}],[\"将其发送到\",{\"1\":{\"488\":1}}],[\"将其保存成\",{\"1\":{\"436\":1}}],[\"将其纳入\",{\"1\":{\"426\":1}}],[\"将其中一个链表的结点都放到\",{\"1\":{\"391\":1}}],[\"将其交换即可\",{\"1\":{\"316\":1}}],[\"将其标记\",{\"1\":{\"234\":2}}],[\"将其拆分为\",{\"1\":{\"86\":1}}],[\"将图中的o改为x\",{\"1\":{\"232\":2}}],[\"将靠近边界的o都改为a\",{\"1\":{\"232\":2}}],[\"将靠近边界的陆地都变成海洋\",{\"1\":{\"230\":2}}],[\"将o变成x\",{\"1\":{\"232\":1}}],[\"将陆地变成海洋\",{\"1\":{\"230\":1}}],[\"将岛屿数量+1\",{\"1\":{\"226\":1}}],[\"将每个部门的id\",{\"1\":{\"579\":1}}],[\"将每个数平方\",{\"1\":{\"282\":1}}],[\"将每块陆地\",{\"1\":{\"228\":1}}],[\"将每一层的元素都放到\",{\"1\":{\"207\":1}}],[\"将每次求得平方和加入到这个\",{\"1\":{\"170\":1}}],[\"将当前位置所覆盖的范围更新为下一步覆盖的范围\",{\"1\":{\"352\":1}}],[\"将当前陆地的面积+1\",{\"1\":{\"228\":1}}],[\"将当前字符转换成int型\",{\"1\":{\"201\":2}}],[\"将当前结点重新加入进去\",{\"1\":{\"60\":1}}],[\"将ip地址保存到最终的集合中\",{\"1\":{\"201\":2}}],[\"将叶子结点增加到\",{\"1\":{\"190\":1}}],[\"将该集合放入到\",{\"1\":{\"187\":1}}],[\"将交集转换回数组\",{\"1\":{\"168\":1}}],[\"将dp数组的第一列初始化为1\",{\"1\":{\"148\":1}}],[\"将dp数组填充尽可能大的值\",{\"1\":{\"107\":1}}],[\"将l指针右移\",{\"1\":{\"314\":1}}],[\"将left与right指向的元素交换\",{\"1\":{\"251\":1}}],[\"将left右移\",{\"1\":{\"177\":1}}],[\"将length重置\",{\"1\":{\"135\":1}}],[\"将list转换成set\",{\"1\":{\"111\":1}}],[\"将买入时的利润设为\",{\"1\":{\"126\":1}}],[\"将空间复杂度降到\",{\"1\":{\"115\":1}}],[\"将差值放入原数组中\",{\"1\":{\"97\":1}}],[\"将二叉搜索树变成一个有序数组\",{\"1\":{\"74\":1}}],[\"将二叉树中序遍历\",{\"1\":{\"56\":1}}],[\"将删除结点的左子树移动到cur的左子树上\",{\"1\":{\"70\":1}}],[\"将删除结点的左子树移动到\",{\"1\":{\"68\":1}}],[\"将值插入二叉搜索树\",{\"1\":{\"65\":1}}],[\"将递归的比较换成队列\",{\"1\":{\"33\":1}}],[\"将\",{\"1\":{\"20\":1,\"33\":1,\"68\":1,\"70\":1,\"97\":1,\"146\":1,\"151\":4,\"167\":1,\"168\":1,\"177\":1,\"203\":1,\"241\":1,\"245\":1,\"255\":1,\"286\":1,\"291\":1,\"313\":2,\"334\":1,\"360\":1,\"370\":1,\"384\":1,\"420\":1,\"454\":1,\"529\":1,\"556\":2,\"729\":1,\"820\":1}}],[\"将左孩子入队\",{\"1\":{\"16\":1}}],[\"将左孩子结点入队\",{\"1\":{\"12\":1}}],[\"将bfs遍历改成了层序遍历\",{\"1\":{\"12\":1}}],[\"将节点增加到集合中\",{\"1\":{\"7\":1}}],[\"将根节点加入到集合中\",{\"1\":{\"6\":1}}],[\"将根节点弹栈\",{\"1\":{\"6\":1}}],[\"ws\",{\"1\":{\"552\":1}}],[\"w3\",{\"1\":{\"441\":1}}],[\"wangwu\",{\"1\":{\"676\":1}}],[\"watch\",{\"1\":{\"453\":1}}],[\"waiting\",{\"1\":{\"763\":5}}],[\"waitdurationinopenstate\",{\"1\":{\"477\":1,\"478\":1}}],[\"wait\",{\"1\":{\"429\":1,\"453\":1,\"476\":1,\"786\":1}}],[\"warning\",{\"1\":{\"701\":1,\"809\":1,\"832\":1}}],[\"warranties\",{\"1\":{\"429\":1}}],[\"warm\",{\"1\":{\"411\":3}}],[\"write和fsync的时机\",{\"1\":{\"810\":1}}],[\"write\",{\"1\":{\"746\":1,\"770\":1}}],[\"write标识当前事务是一个\",{\"1\":{\"744\":1}}],[\"writing\",{\"1\":{\"429\":1}}],[\"wrod1\",{\"1\":{\"152\":1}}],[\"wrod2\",{\"1\":{\"152\":1}}],[\"why\",{\"1\":{\"686\":1}}],[\"where=\",{\"1\":{\"831\":1}}],[\"where后面附\",{\"1\":{\"831\":1}}],[\"where条件过滤出来的结果集请保持在1000行\",{\"1\":{\"726\":1}}],[\"where效率高于having\",{\"1\":{\"726\":1}}],[\"where和having都可以\",{\"1\":{\"564\":1}}],[\"where\",{\"1\":{\"433\":1,\"434\":1,\"510\":1,\"525\":2,\"529\":1,\"533\":4,\"534\":1,\"536\":1,\"541\":5,\"542\":4,\"563\":1,\"564\":2,\"565\":3,\"569\":5,\"573\":6,\"574\":1,\"575\":1,\"578\":4,\"579\":7,\"587\":2,\"613\":1,\"615\":1,\"618\":1,\"651\":1,\"689\":5,\"696\":2,\"704\":8,\"705\":1,\"708\":1,\"709\":1,\"710\":9,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"725\":8,\"726\":2,\"728\":1,\"729\":3,\"771\":2,\"777\":1,\"791\":2,\"800\":2,\"831\":1}}],[\"wherecondition\",{\"1\":{\"432\":1}}],[\"wherecondition=new\",{\"1\":{\"432\":1}}],[\"when\",{\"1\":{\"428\":1,\"559\":9,\"575\":1}}],[\"what\",{\"1\":{\"426\":1}}],[\"while\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"12\":4,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"29\":1,\"31\":1,\"33\":1,\"35\":1,\"39\":4,\"41\":1,\"43\":2,\"45\":1,\"54\":2,\"66\":1,\"68\":1,\"70\":1,\"146\":1,\"171\":3,\"173\":3,\"177\":4,\"179\":3,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"242\":1,\"245\":3,\"251\":1,\"254\":1,\"256\":1,\"270\":3,\"271\":5,\"273\":1,\"274\":1,\"275\":3,\"276\":1,\"277\":1,\"283\":1,\"286\":1,\"289\":1,\"292\":3,\"305\":2,\"314\":1,\"317\":1,\"323\":1,\"329\":1,\"335\":1,\"378\":1,\"382\":1,\"389\":2,\"392\":3,\"395\":1}}],[\"www\",{\"1\":{\"422\":1,\"429\":1,\"441\":1,\"449\":1,\"502\":2}}],[\"wehre\",{\"1\":{\"564\":1}}],[\"weekofyear\",{\"1\":{\"555\":1}}],[\"week\",{\"1\":{\"555\":1}}],[\"weekday\",{\"1\":{\"555\":1}}],[\"we\",{\"1\":{\"452\":1}}],[\"webmvc\",{\"1\":{\"432\":1,\"441\":1,\"443\":1,\"446\":1}}],[\"web\",{\"1\":{\"402\":1,\"410\":1,\"422\":2,\"432\":1,\"446\":1,\"449\":2,\"488\":2,\"489\":1}}],[\"web<\",{\"1\":{\"402\":2,\"432\":1,\"443\":1,\"446\":1}}],[\"webflux\",{\"1\":{\"399\":1,\"491\":1}}],[\"webservlet\",{\"1\":{\"399\":1}}],[\"weight\",{\"1\":{\"91\":8,\"92\":8,\"93\":6,\"95\":2,\"101\":1}}],[\"will\",{\"1\":{\"883\":1}}],[\"without\",{\"1\":{\"429\":1}}],[\"with\",{\"1\":{\"429\":1,\"744\":1,\"785\":1,\"809\":1,\"825\":1}}],[\"wigglemaxlength\",{\"1\":{\"346\":1}}],[\"windows\",{\"1\":{\"518\":1,\"835\":1}}],[\"window\",{\"1\":{\"0\":2,\"153\":1,\"476\":3}}],[\"wttw\",{\"1\":{\"261\":2}}],[\"work\",{\"1\":{\"822\":1}}],[\"worker\",{\"1\":{\"399\":1}}],[\"world\",{\"1\":{\"244\":2}}],[\"wordlist\",{\"1\":{\"245\":3}}],[\"word2相同所需的最小步数\",{\"1\":{\"149\":1}}],[\"word2\",{\"1\":{\"149\":5,\"150\":4,\"151\":6,\"152\":10,\"153\":10}}],[\"word1\",{\"1\":{\"149\":6,\"150\":4,\"151\":6,\"152\":12,\"153\":7}}],[\"wordbreak\",{\"1\":{\"111\":1}}],[\"worddict\",{\"1\":{\"110\":8,\"111\":4}}],[\"w\",{\"1\":{\"91\":3,\"193\":2}}],[\"迭代\",{\"1\":{\"33\":1,\"39\":1,\"54\":2,\"66\":1}}],[\"迭代遍历\",{\"1\":{\"6\":1,\"8\":1}}],[\"迭代法\",{\"1\":{\"6\":1,\"7\":1}}],[\"后者过去分词表示被\",{\"1\":{\"836\":1}}],[\"后边能跟随几个\",{\"1\":{\"744\":1}}],[\"后边搭配一个正则匹配模式\",{\"1\":{\"699\":1}}],[\"后4个字节代表页面被最后修改时对应的日志序列位置\",{\"1\":{\"669\":1}}],[\"后来改名为\",{\"1\":{\"635\":1}}],[\"后天\",{\"1\":{\"557\":1}}],[\"后由美国国家标准局\",{\"1\":{\"516\":1}}],[\"后缀必须是\",{\"1\":{\"504\":1}}],[\"后缀通常用斜杠\",{\"1\":{\"495\":1}}],[\"后弹出来的是被减数\",{\"1\":{\"332\":1}}],[\"后弹出来的是被除数\",{\"1\":{\"332\":1}}],[\"后半部分有序\",{\"1\":{\"277\":1}}],[\"后\",{\"1\":{\"276\":1,\"365\":1,\"454\":1,\"835\":1}}],[\"后面是相同的列就使用单索引列\",{\"1\":{\"725\":1}}],[\"后面\",{\"1\":{\"564\":1}}],[\"后面跟着一个数字表示子网掩码的位数\",{\"1\":{\"495\":1}}],[\"后面跟一个等号\",{\"1\":{\"491\":1}}],[\"后面的线程进来发现已经有缓存了\",{\"1\":{\"844\":1}}],[\"后面的所有值顺序相同\",{\"1\":{\"379\":1}}],[\"后面的每一项数字都是前面两项数字的和\",{\"1\":{\"78\":1}}],[\"后面所有的都变成9\",{\"1\":{\"370\":1}}],[\"后面就没有必要在进行遍历了\",{\"1\":{\"191\":1}}],[\"后移\",{\"1\":{\"146\":1}}],[\"后组成的新字符串\",{\"1\":{\"138\":1}}],[\"后续自己在nacos里面新建\",{\"1\":{\"429\":2}}],[\"后续\",{\"1\":{\"47\":1}}],[\"后续遍历是左右中\",{\"1\":{\"8\":1}}],[\"后是路径\",{\"1\":{\"39\":1}}],[\"后序\",{\"1\":{\"31\":1,\"54\":1}}],[\"后序遍历只不过调整加入集合的顺序即可\",{\"1\":{\"1\":1}}],[\"后序遍历\",{\"0\":{\"8\":1},\"1\":{\"0\":1,\"372\":1}}],[\"后放右\",{\"1\":{\"8\":1}}],[\"后放左孩子\",{\"1\":{\"6\":1}}],[\"所在数据表的对应意向锁\",{\"1\":{\"771\":1}}],[\"所造成的影响并没有刷新到磁盘\",{\"1\":{\"742\":1}}],[\"所\",{\"1\":{\"701\":1}}],[\"所消耗的时间也就越小\",{\"1\":{\"657\":1}}],[\"所耗费的时间也会增加\",{\"1\":{\"642\":1}}],[\"所占多少存储空间并无任何关系\",{\"1\":{\"597\":1}}],[\"所表示的队列\",{\"1\":{\"361\":1}}],[\"所经历的机场\",{\"1\":{\"213\":1}}],[\"所使用的最少操作数\",{\"1\":{\"151\":1}}],[\"所需要最少得完全平方数个数为dp\",{\"1\":{\"109\":1}}],[\"所背的物品价值最大可以为dp\",{\"1\":{\"95\":1}}],[\"所能装入的最大价值\",{\"1\":{\"92\":1}}],[\"所能装入物品的最大价值\",{\"1\":{\"91\":1}}],[\"所谓完整的用户记录\",{\"1\":{\"650\":1}}],[\"所谓后缀就是指算符写在后面\",{\"1\":{\"330\":1}}],[\"所谓的无符号数取值范围\",{\"1\":{\"599\":1}}],[\"所谓的滑动窗口\",{\"1\":{\"285\":1}}],[\"所谓的\",{\"1\":{\"97\":1,\"471\":1,\"650\":1,\"765\":1}}],[\"所谓的翻转\",{\"1\":{\"31\":1}}],[\"所谓前\",{\"1\":{\"1\":1}}],[\"所示\",{\"1\":{\"23\":2}}],[\"所有发生变化的记录都会写到\",{\"1\":{\"823\":1}}],[\"所有用户的连接开始时间和截止时间\",{\"1\":{\"806\":1}}],[\"所有事务都可以看到其他未提交事务的执行结\",{\"1\":{\"746\":1}}],[\"所有列\",{\"1\":{\"725\":1}}],[\"所有列的值\",{\"1\":{\"651\":1}}],[\"所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录\",{\"1\":{\"648\":1}}],[\"所有存储引擎支持每个表至少16个索引\",{\"1\":{\"642\":1}}],[\"所有数据行都使用指向数据列值的头指针\",{\"1\":{\"604\":1}}],[\"所有表中的所有行互相连接\",{\"1\":{\"533\":1}}],[\"所有这些predicate都与http请求的不同属性相匹配\",{\"1\":{\"491\":1}}],[\"所有这些机票都属于一个从\",{\"1\":{\"212\":1}}],[\"所有请求均可通过\",{\"1\":{\"475\":1}}],[\"所有代码均在github\",{\"1\":{\"398\":1,\"439\":1}}],[\"所有元素\",{\"1\":{\"287\":1}}],[\"所有可能的分法\",{\"1\":{\"257\":1}}],[\"所有可能的分割方案\",{\"1\":{\"198\":1}}],[\"所有可能的全排列\",{\"1\":{\"208\":1}}],[\"所有可能的有效组合的列表\",{\"1\":{\"189\":1}}],[\"所有可能的组合为\",{\"1\":{\"104\":1}}],[\"所有的并发问题都可以避免\",{\"1\":{\"746\":1}}],[\"所有的索引列都必须进行等值比较\",{\"1\":{\"704\":1}}],[\"所有的用户记录都存储在了叶子节点\",{\"1\":{\"650\":1}}],[\"所有的数据\",{\"1\":{\"632\":1}}],[\"所有的整数类型都有一个可选的属性unsigned\",{\"1\":{\"596\":1}}],[\"所有的子项目都统一使用同一个版本号\",{\"1\":{\"441\":1}}],[\"所有的行和列都要填充\",{\"1\":{\"217\":1}}],[\"所有的\",{\"1\":{\"99\":1,\"772\":1}}],[\"所有的石头尽可能分成俩堆\",{\"1\":{\"97\":1}}],[\"所有值\",{\"1\":{\"65\":1}}],[\"所有节点的值都是唯一的\",{\"1\":{\"63\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"55\":1}}],[\"所有\",{\"1\":{\"23\":1,\"61\":1,\"194\":1,\"229\":1,\"539\":1,\"578\":1}}],[\"所以字段名称需要慎重考虑\",{\"1\":{\"836\":1}}],[\"所以redo\",{\"1\":{\"812\":1}}],[\"所以row\",{\"1\":{\"681\":1}}],[\"所以系统会给每个线程分配一个块内存作为binlog\",{\"1\":{\"810\":1}}],[\"所以该版本不可以被当前事务访问\",{\"1\":{\"798\":1}}],[\"所以该版本可以被当前事务访问\",{\"1\":{\"798\":2}}],[\"所以该行程必须从\",{\"1\":{\"212\":1}}],[\"所以直接读取记录的最新版本就好了\",{\"1\":{\"797\":1}}],[\"所以每次在拿数据的时候都会上锁\",{\"1\":{\"781\":1}}],[\"所以每个mysql的\",{\"1\":{\"650\":1}}],[\"所以innodb就提出了一种称之为\",{\"1\":{\"777\":1}}],[\"所以innodb表的主键列尽量\",{\"1\":{\"650\":1}}],[\"所以允许这种情况的发生\",{\"1\":{\"762\":1}}],[\"所以锁对数据库而\",{\"1\":{\"760\":1}}],[\"所以符合\",{\"1\":{\"755\":1}}],[\"所以查询性能会受到一定的影响\",{\"1\":{\"724\":1}}],[\"所以有时候也称为伪记录或者虚拟记录\",{\"1\":{\"680\":1}}],[\"所以省去了直接比较两个比较长的字节串的时间损耗\",{\"1\":{\"668\":1}}],[\"所以存储引擎需\",{\"1\":{\"656\":1}}],[\"所以还需要拿着c1再去聚簇索引中查找\",{\"1\":{\"651\":1}}],[\"所以还会有个线程池\",{\"1\":{\"625\":1}}],[\"所以如果我们想根\",{\"1\":{\"651\":1}}],[\"所以如果\",{\"1\":{\"643\":1}}],[\"所以如何找到内存地址相等的结点成为关键\",{\"1\":{\"391\":1}}],[\"所以频繁使用的表不建议包含text类型字段\",{\"1\":{\"605\":1}}],[\"所以除了简短并且固定长度的\",{\"1\":{\"604\":1}}],[\"所以很多人把查询语句单拎出来一类\",{\"1\":{\"517\":1}}],[\"所以可用的主机地址数是2的幂次方\",{\"1\":{\"495\":1}}],[\"所以必须导入aop包\",{\"1\":{\"477\":1}}],[\"所以一套集中式的\",{\"1\":{\"452\":1}}],[\"所以seata框架只需将一阶段保存的快照数据和行锁删掉\",{\"1\":{\"436\":1}}],[\"所以永远不可能到达最后一个下标\",{\"1\":{\"349\":1}}],[\"所以你应该输出2\",{\"1\":{\"343\":1}}],[\"所以你应该输出1\",{\"1\":{\"343\":1}}],[\"所以最坏的情\",{\"1\":{\"749\":1}}],[\"所以最后的字符串为\",{\"1\":{\"327\":1}}],[\"所以最大连续\",{\"1\":{\"306\":1}}],[\"所以最大总和为\",{\"1\":{\"257\":1}}],[\"所以最大利润为\",{\"1\":{\"119\":1,\"123\":1}}],[\"所以在多个未提交事务\",{\"1\":{\"763\":1}}],[\"所以在mysql4\",{\"1\":{\"725\":1}}],[\"所以在\",{\"1\":{\"634\":1,\"635\":1}}],[\"所以在插入多条记录时最好选择使用单条insert语句的方式插入\",{\"1\":{\"542\":1}}],[\"所以在执行完\",{\"1\":{\"313\":1}}],[\"所以在遍历字符串时\",{\"1\":{\"253\":1}}],[\"所以采用的是快慢指针覆盖的方法\",{\"1\":{\"313\":1}}],[\"所以起始位置+1\",{\"1\":{\"289\":1}}],[\"所以当使用\",{\"1\":{\"276\":1}}],[\"所以当word1\",{\"1\":{\"153\":1}}],[\"所以错误的版本之后的所有版本都是错的\",{\"1\":{\"274\":1}}],[\"所以使用\",{\"1\":{\"271\":1}}],[\"所以回溯法也经常和二叉树遍历\",{\"1\":{\"218\":1}}],[\"所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来\",{\"1\":{\"678\":1}}],[\"所以我们并不能在这些数据上使用二分法进行查找\",{\"1\":{\"654\":1}}],[\"所以我们也称这些数据页为节点\",{\"1\":{\"648\":1}}],[\"所以我们要避免使用\",{\"1\":{\"599\":1}}],[\"所以我们输出\",{\"1\":{\"357\":1}}],[\"所以我们第一列都是\",{\"1\":{\"148\":1}}],[\"所以我们首先找到\",{\"1\":{\"67\":1}}],[\"所以只需要\",{\"1\":{\"148\":1,\"153\":1}}],[\"所以不得不依次遍历所有的数据页\",{\"1\":{\"643\":1}}],[\"所以不参与交易可以获得最大利润\",{\"1\":{\"121\":1}}],[\"所以不存在根节点到叶子节点的路径\",{\"1\":{\"44\":1}}],[\"所以递推公式为\",{\"1\":{\"148\":1,\"153\":1}}],[\"所以递推公式\",{\"1\":{\"109\":1}}],[\"所以dp\",{\"1\":{\"107\":1}}],[\"所以答案是\",{\"1\":{\"100\":1,\"357\":1}}],[\"所以数组转化为\",{\"1\":{\"96\":4}}],[\"所以结果应当返回修剪好的二叉搜索树的新的根节点\",{\"1\":{\"69\":1}}],[\"所以子节点是一个值为\",{\"1\":{\"50\":2}}],[\"所以返回\",{\"1\":{\"40\":1}}],[\"所以\",{\"1\":{\"12\":1,\"133\":1,\"188\":1,\"274\":1,\"390\":1,\"596\":1,\"618\":1,\"650\":1,\"658\":1,\"710\":1,\"732\":1}}],[\"所以先将右孩子放入栈中\",{\"1\":{\"6\":1}}],[\"左子节点<本节点\",{\"1\":{\"659\":1}}],[\"左子树为空\",{\"1\":{\"68\":2,\"70\":1}}],[\"左子树不为空\",{\"1\":{\"68\":2,\"70\":1}}],[\"左子树上去搜索\",{\"1\":{\"66\":1}}],[\"左子树上的所有结点的值都小于该结点的值\",{\"1\":{\"54\":1}}],[\"左子树和右子树都是二叉搜索树\",{\"1\":{\"59\":1}}],[\"左子树和右子树都为空\",{\"1\":{\"33\":1}}],[\"左子树结点+右子树结点+根节点\",{\"1\":{\"35\":1}}],[\"左子树或者右子树有一个为空\",{\"1\":{\"33\":1}}],[\"左子树的二叉搜素树数量\",{\"1\":{\"89\":1}}],[\"左子树的右结点和右子树的左节点\",{\"1\":{\"33\":1}}],[\"左子树的右结点和右子树的左节点是相等的\",{\"1\":{\"33\":1}}],[\"左子树的左节点和右子树的右结点\",{\"1\":{\"33\":1}}],[\"左子树的左节点和右子树的右结点是相等的\",{\"1\":{\"33\":1}}],[\"左子树的所有结点的值均小于根结点的值\",{\"1\":{\"0\":1}}],[\"左子树\",{\"1\":{\"2\":1,\"58\":1}}],[\"左下图\",{\"1\":{\"541\":1}}],[\"左中图+右中图的查询结果\",{\"1\":{\"541\":1}}],[\"左中图\",{\"1\":{\"541\":1}}],[\"左上图的查询结果\",{\"1\":{\"541\":1}}],[\"左上图\",{\"1\":{\"541\":1}}],[\"左连接\",{\"1\":{\"539\":1}}],[\"左外连接\",{\"1\":{\"539\":2,\"541\":2}}],[\"左孩子有覆盖\",{\"1\":{\"372\":1}}],[\"左孩子\",{\"1\":{\"360\":3,\"362\":1}}],[\"左孩子结点\",{\"1\":{\"58\":1}}],[\"左孩子结点依次入栈\",{\"1\":{\"6\":1}}],[\"左括号必须以正确的顺序闭合\",{\"1\":{\"324\":1}}],[\"左括号必须用相同类型的右括号闭合\",{\"1\":{\"324\":1}}],[\"左列从下到上\",{\"1\":{\"288\":1}}],[\"左闭右开区间\",{\"1\":{\"271\":1}}],[\"左闭右开\",{\"1\":{\"270\":1,\"273\":1}}],[\"左闭右闭区间\",{\"1\":{\"273\":1}}],[\"左闭右闭\",{\"1\":{\"270\":1,\"271\":1}}],[\"左移\",{\"1\":{\"177\":2,\"179\":1}}],[\"左边孩子的糖果数量\",{\"1\":{\"360\":1}}],[\"左边孩子的分数\",{\"1\":{\"360\":2}}],[\"左边孩子糖果数量\",{\"1\":{\"360\":2}}],[\"左边与右边元素的和相等\",{\"1\":{\"293\":1}}],[\"左边和右边的指针\",{\"1\":{\"292\":1}}],[\"左边部分的和定义为\",{\"1\":{\"290\":1}}],[\"左边部分是\",{\"1\":{\"50\":4}}],[\"左边的表称为\",{\"1\":{\"537\":1}}],[\"左边的和\",{\"1\":{\"291\":1}}],[\"左边的所有元素都小于或者不等于\",{\"1\":{\"273\":2}}],[\"左边的所有元素都不符合题意\",{\"1\":{\"273\":2}}],[\"左边的结果\",{\"1\":{\"85\":1}}],[\"左边所有的位置都不符合题意\",{\"1\":{\"273\":1}}],[\"左边界\",{\"1\":{\"234\":1}}],[\"左边\",{\"1\":{\"50\":1,\"275\":1}}],[\"左边为左子树\",{\"1\":{\"47\":1}}],[\"左右节点的\",{\"1\":{\"372\":1}}],[\"左右节点都是无覆盖状态\",{\"1\":{\"372\":1}}],[\"左右节点都有覆盖\",{\"1\":{\"372\":2}}],[\"左右节点至少有一个有摄像头\",{\"1\":{\"372\":1}}],[\"左右节点至少有一个是无覆盖的情况\",{\"1\":{\"372\":1}}],[\"左右根\",{\"1\":{\"372\":1}}],[\"左右孩子不选的最大和\",{\"1\":{\"117\":1}}],[\"左右子节点其实和\",{\"1\":{\"89\":1}}],[\"左右子树的二叉搜索树数量\",{\"1\":{\"89\":1}}],[\"左右子树的起始范围不太好确定\",{\"1\":{\"47\":1}}],[\"左右子树也必须是二叉搜索树\",{\"1\":{\"73\":1}}],[\"左右子树都为null\",{\"1\":{\"70\":1}}],[\"左右子树都为空\",{\"1\":{\"68\":1}}],[\"左右子树都不为空\",{\"1\":{\"68\":1}}],[\"左右子树均不为空时\",{\"1\":{\"68\":1}}],[\"左右交换\",{\"1\":{\"31\":1}}],[\"左叶子节点\",{\"1\":{\"41\":1}}],[\"左后出\",{\"1\":{\"8\":1}}],[\"左\",{\"1\":{\"7\":1,\"8\":1,\"52\":1,\"56\":2,\"58\":1,\"229\":1,\"372\":1}}],[\"先更新缓存的值为5\",{\"1\":{\"847\":1}}],[\"先删缓存\",{\"0\":{\"848\":1},\"1\":{\"845\":1}}],[\"先删从表\",{\"1\":{\"618\":1}}],[\"先把日志写到\",{\"1\":{\"810\":1}}],[\"先把各个记录和页按照c2列进行排序\",{\"1\":{\"652\":1}}],[\"先创建一个以\",{\"1\":{\"809\":1}}],[\"先创建主表\",{\"1\":{\"618\":1}}],[\"先写数据库\",{\"0\":{\"847\":1,\"849\":1},\"1\":{\"845\":2}}],[\"先写缓存\",{\"0\":{\"846\":1},\"1\":{\"845\":1}}],[\"先写入一个\",{\"1\":{\"754\":1}}],[\"先写死\",{\"1\":{\"446\":1}}],[\"先排序再分组\",{\"1\":{\"726\":1}}],[\"先比较这两个长字节串的校验和\",{\"1\":{\"668\":1}}],[\"先查询出员工的last\",{\"1\":{\"579\":1}}],[\"先从外部查询开始\",{\"1\":{\"570\":1}}],[\"先从太平洋出发找到能够到达的坐标\",{\"1\":{\"234\":1}}],[\"先后有\",{\"1\":{\"516\":1}}],[\"先记录下访问接口的开始时间\",{\"1\":{\"503\":1}}],[\"先记录队列中的结点数量\",{\"1\":{\"12\":1}}],[\"先在主启动类增加\",{\"1\":{\"420\":1}}],[\"先保存下一个结点\",{\"1\":{\"384\":1}}],[\"先保存要移动到的结点\",{\"1\":{\"382\":1}}],[\"先根据\",{\"1\":{\"364\":1}}],[\"先以end来说\",{\"1\":{\"364\":1}}],[\"先弹出来的是减数\",{\"1\":{\"332\":1}}],[\"先弹出来的是除数\",{\"1\":{\"332\":1}}],[\"先弹出来的是结点\",{\"1\":{\"39\":1}}],[\"先对百万条数据进行分组\",{\"1\":{\"565\":1}}],[\"先对二维数组对初始元素进行排序\",{\"1\":{\"296\":1}}],[\"先对数组进行排序\",{\"1\":{\"177\":1}}],[\"先分割\",{\"1\":{\"247\":1}}],[\"先去掉首尾空格\",{\"1\":{\"245\":2}}],[\"先校验该航班是否已经飞过\",{\"1\":{\"213\":1}}],[\"先抽象成二叉树为\",{\"1\":{\"211\":1}}],[\"先抽象成一个二叉树\",{\"1\":{\"205\":1}}],[\"先给出代码\",{\"1\":{\"211\":1}}],[\"先判断是否已经重复添加\",{\"1\":{\"209\":1}}],[\"先来看看\",{\"1\":{\"497\":1}}],[\"先来看看每个节点可能有几种状态\",{\"1\":{\"372\":1}}],[\"先来观察数据库的初始情况\",{\"1\":{\"435\":1}}],[\"先来说二维数组\",{\"1\":{\"91\":1}}],[\"先来讨论一下几种情况\",{\"1\":{\"62\":1}}],[\"先处理结点\",{\"1\":{\"52\":1}}],[\"先看看gateway原厂的过滤器如何实现\",{\"1\":{\"504\":1}}],[\"先看层序遍历代码模板\",{\"1\":{\"39\":1}}],[\"先看一下非递归的先序遍历代码\",{\"1\":{\"39\":1}}],[\"先将原始数据从磁盘中读入内存中来\",{\"1\":{\"752\":1}}],[\"先将heada都放入hash表中\",{\"1\":{\"392\":1}}],[\"先将二维数组中第一个元素放到结果数组中\",{\"1\":{\"296\":1}}],[\"先将与边界相连的陆地\",{\"1\":{\"232\":1}}],[\"先将该节点的上下左右四个方向的节点搜索出来\",{\"1\":{\"222\":1}}],[\"先将俩个字符串排序\",{\"1\":{\"162\":1}}],[\"先将左右子树入队\",{\"1\":{\"33\":1}}],[\"先将根节点入栈\",{\"1\":{\"6\":2,\"8\":1}}],[\"先序遍历的方法有\",{\"1\":{\"39\":1}}],[\"先序遍历\",{\"1\":{\"31\":1,\"37\":1,\"41\":1,\"54\":1}}],[\"先序遍历是中左右\",{\"1\":{\"8\":1}}],[\"先序\",{\"1\":{\"31\":1}}],[\"先放左\",{\"1\":{\"8\":1}}],[\"先遍历与本节点连接的所有节点\",{\"1\":{\"222\":1}}],[\"先遍历背包容量\",{\"1\":{\"109\":1}}],[\"先遍历容量在遍历物品\",{\"1\":{\"105\":1}}],[\"先遍历容量\",{\"1\":{\"105\":1}}],[\"先遍历物品\",{\"1\":{\"105\":1}}],[\"先遍历左子树\",{\"1\":{\"3\":2,\"4\":2}}],[\"先遍历根节点\",{\"1\":{\"2\":2}}],[\"遍历枚举v2\",{\"1\":{\"444\":1}}],[\"遍历枚举v1\",{\"1\":{\"444\":1}}],[\"遍历链表\",{\"1\":{\"377\":1}}],[\"遍历到\",{\"1\":{\"370\":1}}],[\"遍历到空结点直接返回\",{\"1\":{\"68\":1}}],[\"遍历某个数字时\",{\"1\":{\"370\":1}}],[\"遍历对角线\",{\"1\":{\"305\":1}}],[\"遍历第一条对角线的元素\",{\"1\":{\"304\":1}}],[\"遍历第二条对角线的元素\",{\"1\":{\"304\":1}}],[\"遍历检查\",{\"1\":{\"280\":1}}],[\"遍历四个方向\",{\"1\":{\"230\":1,\"232\":1}}],[\"遍历数组\",{\"1\":{\"226\":1,\"232\":1,\"282\":1}}],[\"遍历完得到的\",{\"1\":{\"356\":1}}],[\"遍历完即结束递归\",{\"1\":{\"217\":1}}],[\"遍历完意味着结束递归\",{\"1\":{\"217\":1}}],[\"遍历完所有的行和列就算完成递归\",{\"1\":{\"217\":1}}],[\"遍历完所有结点后\",{\"1\":{\"60\":1}}],[\"遍历1~9个数\",{\"1\":{\"217\":2}}],[\"遍历所有的航班\",{\"1\":{\"213\":1}}],[\"遍历t串中将\",{\"1\":{\"162\":1}}],[\"遍历字符串\",{\"1\":{\"111\":1}}],[\"遍历容量\",{\"1\":{\"103\":2,\"105\":1}}],[\"遍历背包\",{\"1\":{\"97\":1}}],[\"遍历背包容量\",{\"1\":{\"91\":1,\"92\":2,\"93\":2,\"101\":1,\"103\":1}}],[\"遍历物品\",{\"1\":{\"91\":1,\"92\":2,\"93\":2,\"97\":1,\"101\":1,\"103\":3,\"105\":1,\"109\":1}}],[\"遍历二叉树\",{\"1\":{\"60\":1}}],[\"遍历出来的一定是一个升序数组\",{\"1\":{\"58\":1}}],[\"遍历每层结点时\",{\"1\":{\"18\":1}}],[\"遍历左子树\",{\"1\":{\"12\":1,\"31\":1,\"62\":1}}],[\"遍历中某个时刻队列的状态\",{\"1\":{\"12\":1}}],[\"遍历过程中的某一时刻\",{\"1\":{\"12\":1}}],[\"遍历的时候就不会重复遍历了\",{\"1\":{\"226\":1}}],[\"遍历的行数\",{\"1\":{\"215\":1}}],[\"遍历的顺序是不一样的\",{\"1\":{\"105\":1}}],[\"遍历的元素放放到集合中\",{\"1\":{\"56\":1}}],[\"遍历的过程\",{\"1\":{\"12\":1}}],[\"遍历的过程中\",{\"1\":{\"12\":1}}],[\"遍历的结果分层呢\",{\"1\":{\"12\":1}}],[\"遍历的代码比\",{\"1\":{\"12\":1}}],[\"遍历的代码比较\",{\"1\":{\"12\":1}}],[\"遍历与层序遍历的输出结果不同\",{\"1\":{\"12\":1}}],[\"遍历后得到是一维数组\",{\"1\":{\"12\":1}}],[\"遍历使用队列数据结构\",{\"1\":{\"12\":1}}],[\"遍历使用\",{\"1\":{\"12\":1}}],[\"遍历和\",{\"1\":{\"12\":1}}],[\"遍历\",{\"1\":{\"12\":2,\"307\":1}}],[\"遍历右子树\",{\"1\":{\"3\":1,\"12\":1,\"31\":1,\"62\":1}}],[\"遍历根节点\",{\"1\":{\"3\":1}}],[\"遍历顺序为\",{\"1\":{\"157\":1}}],[\"遍历顺序从下到上\",{\"1\":{\"155\":1}}],[\"遍历顺序就很重要了\",{\"1\":{\"93\":1}}],[\"遍历顺序\",{\"1\":{\"3\":1,\"85\":1,\"92\":1,\"95\":1,\"103\":1,\"105\":1,\"107\":1,\"137\":1,\"146\":1,\"152\":1,\"155\":1,\"157\":1,\"261\":1}}],[\"a参数\",{\"1\":{\"831\":1}}],[\"americas\",{\"1\":{\"767\":1}}],[\"amount\",{\"1\":{\"102\":5,\"103\":6,\"106\":5,\"107\":5,\"443\":1,\"710\":2}}],[\"a=3\",{\"1\":{\"757\":1}}],[\"a=\",{\"1\":{\"757\":1}}],[\"a=1\",{\"1\":{\"757\":1}}],[\"a账户的钱扣了\",{\"1\":{\"741\":1}}],[\"a账户200元\",{\"1\":{\"741\":1}}],[\"a账户有200元\",{\"1\":{\"741\":1}}],[\"a表小\",{\"1\":{\"729\":1}}],[\"a表大\",{\"1\":{\"729\":1}}],[\"avl\",{\"0\":{\"660\":1}}],[\"avg\",{\"1\":{\"562\":3,\"563\":1,\"578\":15,\"579\":10}}],[\"averageoflevels\",{\"1\":{\"18\":1}}],[\"a可以用employees表表示\",{\"1\":{\"541\":1}}],[\"aop<\",{\"1\":{\"477\":1}}],[\"a也变为不可用\",{\"1\":{\"472\":1}}],[\"age=30\",{\"1\":{\"715\":3,\"718\":1,\"728\":2}}],[\"agent\",{\"1\":{\"449\":1,\"454\":1}}],[\"age\",{\"1\":{\"434\":1,\"608\":3,\"619\":2,\"715\":7,\"718\":4,\"719\":3,\"720\":2,\"721\":3,\"728\":2}}],[\"agreed\",{\"1\":{\"429\":1}}],[\"autocommit\",{\"1\":{\"589\":1,\"745\":4}}],[\"automatictransitionfromopentohalfopenenabled\",{\"1\":{\"477\":1}}],[\"automatic\",{\"1\":{\"474\":1}}],[\"auto\",{\"1\":{\"431\":9,\"440\":2,\"454\":1,\"617\":8,\"619\":1,\"687\":2,\"772\":4,\"822\":1,\"823\":1}}],[\"autowired\",{\"1\":{\"424\":1,\"446\":1,\"464\":1}}],[\"authentication\",{\"1\":{\"444\":1}}],[\"auth\",{\"1\":{\"429\":1}}],[\"authority访问控制规则\",{\"1\":{\"419\":1}}],[\"al\",{\"1\":{\"699\":1}}],[\"alipay\",{\"1\":{\"836\":1}}],[\"aliyunadmin\",{\"1\":{\"836\":1}}],[\"aliyun\",{\"1\":{\"836\":1}}],[\"aliases\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"alibaba<\",{\"1\":{\"432\":1,\"441\":1,\"443\":1}}],[\"alibaba\",{\"0\":{\"398\":1},\"1\":{\"399\":11,\"401\":1,\"402\":4,\"403\":2,\"405\":1,\"407\":1,\"408\":3,\"419\":1,\"422\":7,\"423\":2,\"432\":7,\"441\":7,\"443\":2,\"446\":1,\"452\":1,\"689\":1},\"2\":{\"438\":1}}],[\"alter\",{\"1\":{\"431\":3,\"517\":1,\"586\":1,\"588\":4,\"612\":1,\"614\":1,\"615\":3,\"616\":2,\"617\":3,\"618\":3,\"620\":1,\"676\":1,\"687\":2,\"770\":1,\"825\":1}}],[\"all的大查询中\",{\"1\":{\"703\":1}}],[\"all的大查询来说\",{\"1\":{\"703\":1}}],[\"all或者子查询的大查询来说\",{\"1\":{\"703\":1}}],[\"all语句\",{\"1\":{\"540\":1}}],[\"all语句时所需要的资源比union语句少\",{\"1\":{\"540\":1}}],[\"all操作符返回两个查询的结果集的并集\",{\"1\":{\"540\":1}}],[\"all关键字分隔\",{\"1\":{\"540\":1}}],[\"all\",{\"0\":{\"540\":1},\"1\":{\"446\":1,\"540\":2,\"541\":2,\"578\":2,\"701\":2,\"702\":1,\"704\":3,\"831\":4,\"832\":2}}],[\"allargsconstructor\",{\"1\":{\"443\":1}}],[\"allowpublickeyretrieval=true\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"all<\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1,\"446\":1}}],[\"allpathssourcetarget\",{\"1\":{\"224\":1}}],[\"allpath\",{\"1\":{\"224\":5}}],[\"a的值\",{\"1\":{\"299\":1}}],[\"a的值被d的值覆盖了\",{\"1\":{\"299\":1}}],[\"a$\",{\"1\":{\"299\":1}}],[\"apache\",{\"1\":{\"406\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":2,\"431\":1,\"441\":3,\"468\":3}}],[\"api<\",{\"1\":{\"423\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"api名称为\",{\"1\":{\"422\":1}}],[\"api\",{\"1\":{\"274\":1,\"402\":1,\"421\":3,\"429\":1,\"431\":1,\"432\":2,\"441\":3,\"447\":1,\"474\":1,\"477\":1,\"486\":1,\"487\":2,\"635\":1}}],[\"app\",{\"1\":{\"422\":1}}],[\"apply\",{\"1\":{\"497\":1,\"504\":1}}],[\"apply方法\",{\"1\":{\"497\":1,\"504\":1}}],[\"applicaiton\",{\"1\":{\"452\":1}}],[\"applicable\",{\"1\":{\"429\":1}}],[\"application\",{\"1\":{\"402\":2,\"403\":4,\"404\":2,\"408\":1,\"419\":2,\"420\":1,\"422\":2,\"423\":1,\"429\":3,\"432\":2,\"443\":1,\"450\":2,\"452\":5,\"463\":3,\"464\":2,\"469\":2,\"489\":2}}],[\"apple\",{\"1\":{\"110\":3}}],[\"applepenapple\",{\"1\":{\"110\":2}}],[\"appender\",{\"1\":{\"429\":2}}],[\"append\",{\"1\":{\"193\":2,\"329\":1}}],[\"ai\",{\"1\":{\"257\":1}}],[\"a2\",{\"1\":{\"257\":1}}],[\"a1\",{\"1\":{\"257\":1}}],[\"asc\",{\"1\":{\"565\":1,\"687\":4,\"725\":1}}],[\"ascii\",{\"1\":{\"246\":1,\"249\":1,\"552\":1}}],[\"asin\",{\"1\":{\"549\":1}}],[\"asia\",{\"1\":{\"492\":4,\"767\":1,\"771\":1}}],[\"async\",{\"1\":{\"474\":1}}],[\"asynccommitting\",{\"1\":{\"428\":1}}],[\"as\",{\"1\":{\"429\":1,\"431\":3,\"521\":2,\"565\":1,\"578\":4,\"579\":2,\"587\":2,\"599\":3,\"608\":4,\"617\":1,\"710\":2,\"883\":1}}],[\"assert\",{\"1\":{\"312\":2}}],[\"aslist\",{\"1\":{\"177\":1,\"179\":1,\"193\":16,\"245\":1,\"504\":1}}],[\"a改为a\",{\"1\":{\"232\":2}}],[\"attrs\",{\"0\":{\"874\":1}}],[\"atomic\",{\"1\":{\"782\":1}}],[\"atomicity\",{\"1\":{\"741\":1}}],[\"atan2\",{\"1\":{\"549\":1}}],[\"atan\",{\"1\":{\"549\":1}}],[\"atguigu4<\",{\"1\":{\"832\":1}}],[\"atguigu01\",{\"1\":{\"806\":1}}],[\"atguiguvalue2\",{\"1\":{\"499\":1}}],[\"atguiguvalue1\",{\"1\":{\"499\":1}}],[\"atguigu2\",{\"1\":{\"499\":1}}],[\"atguigu1\",{\"1\":{\"499\":1}}],[\"atguigu\",{\"1\":{\"402\":1,\"432\":3,\"441\":1,\"442\":1,\"443\":2,\"452\":1,\"470\":1,\"493\":2,\"502\":2,\"504\":2,\"699\":5,\"809\":2,\"831\":10,\"832\":6}}],[\"at\",{\"1\":{\"390\":2,\"399\":1,\"426\":2,\"429\":1,\"431\":7,\"432\":2,\"436\":1,\"606\":1,\"699\":1,\"753\":1}}],[\"atlantic\",{\"1\":{\"234\":4}}],[\"atl\",{\"1\":{\"212\":8}}],[\"ate\",{\"1\":{\"164\":2}}],[\"africa\",{\"1\":{\"767\":1,\"771\":1}}],[\"affected\",{\"1\":{\"767\":1,\"771\":2,\"809\":1,\"832\":2}}],[\"after=2024\",{\"1\":{\"492\":1}}],[\"after\",{\"0\":{\"492\":1},\"1\":{\"436\":2,\"491\":2,\"492\":2}}],[\"af\",{\"1\":{\"192\":1}}],[\"ae\",{\"1\":{\"192\":1}}],[\"aec\",{\"1\":{\"138\":1,\"145\":1}}],[\"admin\",{\"1\":{\"836\":1}}],[\"adapter<\",{\"1\":{\"423\":1}}],[\"adapter\",{\"1\":{\"422\":1}}],[\"ad\",{\"1\":{\"192\":1}}],[\"addtime\",{\"1\":{\"557\":2}}],[\"adddate\",{\"1\":{\"557\":1}}],[\"addorder\",{\"1\":{\"446\":1,\"464\":1}}],[\"addpay\",{\"1\":{\"443\":1,\"464\":2}}],[\"addresponseheader\",{\"1\":{\"501\":1}}],[\"address\",{\"1\":{\"464\":1,\"489\":1,\"608\":3}}],[\"addrequestparameter=customerid\",{\"1\":{\"500\":1}}],[\"addrequestparameter\",{\"1\":{\"500\":1}}],[\"addrequestheader=x\",{\"1\":{\"499\":2}}],[\"addrequestheader\",{\"1\":{\"499\":1}}],[\"addr\",{\"1\":{\"402\":2,\"403\":2,\"404\":4,\"408\":1,\"419\":2,\"420\":1,\"422\":1,\"429\":2,\"432\":2}}],[\"addall\",{\"1\":{\"20\":1}}],[\"add\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"6\":1,\"7\":1,\"8\":1,\"12\":13,\"14\":5,\"16\":4,\"18\":4,\"20\":3,\"22\":4,\"24\":3,\"26\":3,\"28\":3,\"29\":3,\"31\":3,\"33\":6,\"35\":3,\"39\":12,\"43\":6,\"54\":3,\"56\":1,\"60\":3,\"165\":2,\"168\":2,\"171\":2,\"177\":5,\"179\":1,\"187\":4,\"188\":1,\"190\":4,\"191\":2,\"193\":2,\"195\":4,\"197\":2,\"199\":4,\"201\":4,\"203\":5,\"205\":3,\"207\":6,\"209\":4,\"211\":2,\"213\":3,\"215\":3,\"224\":5,\"234\":3,\"245\":1,\"296\":2,\"311\":3,\"362\":1,\"368\":1,\"392\":1,\"395\":1,\"423\":1,\"431\":3,\"443\":4,\"446\":2,\"464\":2,\"557\":4,\"588\":1,\"615\":1,\"616\":1,\"618\":1,\"687\":1}}],[\"a~z的ascii为\",{\"1\":{\"163\":1}}],[\"annsal\",{\"1\":{\"587\":3}}],[\"annotation\",{\"1\":{\"423\":2,\"432\":1}}],[\"annotation<\",{\"1\":{\"423\":1}}],[\"ansi\",{\"1\":{\"516\":1}}],[\"any\",{\"1\":{\"429\":1,\"578\":1}}],[\"an\",{\"1\":{\"257\":1,\"429\":1}}],[\"anagram\",{\"1\":{\"161\":1}}],[\"andequalto\",{\"1\":{\"432\":2}}],[\"and\",{\"1\":{\"110\":1,\"405\":1,\"429\":1,\"474\":1,\"491\":1,\"533\":1,\"534\":1,\"565\":1,\"569\":1,\"573\":3,\"578\":2,\"579\":1,\"617\":1,\"696\":1,\"705\":1,\"710\":2,\"715\":3,\"716\":1,\"718\":2,\"728\":1,\"767\":1,\"771\":1,\"777\":1,\"809\":1,\"822\":1}}],[\"aaca\",{\"1\":{\"327\":1}}],[\"aab\",{\"1\":{\"198\":1}}],[\"aa\",{\"1\":{\"154\":2,\"198\":1,\"327\":1}}],[\"aaa\",{\"1\":{\"154\":2}}],[\"acid四个特性\",{\"1\":{\"741\":1}}],[\"acos\",{\"1\":{\"549\":1}}],[\"accuracy\",{\"1\":{\"612\":1}}],[\"accessors\",{\"1\":{\"444\":1}}],[\"access\",{\"1\":{\"444\":3}}],[\"accountcontroller\",{\"1\":{\"434\":2}}],[\"accountserviceimpl\",{\"1\":{\"434\":2}}],[\"accountservice\",{\"1\":{\"434\":6}}],[\"accountmapper\",{\"1\":{\"434\":4}}],[\"accountfeignapi\",{\"1\":{\"431\":3,\"432\":3}}],[\"account\",{\"0\":{\"434\":1},\"1\":{\"431\":15,\"434\":2,\"435\":1}}],[\"action\",{\"1\":{\"618\":1,\"694\":1}}],[\"action方式\",{\"1\":{\"618\":1}}],[\"active\",{\"1\":{\"403\":7,\"742\":1}}],[\"actuator\",{\"1\":{\"402\":1,\"432\":1,\"446\":1}}],[\"actuator<\",{\"1\":{\"402\":2,\"432\":1,\"443\":1,\"446\":1,\"489\":1}}],[\"ac\",{\"1\":{\"152\":1,\"153\":1,\"699\":1}}],[\"ace\",{\"1\":{\"138\":3,\"145\":1}}],[\"axc\",{\"1\":{\"145\":1}}],[\"ahbgdc\",{\"1\":{\"145\":2}}],[\"aborted\",{\"1\":{\"742\":2}}],[\"abel\",{\"1\":{\"569\":3}}],[\"abel533\",{\"1\":{\"442\":1}}],[\"ab\",{\"1\":{\"528\":2,\"606\":1}}],[\"abbaca\",{\"1\":{\"327\":2}}],[\"ababcbacadefegde\",{\"1\":{\"367\":1}}],[\"ababcbacadefegdehijhklij\",{\"1\":{\"367\":1}}],[\"ababcbaca\",{\"1\":{\"367\":1}}],[\"aba\",{\"1\":{\"260\":1,\"261\":1}}],[\"abc123\",{\"1\":{\"825\":1}}],[\"abcd\",{\"1\":{\"252\":1,\"715\":1,\"716\":1}}],[\"abcdefg\",{\"1\":{\"252\":1,\"710\":1}}],[\"abcde\",{\"1\":{\"138\":3,\"145\":1}}],[\"abc\",{\"1\":{\"138\":4,\"145\":1,\"154\":1,\"717\":2,\"718\":1}}],[\"abstractgatewayfilterfactory<config>\",{\"1\":{\"504\":2}}],[\"abstractroutepredicatefactory<myroutepredicatefactory\",{\"1\":{\"497\":1}}],[\"abstractroutepredicatefactory<config>\",{\"1\":{\"497\":1}}],[\"abs\",{\"1\":{\"37\":2,\"354\":2,\"548\":1}}],[\"a+d\",{\"1\":{\"97\":1}}],[\"ar\",{\"1\":{\"699\":1}}],[\"archive\",{\"1\":{\"635\":1}}],[\"artifactid>\",{\"1\":{\"399\":1,\"402\":14,\"403\":2,\"408\":1,\"419\":1,\"422\":4,\"423\":4,\"432\":17,\"441\":14,\"442\":14,\"443\":13,\"446\":7,\"450\":3,\"452\":2,\"459\":1,\"463\":1,\"468\":2,\"477\":2,\"480\":1,\"481\":1,\"482\":1,\"486\":11,\"489\":4}}],[\"arr\",{\"1\":{\"256\":10}}],[\"arraypairsum\",{\"1\":{\"259\":1}}],[\"arraylist\",{\"1\":{\"224\":1}}],[\"arraylist<int\",{\"1\":{\"296\":1}}],[\"arraylist<integer>\",{\"1\":{\"2\":2,\"3\":1,\"4\":1,\"6\":2,\"7\":1,\"8\":1,\"12\":1,\"16\":1,\"20\":1,\"22\":1,\"56\":1,\"234\":1,\"311\":1,\"368\":1}}],[\"arraylist<list<integer>>\",{\"1\":{\"177\":2,\"179\":1,\"187\":2,\"190\":2,\"191\":1,\"311\":1}}],[\"arraylist<list<string>>\",{\"1\":{\"165\":1}}],[\"arraylist<string>\",{\"1\":{\"39\":3,\"165\":1,\"215\":1,\"245\":1}}],[\"arraylist<double>\",{\"1\":{\"18\":1}}],[\"arraylist<>\",{\"1\":{\"3\":1,\"4\":1,\"7\":1,\"8\":1,\"12\":4,\"14\":2,\"16\":1,\"18\":1,\"20\":2,\"22\":1,\"39\":3,\"56\":1,\"60\":1,\"165\":1,\"177\":2,\"179\":1,\"187\":4,\"190\":4,\"191\":2,\"193\":1,\"195\":4,\"197\":3,\"199\":6,\"201\":4,\"203\":7,\"205\":4,\"207\":6,\"209\":6,\"211\":3,\"215\":2,\"222\":2,\"224\":4,\"234\":2,\"245\":1,\"296\":1,\"311\":2,\"368\":1}}],[\"arrays\",{\"1\":{\"83\":1,\"92\":1,\"95\":1,\"97\":1,\"103\":1,\"105\":1,\"107\":1,\"109\":1,\"115\":2,\"133\":1,\"163\":2,\"165\":1,\"168\":1,\"177\":3,\"179\":2,\"193\":16,\"197\":1,\"205\":1,\"211\":2,\"215\":1,\"245\":1,\"259\":1,\"268\":1,\"283\":1,\"296\":1,\"344\":2,\"354\":2,\"360\":2,\"362\":1,\"364\":2,\"366\":1,\"444\":1,\"504\":1}}],[\"arraydeque<integer>\",{\"1\":{\"335\":1}}],[\"arraydeque<node>\",{\"1\":{\"24\":1}}],[\"arraydeque<treenode>\",{\"1\":{\"18\":1,\"26\":1,\"28\":1,\"35\":1}}],[\"arraydeque<>\",{\"1\":{\"12\":3,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"26\":1,\"28\":1,\"29\":1,\"31\":1,\"35\":1,\"39\":2,\"43\":2,\"54\":1,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"335\":1}}],[\"area++\",{\"1\":{\"228\":3}}],[\"area\",{\"1\":{\"228\":6}}],[\"args\",{\"1\":{\"91\":1,\"403\":2,\"432\":2,\"443\":2,\"444\":1,\"446\":4,\"463\":2,\"464\":2,\"489\":2,\"491\":3}}],[\"a\",{\"1\":{\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"23\":1,\"24\":1,\"26\":1,\"28\":1,\"31\":2,\"35\":1,\"37\":1,\"97\":8,\"117\":1,\"152\":1,\"153\":1,\"154\":4,\"163\":4,\"164\":2,\"177\":1,\"178\":4,\"192\":1,\"193\":2,\"198\":4,\"213\":2,\"232\":7,\"244\":2,\"249\":4,\"276\":9,\"354\":2,\"362\":6,\"364\":4,\"366\":2,\"368\":2,\"390\":5,\"391\":2,\"405\":1,\"429\":1,\"528\":1,\"529\":2,\"552\":1,\"583\":2,\"607\":6,\"617\":1,\"689\":1,\"694\":1,\"699\":1,\"704\":5,\"705\":1,\"709\":1,\"710\":7,\"721\":2,\"725\":7,\"726\":1,\"729\":2,\"746\":7,\"772\":2,\"800\":3,\"809\":1,\"831\":1,\"870\":1}}],[\"n>1\",{\"1\":{\"810\":1}}],[\"nlpros\",{\"1\":{\"710\":2}}],[\"nlogn\",{\"1\":{\"337\":1}}],[\"ndbcluster\",{\"1\":{\"635\":1}}],[\"ndbinfo\",{\"1\":{\"635\":1}}],[\"n天以后的日期\",{\"1\":{\"557\":1}}],[\"nginx请求转发\",{\"1\":{\"487\":1}}],[\"nginx都作为网关\",{\"1\":{\"487\":1}}],[\"nginx是服务器负载均衡\",{\"1\":{\"457\":1}}],[\"nginx服务端负载均衡区别\",{\"1\":{\"457\":1}}],[\"n矩阵中某个元素为0\",{\"1\":{\"300\":1}}],[\"n2\",{\"1\":{\"287\":1}}],[\"n为字符串长度\",{\"1\":{\"256\":1}}],[\"n×n\",{\"1\":{\"214\":1}}],[\"nrt\",{\"1\":{\"213\":2}}],[\"n$\",{\"1\":{\"188\":1}}],[\"n就是树的宽度\",{\"1\":{\"187\":1}}],[\"n皇后是每一行只填充一个数\",{\"1\":{\"217\":1}}],[\"n皇后\",{\"1\":{\"183\":1,\"215\":1,\"218\":1}}],[\"n个数按一定规则全排列\",{\"1\":{\"183\":1,\"218\":1}}],[\"n个数里面按一定规则找出k个数的集合\",{\"1\":{\"183\":1,\"218\":1}}],[\"nas\",{\"1\":{\"632\":1}}],[\"name和gender上建立一个多列索引\",{\"1\":{\"686\":1}}],[\"name和其job\",{\"1\":{\"579\":1}}],[\"name和location\",{\"1\":{\"575\":1}}],[\"name指定要执行删除操作的表\",{\"1\":{\"542\":1}}],[\"name为索引名\",{\"1\":{\"687\":1}}],[\"name为\",{\"1\":{\"539\":1}}],[\"name要和配置中的instances保持一致\",{\"1\":{\"477\":1}}],[\"name=\",{\"1\":{\"442\":4}}],[\"name=com\",{\"1\":{\"442\":1}}],[\"name`\",{\"1\":{\"428\":2}}],[\"namespace主要用来实现隔离\",{\"1\":{\"404\":1}}],[\"namespace=public\",{\"1\":{\"404\":1}}],[\"namespace\",{\"0\":{\"404\":1},\"1\":{\"404\":3,\"419\":1,\"429\":2,\"432\":1}}],[\"name\",{\"1\":{\"402\":2,\"403\":3,\"404\":2,\"408\":1,\"419\":2,\"420\":1,\"422\":1,\"429\":2,\"432\":3,\"442\":3,\"443\":2,\"444\":2,\"450\":3,\"452\":4,\"464\":3,\"477\":1,\"480\":1,\"481\":1,\"482\":1,\"489\":3,\"491\":4,\"499\":3,\"500\":2,\"501\":4,\"520\":2,\"521\":2,\"529\":2,\"533\":10,\"534\":1,\"536\":2,\"538\":4,\"539\":4,\"541\":18,\"542\":3,\"562\":2,\"565\":1,\"569\":6,\"573\":2,\"575\":1,\"578\":2,\"579\":8,\"587\":3,\"608\":3,\"613\":1,\"615\":2,\"618\":3,\"619\":1,\"686\":1,\"687\":18,\"696\":4,\"715\":4,\"716\":1,\"717\":4,\"718\":5,\"728\":1,\"745\":1,\"751\":1,\"767\":1,\"771\":2,\"800\":2,\"806\":1,\"807\":1,\"809\":4,\"836\":2}}],[\"nacosdatasource<>\",{\"1\":{\"424\":1}}],[\"nacosdatasourceproperties\",{\"1\":{\"424\":1}}],[\"nacos<\",{\"1\":{\"419\":1}}],[\"nacos默认的命名空间是\",{\"1\":{\"404\":1}}],[\"nacosconfigclientcontroller\",{\"1\":{\"403\":2}}],[\"nacos端配置文件dataid的命名规则是\",{\"1\":{\"403\":1}}],[\"nacos作为配置中心地址\",{\"1\":{\"403\":1,\"404\":2}}],[\"nacos服务注册中心地址\",{\"1\":{\"403\":1,\"404\":2,\"408\":1,\"432\":1}}],[\"nacos配置说明\",{\"1\":{\"419\":1}}],[\"nacos配置规则\",{\"1\":{\"403\":1}}],[\"nacos配置\",{\"1\":{\"403\":1,\"404\":2}}],[\"nacos微服务提供者叫什么你写什么\",{\"1\":{\"402\":1}}],[\"nacos\",{\"1\":{\"399\":1,\"400\":1,\"401\":2,\"402\":15,\"403\":9,\"404\":4,\"408\":1,\"419\":2,\"420\":4,\"422\":4,\"424\":4,\"429\":8,\"432\":5},\"2\":{\"438\":1}}],[\"native\",{\"1\":{\"825\":1}}],[\"nat\",{\"1\":{\"164\":2}}],[\"nagaram\",{\"1\":{\"161\":1}}],[\"non\",{\"1\":{\"746\":1}}],[\"none\",{\"1\":{\"470\":1}}],[\"no值分别是0和1\",{\"1\":{\"680\":1}}],[\"no值为0和1的记录呢\",{\"1\":{\"680\":1}}],[\"now\",{\"1\":{\"554\":2,\"557\":9}}],[\"noargsconstructor\",{\"1\":{\"443\":1}}],[\"no\",{\"1\":{\"440\":2,\"618\":1,\"680\":1,\"715\":3,\"716\":1,\"717\":3,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"728\":1,\"809\":3,\"831\":10}}],[\"no`\",{\"1\":{\"440\":2}}],[\"normal\",{\"1\":{\"431\":3,\"737\":1}}],[\"nosuchmethoderror\",{\"1\":{\"422\":1}}],[\"notation\",{\"1\":{\"608\":1}}],[\"notempty\",{\"1\":{\"497\":1}}],[\"notes\",{\"1\":{\"454\":2}}],[\"not\",{\"0\":{\"720\":1},\"1\":{\"117\":2,\"428\":13,\"429\":2,\"431\":30,\"440\":7,\"585\":1,\"587\":1,\"595\":1,\"613\":1,\"614\":4,\"617\":3,\"618\":1,\"620\":2,\"676\":1,\"686\":1,\"720\":1,\"775\":1,\"889\":1}}],[\"node1\",{\"1\":{\"831\":4}}],[\"node节点的儿子节点不能选\",{\"1\":{\"117\":1}}],[\"nodes\",{\"1\":{\"49\":3}}],[\"node\",{\"1\":{\"6\":6,\"7\":3,\"11\":1,\"12\":15,\"13\":1,\"14\":6,\"15\":1,\"16\":7,\"17\":1,\"18\":7,\"20\":11,\"21\":1,\"22\":7,\"23\":5,\"24\":20,\"25\":1,\"26\":6,\"27\":1,\"28\":8,\"29\":5,\"30\":1,\"31\":14,\"32\":1,\"34\":1,\"35\":6,\"36\":1,\"37\":9,\"38\":1,\"39\":45,\"40\":1,\"41\":16,\"42\":1,\"43\":16,\"44\":1,\"45\":9,\"52\":1,\"53\":1,\"54\":7,\"55\":1,\"57\":1,\"59\":1,\"61\":2,\"65\":2,\"67\":1,\"69\":1,\"73\":2,\"116\":1,\"117\":6,\"224\":16,\"376\":2,\"377\":1,\"379\":16,\"380\":1,\"383\":1,\"385\":1,\"388\":1,\"390\":1,\"393\":1}}],[\"n−2\",{\"1\":{\"115\":1}}],[\"n−1\",{\"1\":{\"115\":1}}],[\"n=1\",{\"1\":{\"89\":1}}],[\"n=2\",{\"1\":{\"89\":1}}],[\"n+1\",{\"1\":{\"79\":1,\"81\":1,\"89\":1,\"299\":1,\"304\":4}}],[\"number\",{\"1\":{\"476\":2,\"668\":1}}],[\"numbers\",{\"1\":{\"240\":10,\"241\":2,\"242\":6}}],[\"numrows\",{\"1\":{\"309\":5,\"311\":2}}],[\"numenclaves\",{\"1\":{\"230\":2}}],[\"numislandsbfs\",{\"1\":{\"226\":1}}],[\"numislands\",{\"1\":{\"226\":1}}],[\"numdistinct\",{\"1\":{\"148\":1}}],[\"num\",{\"1\":{\"115\":2,\"211\":3,\"338\":3,\"565\":3}}],[\"numtrees\",{\"1\":{\"89\":1}}],[\"numsr\",{\"1\":{\"284\":2}}],[\"numsl+1\",{\"1\":{\"284\":1}}],[\"numsl\",{\"1\":{\"284\":1}}],[\"nums2都放入set集合中\",{\"1\":{\"167\":1}}],[\"nums2第j个元素的公共子序列的长度是dp\",{\"1\":{\"141\":1}}],[\"nums2中也应该元素1的后面\",{\"1\":{\"141\":1}}],[\"nums2以\",{\"1\":{\"137\":2}}],[\"nums2\",{\"1\":{\"136\":5,\"137\":12,\"139\":1,\"140\":10,\"141\":4,\"166\":5,\"168\":2}}],[\"nums1中元素1的后面\",{\"1\":{\"141\":1}}],[\"nums1\",{\"1\":{\"136\":5,\"137\":10,\"139\":1,\"140\":10,\"141\":4,\"166\":5,\"167\":1,\"168\":2}}],[\"numsquares\",{\"1\":{\"109\":1}}],[\"nums\",{\"1\":{\"47\":3,\"49\":3,\"50\":9,\"51\":11,\"71\":6,\"72\":7,\"94\":5,\"95\":11,\"98\":7,\"99\":14,\"104\":7,\"105\":5,\"112\":2,\"113\":15,\"114\":5,\"115\":20,\"132\":6,\"133\":7,\"134\":10,\"135\":4,\"142\":6,\"143\":10,\"174\":8,\"175\":11,\"176\":21,\"177\":38,\"178\":13,\"179\":29,\"201\":8,\"202\":6,\"203\":12,\"204\":5,\"205\":10,\"206\":5,\"207\":16,\"208\":7,\"209\":14,\"210\":5,\"211\":16,\"257\":5,\"259\":5,\"266\":4,\"268\":3,\"269\":8,\"271\":12,\"273\":20,\"275\":18,\"276\":19,\"277\":33,\"278\":12,\"280\":6,\"281\":3,\"282\":12,\"283\":17,\"284\":3,\"286\":4,\"290\":15,\"292\":6,\"293\":8,\"306\":5,\"308\":3,\"312\":20,\"313\":5,\"314\":6,\"315\":5,\"317\":9,\"333\":6,\"334\":9,\"335\":5,\"336\":4,\"338\":2,\"345\":7,\"346\":6,\"347\":6,\"348\":2,\"349\":5,\"350\":10,\"351\":13,\"352\":4,\"353\":11,\"354\":12}}],[\"null无法使用\",{\"0\":{\"720\":1}}],[\"null+unique\",{\"1\":{\"686\":1}}],[\"null值列表也不存在了\",{\"1\":{\"679\":1}}],[\"null值列表\",{\"0\":{\"679\":1}}],[\"null方式\",{\"1\":{\"618\":1}}],[\"null时\",{\"1\":{\"606\":1}}],[\"nullif\",{\"1\":{\"552\":1}}],[\"null不等同于0或者\",{\"1\":{\"523\":1}}],[\"null$\",{\"1\":{\"62\":1,\"386\":1}}],[\"null\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"6\":3,\"7\":3,\"8\":3,\"11\":2,\"12\":9,\"13\":2,\"14\":3,\"15\":3,\"16\":3,\"17\":2,\"18\":3,\"19\":14,\"20\":2,\"21\":1,\"22\":1,\"23\":2,\"24\":4,\"25\":3,\"26\":3,\"27\":6,\"28\":5,\"29\":2,\"31\":5,\"32\":2,\"33\":12,\"35\":4,\"36\":4,\"37\":3,\"38\":1,\"39\":18,\"40\":2,\"41\":9,\"42\":3,\"43\":7,\"44\":4,\"45\":8,\"46\":2,\"47\":1,\"48\":2,\"49\":1,\"50\":5,\"51\":1,\"52\":6,\"53\":1,\"54\":9,\"55\":2,\"56\":2,\"57\":2,\"58\":1,\"59\":1,\"60\":1,\"61\":4,\"62\":9,\"63\":6,\"65\":8,\"66\":5,\"67\":9,\"68\":8,\"69\":5,\"70\":8,\"71\":4,\"72\":1,\"73\":14,\"74\":1,\"113\":1,\"115\":1,\"116\":3,\"117\":1,\"128\":1,\"193\":1,\"317\":1,\"321\":3,\"371\":5,\"378\":1,\"382\":5,\"386\":1,\"387\":2,\"389\":4,\"390\":3,\"392\":8,\"393\":2,\"395\":2,\"424\":1,\"428\":9,\"431\":36,\"432\":1,\"440\":7,\"444\":2,\"503\":1,\"523\":1,\"528\":7,\"537\":1,\"541\":5,\"606\":1,\"613\":1,\"614\":4,\"617\":4,\"618\":2,\"620\":2,\"676\":3,\"679\":1,\"701\":11,\"704\":5,\"710\":1,\"720\":2,\"728\":1}}],[\"n叉树我们只需要改变入队规则\",{\"1\":{\"20\":1}}],[\"n记录每一层的结点个数\",{\"1\":{\"12\":1}}],[\"n\",{\"1\":{\"12\":8,\"14\":2,\"19\":1,\"78\":11,\"79\":5,\"80\":4,\"81\":7,\"84\":6,\"85\":6,\"86\":4,\"87\":7,\"88\":6,\"89\":4,\"91\":1,\"100\":6,\"101\":5,\"108\":5,\"109\":5,\"115\":1,\"151\":2,\"169\":5,\"171\":15,\"172\":6,\"173\":15,\"178\":2,\"186\":6,\"187\":10,\"188\":6,\"189\":5,\"190\":10,\"191\":8,\"193\":2,\"214\":8,\"215\":19,\"223\":5,\"225\":2,\"227\":3,\"229\":3,\"230\":2,\"231\":3,\"232\":2,\"233\":4,\"249\":4,\"253\":4,\"254\":3,\"256\":1,\"257\":4,\"269\":2,\"273\":1,\"274\":7,\"275\":1,\"276\":9,\"277\":2,\"284\":1,\"287\":5,\"288\":1,\"289\":7,\"297\":4,\"298\":9,\"299\":68,\"303\":4,\"304\":6,\"305\":8,\"336\":3,\"345\":1,\"347\":1,\"351\":5,\"355\":4,\"359\":3,\"369\":6,\"370\":2,\"383\":3,\"388\":5,\"389\":2,\"390\":3,\"533\":1,\"549\":1,\"552\":6,\"557\":3,\"562\":1,\"658\":1,\"680\":2,\"729\":1,\"737\":2,\"832\":1}}],[\"never\",{\"1\":{\"467\":1}}],[\"net\",{\"1\":{\"454\":1}}],[\"nettee\",{\"1\":{\"12\":1}}],[\"need\",{\"1\":{\"431\":3}}],[\"next就分别代表本页的上一个和下一个页的页号\",{\"1\":{\"668\":1}}],[\"next一定是\",{\"1\":{\"395\":1}}],[\"next指向交换后后的结点\",{\"1\":{\"387\":1}}],[\"nexthead\",{\"1\":{\"387\":3}}],[\"next$\",{\"1\":{\"377\":3,\"389\":1}}],[\"nextdistance\",{\"1\":{\"352\":7}}],[\"nexty\",{\"1\":{\"226\":7,\"228\":7,\"230\":6,\"232\":7,\"234\":6}}],[\"nextx\",{\"1\":{\"226\":7,\"228\":7,\"230\":7,\"232\":8,\"234\":6}}],[\"next\",{\"0\":{\"777\":1},\"1\":{\"23\":6,\"24\":5,\"377\":2,\"378\":8,\"379\":4,\"381\":2,\"382\":5,\"384\":21,\"386\":1,\"387\":6,\"389\":10,\"392\":4,\"393\":1,\"395\":1,\"643\":1,\"668\":1,\"680\":1,\"777\":2,\"778\":1}}],[\"newhead\",{\"1\":{\"386\":2,\"387\":3}}],[\"newarraylist\",{\"1\":{\"215\":3}}],[\"new\",{\"1\":{\"0\":2,\"2\":1,\"3\":1,\"4\":1,\"6\":2,\"7\":2,\"8\":2,\"12\":7,\"14\":3,\"16\":2,\"18\":2,\"20\":3,\"22\":2,\"24\":1,\"26\":1,\"28\":1,\"29\":1,\"31\":1,\"33\":1,\"35\":1,\"39\":7,\"41\":1,\"43\":2,\"45\":1,\"47\":2,\"49\":2,\"51\":1,\"54\":1,\"56\":1,\"60\":2,\"66\":4,\"72\":1,\"79\":1,\"81\":1,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"91\":1,\"92\":1,\"95\":1,\"97\":1,\"99\":1,\"101\":1,\"103\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":2,\"113\":1,\"115\":1,\"117\":2,\"120\":1,\"122\":1,\"124\":1,\"126\":2,\"128\":1,\"130\":1,\"133\":1,\"137\":1,\"139\":1,\"141\":1,\"143\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":1,\"153\":1,\"155\":1,\"157\":1,\"163\":3,\"165\":3,\"168\":3,\"171\":2,\"175\":3,\"177\":4,\"179\":1,\"187\":6,\"190\":6,\"191\":3,\"193\":4,\"195\":4,\"197\":3,\"199\":6,\"201\":4,\"203\":7,\"205\":4,\"207\":8,\"209\":6,\"211\":4,\"213\":5,\"215\":2,\"222\":2,\"224\":5,\"226\":4,\"228\":4,\"230\":3,\"232\":3,\"234\":4,\"242\":1,\"245\":1,\"248\":1,\"254\":1,\"256\":1,\"262\":1,\"275\":4,\"283\":1,\"289\":1,\"296\":2,\"298\":1,\"302\":2,\"305\":1,\"311\":2,\"321\":1,\"323\":2,\"326\":1,\"329\":2,\"332\":1,\"335\":2,\"338\":4,\"360\":1,\"362\":2,\"368\":2,\"378\":1,\"384\":1,\"389\":1,\"392\":1,\"395\":1,\"402\":1,\"416\":1,\"422\":1,\"423\":6,\"424\":3,\"443\":1,\"444\":2,\"462\":2,\"467\":1,\"477\":1,\"497\":1,\"504\":1}}],[\"pxxxxxx\",{\"1\":{\"831\":2}}],[\"p密码\",{\"1\":{\"831\":1}}],[\"ppass\",{\"1\":{\"809\":1}}],[\"phantom\",{\"1\":{\"746\":1}}],[\"ptr\",{\"1\":{\"681\":1}}],[\"pk\",{\"1\":{\"618\":1}}],[\"pwd\",{\"1\":{\"615\":1}}],[\"player\",{\"1\":{\"565\":5,\"736\":1,\"737\":1,\"791\":1}}],[\"plugin\",{\"1\":{\"869\":1}}],[\"plugins>\",{\"1\":{\"402\":2,\"442\":1,\"443\":1,\"446\":1,\"489\":1}}],[\"plugin>\",{\"1\":{\"402\":2,\"442\":3,\"443\":1,\"446\":1,\"489\":1}}],[\"plugin<\",{\"1\":{\"402\":2,\"442\":2,\"443\":1,\"446\":1,\"489\":1}}],[\"pi\",{\"1\":{\"548\":1}}],[\"pct\",{\"1\":{\"523\":2}}],[\"pct可能存在null的情况\",{\"1\":{\"523\":1}}],[\"p2俩个参数\",{\"1\":{\"417\":1}}],[\"p2\",{\"1\":{\"417\":3}}],[\"p1的参数值等于5时\",{\"1\":{\"417\":1}}],[\"p1等于零直接异常\",{\"1\":{\"416\":1}}],[\"p1\",{\"1\":{\"416\":8,\"417\":4}}],[\"pb会同时到达相交结点直接返回即可\",{\"1\":{\"391\":1}}],[\"pb\",{\"1\":{\"391\":3,\"392\":5}}],[\"pbrother\",{\"1\":{\"145\":1}}],[\"pq\",{\"1\":{\"338\":3}}],[\"png\",{\"1\":{\"299\":1,\"429\":1,\"509\":1}}],[\"ps\",{\"1\":{\"184\":1}}],[\"performance\",{\"1\":{\"635\":1}}],[\"period\",{\"1\":{\"557\":2}}],[\"persistence<\",{\"1\":{\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"persistence\",{\"1\":{\"432\":1,\"441\":3,\"442\":1,\"443\":1}}],[\"person\",{\"1\":{\"362\":3}}],[\"permittednumberofcallsinhalfopenstate\",{\"1\":{\"477\":1,\"478\":1}}],[\"permitted\",{\"1\":{\"476\":1}}],[\"permissions\",{\"1\":{\"429\":1}}],[\"permuteunique\",{\"1\":{\"211\":1}}],[\"permute\",{\"1\":{\"209\":1}}],[\"people\",{\"1\":{\"361\":7,\"362\":4}}],[\"pen\",{\"1\":{\"110\":2}}],[\"peeklast\",{\"1\":{\"335\":1}}],[\"peek\",{\"1\":{\"24\":1,\"321\":7,\"323\":2,\"329\":1,\"335\":2}}],[\"pad\",{\"1\":{\"552\":2}}],[\"page最小记录\",{\"1\":{\"667\":1}}],[\"page\",{\"0\":{\"673\":1,\"674\":1},\"1\":{\"645\":1,\"666\":1,\"667\":1,\"668\":9,\"680\":1,\"753\":3,\"810\":1,\"883\":1}}],[\"pages\",{\"1\":{\"485\":1}}],[\"pageable\",{\"1\":{\"463\":2}}],[\"page<store>\",{\"1\":{\"463\":1}}],[\"pause\",{\"1\":{\"454\":1}}],[\"patterns\",{\"1\":{\"493\":1}}],[\"pattern\",{\"1\":{\"444\":2}}],[\"path为日志文件所在的目录路径\",{\"1\":{\"807\":1}}],[\"path=\",{\"1\":{\"422\":1,\"489\":2,\"499\":3,\"500\":1,\"502\":1}}],[\"pathvariable\",{\"1\":{\"402\":2,\"416\":3,\"420\":1,\"443\":2,\"446\":1,\"463\":2,\"464\":3,\"477\":3,\"480\":1,\"481\":1,\"482\":1}}],[\"path保存行程\",{\"1\":{\"213\":1}}],[\"path集合中\",{\"1\":{\"209\":1}}],[\"path\",{\"0\":{\"493\":1},\"1\":{\"39\":12,\"195\":9,\"197\":5,\"199\":11,\"201\":14,\"203\":10,\"205\":5,\"207\":19,\"209\":15,\"211\":6,\"213\":13,\"222\":1,\"224\":11,\"429\":1,\"493\":1,\"806\":2,\"807\":1}}],[\"packaging>\",{\"1\":{\"441\":1}}],[\"package\",{\"1\":{\"432\":1,\"442\":4,\"443\":1,\"452\":1}}],[\"pacific\",{\"1\":{\"234\":4}}],[\"pacificatlantic\",{\"1\":{\"234\":1}}],[\"paycircuitcontroller中当id\",{\"1\":{\"477\":1}}],[\"paycircuitcontroller\",{\"1\":{\"477\":2}}],[\"paycontroller\",{\"1\":{\"443\":2}}],[\"payfeignapi\",{\"1\":{\"464\":7,\"470\":1,\"477\":3,\"480\":1,\"481\":1,\"482\":1}}],[\"payfeignsentinelapi\",{\"1\":{\"420\":2}}],[\"payfeignsentinelapifallback\",{\"1\":{\"420\":2}}],[\"payno\",{\"1\":{\"443\":1}}],[\"paydto\",{\"1\":{\"443\":5,\"446\":4,\"464\":6}}],[\"paymapper\",{\"1\":{\"443\":7}}],[\"payment8001\",{\"1\":{\"477\":1}}],[\"paymentsrv\",{\"1\":{\"446\":3,\"451\":1,\"459\":1}}],[\"paymentinfo\",{\"1\":{\"402\":1}}],[\"payment\",{\"1\":{\"402\":2,\"420\":2,\"443\":1,\"450\":1,\"451\":2,\"452\":1,\"459\":1,\"460\":1,\"464\":1,\"466\":1,\"477\":2,\"478\":1,\"480\":2,\"481\":2,\"482\":2,\"489\":2,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":1}}],[\"payment9001\",{\"1\":{\"402\":2}}],[\"payserviceimpl\",{\"1\":{\"443\":2}}],[\"payservice\",{\"1\":{\"443\":9}}],[\"pay表包名\",{\"1\":{\"442\":1}}],[\"pay17203699\",{\"1\":{\"440\":1}}],[\"pay`\",{\"1\":{\"440\":2}}],[\"pay\",{\"1\":{\"402\":3,\"420\":1,\"422\":4,\"423\":1,\"440\":3,\"442\":2,\"443\":26,\"446\":4,\"451\":1,\"459\":3,\"464\":6,\"477\":5,\"480\":1,\"481\":1,\"482\":1,\"489\":6,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":6,\"500\":2,\"502\":2}}],[\"payalibabacontroller\",{\"1\":{\"402\":2}}],[\"pa\",{\"1\":{\"391\":2,\"392\":6}}],[\"password=\",{\"1\":{\"442\":1,\"826\":1}}],[\"password\",{\"1\":{\"255\":5,\"256\":7,\"429\":4,\"431\":3,\"432\":1,\"442\":2,\"443\":1,\"444\":1,\"452\":1,\"825\":1}}],[\"part\",{\"1\":{\"831\":1}}],[\"partially\",{\"1\":{\"742\":1}}],[\"partitions\",{\"1\":{\"701\":1}}],[\"partitionlabels\",{\"1\":{\"368\":1}}],[\"partition\",{\"1\":{\"199\":1}}],[\"part3\",{\"1\":{\"704\":1}}],[\"part2\",{\"1\":{\"704\":1}}],[\"parent<\",{\"1\":{\"441\":1}}],[\"parser\",{\"0\":{\"628\":1}}],[\"parseobject\",{\"1\":{\"424\":1}}],[\"parseorigin\",{\"1\":{\"418\":1}}],[\"parseint\",{\"1\":{\"370\":1}}],[\"paramflowitemlist\",{\"1\":{\"419\":2}}],[\"paramidx\",{\"1\":{\"419\":2}}],[\"param\",{\"1\":{\"85\":2,\"190\":4,\"191\":4,\"215\":3,\"419\":1,\"434\":2,\"445\":1,\"446\":1,\"464\":2,\"477\":1,\"480\":1,\"481\":1,\"494\":1,\"503\":2}}],[\"p都小说明在root的左右边\",{\"1\":{\"64\":1}}],[\"p都小\",{\"1\":{\"64\":1}}],[\"p都大说明在root的左边\",{\"1\":{\"64\":1}}],[\"p都大\",{\"1\":{\"64\":1}}],[\"p$\",{\"1\":{\"62\":1}}],[\"p\",{\"1\":{\"61\":7,\"62\":7,\"63\":5,\"64\":8,\"81\":3,\"193\":2,\"378\":7,\"698\":1,\"831\":7,\"832\":5}}],[\"proot\",{\"1\":{\"809\":1}}],[\"province\",{\"1\":{\"608\":3}}],[\"provider\",{\"1\":{\"402\":4,\"420\":2,\"477\":1}}],[\"programdata\",{\"1\":{\"809\":2}}],[\"programmercarl\",{\"1\":{\"279\":1,\"282\":1}}],[\"prog\",{\"1\":{\"578\":6}}],[\"probability\",{\"1\":{\"486\":1}}],[\"problems\",{\"1\":{\"12\":1,\"73\":1}}],[\"project>\",{\"1\":{\"441\":1}}],[\"project\",{\"1\":{\"441\":1,\"836\":1}}],[\"projectlombok<\",{\"1\":{\"402\":2,\"432\":1,\"441\":1,\"442\":2,\"443\":1,\"446\":1}}],[\"proxy\",{\"1\":{\"432\":1}}],[\"productid=1\",{\"1\":{\"435\":1}}],[\"productid\",{\"1\":{\"433\":6}}],[\"product\",{\"1\":{\"433\":1}}],[\"prod\",{\"1\":{\"403\":1,\"404\":2}}],[\"profiles\",{\"1\":{\"403\":4}}],[\"profile\",{\"1\":{\"403\":2,\"452\":2}}],[\"properties>\",{\"1\":{\"441\":1}}],[\"properties\",{\"1\":{\"403\":2,\"431\":1,\"442\":2}}],[\"prev和fil\",{\"1\":{\"668\":1}}],[\"prev\",{\"1\":{\"668\":1}}],[\"predicate<serverwebexchange>\",{\"1\":{\"497\":1}}],[\"predicate断言\",{\"0\":{\"491\":1}}],[\"predicate\",{\"1\":{\"488\":2}}],[\"predicates\",{\"1\":{\"422\":1,\"489\":2,\"491\":2,\"492\":4,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":1}}],[\"prefer\",{\"1\":{\"464\":1,\"489\":1}}],[\"prefixpath=\",{\"1\":{\"502\":1}}],[\"prefixpath\",{\"1\":{\"502\":2,\"504\":1}}],[\"prefix\",{\"1\":{\"403\":4}}],[\"precedence\",{\"1\":{\"423\":1}}],[\"pre指向上一结点\",{\"1\":{\"381\":1}}],[\"pre表示上一结点\",{\"1\":{\"381\":1}}],[\"pre$\",{\"1\":{\"381\":1}}],[\"pre\",{\"1\":{\"58\":3,\"60\":3,\"115\":6,\"382\":7,\"384\":6,\"488\":1}}],[\"preend\",{\"1\":{\"49\":3}}],[\"prestart\",{\"1\":{\"49\":6}}],[\"preorder保证\",{\"1\":{\"48\":1}}],[\"preorder\",{\"1\":{\"48\":9,\"49\":7}}],[\"preordertraversal2\",{\"1\":{\"6\":1}}],[\"preordertraversal\",{\"1\":{\"2\":3}}],[\"privileges\",{\"1\":{\"825\":1}}],[\"private\",{\"1\":{\"33\":1,\"51\":1,\"58\":2,\"60\":4,\"201\":2,\"213\":4,\"215\":3,\"217\":2,\"226\":1,\"402\":3,\"403\":1,\"423\":3,\"424\":2,\"432\":4,\"433\":2,\"434\":1,\"443\":5,\"444\":8,\"446\":1,\"459\":1,\"464\":1,\"477\":1,\"497\":1,\"503\":1,\"504\":1}}],[\"primary\",{\"1\":{\"428\":4,\"431\":3,\"440\":1,\"613\":1,\"616\":5,\"617\":3,\"618\":6,\"619\":1,\"620\":1,\"643\":1,\"687\":2}}],[\"priorityqueue<>\",{\"1\":{\"338\":1}}],[\"priorityqueue<int\",{\"1\":{\"338\":1}}],[\"priorityqueue默认创建的就是小顶堆\",{\"1\":{\"338\":1}}],[\"price\",{\"1\":{\"120\":5}}],[\"prices\",{\"1\":{\"119\":5,\"120\":13,\"121\":7,\"122\":28,\"123\":6,\"124\":16,\"125\":6,\"126\":15,\"127\":5,\"128\":18,\"129\":10,\"130\":7}}],[\"printstacktrace\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"print\",{\"1\":{\"91\":1,\"278\":1}}],[\"println\",{\"1\":{\"39\":3,\"83\":1,\"91\":1,\"92\":1,\"103\":1,\"105\":1,\"280\":1,\"410\":1,\"432\":4,\"443\":1,\"444\":3,\"445\":1,\"464\":2,\"481\":2,\"503\":1,\"504\":1}}],[\"pointer\",{\"1\":{\"794\":2}}],[\"points\",{\"1\":{\"363\":7,\"364\":13}}],[\"power\",{\"1\":{\"550\":1}}],[\"powerful\",{\"1\":{\"405\":1}}],[\"pow\",{\"1\":{\"550\":1}}],[\"pool中的页面\",{\"1\":{\"749\":1}}],[\"pool\",{\"1\":{\"432\":1,\"443\":1,\"452\":1,\"481\":3}}],[\"pom增加依赖\",{\"1\":{\"450\":1}}],[\"pom\",{\"1\":{\"402\":2,\"423\":1,\"432\":1,\"433\":1,\"434\":1,\"441\":3,\"442\":1,\"443\":1,\"446\":1,\"464\":1,\"489\":1}}],[\"port\",{\"1\":{\"402\":3,\"403\":1,\"408\":2,\"420\":1,\"422\":1,\"429\":3,\"432\":1,\"443\":1,\"446\":1,\"450\":1,\"452\":2,\"464\":2,\"489\":2}}],[\"pos=具体值\",{\"1\":{\"826\":1}}],[\"position\",{\"1\":{\"809\":4}}],[\"position=终止点\",{\"1\":{\"809\":1}}],[\"position=起始点\",{\"1\":{\"809\":1}}],[\"possible\",{\"1\":{\"701\":1}}],[\"pos\",{\"1\":{\"393\":7,\"809\":2}}],[\"post\",{\"1\":{\"463\":1,\"488\":1,\"496\":1}}],[\"postforobject\",{\"1\":{\"446\":1}}],[\"postmapping\",{\"1\":{\"431\":2,\"443\":1,\"464\":2}}],[\"postconstruct\",{\"1\":{\"422\":1,\"423\":2}}],[\"postend\",{\"1\":{\"47\":4}}],[\"poststart\",{\"1\":{\"47\":5}}],[\"postorder保证是树的后序遍历\",{\"1\":{\"46\":1}}],[\"postorder\",{\"1\":{\"46\":8,\"47\":7}}],[\"postordertraversal2\",{\"1\":{\"8\":1}}],[\"postordertraversal\",{\"1\":{\"4\":3}}],[\"polllast\",{\"1\":{\"335\":1}}],[\"poll\",{\"1\":{\"12\":4,\"14\":1,\"16\":1,\"20\":1,\"22\":1,\"24\":2,\"26\":1,\"28\":1,\"29\":2,\"31\":1,\"33\":2,\"39\":3,\"43\":2,\"54\":1,\"226\":4,\"228\":4,\"230\":4,\"232\":4,\"335\":1,\"338\":1}}],[\"pop的时机\",{\"1\":{\"39\":1}}],[\"pop\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"12\":1,\"18\":1,\"29\":1,\"35\":1,\"39\":3,\"41\":1,\"45\":2,\"321\":7,\"322\":1,\"323\":3,\"326\":5,\"329\":2,\"332\":9,\"334\":2}}],[\"purge\",{\"1\":{\"809\":3}}],[\"putmapping\",{\"1\":{\"443\":1}}],[\"put\",{\"1\":{\"47\":1,\"49\":1,\"165\":1,\"175\":1,\"193\":16,\"338\":1,\"422\":2,\"423\":2,\"503\":1}}],[\"pushdown\",{\"1\":{\"728\":1}}],[\"push\",{\"1\":{\"6\":3,\"7\":1,\"8\":3,\"39\":9,\"41\":3,\"45\":6,\"321\":8,\"322\":1,\"323\":3,\"326\":1,\"329\":1,\"332\":5,\"334\":2}}],[\"public\",{\"1\":{\"2\":2,\"3\":1,\"4\":1,\"6\":1,\"7\":1,\"8\":1,\"12\":3,\"14\":1,\"16\":2,\"18\":2,\"20\":6,\"22\":2,\"24\":8,\"26\":2,\"28\":2,\"31\":5,\"33\":2,\"35\":3,\"37\":5,\"39\":7,\"41\":3,\"43\":3,\"45\":2,\"47\":2,\"49\":2,\"51\":2,\"52\":1,\"54\":4,\"56\":3,\"58\":2,\"60\":2,\"62\":1,\"64\":1,\"66\":2,\"68\":1,\"70\":2,\"72\":2,\"74\":2,\"79\":1,\"81\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"91\":3,\"92\":1,\"95\":1,\"97\":1,\"99\":1,\"101\":1,\"103\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":3,\"117\":3,\"120\":2,\"122\":2,\"124\":1,\"126\":1,\"128\":1,\"130\":1,\"133\":1,\"135\":1,\"137\":1,\"139\":1,\"141\":1,\"143\":1,\"146\":2,\"148\":1,\"150\":1,\"152\":1,\"155\":1,\"157\":1,\"163\":2,\"165\":1,\"168\":1,\"171\":3,\"173\":1,\"175\":2,\"177\":2,\"179\":1,\"187\":2,\"190\":2,\"191\":2,\"193\":3,\"195\":3,\"197\":2,\"199\":5,\"201\":3,\"203\":3,\"205\":2,\"207\":3,\"209\":3,\"211\":2,\"213\":3,\"215\":3,\"217\":3,\"224\":1,\"226\":3,\"228\":4,\"230\":4,\"232\":4,\"234\":2,\"242\":1,\"245\":2,\"248\":1,\"251\":1,\"254\":2,\"256\":3,\"259\":1,\"262\":1,\"268\":1,\"271\":2,\"273\":2,\"274\":1,\"275\":2,\"276\":1,\"277\":1,\"280\":1,\"283\":2,\"286\":1,\"289\":1,\"292\":1,\"293\":1,\"296\":1,\"298\":1,\"299\":1,\"302\":1,\"305\":1,\"308\":1,\"311\":1,\"314\":1,\"317\":1,\"323\":6,\"326\":1,\"329\":1,\"332\":1,\"335\":1,\"338\":1,\"344\":1,\"346\":1,\"348\":1,\"350\":3,\"352\":1,\"354\":1,\"356\":1,\"358\":1,\"360\":1,\"362\":1,\"364\":2,\"366\":1,\"368\":1,\"370\":1,\"372\":2,\"378\":1,\"379\":1,\"382\":1,\"384\":2,\"387\":1,\"389\":1,\"392\":1,\"395\":1,\"402\":6,\"403\":4,\"404\":1,\"410\":4,\"416\":5,\"417\":2,\"418\":4,\"419\":1,\"420\":4,\"422\":2,\"423\":6,\"424\":2,\"431\":2,\"432\":7,\"433\":5,\"434\":5,\"442\":1,\"443\":20,\"444\":8,\"445\":2,\"446\":8,\"451\":1,\"463\":3,\"464\":11,\"467\":2,\"477\":6,\"480\":2,\"481\":2,\"482\":2,\"489\":2,\"497\":6,\"503\":3,\"504\":6,\"885\":1}}],[\"lsn\",{\"1\":{\"668\":1,\"669\":1}}],[\"ltrim\",{\"1\":{\"552\":1}}],[\"lpad\",{\"1\":{\"552\":1}}],[\"ln\",{\"1\":{\"550\":1}}],[\"lmhmhl\",{\"1\":{\"475\":1,\"479\":1,\"482\":1}}],[\"lb表示负载均衡loadbalance\",{\"1\":{\"489\":1}}],[\"lb\",{\"1\":{\"458\":3,\"489\":2,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":1}}],[\"lb负载均衡\",{\"1\":{\"457\":1}}],[\"lvs\",{\"1\":{\"457\":1}}],[\"l=1\",{\"1\":{\"334\":1}}],[\"l指针指向元素0\",{\"1\":{\"316\":1}}],[\"l指针是+1的\",{\"1\":{\"313\":1}}],[\"l++\",{\"1\":{\"314\":1}}],[\"l+1处的重复元素\",{\"1\":{\"314\":1}}],[\"l+1\",{\"1\":{\"313\":4,\"314\":2}}],[\"l+1指向的元素\",{\"1\":{\"313\":1}}],[\"l>=left\",{\"1\":{\"275\":1}}],[\"lrloseumgh\",{\"1\":{\"255\":1}}],[\"lhr\",{\"1\":{\"212\":3}}],[\"lgb\",{\"1\":{\"212\":1}}],[\"lga\",{\"1\":{\"212\":1}}],[\"l\",{\"1\":{\"134\":5,\"193\":2,\"249\":4,\"275\":3,\"313\":13,\"314\":2,\"334\":3,\"699\":1}}],[\"laptop\",{\"1\":{\"809\":3}}],[\"law\",{\"1\":{\"429\":1}}],[\"languages\",{\"1\":{\"517\":1}}],[\"language\",{\"1\":{\"429\":1,\"516\":1,\"517\":3}}],[\"lang\",{\"1\":{\"419\":2,\"422\":1,\"477\":1,\"478\":1}}],[\"landnums++\",{\"1\":{\"226\":2,\"230\":1}}],[\"landnums\",{\"1\":{\"226\":4,\"230\":5}}],[\"lastname\",{\"1\":{\"521\":1}}],[\"last\",{\"0\":{\"696\":1},\"1\":{\"520\":1,\"521\":1,\"529\":2,\"533\":5,\"534\":1,\"536\":2,\"538\":2,\"539\":3,\"541\":9,\"557\":2,\"562\":2,\"569\":6,\"573\":1,\"575\":2,\"578\":2,\"579\":5,\"587\":3,\"696\":5,\"822\":1}}],[\"lastindex\",{\"1\":{\"368\":3}}],[\"laststoneweightii\",{\"1\":{\"97\":1}}],[\"largestsumafterknegations\",{\"1\":{\"354\":1}}],[\"largestvalues\",{\"1\":{\"22\":1}}],[\"lobal\",{\"1\":{\"746\":1}}],[\"lo\",{\"1\":{\"533\":3,\"538\":2}}],[\"localtimestamp\",{\"1\":{\"554\":1}}],[\"localtime\",{\"1\":{\"554\":1}}],[\"localhost\",{\"1\":{\"401\":1,\"402\":2,\"403\":2,\"404\":4,\"407\":1,\"408\":2,\"418\":2,\"419\":2,\"420\":2,\"422\":4,\"429\":2,\"431\":3,\"432\":2,\"435\":1,\"442\":1,\"443\":1,\"446\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":2,\"464\":1,\"477\":2,\"485\":1,\"486\":1,\"489\":1,\"502\":1}}],[\"locate\",{\"1\":{\"552\":1}}],[\"location\",{\"1\":{\"533\":2,\"538\":2,\"575\":2}}],[\"locations\",{\"1\":{\"432\":1,\"443\":1,\"452\":1,\"533\":1,\"538\":1}}],[\"locking\",{\"1\":{\"771\":1}}],[\"locks是在存储引擎\",{\"1\":{\"777\":1}}],[\"locks\",{\"0\":{\"775\":1,\"776\":1,\"777\":1,\"778\":1},\"1\":{\"770\":1,\"777\":2,\"778\":1}}],[\"lock`\",{\"1\":{\"428\":5}}],[\"locked\",{\"1\":{\"428\":1}}],[\"lock\",{\"1\":{\"428\":9,\"429\":4,\"767\":1,\"768\":1,\"770\":2,\"771\":3,\"773\":1,\"774\":1,\"775\":1,\"777\":1,\"778\":1,\"785\":1,\"786\":1,\"791\":1}}],[\"load\",{\"1\":{\"457\":1}}],[\"loadgwflowrule\",{\"1\":{\"424\":2}}],[\"loadrules\",{\"1\":{\"423\":1}}],[\"loadbalance本地负载均衡\",{\"1\":{\"457\":1}}],[\"loadbalance本地负载均衡客户端\",{\"1\":{\"457\":1}}],[\"loadbalance替换\",{\"1\":{\"457\":1}}],[\"loadbalanced\",{\"1\":{\"402\":1,\"451\":1,\"458\":1}}],[\"loadbalance\",{\"0\":{\"456\":1},\"1\":{\"402\":1,\"459\":1,\"462\":2}}],[\"loadbalancer<\",{\"1\":{\"402\":1,\"432\":1,\"459\":1}}],[\"loadbalancer\",{\"1\":{\"402\":2,\"432\":1,\"458\":1,\"462\":1}}],[\"lombok\",{\"1\":{\"402\":2,\"432\":1,\"441\":3,\"442\":1,\"443\":1,\"446\":1}}],[\"loop从1开始\",{\"1\":{\"289\":1}}],[\"loop++\",{\"1\":{\"289\":1}}],[\"loop\",{\"1\":{\"289\":5}}],[\"log信息\",{\"1\":{\"826\":1}}],[\"log与binlog两份日志之间的逻辑不一致\",{\"1\":{\"812\":1}}],[\"log与binlog两块日志\",{\"1\":{\"812\":1}}],[\"log与binlog的\",{\"1\":{\"812\":1}}],[\"log在事务执行过程中可以不断写入\",{\"1\":{\"812\":1}}],[\"log它是\",{\"1\":{\"811\":1}}],[\"log刷盘流程一样\",{\"1\":{\"810\":1}}],[\"log刷新到磁盘\",{\"1\":{\"757\":1}}],[\"log文件路径\",{\"1\":{\"809\":1}}],[\"log保存了历史快照\",{\"1\":{\"799\":1}}],[\"log+\",{\"1\":{\"799\":1}}],[\"log里\",{\"1\":{\"796\":1}}],[\"log把数据刷回磁盘\",{\"1\":{\"757\":1}}],[\"log已经持久化\",{\"1\":{\"757\":1}}],[\"log也需要持久性的保护\",{\"1\":{\"755\":1}}],[\"log会产生redo\",{\"1\":{\"755\":1}}],[\"log是事务原子性的保证\",{\"1\":{\"754\":1}}],[\"log是事务持久性的保证\",{\"1\":{\"754\":1}}],[\"log的产生\",{\"1\":{\"755\":1}}],[\"log的产生会伴随着redo\",{\"1\":{\"755\":1}}],[\"log的时候先写redo\",{\"1\":{\"753\":1}}],[\"log的写入并不是直接写入磁盘的\",{\"1\":{\"753\":1}}],[\"log可以简单分为以下两个部分\",{\"1\":{\"751\":1}}],[\"log不断记录\",{\"1\":{\"750\":1}}],[\"log=mysql\",{\"1\":{\"824\":1}}],[\"log=on\",{\"1\":{\"806\":2}}],[\"log=off\",{\"1\":{\"698\":3}}],[\"log=\",{\"1\":{\"698\":1}}],[\"log2n\",{\"1\":{\"658\":1,\"660\":1}}],[\"log2\",{\"1\":{\"550\":1}}],[\"log10\",{\"1\":{\"550\":1}}],[\"logger\",{\"1\":{\"470\":2}}],[\"logging<\",{\"1\":{\"450\":2}}],[\"logging\",{\"1\":{\"429\":1,\"432\":1,\"450\":1,\"470\":2}}],[\"log`\",{\"1\":{\"431\":9}}],[\"login\",{\"1\":{\"429\":1}}],[\"logstash\",{\"1\":{\"429\":2}}],[\"logs\",{\"1\":{\"429\":1,\"698\":1,\"809\":5,\"823\":1}}],[\"logback\",{\"1\":{\"429\":2}}],[\"logn\",{\"1\":{\"277\":1}}],[\"log\",{\"0\":{\"808\":1,\"813\":1},\"1\":{\"273\":1,\"275\":1,\"276\":1,\"277\":1,\"336\":1,\"416\":2,\"429\":1,\"431\":7,\"432\":10,\"433\":2,\"434\":2,\"445\":1,\"503\":6,\"550\":1,\"668\":1,\"698\":1,\"699\":5,\"747\":2,\"751\":5,\"752\":4,\"753\":9,\"754\":1,\"755\":1,\"757\":4,\"795\":1,\"799\":1,\"800\":1,\"806\":6,\"807\":11,\"808\":2,\"809\":14,\"811\":1,\"812\":1,\"820\":3,\"823\":2,\"826\":2}}],[\"lower\",{\"1\":{\"552\":1}}],[\"lowest\",{\"1\":{\"534\":1}}],[\"lowestcommonancestor\",{\"1\":{\"62\":3,\"64\":3}}],[\"low+1\",{\"1\":{\"276\":1}}],[\"low=high\",{\"1\":{\"276\":1}}],[\"low=high时\",{\"1\":{\"276\":1}}],[\"low\",{\"1\":{\"69\":4,\"70\":12,\"276\":7,\"797\":3,\"798\":2,\"800\":1,\"831\":1}}],[\"longtext\",{\"1\":{\"603\":1,\"605\":1}}],[\"longblob\",{\"1\":{\"431\":3}}],[\"longestpalindrome\",{\"1\":{\"262\":1}}],[\"longestpalindromesubseq\",{\"1\":{\"157\":1}}],[\"longestcommonsubsequence\",{\"1\":{\"139\":1}}],[\"long\",{\"1\":{\"56\":1,\"268\":1,\"431\":4,\"433\":3,\"434\":6,\"444\":1,\"463\":2,\"503\":1,\"697\":1,\"698\":2}}],[\"lib\",{\"1\":{\"699\":5,\"806\":1,\"822\":1}}],[\"lisi\",{\"1\":{\"676\":1,\"680\":1}}],[\"listb\",{\"1\":{\"390\":7}}],[\"lista\",{\"1\":{\"390\":7}}],[\"listnode\",{\"1\":{\"378\":5,\"379\":1,\"382\":5,\"384\":13,\"387\":4,\"389\":5,\"392\":5,\"395\":3}}],[\"list\",{\"1\":{\"165\":3,\"215\":3,\"234\":4,\"321\":1,\"384\":1,\"460\":2,\"807\":1}}],[\"list索引下标从0开始\",{\"1\":{\"12\":1}}],[\"list<store>\",{\"1\":{\"463\":1}}],[\"list<string>>\",{\"1\":{\"165\":1,\"193\":4}}],[\"list<string>\",{\"1\":{\"39\":4,\"111\":1,\"165\":1,\"193\":4,\"199\":2,\"201\":5,\"213\":1,\"215\":1,\"222\":1,\"245\":1,\"497\":1,\"504\":1}}],[\"list<serviceinstance>\",{\"1\":{\"460\":1}}],[\"list<pay>\",{\"1\":{\"443\":2}}],[\"list<viewresolver>\",{\"1\":{\"423\":1}}],[\"list<list<string>>\",{\"1\":{\"165\":1,\"199\":3,\"213\":3,\"215\":2,\"222\":1}}],[\"list<list<integer>>\",{\"1\":{\"12\":4,\"14\":2,\"20\":2,\"177\":2,\"179\":1,\"187\":1,\"190\":1,\"191\":1,\"195\":2,\"197\":2,\"203\":3,\"205\":2,\"207\":3,\"209\":3,\"211\":2,\"224\":3,\"234\":2,\"311\":1}}],[\"list<node>\",{\"1\":{\"20\":2}}],[\"list<double>\",{\"1\":{\"18\":1}}],[\"list<integer>\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"6\":1,\"7\":1,\"8\":1,\"12\":1,\"14\":1,\"16\":1,\"22\":1,\"56\":1,\"60\":1,\"177\":1,\"195\":1,\"197\":1,\"203\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":1,\"224\":2,\"368\":1}}],[\"lived\",{\"1\":{\"636\":1}}],[\"like以通配符\",{\"0\":{\"721\":1}}],[\"like\",{\"1\":{\"529\":1,\"585\":1,\"635\":1,\"695\":1,\"696\":2,\"698\":2,\"710\":1,\"721\":2,\"745\":1,\"746\":1,\"751\":1,\"806\":1,\"807\":1,\"809\":1}}],[\"linux系统\",{\"1\":{\"807\":1}}],[\"linux\",{\"1\":{\"518\":1,\"835\":1}}],[\"linked\",{\"1\":{\"384\":1}}],[\"linkedlist<int\",{\"1\":{\"362\":1}}],[\"linkedlist<integer>\",{\"1\":{\"187\":2,\"190\":2,\"191\":1}}],[\"linkedlist<string>\",{\"1\":{\"213\":4}}],[\"linkedlist<>\",{\"1\":{\"33\":1,\"187\":2,\"190\":2,\"191\":1,\"213\":4,\"362\":1}}],[\"linkedlist<treenode>\",{\"1\":{\"33\":1}}],[\"licenses\",{\"1\":{\"429\":1}}],[\"license\",{\"1\":{\"429\":8}}],[\"licensed\",{\"1\":{\"429\":1}}],[\"limit不能使用子查询\",{\"1\":{\"579\":1}}],[\"limitrefreshperiod\",{\"1\":{\"482\":1}}],[\"limitforperiod\",{\"1\":{\"482\":1}}],[\"limiting\",{\"1\":{\"474\":1}}],[\"limit\",{\"1\":{\"429\":1,\"565\":3,\"710\":3,\"726\":3,\"729\":2,\"797\":5,\"798\":4,\"800\":3,\"809\":2}}],[\"limitations\",{\"1\":{\"429\":1}}],[\"limitapp\",{\"1\":{\"419\":2}}],[\"limiter\",{\"1\":{\"411\":1}}],[\"leading\",{\"1\":{\"552\":1}}],[\"least\",{\"1\":{\"548\":1}}],[\"lemonadechange\",{\"1\":{\"358\":1}}],[\"len个字符长的子串替换为字符串replacestr\",{\"1\":{\"552\":1}}],[\"len\",{\"0\":{\"706\":1},\"1\":{\"278\":2,\"552\":6,\"701\":1}}],[\"length2\",{\"1\":{\"141\":4,\"146\":6,\"150\":5,\"152\":6}}],[\"length1\",{\"1\":{\"141\":4,\"146\":7,\"150\":5,\"152\":6}}],[\"length++\",{\"1\":{\"135\":1,\"389\":1}}],[\"length+1\",{\"1\":{\"83\":2}}],[\"lengthoflis\",{\"1\":{\"133\":1}}],[\"length\",{\"1\":{\"46\":3,\"47\":3,\"48\":3,\"49\":3,\"50\":1,\"51\":1,\"71\":1,\"72\":1,\"82\":1,\"83\":2,\"91\":3,\"92\":2,\"93\":2,\"94\":1,\"95\":2,\"96\":1,\"97\":1,\"98\":1,\"99\":2,\"100\":2,\"102\":1,\"103\":2,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"110\":3,\"111\":3,\"112\":1,\"113\":5,\"114\":1,\"115\":15,\"119\":1,\"120\":6,\"121\":1,\"122\":7,\"123\":1,\"124\":5,\"125\":1,\"126\":6,\"127\":1,\"128\":4,\"129\":1,\"130\":6,\"132\":1,\"133\":2,\"134\":1,\"135\":5,\"136\":2,\"137\":4,\"138\":2,\"139\":6,\"140\":2,\"141\":2,\"142\":1,\"143\":4,\"145\":2,\"146\":6,\"147\":2,\"148\":7,\"149\":2,\"150\":2,\"151\":2,\"152\":2,\"154\":1,\"155\":6,\"156\":1,\"157\":9,\"161\":2,\"163\":5,\"164\":2,\"165\":1,\"166\":2,\"174\":1,\"175\":3,\"176\":1,\"177\":4,\"178\":1,\"179\":3,\"192\":1,\"193\":7,\"194\":1,\"195\":2,\"196\":1,\"197\":1,\"198\":1,\"199\":4,\"200\":1,\"201\":4,\"202\":1,\"203\":4,\"204\":1,\"205\":2,\"206\":1,\"207\":2,\"208\":1,\"209\":4,\"210\":1,\"211\":3,\"212\":4,\"216\":2,\"217\":2,\"223\":1,\"224\":4,\"225\":2,\"226\":10,\"227\":2,\"228\":10,\"229\":2,\"230\":8,\"231\":2,\"232\":8,\"233\":2,\"234\":2,\"240\":2,\"242\":1,\"244\":1,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"251\":1,\"254\":2,\"255\":1,\"256\":2,\"257\":1,\"259\":1,\"260\":1,\"262\":7,\"268\":1,\"271\":2,\"273\":5,\"275\":4,\"276\":2,\"277\":3,\"280\":1,\"283\":3,\"286\":1,\"290\":3,\"292\":3,\"293\":2,\"294\":2,\"296\":1,\"297\":2,\"298\":1,\"299\":1,\"302\":4,\"303\":2,\"305\":2,\"306\":1,\"308\":1,\"312\":2,\"313\":1,\"314\":1,\"315\":1,\"317\":2,\"324\":1,\"326\":2,\"327\":1,\"329\":1,\"330\":1,\"333\":2,\"335\":4,\"336\":1,\"343\":2,\"344\":4,\"345\":1,\"346\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":5,\"351\":1,\"352\":3,\"353\":1,\"354\":3,\"355\":2,\"356\":1,\"357\":1,\"358\":1,\"359\":1,\"360\":5,\"361\":2,\"362\":1,\"363\":2,\"364\":2,\"365\":2,\"366\":1,\"367\":1,\"368\":2,\"370\":3,\"389\":5,\"391\":2,\"552\":3,\"687\":4}}],[\"let\",{\"1\":{\"246\":1}}],[\"lettercombinations\",{\"1\":{\"193\":1}}],[\"letterlist\",{\"1\":{\"193\":6}}],[\"leet\",{\"0\":{\"890\":1},\"1\":{\"110\":2}}],[\"leetcode题解\",{\"1\":{\"239\":1}}],[\"leetcode\",{\"1\":{\"12\":1,\"73\":1,\"110\":2,\"149\":1,\"246\":1}}],[\"level3\",{\"1\":{\"836\":1}}],[\"level++\",{\"1\":{\"28\":1}}],[\"levelsize\",{\"1\":{\"16\":3,\"18\":3,\"20\":2,\"22\":2,\"24\":3,\"43\":2}}],[\"levelorderbottom\",{\"1\":{\"14\":1}}],[\"levelorder\",{\"1\":{\"12\":2,\"20\":1}}],[\"level\",{\"1\":{\"12\":1,\"28\":3,\"432\":1,\"470\":4,\"534\":1,\"746\":1,\"836\":1}}],[\"left==0||right==0\",{\"1\":{\"372\":1}}],[\"left==2\",{\"1\":{\"372\":1}}],[\"left==null\",{\"1\":{\"39\":1}}],[\"left=mincame\",{\"1\":{\"372\":1}}],[\"leftmost\",{\"1\":{\"321\":1}}],[\"left和right指针都是从0开始\",{\"1\":{\"317\":1}}],[\"left和right都不为空\",{\"1\":{\"62\":1}}],[\"leftsum\",{\"1\":{\"292\":3,\"293\":6}}],[\"left<=right\",{\"1\":{\"275\":1}}],[\"left+\",{\"1\":{\"275\":1}}],[\"left+1\",{\"1\":{\"242\":1}}],[\"left++\",{\"1\":{\"177\":3,\"179\":1,\"251\":1,\"254\":1,\"256\":1,\"286\":1,\"292\":1,\"317\":1}}],[\"left指针右移\",{\"1\":{\"241\":1}}],[\"left时\",{\"1\":{\"70\":1}}],[\"left开始递归\",{\"1\":{\"70\":1}}],[\"left$\",{\"1\":{\"33\":1}}],[\"left\",{\"1\":{\"2\":5,\"3\":1,\"4\":1,\"6\":2,\"7\":1,\"8\":2,\"12\":8,\"14\":2,\"16\":6,\"18\":6,\"22\":6,\"23\":1,\"24\":6,\"26\":6,\"28\":7,\"29\":2,\"31\":13,\"33\":25,\"35\":7,\"37\":12,\"39\":14,\"41\":12,\"43\":5,\"45\":6,\"47\":4,\"49\":4,\"51\":1,\"52\":3,\"54\":8,\"56\":4,\"58\":1,\"60\":1,\"62\":6,\"64\":1,\"66\":5,\"68\":9,\"70\":12,\"72\":6,\"74\":1,\"117\":9,\"177\":18,\"179\":8,\"241\":3,\"242\":5,\"251\":4,\"254\":4,\"256\":4,\"261\":1,\"270\":4,\"271\":19,\"273\":7,\"274\":9,\"275\":3,\"276\":3,\"277\":11,\"286\":4,\"292\":3,\"299\":8,\"317\":3,\"372\":5,\"383\":6,\"384\":3,\"539\":3,\"541\":4,\"552\":1,\"565\":1,\"699\":1,\"710\":1,\"717\":1}}],[\"rdcconfig\",{\"1\":{\"836\":1}}],[\"rdc\",{\"1\":{\"836\":1}}],[\"rdbms\",{\"0\":{\"508\":2,\"509\":1},\"1\":{\"508\":1}}],[\"r选项来备份存储过程及函数\",{\"1\":{\"831\":1}}],[\"rbr\",{\"1\":{\"823\":3}}],[\"r2\",{\"1\":{\"736\":1}}],[\"r1\",{\"1\":{\"736\":3}}],[\"r1tyc0d3s3cu\",{\"1\":{\"255\":1}}],[\"rpad\",{\"1\":{\"552\":1}}],[\"rc375\",{\"1\":{\"444\":1}}],[\"rc404\",{\"1\":{\"444\":1}}],[\"rc401\",{\"1\":{\"444\":1}}],[\"rc403\",{\"1\":{\"444\":1}}],[\"rc999\",{\"1\":{\"444\":1}}],[\"rc204\",{\"1\":{\"444\":1}}],[\"rc203\",{\"1\":{\"444\":1}}],[\"rc202\",{\"1\":{\"444\":1}}],[\"rc201\",{\"1\":{\"444\":1}}],[\"rc200\",{\"1\":{\"444\":3}}],[\"rc2\",{\"1\":{\"441\":1}}],[\"rc2<\",{\"1\":{\"441\":1}}],[\"rc500\",{\"1\":{\"420\":1,\"444\":1,\"445\":1}}],[\"rm\",{\"1\":{\"426\":2}}],[\"rtrim\",{\"1\":{\"552\":1}}],[\"rt\",{\"1\":{\"412\":1,\"419\":1}}],[\"rules\",{\"1\":{\"423\":3}}],[\"rule\",{\"1\":{\"419\":3}}],[\"ruleconstant\",{\"1\":{\"411\":2}}],[\"runtimeexception\",{\"1\":{\"416\":1,\"445\":1,\"477\":2}}],[\"runtime\",{\"1\":{\"416\":1}}],[\"run\",{\"1\":{\"403\":1,\"432\":1,\"443\":1,\"446\":2,\"463\":1,\"464\":1,\"489\":1}}],[\"r=7\",{\"1\":{\"334\":1}}],[\"r=6\",{\"1\":{\"334\":1}}],[\"r=5\",{\"1\":{\"334\":1}}],[\"r=4\",{\"1\":{\"334\":1}}],[\"r=3\",{\"1\":{\"334\":1}}],[\"r=2\",{\"1\":{\"334\":1}}],[\"r指针指向不为0的元素\",{\"1\":{\"316\":1}}],[\"r指向替换\",{\"1\":{\"313\":1}}],[\"r继续移动\",{\"1\":{\"313\":1}}],[\"r<nums\",{\"1\":{\"313\":1}}],[\"r<=right\",{\"1\":{\"275\":1}}],[\"r作为快指针\",{\"1\":{\"313\":1}}],[\"r快慢指针\",{\"1\":{\"313\":1}}],[\"r++\",{\"1\":{\"275\":1,\"314\":1}}],[\"ribbon\",{\"1\":{\"457\":2}}],[\"ri\",{\"1\":{\"233\":2}}],[\"right==2\",{\"1\":{\"372\":1}}],[\"right==null\",{\"1\":{\"39\":1}}],[\"right=mincame\",{\"1\":{\"372\":1}}],[\"rightsum\",{\"1\":{\"292\":3}}],[\"rightsideview\",{\"1\":{\"16\":1}}],[\"right++\",{\"1\":{\"254\":1,\"286\":1,\"292\":1,\"317\":1}}],[\"right+1\",{\"1\":{\"242\":1}}],[\"right指针在数组中\",{\"1\":{\"241\":1}}],[\"right指向尾元素\",{\"1\":{\"241\":1}}],[\"right指向末尾元素\",{\"1\":{\"177\":1}}],[\"right去重\",{\"1\":{\"177\":1,\"179\":1}}],[\"right开始递归\",{\"1\":{\"70\":1}}],[\"right\",{\"1\":{\"2\":5,\"3\":1,\"4\":1,\"6\":2,\"7\":1,\"8\":2,\"12\":8,\"14\":2,\"16\":6,\"18\":6,\"22\":6,\"23\":1,\"24\":6,\"26\":6,\"28\":7,\"29\":2,\"31\":13,\"33\":27,\"35\":7,\"37\":12,\"39\":14,\"41\":5,\"43\":5,\"45\":6,\"47\":1,\"49\":1,\"51\":1,\"52\":3,\"54\":5,\"56\":4,\"58\":1,\"60\":1,\"62\":9,\"64\":1,\"66\":5,\"68\":7,\"70\":10,\"72\":5,\"74\":1,\"117\":9,\"177\":19,\"179\":10,\"241\":3,\"242\":5,\"251\":5,\"254\":4,\"256\":5,\"261\":1,\"270\":4,\"271\":19,\"273\":6,\"274\":6,\"275\":3,\"276\":4,\"277\":7,\"286\":5,\"292\":3,\"299\":8,\"317\":5,\"372\":5,\"383\":6,\"384\":2,\"539\":1,\"541\":4,\"552\":1,\"565\":1}}],[\"ram\",{\"1\":{\"760\":1}}],[\"range\",{\"1\":{\"704\":3,\"728\":1,\"836\":1}}],[\"rand\",{\"1\":{\"548\":10}}],[\"radians\",{\"1\":{\"549\":1}}],[\"ratelimiter<\",{\"1\":{\"482\":1}}],[\"ratelimiter\",{\"1\":{\"474\":1,\"482\":6}}],[\"ratelimit\",{\"1\":{\"416\":1,\"419\":1,\"482\":1}}],[\"rate\",{\"1\":{\"411\":1,\"474\":1,\"476\":2}}],[\"ratings\",{\"1\":{\"359\":5,\"360\":15}}],[\"rat\",{\"1\":{\"161\":1}}],[\"rabbitmq\",{\"0\":{\"852\":1},\"1\":{\"850\":1}}],[\"rabbit\",{\"1\":{\"147\":2}}],[\"rabbbit\",{\"1\":{\"147\":4}}],[\"roll\",{\"1\":{\"681\":1,\"794\":2}}],[\"rollbackfor\",{\"1\":{\"432\":2}}],[\"rollback\",{\"1\":{\"431\":3,\"517\":2,\"636\":1}}],[\"rollbacking\",{\"1\":{\"428\":1}}],[\"round\",{\"1\":{\"548\":7}}],[\"routines\",{\"1\":{\"831\":1}}],[\"routh2\",{\"1\":{\"489\":2}}],[\"routh1\",{\"1\":{\"422\":2,\"423\":1,\"489\":2,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":1}}],[\"routepredicatefactory<c>\",{\"1\":{\"497\":1}}],[\"routepredicatefactory\",{\"1\":{\"491\":1,\"497\":1}}],[\"routes\",{\"1\":{\"422\":1,\"489\":1,\"491\":2,\"492\":3,\"493\":3,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":3,\"504\":1}}],[\"routeid\",{\"1\":{\"421\":1,\"422\":1,\"424\":1}}],[\"route\",{\"1\":{\"421\":1,\"488\":1,\"491\":2,\"492\":1,\"502\":2,\"504\":1}}],[\"rocketmq\",{\"1\":{\"399\":2}}],[\"rotate\",{\"1\":{\"298\":1,\"299\":1}}],[\"row模式\",{\"1\":{\"823\":1}}],[\"rows\",{\"0\":{\"708\":1},\"1\":{\"701\":2,\"709\":1,\"767\":2,\"771\":2,\"806\":1,\"807\":1,\"809\":3,\"832\":1}}],[\"rowlength\",{\"1\":{\"230\":8,\"232\":8,\"234\":8,\"302\":3}}],[\"row表示行\",{\"1\":{\"217\":1}}],[\"row表示当前处理的是第几行\",{\"1\":{\"215\":1}}],[\"row++\",{\"1\":{\"217\":2}}],[\"row+1\",{\"1\":{\"215\":2}}],[\"row\",{\"1\":{\"215\":21,\"217\":20,\"302\":4,\"311\":4,\"509\":1,\"606\":1,\"643\":1,\"675\":1,\"676\":3,\"681\":1,\"745\":1,\"771\":2,\"774\":2,\"809\":3,\"823\":1,\"832\":1}}],[\"rorse\",{\"1\":{\"151\":2}}],[\"rose\",{\"1\":{\"151\":2}}],[\"ros\",{\"1\":{\"151\":2}}],[\"robmax\",{\"1\":{\"115\":3}}],[\"rob\",{\"1\":{\"113\":1,\"115\":2,\"117\":1}}],[\"rootcontext\",{\"1\":{\"432\":2}}],[\"rootcontent\",{\"1\":{\"426\":1}}],[\"root==null\",{\"1\":{\"372\":1}}],[\"root为叶子结点\",{\"1\":{\"68\":1}}],[\"root在\",{\"1\":{\"64\":1}}],[\"root2\",{\"1\":{\"52\":9}}],[\"root1\",{\"1\":{\"52\":12}}],[\"rootidnex\",{\"1\":{\"51\":1}}],[\"rootindex\",{\"1\":{\"47\":4,\"49\":4,\"51\":7,\"72\":4}}],[\"root\",{\"1\":{\"2\":5,\"3\":5,\"4\":5,\"6\":3,\"7\":3,\"8\":3,\"11\":4,\"12\":13,\"13\":4,\"14\":3,\"16\":3,\"17\":3,\"18\":3,\"19\":2,\"20\":3,\"21\":3,\"22\":3,\"23\":2,\"24\":5,\"25\":3,\"26\":3,\"27\":2,\"28\":3,\"29\":2,\"30\":4,\"31\":12,\"32\":3,\"33\":10,\"34\":4,\"35\":7,\"36\":3,\"37\":8,\"38\":3,\"39\":16,\"40\":3,\"41\":5,\"42\":1,\"43\":7,\"44\":4,\"45\":14,\"47\":5,\"49\":5,\"51\":4,\"53\":4,\"54\":25,\"55\":3,\"56\":13,\"57\":3,\"58\":8,\"59\":3,\"60\":11,\"61\":3,\"62\":17,\"63\":3,\"64\":15,\"65\":4,\"66\":13,\"67\":5,\"68\":26,\"69\":3,\"70\":37,\"72\":4,\"73\":3,\"74\":9,\"116\":5,\"117\":2,\"372\":8,\"429\":1,\"431\":3,\"432\":2,\"442\":1,\"443\":2,\"452\":2,\"831\":4,\"832\":1}}],[\"r\",{\"1\":{\"81\":4,\"134\":5,\"151\":2,\"193\":2,\"233\":4,\"275\":3,\"313\":8,\"314\":4,\"334\":3,\"512\":1,\"699\":3,\"831\":1}}],[\"reentrantlock\",{\"1\":{\"781\":1}}],[\"rename\",{\"1\":{\"588\":1}}],[\"replication\",{\"1\":{\"822\":1,\"823\":3,\"825\":2}}],[\"replace\",{\"1\":{\"552\":1}}],[\"replacestr\",{\"1\":{\"552\":1}}],[\"repeatable\",{\"1\":{\"746\":4,\"764\":1,\"765\":1,\"797\":1}}],[\"repeat\",{\"1\":{\"552\":1}}],[\"reporter2<\",{\"1\":{\"486\":2}}],[\"reporter\",{\"1\":{\"486\":7}}],[\"revoke\",{\"1\":{\"517\":1}}],[\"reversebetween\",{\"1\":{\"384\":1}}],[\"reverselist\",{\"1\":{\"382\":1}}],[\"reversestr\",{\"1\":{\"254\":1}}],[\"reversestring\",{\"1\":{\"251\":1}}],[\"reversewords\",{\"1\":{\"245\":2,\"248\":1}}],[\"reverse\",{\"1\":{\"8\":1,\"14\":1,\"245\":1,\"248\":1,\"254\":2,\"256\":4,\"329\":1,\"552\":1}}],[\"redolog日志恢复数据时\",{\"1\":{\"812\":1}}],[\"redolog对比\",{\"0\":{\"811\":1}}],[\"redo整体流程\",{\"0\":{\"752\":1}}],[\"redo组成\",{\"0\":{\"751\":1}}],[\"redo日志是顺序写入磁盘的\",{\"1\":{\"750\":1}}],[\"redo日志是如何恢复呢\",{\"1\":{\"747\":1}}],[\"redo日志占用的空间非常小\",{\"1\":{\"750\":1}}],[\"redo日志降低了刷盘频率\",{\"1\":{\"750\":1}}],[\"redo\",{\"0\":{\"748\":1,\"749\":1,\"753\":1},\"1\":{\"747\":4,\"749\":1,\"750\":1,\"751\":4,\"752\":2,\"753\":6,\"754\":1,\"811\":2,\"812\":3}}],[\"redundant\",{\"1\":{\"675\":1}}],[\"redis将热点数据保存在内存数据库中\",{\"1\":{\"818\":1}}],[\"redis\",{\"0\":{\"892\":1},\"1\":{\"510\":1,\"818\":2,\"843\":1,\"846\":1},\"2\":{\"854\":1}}],[\"redirectto=302\",{\"1\":{\"502\":1}}],[\"redirectto\",{\"1\":{\"502\":1}}],[\"redirect\",{\"1\":{\"422\":2}}],[\"red\",{\"1\":{\"502\":2}}],[\"regarded\",{\"1\":{\"883\":1}}],[\"region\",{\"1\":{\"767\":2,\"771\":6}}],[\"regions\",{\"1\":{\"767\":1,\"771\":2}}],[\"register2property\",{\"1\":{\"424\":1}}],[\"register\",{\"1\":{\"423\":1}}],[\"registry\",{\"1\":{\"402\":1,\"429\":1,\"432\":1}}],[\"regexp\",{\"1\":{\"491\":1,\"494\":1}}],[\"ref访问方法来执行对\",{\"1\":{\"704\":1}}],[\"ref\",{\"0\":{\"707\":1},\"1\":{\"701\":1,\"704\":10,\"728\":3}}],[\"referential\",{\"1\":{\"612\":1}}],[\"references\",{\"1\":{\"618\":4,\"687\":1}}],[\"reference\",{\"1\":{\"458\":1,\"513\":1}}],[\"refreshscope注解使当前类下的配置支持nacos的动态刷新功能\",{\"1\":{\"403\":1}}],[\"refreshscope\",{\"1\":{\"403\":2,\"453\":1}}],[\"rewritebatchedstatements=true\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"real默认就是\",{\"1\":{\"599\":1}}],[\"real\",{\"1\":{\"599\":5}}],[\"readview规则\",{\"0\":{\"798\":1}}],[\"readview是和事务一一对应的\",{\"1\":{\"796\":1}}],[\"readview\",{\"1\":{\"796\":3,\"799\":6,\"800\":3}}],[\"readview的存在本身就保证了\",{\"1\":{\"765\":1}}],[\"read隔离级别下会使用到mvcc读取记录\",{\"1\":{\"765\":1}}],[\"readtimeout\",{\"1\":{\"466\":1}}],[\"read\",{\"1\":{\"466\":1,\"744\":2,\"746\":11,\"764\":1,\"765\":2,\"770\":1,\"785\":1,\"795\":1,\"797\":4,\"799\":4,\"823\":1}}],[\"readabledatasource<string\",{\"1\":{\"424\":1}}],[\"readme\",{\"1\":{\"399\":1}}],[\"reactive\",{\"1\":{\"422\":2}}],[\"request\",{\"1\":{\"469\":2,\"493\":2,\"499\":2,\"504\":3}}],[\"requestmethod\",{\"1\":{\"463\":4}}],[\"requestmapping\",{\"1\":{\"433\":1,\"434\":1,\"463\":4}}],[\"requestbody\",{\"1\":{\"443\":2,\"446\":1,\"464\":2}}],[\"requests\",{\"1\":{\"423\":2}}],[\"requestsentinel4\",{\"1\":{\"418\":1}}],[\"requestoriginparser\",{\"1\":{\"418\":1}}],[\"requestparam\",{\"1\":{\"417\":2,\"431\":4,\"434\":2}}],[\"required\",{\"1\":{\"417\":2,\"429\":1}}],[\"relay\",{\"0\":{\"813\":1},\"1\":{\"813\":2,\"820\":2,\"824\":2,\"826\":1}}],[\"relationship\",{\"1\":{\"512\":1}}],[\"reliability\",{\"1\":{\"405\":1,\"612\":1}}],[\"releases\",{\"1\":{\"401\":1,\"407\":1}}],[\"rec\",{\"1\":{\"680\":3,\"775\":1}}],[\"record值为32\",{\"1\":{\"680\":1}}],[\"records中的这些记录按照指定的行格式一条一条摆在user\",{\"1\":{\"671\":1}}],[\"records部分替代掉之后\",{\"1\":{\"670\":1}}],[\"records部分\",{\"1\":{\"670\":1,\"671\":1}}],[\"records这个部分\",{\"1\":{\"670\":1}}],[\"records\",{\"0\":{\"671\":1},\"1\":{\"667\":1,\"670\":1}}],[\"record\",{\"0\":{\"775\":1},\"1\":{\"643\":2,\"645\":2,\"676\":2,\"680\":2}}],[\"recordexceptions\",{\"1\":{\"477\":2,\"478\":1}}],[\"reconstructqueue\",{\"1\":{\"362\":1}}],[\"recursive\",{\"1\":{\"33\":4}}],[\"recursion\",{\"1\":{\"12\":4}}],[\"remoteaddr=192\",{\"1\":{\"495\":1}}],[\"remoteaddr\",{\"0\":{\"495\":1},\"1\":{\"495\":1}}],[\"removeresponseheader需要一个\",{\"1\":{\"501\":1}}],[\"removerequestparameter=customername\",{\"1\":{\"500\":1}}],[\"removerequestparameter\",{\"1\":{\"500\":1}}],[\"removerequestheader=sec\",{\"1\":{\"499\":1}}],[\"removerequestheader\",{\"1\":{\"499\":1}}],[\"removenthfromend\",{\"1\":{\"389\":1}}],[\"removeduplicates\",{\"1\":{\"312\":1,\"314\":1,\"329\":1}}],[\"removeelements\",{\"1\":{\"378\":1}}],[\"removeelement\",{\"1\":{\"278\":1,\"280\":1}}],[\"remove\",{\"1\":{\"195\":2,\"197\":1,\"199\":2,\"201\":2,\"203\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":1,\"224\":2}}],[\"removelast\",{\"1\":{\"187\":3,\"188\":1,\"190\":2,\"191\":1,\"213\":2}}],[\"remain\",{\"1\":{\"356\":10}}],[\"retrying\",{\"1\":{\"474\":1}}],[\"retry\",{\"1\":{\"467\":1,\"474\":1}}],[\"retryer\",{\"1\":{\"467\":3}}],[\"retryrollbacking\",{\"1\":{\"428\":1}}],[\"retrycommitting\",{\"1\":{\"428\":1}}],[\"retentionpolicy\",{\"1\":{\"416\":1}}],[\"retention\",{\"1\":{\"416\":1}}],[\"retainall\",{\"1\":{\"168\":1}}],[\"returncodeenum\",{\"1\":{\"420\":1,\"444\":9,\"445\":1}}],[\"return\",{\"1\":{\"2\":2,\"3\":2,\"4\":2,\"6\":2,\"7\":2,\"8\":2,\"12\":5,\"14\":2,\"16\":2,\"18\":2,\"20\":2,\"22\":2,\"24\":2,\"26\":2,\"28\":3,\"31\":5,\"33\":10,\"35\":4,\"37\":8,\"39\":10,\"41\":4,\"43\":7,\"45\":6,\"47\":3,\"49\":3,\"51\":4,\"52\":3,\"54\":9,\"56\":6,\"58\":2,\"60\":2,\"62\":4,\"64\":3,\"66\":4,\"68\":6,\"70\":10,\"72\":3,\"74\":2,\"79\":2,\"81\":3,\"83\":1,\"85\":2,\"87\":2,\"89\":1,\"95\":4,\"97\":1,\"99\":3,\"101\":1,\"103\":1,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":3,\"115\":7,\"117\":3,\"120\":2,\"122\":2,\"124\":1,\"126\":1,\"128\":2,\"130\":1,\"133\":1,\"135\":1,\"137\":1,\"139\":1,\"141\":1,\"143\":1,\"146\":2,\"148\":1,\"150\":1,\"152\":1,\"155\":1,\"157\":1,\"163\":5,\"165\":1,\"168\":1,\"171\":5,\"173\":2,\"175\":2,\"177\":4,\"179\":2,\"185\":2,\"187\":3,\"190\":4,\"191\":4,\"193\":4,\"195\":5,\"197\":2,\"199\":7,\"201\":14,\"203\":3,\"205\":2,\"207\":2,\"209\":3,\"211\":2,\"213\":6,\"215\":13,\"217\":13,\"222\":1,\"224\":3,\"226\":3,\"228\":3,\"230\":3,\"232\":1,\"234\":2,\"242\":1,\"245\":2,\"248\":1,\"254\":1,\"256\":2,\"259\":1,\"262\":1,\"268\":1,\"271\":4,\"273\":4,\"274\":1,\"275\":4,\"276\":3,\"277\":2,\"280\":1,\"283\":2,\"286\":1,\"289\":1,\"292\":3,\"293\":2,\"296\":1,\"305\":1,\"308\":1,\"311\":1,\"314\":1,\"317\":1,\"321\":3,\"323\":4,\"326\":6,\"329\":1,\"332\":1,\"335\":1,\"338\":1,\"344\":2,\"346\":1,\"348\":1,\"350\":8,\"352\":3,\"354\":1,\"356\":1,\"358\":2,\"360\":1,\"362\":3,\"364\":2,\"366\":1,\"368\":1,\"370\":1,\"372\":11,\"378\":1,\"382\":2,\"384\":1,\"387\":2,\"389\":2,\"392\":4,\"395\":2,\"402\":3,\"403\":1,\"410\":2,\"416\":3,\"417\":2,\"418\":2,\"420\":1,\"422\":1,\"423\":3,\"424\":2,\"432\":1,\"433\":1,\"434\":1,\"443\":9,\"444\":5,\"445\":2,\"446\":3,\"459\":1,\"464\":7,\"467\":2,\"470\":1,\"477\":4,\"480\":3,\"481\":3,\"482\":2,\"497\":5,\"503\":4,\"504\":4}}],[\"reset\",{\"1\":{\"809\":1,\"826\":1}}],[\"residue\",{\"1\":{\"433\":2,\"434\":2}}],[\"resilience4j提供了两种隔离的实现方式\",{\"1\":{\"479\":1}}],[\"resilience4j<\",{\"1\":{\"477\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"resilience4j\",{\"0\":{\"473\":1},\"1\":{\"474\":8,\"475\":1,\"477\":4,\"478\":2,\"479\":1,\"480\":3,\"481\":3,\"482\":4},\"2\":{\"506\":1}}],[\"resilience\",{\"1\":{\"405\":1}}],[\"responsestatus\",{\"1\":{\"445\":1}}],[\"response\",{\"1\":{\"422\":3,\"469\":1}}],[\"resource=\",{\"1\":{\"442\":1}}],[\"resources\",{\"1\":{\"442\":1}}],[\"resources>\",{\"1\":{\"442\":1}}],[\"resources<\",{\"1\":{\"442\":1}}],[\"resource>\",{\"1\":{\"442\":2}}],[\"resourcetype\",{\"1\":{\"416\":1}}],[\"resource\",{\"1\":{\"402\":1,\"419\":5,\"424\":1,\"426\":1,\"432\":4,\"433\":2,\"434\":2,\"443\":2,\"477\":1}}],[\"restart\",{\"1\":{\"635\":1,\"822\":1}}],[\"restrict\",{\"1\":{\"618\":2}}],[\"restrict方式\",{\"1\":{\"618\":1}}],[\"rest接口第几次请求数\",{\"1\":{\"460\":1}}],[\"restcontrolleradvice\",{\"1\":{\"445\":1}}],[\"restcontroller\",{\"1\":{\"402\":2,\"403\":1,\"418\":1,\"432\":1,\"433\":1,\"434\":1,\"443\":1,\"446\":1,\"464\":1,\"477\":2}}],[\"resttemplate调用\",{\"1\":{\"447\":1}}],[\"resttemplateconfig\",{\"1\":{\"402\":1}}],[\"resttemplate\",{\"1\":{\"399\":1,\"402\":7,\"446\":5,\"451\":1,\"458\":1,\"459\":1,\"462\":1,\"464\":1}}],[\"restoreipaddresses\",{\"1\":{\"201\":1}}],[\"res=0\",{\"1\":{\"372\":1}}],[\"res$\",{\"1\":{\"307\":2}}],[\"res保存最终的一个行程\",{\"1\":{\"213\":1}}],[\"res集合中\",{\"1\":{\"203\":2}}],[\"res存放所有的集合\",{\"1\":{\"187\":1}}],[\"res++\",{\"1\":{\"155\":2,\"344\":1,\"372\":2}}],[\"res一定是从小到大排\",{\"1\":{\"56\":1}}],[\"resultn\",{\"1\":{\"559\":1}}],[\"resultdata<string>\",{\"1\":{\"445\":1}}],[\"resultdata<>\",{\"1\":{\"444\":2}}],[\"resultdata<t>\",{\"1\":{\"444\":5}}],[\"resultdata\",{\"1\":{\"420\":3,\"431\":2,\"432\":2,\"433\":2,\"434\":2,\"444\":10,\"445\":2,\"446\":4,\"464\":11}}],[\"result+\",{\"1\":{\"402\":1}}],[\"result++\",{\"1\":{\"372\":2}}],[\"result=\",{\"1\":{\"334\":5}}],[\"result==integer\",{\"1\":{\"286\":1}}],[\"result\",{\"1\":{\"54\":4,\"233\":2,\"282\":2,\"283\":4,\"286\":4,\"372\":2,\"402\":1,\"432\":2,\"474\":1,\"703\":1}}],[\"res\",{\"1\":{\"2\":4,\"3\":4,\"4\":4,\"6\":4,\"7\":4,\"8\":6,\"12\":9,\"14\":5,\"16\":4,\"18\":4,\"20\":4,\"22\":4,\"39\":15,\"43\":3,\"56\":9,\"58\":4,\"60\":8,\"122\":3,\"133\":4,\"135\":5,\"137\":4,\"143\":4,\"155\":2,\"163\":4,\"165\":3,\"175\":8,\"177\":8,\"179\":4,\"187\":6,\"190\":5,\"191\":3,\"193\":5,\"195\":4,\"197\":3,\"199\":7,\"201\":5,\"203\":6,\"205\":4,\"207\":5,\"209\":5,\"211\":3,\"213\":5,\"215\":4,\"222\":1,\"234\":3,\"245\":4,\"262\":4,\"289\":7,\"296\":11,\"305\":4,\"308\":6,\"311\":5,\"329\":3,\"334\":1,\"335\":3,\"344\":2,\"348\":7,\"368\":3,\"372\":1}}],[\"=emp\",{\"1\":{\"541\":5}}],[\"=root\",{\"1\":{\"431\":3,\"442\":1}}],[\"=7\",{\"1\":{\"334\":1}}],[\"=6\",{\"1\":{\"334\":1}}],[\"=5\",{\"1\":{\"334\":1}}],[\"=new\",{\"1\":{\"215\":1}}],[\"=null\",{\"1\":{\"22\":2}}],[\"=30\",{\"1\":{\"719\":2}}],[\"=3\",{\"1\":{\"187\":1,\"334\":1}}],[\"=2\",{\"1\":{\"140\":2}}],[\"=4\",{\"1\":{\"140\":2}}],[\"=min\",{\"1\":{\"83\":1}}],[\"=1\",{\"1\":{\"79\":1,\"85\":2,\"133\":1,\"460\":2}}],[\"=0\",{\"1\":{\"79\":1,\"124\":2,\"460\":2}}],[\"=========resilience4j\",{\"1\":{\"477\":1}}],[\"==================>结束新建订单\",{\"1\":{\"432\":1}}],[\"==================>开始新建订单\",{\"1\":{\"432\":1}}],[\"========================zipkin===================\",{\"1\":{\"486\":1}}],[\"========================seata===================\",{\"1\":{\"432\":1}}],[\"========================mybatis===================\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"==========applicationname\",{\"1\":{\"432\":1,\"443\":1,\"452\":1}}],[\"==0\",{\"1\":{\"372\":1}}],[\"==>\",{\"1\":{\"295\":2}}],[\"==target\",{\"1\":{\"275\":3}}],[\"==1\",{\"1\":{\"115\":1,\"326\":1}}],[\"==\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"6\":1,\"7\":1,\"8\":1,\"12\":3,\"14\":1,\"16\":2,\"18\":1,\"20\":1,\"22\":1,\"24\":2,\"26\":1,\"28\":3,\"31\":3,\"33\":12,\"35\":2,\"37\":5,\"39\":10,\"41\":6,\"43\":4,\"45\":8,\"46\":1,\"48\":1,\"52\":2,\"54\":5,\"56\":2,\"58\":1,\"60\":5,\"62\":12,\"66\":4,\"68\":6,\"70\":6,\"74\":1,\"87\":1,\"95\":3,\"96\":1,\"97\":1,\"101\":1,\"107\":1,\"113\":3,\"115\":4,\"117\":1,\"128\":1,\"137\":4,\"139\":2,\"140\":1,\"141\":1,\"146\":6,\"148\":1,\"150\":1,\"152\":4,\"153\":4,\"155\":6,\"157\":2,\"171\":2,\"173\":4,\"174\":1,\"175\":1,\"176\":1,\"177\":5,\"178\":1,\"179\":4,\"187\":2,\"190\":4,\"191\":2,\"193\":4,\"195\":3,\"197\":2,\"199\":2,\"201\":4,\"205\":1,\"209\":2,\"211\":10,\"212\":3,\"213\":3,\"215\":8,\"216\":2,\"217\":7,\"223\":1,\"224\":2,\"225\":2,\"226\":3,\"227\":2,\"228\":3,\"229\":2,\"230\":14,\"231\":2,\"232\":18,\"233\":2,\"245\":1,\"257\":1,\"261\":5,\"262\":1,\"268\":1,\"271\":4,\"273\":1,\"275\":2,\"276\":1,\"277\":1,\"280\":1,\"289\":1,\"290\":3,\"292\":2,\"293\":1,\"294\":1,\"297\":2,\"302\":1,\"303\":2,\"305\":1,\"308\":1,\"311\":2,\"312\":2,\"313\":1,\"317\":2,\"326\":6,\"344\":2,\"346\":4,\"350\":1,\"352\":3,\"354\":2,\"355\":2,\"358\":2,\"359\":1,\"362\":1,\"363\":1,\"365\":1,\"368\":1,\"372\":7,\"376\":1,\"378\":1,\"382\":2,\"386\":2,\"387\":2,\"389\":2,\"390\":2,\"391\":1,\"392\":4,\"416\":1,\"477\":2}}],[\"=\",{\"0\":{\"719\":1},\"1\":{\"2\":5,\"3\":1,\"4\":1,\"6\":5,\"7\":8,\"8\":5,\"11\":3,\"12\":20,\"13\":3,\"14\":8,\"16\":11,\"17\":2,\"18\":12,\"19\":2,\"20\":10,\"21\":2,\"22\":11,\"23\":2,\"24\":12,\"25\":2,\"26\":11,\"27\":2,\"28\":11,\"29\":4,\"30\":3,\"31\":15,\"32\":2,\"33\":7,\"34\":3,\"35\":11,\"36\":3,\"37\":6,\"38\":2,\"39\":21,\"40\":2,\"41\":7,\"42\":1,\"43\":13,\"44\":7,\"45\":5,\"46\":4,\"47\":7,\"48\":4,\"49\":7,\"50\":2,\"51\":7,\"52\":6,\"53\":4,\"54\":12,\"55\":2,\"56\":5,\"57\":2,\"58\":4,\"59\":2,\"60\":8,\"61\":10,\"62\":5,\"63\":7,\"65\":6,\"66\":8,\"67\":6,\"68\":7,\"69\":6,\"70\":9,\"71\":2,\"72\":4,\"73\":3,\"74\":2,\"78\":15,\"79\":6,\"80\":2,\"81\":15,\"82\":2,\"83\":6,\"84\":8,\"85\":10,\"86\":6,\"87\":9,\"88\":2,\"89\":7,\"91\":13,\"92\":14,\"93\":6,\"94\":2,\"95\":9,\"96\":3,\"97\":8,\"98\":10,\"99\":12,\"100\":6,\"101\":8,\"102\":6,\"103\":10,\"104\":4,\"105\":4,\"106\":7,\"107\":8,\"108\":4,\"109\":6,\"110\":6,\"111\":8,\"112\":9,\"113\":10,\"114\":9,\"115\":13,\"116\":4,\"117\":12,\"119\":6,\"120\":15,\"121\":16,\"122\":13,\"123\":16,\"124\":11,\"125\":16,\"126\":14,\"127\":2,\"128\":16,\"129\":9,\"130\":8,\"132\":3,\"133\":6,\"134\":2,\"135\":5,\"136\":4,\"137\":12,\"138\":6,\"139\":7,\"140\":6,\"141\":9,\"142\":3,\"143\":9,\"145\":4,\"146\":14,\"147\":4,\"148\":9,\"149\":4,\"150\":10,\"151\":4,\"152\":27,\"153\":13,\"154\":2,\"155\":9,\"156\":2,\"157\":15,\"161\":4,\"163\":7,\"164\":3,\"165\":5,\"166\":4,\"168\":3,\"169\":6,\"170\":4,\"171\":14,\"172\":4,\"173\":4,\"174\":6,\"175\":11,\"176\":12,\"177\":9,\"178\":4,\"179\":5,\"186\":4,\"187\":8,\"188\":8,\"189\":11,\"190\":9,\"191\":4,\"192\":3,\"193\":9,\"194\":8,\"195\":6,\"196\":4,\"197\":6,\"198\":2,\"199\":14,\"200\":3,\"201\":19,\"202\":2,\"203\":6,\"204\":2,\"205\":3,\"206\":2,\"207\":8,\"208\":3,\"209\":6,\"210\":2,\"211\":8,\"212\":4,\"213\":10,\"214\":2,\"215\":18,\"216\":1,\"217\":23,\"222\":2,\"223\":3,\"224\":6,\"225\":2,\"226\":19,\"227\":2,\"228\":25,\"229\":2,\"230\":25,\"231\":2,\"232\":27,\"233\":3,\"234\":15,\"240\":12,\"242\":5,\"244\":3,\"245\":8,\"246\":2,\"248\":3,\"249\":2,\"251\":5,\"252\":4,\"254\":6,\"255\":4,\"256\":6,\"257\":10,\"259\":2,\"260\":2,\"261\":2,\"262\":7,\"266\":3,\"268\":1,\"269\":4,\"270\":2,\"271\":12,\"273\":15,\"274\":10,\"275\":20,\"276\":15,\"277\":13,\"278\":10,\"280\":6,\"281\":2,\"282\":2,\"283\":8,\"284\":6,\"286\":6,\"287\":2,\"289\":11,\"290\":7,\"292\":5,\"293\":5,\"294\":3,\"296\":3,\"297\":2,\"298\":9,\"299\":36,\"302\":11,\"303\":2,\"304\":1,\"305\":11,\"306\":2,\"308\":6,\"309\":2,\"311\":4,\"312\":8,\"313\":3,\"314\":4,\"315\":2,\"317\":6,\"321\":1,\"323\":2,\"324\":3,\"326\":7,\"329\":4,\"330\":11,\"332\":3,\"333\":4,\"334\":19,\"335\":6,\"336\":4,\"338\":5,\"343\":4,\"344\":3,\"345\":3,\"346\":5,\"347\":3,\"348\":6,\"349\":2,\"350\":9,\"351\":2,\"352\":6,\"353\":6,\"354\":4,\"355\":14,\"356\":7,\"357\":2,\"358\":4,\"359\":2,\"360\":9,\"361\":4,\"362\":1,\"363\":8,\"364\":9,\"365\":4,\"366\":6,\"367\":2,\"368\":10,\"369\":3,\"370\":7,\"372\":3,\"376\":6,\"377\":1,\"378\":6,\"379\":6,\"380\":3,\"381\":2,\"382\":10,\"383\":6,\"384\":15,\"385\":3,\"387\":4,\"388\":6,\"389\":11,\"390\":15,\"392\":12,\"393\":6,\"395\":4,\"400\":1,\"402\":2,\"410\":1,\"416\":3,\"417\":6,\"418\":1,\"420\":2,\"422\":2,\"423\":5,\"424\":3,\"428\":8,\"431\":23,\"432\":10,\"433\":3,\"434\":4,\"442\":2,\"443\":7,\"444\":12,\"446\":1,\"451\":1,\"459\":1,\"460\":4,\"463\":9,\"464\":4,\"477\":6,\"480\":4,\"481\":5,\"482\":3,\"491\":1,\"495\":1,\"497\":1,\"503\":3,\"504\":1,\"525\":1,\"528\":7,\"529\":1,\"533\":5,\"536\":1,\"538\":3,\"539\":2,\"541\":4,\"542\":2,\"565\":1,\"569\":3,\"573\":9,\"574\":1,\"575\":1,\"578\":5,\"579\":4,\"587\":2,\"589\":1,\"599\":2,\"613\":1,\"615\":1,\"618\":1,\"643\":1,\"651\":1,\"658\":1,\"696\":1,\"698\":1,\"704\":8,\"705\":1,\"707\":1,\"709\":2,\"710\":11,\"715\":3,\"716\":2,\"717\":3,\"718\":1,\"721\":1,\"725\":3,\"726\":1,\"728\":4,\"745\":1,\"746\":1,\"771\":2,\"800\":9,\"870\":1}}],[\"t选项\",{\"1\":{\"831\":1}}],[\"tbname\",{\"1\":{\"831\":2}}],[\"t2\",{\"1\":{\"771\":1}}],[\"t1\",{\"1\":{\"689\":1,\"763\":2,\"771\":1}}],[\"tuesday\",{\"1\":{\"555\":1}}],[\"tk单独使用\",{\"1\":{\"442\":1}}],[\"tk\",{\"1\":{\"432\":1,\"442\":2}}],[\"txt的文件也是可以的\",{\"1\":{\"831\":1}}],[\"txtimeoutcheck\",{\"1\":{\"428\":1}}],[\"tx\",{\"1\":{\"432\":3}}],[\"tm\",{\"1\":{\"426\":3,\"435\":1}}],[\"tmp\",{\"1\":{\"299\":2}}],[\"tcp\",{\"1\":{\"449\":1,\"625\":2}}],[\"tc\",{\"1\":{\"426\":6}}],[\"tcc\",{\"1\":{\"426\":1}}],[\"type△\",{\"0\":{\"704\":1}}],[\"type的值就是dependent\",{\"1\":{\"703\":1}}],[\"type为dependent\",{\"1\":{\"703\":1}}],[\"type为1的情况\",{\"1\":{\"680\":1}}],[\"type就是derived\",{\"1\":{\"703\":1}}],[\"type就是dependent\",{\"1\":{\"703\":1}}],[\"type就是subquery\",{\"1\":{\"703\":1}}],[\"type都能取哪些值\",{\"1\":{\"703\":1}}],[\"type属性就是materialized\",{\"1\":{\"703\":1}}],[\"type属性\",{\"1\":{\"703\":1}}],[\"type值就是union\",{\"1\":{\"703\":1}}],[\"type值就是primary\",{\"1\":{\"703\":1}}],[\"type值分别为2和3\",{\"1\":{\"680\":1}}],[\"type值都是0\",{\"1\":{\"680\":1}}],[\"type参数取值如下\",{\"1\":{\"558\":1}}],[\"type和format\",{\"1\":{\"558\":1}}],[\"type指定返回的值\",{\"1\":{\"555\":1}}],[\"types\",{\"1\":{\"469\":1}}],[\"type=\",{\"1\":{\"442\":2}}],[\"type=1\",{\"1\":{\"422\":1}}],[\"type`\",{\"1\":{\"428\":1}}],[\"typereference<set<gatewayflowrule>>\",{\"1\":{\"424\":1}}],[\"type说明\",{\"1\":{\"419\":1}}],[\"type\",{\"0\":{\"703\":1},\"1\":{\"416\":1,\"419\":4,\"429\":3,\"432\":3,\"443\":2,\"444\":1,\"452\":2,\"476\":1,\"480\":3,\"481\":5,\"555\":2,\"557\":4,\"558\":2,\"643\":1,\"645\":2,\"668\":1,\"680\":1,\"687\":1,\"701\":2,\"703\":1,\"704\":1}}],[\"type>\",{\"1\":{\"399\":1,\"441\":3,\"486\":1}}],[\"tt\",{\"1\":{\"261\":1}}],[\"tsetnoc\",{\"1\":{\"246\":1}}],[\"title\",{\"1\":{\"883\":3}}],[\"time的所有查询\",{\"1\":{\"805\":1}}],[\"time的默认值为10\",{\"1\":{\"697\":1}}],[\"time类型\",{\"1\":{\"602\":1}}],[\"timediff\",{\"1\":{\"557\":3}}],[\"time2\",{\"1\":{\"557\":4}}],[\"time1\",{\"1\":{\"557\":4}}],[\"timelimiter默认限制远程1s\",{\"1\":{\"481\":1}}],[\"timelimiter\",{\"1\":{\"474\":1,\"478\":2,\"480\":1,\"481\":1}}],[\"timeout\",{\"1\":{\"466\":2,\"474\":1,\"478\":1,\"480\":1,\"481\":1,\"482\":1,\"786\":1}}],[\"timezone\",{\"1\":{\"444\":2}}],[\"time\",{\"1\":{\"444\":2,\"453\":1,\"476\":1,\"478\":2,\"503\":4,\"554\":2,\"555\":3,\"556\":4,\"557\":1,\"558\":2,\"602\":1,\"696\":2,\"697\":1,\"698\":2}}],[\"timestamp\",{\"1\":{\"440\":5,\"444\":2,\"554\":8,\"602\":1}}],[\"timeunit\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"time`\",{\"1\":{\"428\":1,\"440\":2}}],[\"timewindow\",{\"1\":{\"419\":1}}],[\"tinyint\",{\"1\":{\"428\":3,\"440\":1,\"593\":1,\"595\":1,\"598\":1}}],[\"tindex++\",{\"1\":{\"146\":1}}],[\"tindex\",{\"1\":{\"146\":6}}],[\"tindex指向t\",{\"1\":{\"146\":1}}],[\"tickets\",{\"1\":{\"212\":6,\"213\":23}}],[\"throws\",{\"1\":{\"424\":1}}],[\"throw\",{\"1\":{\"416\":1,\"477\":1}}],[\"throwable>\",{\"1\":{\"416\":2}}],[\"throwable\",{\"1\":{\"416\":3,\"422\":1,\"423\":1,\"477\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"thread每隔1s进行一次重做日\",{\"1\":{\"753\":1}}],[\"thread\",{\"1\":{\"481\":5,\"820\":1,\"822\":1}}],[\"threadpool的例子\",{\"1\":{\"481\":1}}],[\"threadpool\",{\"1\":{\"481\":6}}],[\"threshold\",{\"1\":{\"411\":1,\"476\":3}}],[\"threesum1\",{\"1\":{\"177\":1}}],[\"threesum\",{\"1\":{\"177\":1}}],[\"these\",{\"1\":{\"822\":1}}],[\"there\",{\"1\":{\"617\":1}}],[\"then\",{\"1\":{\"503\":1,\"559\":9,\"575\":1}}],[\"the\",{\"1\":{\"244\":2,\"321\":1,\"423\":1,\"428\":4,\"429\":9,\"431\":3,\"445\":1,\"481\":2,\"822\":1,\"883\":1}}],[\"this\",{\"1\":{\"2\":4,\"16\":4,\"18\":4,\"22\":4,\"26\":4,\"28\":4,\"31\":8,\"35\":4,\"37\":4,\"117\":4,\"384\":3,\"423\":2,\"429\":1,\"431\":3,\"444\":3}}],[\"twosum1\",{\"1\":{\"175\":1}}],[\"twosum\",{\"1\":{\"175\":1,\"242\":1}}],[\"t串中出现字符的次数递减\",{\"1\":{\"163\":1}}],[\"t分别排序\",{\"1\":{\"163\":1}}],[\"t中找到了一个字符在s中也出现了\",{\"1\":{\"153\":1}}],[\"t中前\",{\"1\":{\"146\":1}}],[\"test`\",{\"1\":{\"595\":1}}],[\"test2\",{\"1\":{\"418\":1}}],[\"test1\",{\"1\":{\"418\":1}}],[\"testhotkey\",{\"1\":{\"417\":8,\"419\":1}}],[\"testdatabase\",{\"1\":{\"586\":2}}],[\"testd\",{\"1\":{\"410\":4}}],[\"testc\",{\"1\":{\"410\":4}}],[\"testb\",{\"1\":{\"410\":1,\"411\":1}}],[\"testa\",{\"1\":{\"410\":2}}],[\"test<\",{\"1\":{\"402\":1,\"432\":1,\"441\":1,\"442\":1,\"443\":1}}],[\"test\",{\"1\":{\"402\":1,\"403\":1,\"432\":1,\"441\":4,\"443\":1,\"497\":1,\"606\":6,\"607\":5,\"608\":3,\"676\":2}}],[\"testweightbagproblembyone\",{\"1\":{\"92\":1}}],[\"testweightbagproblem\",{\"1\":{\"91\":2}}],[\"ten++\",{\"1\":{\"358\":1}}],[\"ten\",{\"1\":{\"358\":3}}],[\"tel\",{\"1\":{\"246\":1}}],[\"team\",{\"1\":{\"565\":5,\"736\":1}}],[\"tea\",{\"1\":{\"164\":2}}],[\"text类型\",{\"1\":{\"678\":1}}],[\"text文本类型\",{\"1\":{\"605\":1}}],[\"text用来保存文本类型的字符串\",{\"1\":{\"605\":1}}],[\"text\",{\"0\":{\"605\":1},\"1\":{\"469\":1,\"605\":2}}],[\"text2的最长公共子序列\",{\"1\":{\"139\":1}}],[\"text2从\",{\"1\":{\"139\":1}}],[\"text2\",{\"1\":{\"138\":6,\"139\":2}}],[\"text1的最长公共子序列\",{\"1\":{\"139\":1}}],[\"text1\",{\"1\":{\"138\":6,\"139\":2}}],[\"temporary`并不是一个好的征兆\",{\"1\":{\"710\":1}}],[\"temporary`提示\",{\"1\":{\"710\":1}}],[\"temp$$\",{\"1\":{\"299\":1}}],[\"temp$\",{\"1\":{\"299\":1}}],[\"temp\",{\"1\":{\"31\":2,\"115\":3,\"251\":2,\"254\":2,\"256\":2,\"298\":4,\"299\":13,\"317\":2,\"382\":3,\"389\":11,\"392\":11,\"395\":7,\"619\":1}}],[\"task\",{\"1\":{\"836\":1}}],[\"tailer\",{\"1\":{\"667\":1}}],[\"take\",{\"1\":{\"246\":1}}],[\"tar\",{\"1\":{\"542\":3}}],[\"tartget\",{\"1\":{\"195\":1}}],[\"targetproject=\",{\"1\":{\"442\":3}}],[\"targetpackage=\",{\"1\":{\"442\":3}}],[\"targetruntime=\",{\"1\":{\"442\":1}}],[\"target>\",{\"1\":{\"441\":1}}],[\"target>17<\",{\"1\":{\"441\":1}}],[\"target的关系\",{\"1\":{\"273\":1}}],[\"target~n\",{\"1\":{\"256\":1}}],[\"target~\",{\"1\":{\"256\":1}}],[\"target是\",{\"1\":{\"179\":1}}],[\"target$\",{\"1\":{\"179\":1}}],[\"target\",{\"1\":{\"95\":7,\"97\":4,\"98\":5,\"99\":8,\"104\":5,\"105\":4,\"174\":5,\"175\":6,\"178\":5,\"179\":6,\"194\":7,\"195\":12,\"196\":5,\"197\":6,\"240\":5,\"241\":1,\"242\":3,\"255\":5,\"256\":6,\"269\":4,\"271\":10,\"273\":18,\"275\":10,\"277\":12,\"284\":5,\"285\":1,\"286\":2,\"416\":1}}],[\"targetsum\",{\"1\":{\"44\":6,\"45\":7}}],[\"tan\",{\"1\":{\"164\":2,\"549\":1}}],[\"table=atguigu\",{\"1\":{\"831\":1}}],[\"table语在存在的表上创建索引\",{\"1\":{\"687\":1}}],[\"tablename\",{\"1\":{\"618\":1}}],[\"tablename=\",{\"1\":{\"431\":3,\"442\":1}}],[\"tables\",{\"1\":{\"586\":1,\"770\":3,\"785\":1}}],[\"table2\",{\"1\":{\"540\":1}}],[\"table1\",{\"1\":{\"540\":1}}],[\"table>\",{\"1\":{\"431\":3,\"442\":1}}],[\"table`\",{\"1\":{\"428\":3}}],[\"table\",{\"0\":{\"701\":1},\"1\":{\"77\":1,\"79\":1,\"81\":1,\"83\":1,\"85\":1,\"338\":4,\"428\":7,\"429\":7,\"431\":12,\"440\":2,\"542\":4,\"563\":1,\"587\":3,\"588\":7,\"589\":1,\"595\":1,\"606\":1,\"607\":1,\"608\":1,\"612\":2,\"613\":3,\"614\":2,\"615\":7,\"616\":4,\"617\":8,\"618\":12,\"619\":1,\"620\":2,\"643\":1,\"676\":5,\"687\":10,\"701\":1,\"704\":1,\"770\":2,\"771\":2,\"831\":1,\"832\":1}}],[\"toc\",{\"1\":{\"861\":1}}],[\"tochararray\",{\"1\":{\"101\":1,\"139\":2,\"163\":2,\"165\":1,\"193\":1,\"254\":1,\"256\":1,\"368\":1,\"370\":1}}],[\"tong\",{\"1\":{\"676\":1,\"680\":1}}],[\"too\",{\"1\":{\"423\":2}}],[\"tomcat\",{\"1\":{\"407\":1}}],[\"tokenvalidityinmilliseconds\",{\"1\":{\"429\":1}}],[\"token\",{\"1\":{\"332\":3,\"444\":1}}],[\"tokens\",{\"1\":{\"330\":6,\"332\":2}}],[\"topic\",{\"1\":{\"429\":1}}],[\"topkfrequent\",{\"1\":{\"338\":1}}],[\"top\",{\"1\":{\"321\":2}}],[\"toi\",{\"1\":{\"212\":4}}],[\"toarray\",{\"1\":{\"168\":2,\"296\":1,\"354\":1,\"362\":1}}],[\"tostring\",{\"1\":{\"83\":1,\"92\":1,\"103\":1,\"105\":1,\"193\":2,\"248\":1,\"329\":1,\"443\":1}}],[\"total<0不能走完一圈\",{\"1\":{\"356\":1}}],[\"total\",{\"1\":{\"74\":2,\"356\":7}}],[\"to\",{\"1\":{\"73\":1,\"321\":1,\"428\":3,\"429\":2,\"431\":3,\"432\":1,\"443\":1,\"452\":1,\"513\":3,\"556\":2,\"557\":2,\"558\":4,\"588\":1,\"809\":1,\"822\":1,\"825\":2,\"826\":2}}],[\"t\",{\"1\":{\"61\":1,\"63\":1,\"91\":1,\"145\":6,\"146\":8,\"147\":6,\"148\":12,\"151\":1,\"153\":9,\"161\":8,\"162\":1,\"163\":6,\"193\":2,\"402\":2,\"416\":1,\"423\":1,\"431\":11,\"432\":3,\"433\":1,\"434\":1,\"440\":2,\"442\":2,\"444\":2,\"477\":2,\"480\":1,\"481\":4,\"482\":1,\"579\":3,\"618\":1,\"634\":2,\"699\":9,\"704\":3,\"726\":2,\"770\":4}}],[\"trx信息\",{\"1\":{\"763\":1}}],[\"trx\",{\"1\":{\"681\":1,\"753\":1,\"794\":1,\"797\":3,\"798\":2,\"800\":8}}],[\"trigger的调用和触发无法被正确复制的问题\",{\"1\":{\"823\":1}}],[\"trigger\",{\"1\":{\"589\":1}}],[\"trim\",{\"1\":{\"245\":2,\"552\":4}}],[\"trimbst1\",{\"1\":{\"70\":3}}],[\"trimbst\",{\"1\":{\"70\":5}}],[\"trust\",{\"1\":{\"809\":1}}],[\"truncated\",{\"1\":{\"606\":1}}],[\"truncate\",{\"0\":{\"589\":1},\"1\":{\"517\":1,\"548\":4,\"588\":1,\"589\":3}}],[\"true\",{\"1\":{\"32\":1,\"33\":4,\"36\":2,\"37\":1,\"44\":2,\"45\":1,\"55\":1,\"56\":2,\"94\":1,\"95\":1,\"110\":5,\"111\":4,\"145\":1,\"155\":4,\"161\":1,\"163\":1,\"169\":2,\"171\":1,\"172\":3,\"199\":2,\"201\":2,\"211\":5,\"213\":6,\"215\":6,\"217\":9,\"226\":2,\"228\":2,\"234\":1,\"261\":2,\"262\":1,\"266\":3,\"274\":2,\"302\":1,\"321\":1,\"324\":2,\"349\":2,\"350\":5,\"357\":3,\"358\":1,\"420\":1,\"432\":1,\"442\":1,\"443\":1,\"444\":1,\"452\":1,\"464\":1,\"468\":1,\"469\":2,\"477\":3,\"489\":1,\"497\":1,\"763\":2}}],[\"try\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"trade\",{\"1\":{\"836\":1}}],[\"traditional\",{\"1\":{\"772\":1}}],[\"trailing\",{\"1\":{\"552\":1}}],[\"tracing<\",{\"1\":{\"486\":2}}],[\"tracing指标追踪\",{\"1\":{\"486\":2}}],[\"tracing\",{\"1\":{\"486\":13}}],[\"transactional\",{\"1\":{\"432\":1}}],[\"transaction\",{\"1\":{\"426\":3,\"428\":1,\"431\":9,\"517\":1,\"744\":2,\"745\":1,\"746\":4,\"757\":1,\"774\":1}}],[\"transport\",{\"1\":{\"408\":1,\"420\":1,\"422\":1,\"423\":1}}],[\"traversal\",{\"1\":{\"12\":1,\"372\":4}}],[\"tree\",{\"0\":{\"661\":1,\"662\":1},\"1\":{\"12\":1,\"16\":1,\"18\":1,\"22\":1,\"26\":1,\"28\":1,\"31\":2,\"35\":1,\"37\":1,\"73\":3,\"117\":1,\"653\":2,\"660\":1,\"661\":2,\"662\":2,\"716\":1}}],[\"treenode\",{\"1\":{\"2\":9,\"3\":1,\"4\":1,\"6\":2,\"7\":3,\"8\":2,\"12\":15,\"14\":2,\"16\":10,\"18\":10,\"22\":10,\"26\":10,\"28\":10,\"29\":2,\"31\":23,\"33\":6,\"35\":11,\"37\":12,\"39\":13,\"41\":4,\"43\":5,\"45\":4,\"47\":4,\"49\":4,\"51\":4,\"52\":3,\"54\":11,\"56\":3,\"58\":2,\"60\":2,\"62\":6,\"64\":4,\"66\":9,\"68\":3,\"70\":5,\"72\":4,\"74\":3,\"117\":10,\"372\":4}}],[\"ix\",{\"1\":{\"771\":2}}],[\"icp可以用于myisam和innnodb存储引擎\",{\"1\":{\"728\":1}}],[\"icp可以减少存储引擎访问基表的次数以及mysql服务器访问存储引擎的次数\",{\"1\":{\"728\":1}}],[\"icp使用条件\",{\"1\":{\"728\":1}}],[\"icp\",{\"1\":{\"728\":1}}],[\"ico\",{\"1\":{\"429\":1}}],[\"iable\",{\"1\":{\"687\":1}}],[\"i0\",{\"1\":{\"660\":1}}],[\"ibd\",{\"1\":{\"636\":1}}],[\"ibd中\",{\"1\":{\"636\":1}}],[\"ibfk\",{\"1\":{\"618\":1}}],[\"ibm\",{\"1\":{\"516\":1}}],[\"it\",{\"1\":{\"431\":3,\"578\":6,\"617\":1,\"867\":2}}],[\"iterator\",{\"1\":{\"39\":2}}],[\"item集合中\",{\"1\":{\"187\":1}}],[\"item\",{\"1\":{\"12\":5,\"14\":3,\"20\":3,\"177\":5,\"187\":13,\"188\":11,\"190\":13,\"191\":7}}],[\"ignore\",{\"1\":{\"429\":1,\"823\":1,\"831\":2,\"832\":1}}],[\"id10\",{\"1\":{\"831\":1}}],[\"identified\",{\"1\":{\"825\":3}}],[\"id属性值是不是在\",{\"1\":{\"798\":1}}],[\"id属性值在readview的\",{\"1\":{\"798\":1}}],[\"id属性值大于或等于readview中的\",{\"1\":{\"798\":1}}],[\"id属性值小于readview中的\",{\"1\":{\"798\":1}}],[\"id属性值与readview中的\",{\"1\":{\"798\":1}}],[\"ids=\",{\"1\":{\"800\":2}}],[\"ids\",{\"1\":{\"797\":2,\"798\":1}}],[\"id在\",{\"1\":{\"776\":1}}],[\"id号每个号码\",{\"1\":{\"702\":1}}],[\"id值越大\",{\"1\":{\"702\":1}}],[\"id值相同\",{\"1\":{\"702\":1}}],[\"id值为多个\",{\"1\":{\"702\":1}}],[\"id是在没有自定义主键以及unique键的情况下才会存在的\",{\"1\":{\"681\":1}}],[\"id的值就是5\",{\"1\":{\"797\":1}}],[\"id的隐藏列作为主键\",{\"1\":{\"681\":1}}],[\"id的员工的employee\",{\"1\":{\"579\":1}}],[\"id与job\",{\"1\":{\"579\":1}}],[\"id与location\",{\"1\":{\"575\":1}}],[\"id以及\",{\"1\":{\"578\":2}}],[\"id中比job\",{\"1\":{\"578\":2}}],[\"id相同的数目不小于2\",{\"1\":{\"579\":1}}],[\"id相同的其他员工的employee\",{\"1\":{\"573\":1}}],[\"id相同\",{\"1\":{\"575\":1}}],[\"id为\",{\"1\":{\"578\":2}}],[\"id为1800\",{\"1\":{\"575\":1}}],[\"id为整数才可访问\",{\"1\":{\"493\":1}}],[\"id和department\",{\"1\":{\"573\":1}}],[\"id和salary\",{\"1\":{\"573\":1}}],[\"idx\",{\"1\":{\"552\":1,\"686\":1,\"715\":4,\"718\":2}}],[\"id唯一标识\",{\"1\":{\"484\":1}}],[\"idutil\",{\"1\":{\"477\":1}}],[\"id=2\",{\"1\":{\"824\":1}}],[\"id=20\",{\"1\":{\"800\":2}}],[\"id=31\",{\"1\":{\"800\":1}}],[\"id=10\",{\"1\":{\"800\":1}}],[\"id=1\",{\"1\":{\"800\":1}}],[\"id=900001\",{\"1\":{\"696\":1}}],[\"id=\",{\"1\":{\"433\":1,\"434\":1,\"442\":1,\"823\":1}}],[\"id`\",{\"1\":{\"428\":15,\"431\":12,\"440\":1,\"579\":2}}],[\"id\",{\"0\":{\"702\":1},\"1\":{\"402\":9,\"404\":1,\"422\":1,\"426\":1,\"431\":10,\"433\":1,\"434\":1,\"442\":1,\"443\":15,\"446\":4,\"464\":9,\"477\":15,\"480\":5,\"481\":6,\"482\":5,\"484\":1,\"489\":2,\"491\":2,\"492\":3,\"493\":4,\"494\":1,\"495\":1,\"496\":1,\"497\":1,\"499\":3,\"500\":1,\"502\":3,\"504\":1,\"522\":7,\"523\":1,\"525\":1,\"529\":1,\"533\":12,\"536\":4,\"538\":6,\"539\":4,\"541\":23,\"559\":1,\"563\":2,\"564\":4,\"565\":4,\"573\":23,\"574\":3,\"575\":5,\"578\":17,\"579\":20,\"587\":4,\"618\":6,\"619\":2,\"634\":2,\"681\":2,\"686\":1,\"687\":6,\"689\":1,\"696\":7,\"701\":1,\"704\":4,\"707\":2,\"710\":2,\"726\":5,\"731\":1,\"737\":1,\"767\":1,\"771\":4,\"777\":2,\"794\":2,\"797\":8,\"798\":5,\"799\":1,\"800\":15,\"831\":1,\"836\":2,\"837\":4,\"874\":1}}],[\"io是很耗时的\",{\"1\":{\"725\":1}}],[\"io次数就越少\",{\"1\":{\"648\":1}}],[\"io\",{\"1\":{\"399\":1,\"405\":1,\"429\":1,\"432\":1,\"449\":1,\"458\":1,\"485\":1,\"657\":2,\"660\":1,\"725\":1,\"822\":1}}],[\"i的位置比最远距离还要远\",{\"1\":{\"350\":2}}],[\"i的元素与\",{\"1\":{\"133\":1}}],[\"i=7\",{\"1\":{\"334\":1}}],[\"i=6\",{\"1\":{\"334\":1}}],[\"i=5\",{\"1\":{\"334\":1}}],[\"i=4\",{\"1\":{\"334\":1}}],[\"i=3\",{\"1\":{\"334\":1}}],[\"i=startindex\",{\"1\":{\"197\":1}}],[\"i在区间之内\",{\"1\":{\"334\":1}}],[\"i是偶数\",{\"1\":{\"305\":1}}],[\"i是奇数\",{\"1\":{\"305\":1}}],[\"i为奇数\",{\"1\":{\"304\":2}}],[\"i为偶数\",{\"1\":{\"304\":3}}],[\"i$\",{\"1\":{\"299\":1}}],[\"i>cover\",{\"1\":{\"350\":2}}],[\"i>\",{\"1\":{\"205\":1}}],[\"i>0\",{\"1\":{\"177\":1}}],[\"ii\",{\"0\":{\"287\":1},\"1\":{\"205\":1}}],[\"iptables\",{\"1\":{\"824\":1}}],[\"ipv4或ipv6\",{\"1\":{\"495\":1}}],[\"ip地址了\",{\"1\":{\"451\":1}}],[\"ip\",{\"1\":{\"200\":5,\"464\":1,\"489\":1,\"495\":2,\"822\":1}}],[\"i<=n\",{\"1\":{\"188\":1}}],[\"i<=\",{\"1\":{\"188\":1}}],[\"i到j\",{\"1\":{\"155\":1}}],[\"i~j\",{\"1\":{\"155\":2,\"157\":3,\"262\":1}}],[\"i+nums\",{\"1\":{\"350\":4,\"352\":1}}],[\"i+k\",{\"1\":{\"254\":2}}],[\"i+=2\",{\"1\":{\"259\":1}}],[\"i+=\",{\"1\":{\"254\":1}}],[\"i+1~j\",{\"1\":{\"157\":1}}],[\"i+1\",{\"1\":{\"155\":7,\"157\":4,\"175\":1,\"177\":4,\"179\":2,\"187\":3,\"188\":1,\"199\":2,\"203\":2,\"205\":1,\"245\":1,\"259\":1,\"261\":3,\"262\":2,\"355\":1,\"356\":3,\"370\":2}}],[\"i++\",{\"1\":{\"12\":2,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"35\":1,\"43\":1,\"47\":1,\"49\":1,\"51\":1,\"56\":1,\"60\":1,\"79\":1,\"81\":2,\"83\":1,\"85\":3,\"87\":1,\"89\":1,\"91\":2,\"92\":2,\"93\":2,\"95\":1,\"97\":1,\"99\":2,\"103\":3,\"105\":1,\"107\":1,\"109\":1,\"111\":1,\"113\":1,\"115\":2,\"120\":1,\"122\":2,\"124\":1,\"126\":1,\"128\":1,\"130\":1,\"133\":1,\"135\":1,\"137\":2,\"139\":1,\"141\":1,\"143\":1,\"146\":1,\"148\":2,\"150\":1,\"152\":3,\"157\":2,\"163\":1,\"165\":1,\"175\":2,\"177\":2,\"179\":1,\"187\":3,\"188\":1,\"190\":2,\"191\":1,\"193\":2,\"195\":2,\"197\":1,\"199\":4,\"201\":4,\"203\":2,\"205\":1,\"207\":2,\"209\":2,\"211\":1,\"213\":1,\"215\":2,\"217\":6,\"224\":2,\"226\":2,\"228\":2,\"230\":5,\"232\":5,\"234\":4,\"248\":1,\"273\":1,\"275\":2,\"278\":1,\"280\":1,\"283\":2,\"289\":1,\"293\":2,\"296\":1,\"298\":2,\"299\":1,\"302\":2,\"305\":1,\"308\":1,\"311\":1,\"312\":1,\"326\":1,\"329\":1,\"335\":1,\"338\":1,\"346\":1,\"348\":1,\"350\":3,\"352\":1,\"354\":1,\"356\":1,\"358\":1,\"360\":2,\"364\":2,\"366\":1,\"368\":2,\"370\":1,\"384\":2}}],[\"i个字符串\",{\"1\":{\"111\":1}}],[\"i−2\",{\"1\":{\"83\":2}}],[\"i−1\",{\"1\":{\"83\":2}}],[\"isolation\",{\"1\":{\"746\":4}}],[\"isnull\",{\"0\":{\"720\":1}}],[\"isnullorempty\",{\"1\":{\"497\":1}}],[\"isbadversion\",{\"1\":{\"274\":5}}],[\"isbalanced\",{\"1\":{\"37\":4}}],[\"is\",{\"0\":{\"720\":1},\"1\":{\"244\":2,\"321\":5,\"426\":1,\"428\":1,\"429\":3,\"452\":1,\"454\":1,\"541\":5,\"704\":1,\"710\":1,\"720\":2,\"763\":5,\"771\":2,\"809\":1}}],[\"isvalid\",{\"1\":{\"201\":4,\"215\":4,\"217\":4,\"326\":1}}],[\"isvalidbst\",{\"1\":{\"56\":3}}],[\"isvalidbst1\",{\"1\":{\"56\":1}}],[\"ispalindrome\",{\"1\":{\"199\":4}}],[\"isugly\",{\"1\":{\"173\":1}}],[\"ishappy1\",{\"1\":{\"171\":1}}],[\"ishappy\",{\"1\":{\"171\":2}}],[\"isanagram1\",{\"1\":{\"163\":1}}],[\"isanagram\",{\"1\":{\"163\":1}}],[\"issubsequence1\",{\"1\":{\"146\":1}}],[\"issubsequence\",{\"1\":{\"146\":1}}],[\"issymmetric1\",{\"1\":{\"33\":1}}],[\"issymmetric2\",{\"1\":{\"33\":1}}],[\"isempty\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"12\":3,\"14\":1,\"16\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":1,\"29\":1,\"31\":1,\"35\":1,\"39\":4,\"41\":1,\"43\":2,\"45\":1,\"54\":1,\"207\":2,\"226\":1,\"228\":1,\"230\":1,\"232\":1,\"323\":2,\"326\":2,\"329\":2,\"335\":1}}],[\"i\",{\"1\":{\"12\":5,\"14\":2,\"16\":3,\"18\":2,\"20\":2,\"22\":2,\"24\":3,\"26\":2,\"28\":2,\"35\":2,\"43\":2,\"46\":2,\"47\":4,\"48\":2,\"49\":4,\"50\":1,\"51\":4,\"56\":4,\"60\":4,\"71\":1,\"79\":11,\"81\":21,\"82\":3,\"83\":15,\"85\":21,\"87\":21,\"89\":10,\"91\":32,\"92\":14,\"93\":10,\"94\":1,\"95\":13,\"96\":3,\"97\":3,\"98\":2,\"99\":16,\"100\":2,\"101\":13,\"102\":1,\"103\":13,\"104\":1,\"105\":5,\"106\":1,\"107\":15,\"109\":11,\"110\":2,\"111\":9,\"112\":1,\"113\":19,\"114\":1,\"115\":12,\"117\":2,\"119\":4,\"120\":25,\"121\":3,\"122\":34,\"123\":3,\"124\":44,\"125\":3,\"126\":48,\"127\":3,\"128\":31,\"129\":3,\"130\":20,\"132\":1,\"133\":15,\"134\":4,\"135\":4,\"136\":2,\"137\":23,\"139\":17,\"140\":3,\"141\":10,\"142\":1,\"143\":15,\"146\":20,\"148\":31,\"150\":8,\"151\":1,\"152\":48,\"153\":53,\"155\":29,\"157\":30,\"163\":4,\"164\":2,\"165\":4,\"166\":2,\"168\":4,\"174\":1,\"175\":12,\"176\":5,\"177\":21,\"178\":1,\"179\":14,\"187\":8,\"188\":3,\"190\":12,\"191\":6,\"192\":1,\"193\":8,\"194\":1,\"195\":14,\"196\":1,\"197\":11,\"199\":18,\"201\":20,\"202\":1,\"203\":6,\"204\":1,\"205\":6,\"206\":1,\"207\":14,\"208\":1,\"209\":8,\"210\":1,\"211\":30,\"212\":2,\"213\":25,\"215\":22,\"216\":2,\"217\":18,\"223\":8,\"224\":10,\"225\":2,\"226\":23,\"227\":2,\"228\":13,\"229\":2,\"230\":22,\"231\":2,\"232\":28,\"233\":1,\"234\":17,\"240\":1,\"245\":11,\"248\":4,\"249\":1,\"254\":3,\"257\":1,\"259\":3,\"261\":15,\"262\":9,\"273\":7,\"275\":9,\"276\":1,\"277\":1,\"278\":3,\"280\":3,\"282\":8,\"283\":11,\"289\":8,\"290\":1,\"293\":8,\"294\":2,\"295\":5,\"296\":5,\"297\":2,\"298\":12,\"299\":72,\"302\":8,\"303\":2,\"304\":24,\"305\":11,\"306\":1,\"308\":3,\"311\":6,\"312\":5,\"315\":1,\"326\":4,\"329\":4,\"330\":1,\"333\":1,\"334\":6,\"335\":8,\"338\":3,\"343\":5,\"344\":4,\"345\":1,\"346\":6,\"347\":1,\"348\":5,\"349\":1,\"350\":14,\"351\":7,\"352\":6,\"353\":5,\"354\":5,\"355\":6,\"356\":13,\"357\":3,\"358\":4,\"359\":1,\"360\":30,\"361\":2,\"363\":2,\"364\":8,\"365\":2,\"366\":5,\"368\":10,\"370\":8,\"384\":4,\"443\":2,\"558\":2,\"660\":1,\"666\":1,\"704\":1,\"760\":1,\"820\":2,\"822\":1,\"886\":1}}],[\"ini\",{\"1\":{\"809\":1}}],[\"ini中做如下配置\",{\"1\":{\"807\":1}}],[\"ini配置文件来设置\",{\"1\":{\"806\":1}}],[\"init\",{\"1\":{\"424\":1,\"431\":3}}],[\"initblockhandler\",{\"1\":{\"423\":2}}],[\"initblockhandlers\",{\"1\":{\"422\":1}}],[\"inoodb\",{\"1\":{\"771\":1}}],[\"inorder保证\",{\"1\":{\"48\":1}}],[\"inorder保证是树的中序遍历\",{\"1\":{\"46\":1}}],[\"inorder\",{\"1\":{\"46\":9,\"47\":4,\"48\":8,\"49\":4}}],[\"inordertraversal2\",{\"1\":{\"7\":1}}],[\"inordertraversal\",{\"1\":{\"3\":3}}],[\"inner\",{\"1\":{\"538\":2,\"541\":1,\"701\":1,\"702\":1,\"704\":1,\"707\":1,\"709\":1,\"710\":1}}],[\"innodb规定使用加锁的方式来访问记录\",{\"1\":{\"797\":1}}],[\"innodb规定的最小记录与最大记录这两条记录的构造十分简单\",{\"1\":{\"672\":1}}],[\"innodb为每个事务构造了一个数组\",{\"1\":{\"796\":1}}],[\"innodb就把这种类型的锁命名为insert\",{\"1\":{\"778\":1}}],[\"innodb默认的锁就是next\",{\"1\":{\"777\":1}}],[\"innodb与myisam的最大不同有两点\",{\"1\":{\"774\":1}}],[\"innodb给出\",{\"1\":{\"753\":1}}],[\"innodb存储引擎使用两阶段提交方案\",{\"1\":{\"812\":1}}],[\"innodb存储引擎是不会为这个表添加表级别的\",{\"1\":{\"770\":1}}],[\"innodb存储引擎会对表\",{\"1\":{\"770\":2}}],[\"innodb存储引擎会执行一个相反的update\",{\"1\":{\"755\":1}}],[\"innodb存储引擎会执行一个insert\",{\"1\":{\"755\":1}}],[\"innodb存储引擎会完成一个delete\",{\"1\":{\"755\":1}}],[\"innodb存储引擎有一个后台线程\",{\"1\":{\"753\":1}}],[\"innodb存储引擎设计了4种不同类型的行格式\",{\"1\":{\"675\":1}}],[\"innodb存储引擎以页为单位把数据加载到内存中处理\",{\"1\":{\"668\":1}}],[\"innodb都是以页为单位存放数据的\",{\"1\":{\"668\":1}}],[\"innodb通过页号可以唯一定位一个页\",{\"1\":{\"668\":1}}],[\"innodb数据存储结构\",{\"0\":{\"665\":1}}],[\"innodb的索引方式为\",{\"1\":{\"655\":1}}],[\"innodb不支持全文索引\",{\"1\":{\"655\":1}}],[\"innodb不仅缓存索引还要缓存真实数据\",{\"1\":{\"636\":1,\"655\":1}}],[\"innodb支持行级锁\",{\"1\":{\"655\":1}}],[\"innodb支持外键\",{\"1\":{\"655\":1}}],[\"innodb支持mvcc\",{\"1\":{\"655\":1}}],[\"innodb支持事物\",{\"1\":{\"655\":1}}],[\"innodb中\",{\"1\":{\"799\":1}}],[\"innodb中的实现主要是为了提高数据库并发性能\",{\"1\":{\"791\":1}}],[\"innodb中的行锁\",{\"0\":{\"774\":1}}],[\"innodb中的索引方案\",{\"0\":{\"644\":1}}],[\"innodb中执行select\",{\"1\":{\"770\":1}}],[\"innodb中页的大小默认为\",{\"1\":{\"666\":1}}],[\"innodb中索引即数据\",{\"1\":{\"654\":1}}],[\"innodb和myisam默认的索\",{\"1\":{\"653\":1}}],[\"innodb会隐式的定义一个主键来作为聚簇索引\",{\"1\":{\"650\":1}}],[\"innodb会选择\",{\"1\":{\"650\":1}}],[\"innodb写的处理效率差一些\",{\"1\":{\"636\":1,\"655\":1}}],[\"innodb是\",{\"1\":{\"636\":1}}],[\"innodb是mysql的\",{\"1\":{\"636\":1}}],[\"innodb引擎会在写redo\",{\"1\":{\"753\":1}}],[\"innodb引擎与myisam引擎对比\",{\"0\":{\"655\":1}}],[\"innodb引擎\",{\"0\":{\"636\":1}}],[\"innodb引擎的表用count\",{\"1\":{\"562\":1}}],[\"innodb\",{\"0\":{\"675\":1},\"1\":{\"428\":4,\"431\":3,\"604\":1,\"635\":1,\"655\":1,\"666\":1,\"675\":1,\"729\":1,\"751\":2,\"753\":1,\"770\":1,\"771\":1,\"777\":1,\"794\":1,\"811\":2}}],[\"inputid\",{\"1\":{\"477\":1}}],[\"inputstack\",{\"1\":{\"323\":6}}],[\"invalid\",{\"1\":{\"444\":1}}],[\"inverttree\",{\"1\":{\"31\":4}}],[\"inc\",{\"1\":{\"772\":2}}],[\"incorrect\",{\"1\":{\"617\":2}}],[\"includes>\",{\"1\":{\"442\":1}}],[\"include>\",{\"1\":{\"442\":1}}],[\"increment相当于删除\",{\"1\":{\"617\":1}}],[\"increment=2\",{\"1\":{\"431\":1}}],[\"increment=1\",{\"1\":{\"431\":2,\"440\":1}}],[\"increment\",{\"1\":{\"431\":6,\"440\":1,\"617\":7,\"619\":1,\"687\":2,\"772\":2,\"823\":1}}],[\"incubator\",{\"1\":{\"428\":1,\"431\":1}}],[\"inherited\",{\"1\":{\"416\":1}}],[\"infimum\",{\"0\":{\"672\":1}}],[\"infimum+supremum\",{\"1\":{\"667\":1}}],[\"information\",{\"1\":{\"613\":2,\"615\":1,\"618\":1}}],[\"info`\",{\"1\":{\"431\":3}}],[\"info\",{\"1\":{\"403\":2,\"431\":3,\"432\":13,\"433\":2,\"434\":2,\"459\":3,\"464\":1,\"489\":1,\"503\":6,\"689\":1,\"696\":2,\"831\":4}}],[\"infectbfs\",{\"1\":{\"226\":2,\"228\":2,\"230\":2,\"232\":2}}],[\"infect\",{\"1\":{\"226\":6,\"228\":6,\"230\":6,\"232\":6,\"234\":6}}],[\"inention\",{\"1\":{\"151\":2}}],[\"inend\",{\"1\":{\"47\":3,\"49\":3}}],[\"instr\",{\"1\":{\"552\":1}}],[\"instances\",{\"1\":{\"460\":3,\"477\":1,\"478\":1,\"480\":1,\"481\":1,\"482\":1}}],[\"instance\",{\"1\":{\"441\":1}}],[\"instart\",{\"1\":{\"47\":6,\"49\":4}}],[\"insert语句\",{\"1\":{\"772\":1}}],[\"insert为主的应用\",{\"1\":{\"637\":1}}],[\"insertselective\",{\"1\":{\"432\":1,\"443\":1}}],[\"insert\",{\"0\":{\"778\":1},\"1\":{\"428\":4,\"431\":2,\"440\":1,\"517\":1,\"542\":5,\"552\":1,\"606\":5,\"607\":3,\"608\":1,\"676\":1,\"680\":1,\"689\":1,\"704\":1,\"731\":1,\"755\":1,\"770\":2,\"772\":6,\"778\":1,\"791\":1,\"794\":2,\"800\":2,\"823\":3,\"831\":1,\"832\":1}}],[\"insertintobst1\",{\"1\":{\"66\":1}}],[\"insertintobst\",{\"1\":{\"66\":3}}],[\"index排序中\",{\"1\":{\"725\":1}}],[\"index语句在已已存在的表上添加索引\",{\"1\":{\"687\":1}}],[\"index++\",{\"1\":{\"305\":2,\"335\":1}}],[\"index2\",{\"1\":{\"240\":7}}],[\"index1\",{\"1\":{\"240\":7}}],[\"index\",{\"1\":{\"51\":4,\"305\":1,\"335\":1,\"344\":4,\"431\":3,\"432\":1,\"441\":1,\"443\":1,\"446\":1,\"552\":1,\"615\":2,\"618\":2,\"642\":1,\"643\":3,\"687\":13,\"704\":8,\"715\":3,\"718\":2,\"725\":4,\"728\":3,\"809\":3,\"813\":1}}],[\"in\",{\"1\":{\"47\":3,\"410\":1,\"429\":2,\"445\":1,\"476\":2,\"552\":2,\"658\":1,\"701\":1,\"704\":2,\"725\":1,\"729\":2,\"745\":1,\"767\":2,\"771\":3,\"791\":1,\"806\":1,\"807\":1,\"809\":4,\"883\":1}}],[\"into\",{\"1\":{\"428\":4,\"431\":2,\"440\":1,\"542\":5,\"606\":5,\"607\":3,\"608\":1,\"676\":1,\"680\":1,\"704\":1,\"772\":2,\"791\":1,\"800\":2,\"832\":1}}],[\"introduction\",{\"1\":{\"405\":1}}],[\"int类型最大值为\",{\"1\":{\"274\":1}}],[\"intvalue\",{\"1\":{\"168\":1,\"354\":1}}],[\"integrity\",{\"1\":{\"612\":5}}],[\"integer数组转换成\",{\"1\":{\"168\":1}}],[\"integerbreak\",{\"1\":{\"87\":1}}],[\"integer>\",{\"1\":{\"47\":2,\"49\":1,\"175\":1,\"338\":2}}],[\"integer\",{\"1\":{\"22\":1,\"45\":2,\"47\":1,\"49\":2,\"58\":3,\"60\":4,\"107\":3,\"109\":1,\"120\":1,\"168\":3,\"193\":2,\"286\":1,\"296\":1,\"332\":3,\"348\":1,\"354\":1,\"364\":2,\"366\":1,\"370\":1,\"402\":2,\"416\":3,\"433\":3,\"443\":9,\"446\":1,\"464\":3,\"477\":4,\"480\":1,\"481\":2,\"482\":2,\"593\":1,\"595\":1,\"598\":1}}],[\"interleaved\",{\"1\":{\"772\":2}}],[\"interval\",{\"1\":{\"557\":6}}],[\"intervals\",{\"1\":{\"294\":6,\"295\":2,\"296\":7,\"365\":7,\"366\":8}}],[\"internal\",{\"1\":{\"445\":1,\"807\":2}}],[\"interruptedexception\",{\"1\":{\"434\":1,\"477\":1,\"481\":1}}],[\"interface\",{\"1\":{\"416\":1,\"420\":1,\"431\":2,\"432\":1,\"433\":1,\"434\":1,\"443\":1,\"463\":1,\"464\":1,\"627\":1}}],[\"intersect\",{\"1\":{\"710\":1}}],[\"intersected\",{\"1\":{\"390\":2}}],[\"intersectval\",{\"1\":{\"390\":6}}],[\"intersection\",{\"1\":{\"168\":3}}],[\"intention\",{\"0\":{\"778\":1},\"1\":{\"151\":2,\"771\":2,\"778\":2}}],[\"ints\",{\"1\":{\"60\":3,\"242\":4,\"338\":3}}],[\"int\",{\"1\":{\"2\":3,\"12\":5,\"14\":2,\"16\":5,\"18\":5,\"20\":5,\"22\":6,\"23\":1,\"24\":5,\"26\":7,\"28\":7,\"31\":6,\"35\":8,\"37\":7,\"41\":4,\"43\":7,\"45\":2,\"47\":9,\"49\":8,\"51\":11,\"54\":4,\"56\":1,\"58\":1,\"60\":4,\"66\":2,\"68\":1,\"70\":4,\"72\":5,\"79\":5,\"81\":9,\"83\":5,\"85\":9,\"87\":6,\"89\":6,\"91\":12,\"92\":9,\"93\":4,\"95\":7,\"97\":8,\"99\":10,\"101\":8,\"103\":11,\"105\":7,\"107\":7,\"109\":6,\"111\":2,\"113\":5,\"115\":14,\"117\":14,\"120\":11,\"122\":10,\"124\":6,\"126\":13,\"128\":5,\"130\":7,\"133\":7,\"135\":5,\"137\":10,\"139\":5,\"141\":9,\"143\":7,\"146\":10,\"148\":6,\"150\":7,\"152\":11,\"155\":5,\"157\":8,\"163\":4,\"165\":1,\"168\":6,\"171\":8,\"173\":1,\"175\":14,\"177\":8,\"179\":6,\"187\":12,\"188\":1,\"190\":12,\"191\":7,\"193\":2,\"195\":12,\"197\":7,\"199\":10,\"201\":12,\"203\":7,\"205\":4,\"207\":7,\"209\":5,\"211\":3,\"213\":1,\"215\":19,\"217\":20,\"224\":5,\"226\":21,\"228\":27,\"230\":33,\"232\":25,\"234\":13,\"242\":7,\"245\":2,\"248\":1,\"251\":2,\"254\":5,\"256\":4,\"259\":4,\"262\":3,\"268\":1,\"271\":12,\"273\":10,\"274\":5,\"275\":19,\"276\":5,\"277\":6,\"278\":2,\"280\":6,\"283\":10,\"286\":7,\"289\":8,\"292\":7,\"293\":6,\"296\":4,\"298\":8,\"299\":5,\"302\":7,\"305\":12,\"308\":5,\"311\":3,\"312\":4,\"314\":4,\"317\":3,\"321\":3,\"323\":3,\"326\":1,\"329\":1,\"332\":1,\"335\":8,\"338\":8,\"344\":6,\"346\":5,\"348\":5,\"350\":9,\"352\":6,\"354\":4,\"356\":7,\"358\":4,\"360\":8,\"362\":4,\"364\":10,\"366\":5,\"368\":6,\"370\":5,\"372\":9,\"378\":1,\"384\":7,\"389\":2,\"416\":1,\"428\":1,\"431\":8,\"432\":2,\"434\":1,\"440\":2,\"443\":8,\"503\":1,\"593\":1,\"595\":1,\"597\":6,\"598\":4,\"617\":2,\"618\":3,\"619\":2,\"643\":2,\"687\":3,\"689\":2,\"704\":1}}],[\"ifnull\",{\"1\":{\"559\":2}}],[\"if\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"6\":3,\"7\":2,\"8\":3,\"12\":10,\"14\":3,\"16\":4,\"18\":3,\"20\":2,\"22\":3,\"24\":3,\"26\":3,\"28\":4,\"29\":2,\"31\":5,\"33\":8,\"35\":4,\"37\":4,\"39\":17,\"41\":6,\"43\":8,\"45\":6,\"47\":1,\"49\":1,\"51\":2,\"52\":2,\"54\":10,\"56\":4,\"58\":1,\"60\":5,\"62\":3,\"64\":2,\"66\":7,\"68\":7,\"70\":8,\"72\":1,\"74\":1,\"79\":1,\"81\":1,\"87\":1,\"91\":1,\"93\":1,\"95\":3,\"99\":3,\"101\":1,\"103\":1,\"105\":1,\"107\":1,\"111\":1,\"113\":2,\"115\":4,\"117\":1,\"120\":2,\"128\":1,\"133\":2,\"135\":1,\"137\":4,\"139\":1,\"141\":1,\"143\":1,\"146\":2,\"148\":1,\"150\":1,\"152\":6,\"153\":6,\"155\":2,\"157\":1,\"163\":3,\"171\":2,\"173\":1,\"175\":2,\"177\":7,\"179\":5,\"185\":2,\"187\":2,\"190\":2,\"191\":2,\"193\":3,\"195\":4,\"197\":3,\"199\":6,\"201\":13,\"203\":2,\"205\":2,\"207\":4,\"209\":4,\"211\":4,\"213\":8,\"215\":10,\"217\":12,\"222\":1,\"224\":2,\"226\":5,\"228\":5,\"230\":7,\"232\":9,\"234\":3,\"242\":2,\"262\":2,\"271\":8,\"273\":3,\"274\":1,\"275\":5,\"276\":1,\"277\":4,\"280\":1,\"282\":2,\"283\":1,\"289\":1,\"292\":2,\"293\":1,\"296\":1,\"302\":2,\"305\":1,\"308\":1,\"311\":1,\"314\":1,\"317\":2,\"323\":1,\"326\":6,\"329\":1,\"335\":2,\"344\":2,\"346\":2,\"348\":1,\"350\":5,\"352\":3,\"354\":2,\"356\":1,\"358\":4,\"360\":4,\"362\":1,\"364\":2,\"366\":1,\"368\":1,\"370\":1,\"372\":9,\"378\":1,\"382\":1,\"387\":1,\"389\":1,\"392\":2,\"395\":1,\"416\":1,\"428\":4,\"429\":1,\"431\":3,\"432\":1,\"440\":1,\"444\":1,\"477\":2,\"497\":2,\"503\":1,\"504\":1,\"559\":3,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"595\":1}}],[\"imit\",{\"1\":{\"726\":1}}],[\"import\",{\"1\":{\"432\":1}}],[\"implied\",{\"1\":{\"429\":1}}],[\"implements\",{\"1\":{\"418\":1,\"420\":1,\"432\":1,\"433\":1,\"434\":1,\"443\":2,\"503\":1}}],[\"img\",{\"1\":{\"0\":1,\"11\":1,\"12\":1,\"13\":1,\"15\":1,\"17\":2,\"19\":2,\"21\":1,\"23\":1,\"25\":1,\"27\":1,\"30\":2,\"32\":2,\"34\":1,\"36\":2,\"38\":1,\"40\":1,\"42\":2,\"44\":2,\"46\":1,\"48\":1,\"50\":2,\"52\":1,\"53\":2,\"55\":2,\"57\":2,\"59\":1,\"61\":2,\"63\":1,\"65\":1,\"67\":1,\"69\":2,\"71\":2,\"84\":1,\"88\":1,\"116\":2,\"140\":1,\"192\":1,\"212\":2,\"214\":1,\"216\":1,\"223\":2,\"227\":1,\"229\":2,\"231\":1,\"233\":1,\"245\":2,\"282\":1,\"287\":1,\"297\":2,\"303\":1,\"309\":1,\"371\":2,\"376\":1,\"379\":2,\"380\":2,\"381\":1,\"383\":1,\"385\":1,\"388\":1,\"390\":4,\"393\":3,\"851\":2,\"852\":1,\"853\":2}}],[\"image\",{\"1\":{\"0\":2,\"8\":1,\"33\":1,\"47\":1,\"49\":1,\"68\":2,\"72\":1,\"83\":1,\"85\":1,\"89\":2,\"91\":2,\"95\":1,\"117\":5,\"137\":1,\"143\":1,\"155\":2,\"157\":1,\"190\":1,\"199\":1,\"201\":1,\"203\":1,\"205\":1,\"207\":1,\"209\":1,\"211\":3,\"213\":1,\"245\":1,\"256\":1,\"261\":1,\"276\":1,\"288\":2,\"298\":2,\"304\":3,\"313\":4,\"322\":1,\"346\":1,\"364\":3,\"366\":1,\"377\":1,\"384\":1,\"386\":1,\"401\":1,\"403\":2,\"404\":3,\"406\":1,\"407\":1,\"409\":1,\"410\":4,\"411\":4,\"413\":1,\"414\":1,\"415\":1,\"416\":2,\"417\":2,\"418\":1,\"419\":1,\"420\":2,\"422\":3,\"424\":1,\"426\":1,\"430\":1,\"435\":5,\"436\":6,\"439\":1,\"440\":1,\"441\":5,\"442\":2,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"450\":1,\"451\":3,\"452\":1,\"454\":3,\"458\":3,\"459\":1,\"464\":1,\"466\":2,\"467\":1,\"468\":1,\"470\":1,\"472\":1,\"474\":1,\"480\":1,\"481\":1,\"483\":1,\"484\":1,\"487\":1,\"489\":1,\"491\":1,\"492\":1,\"493\":1,\"494\":1,\"497\":2,\"504\":1,\"509\":1,\"512\":1,\"513\":4,\"521\":1,\"522\":2,\"523\":1,\"527\":1,\"528\":3,\"529\":1,\"530\":1,\"531\":1,\"532\":1,\"533\":2,\"534\":1,\"536\":1,\"539\":2,\"540\":2,\"541\":1,\"545\":1,\"548\":2,\"554\":1,\"555\":1,\"557\":1,\"558\":2,\"569\":1,\"570\":2,\"572\":1,\"577\":1,\"579\":3,\"582\":1,\"592\":1,\"593\":1,\"595\":1,\"599\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":2,\"605\":1,\"606\":1,\"607\":1,\"618\":1,\"624\":1,\"631\":1,\"633\":1,\"634\":2,\"643\":3,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"651\":1,\"653\":1,\"654\":2,\"655\":1,\"658\":3,\"659\":1,\"660\":2,\"661\":2,\"662\":1,\"667\":1,\"668\":3,\"670\":1,\"672\":1,\"674\":1,\"677\":1,\"680\":4,\"681\":1,\"694\":3,\"695\":1,\"698\":1,\"699\":1,\"700\":1,\"702\":5,\"703\":9,\"704\":9,\"705\":1,\"707\":1,\"708\":1,\"709\":1,\"715\":1,\"717\":2,\"718\":1,\"719\":2,\"720\":2,\"721\":2,\"732\":1,\"736\":1,\"737\":1,\"741\":1,\"742\":1,\"746\":1,\"752\":1,\"753\":2,\"757\":1,\"763\":2,\"766\":1,\"767\":1,\"770\":1,\"771\":1,\"775\":1,\"776\":2,\"786\":1,\"793\":2,\"794\":2,\"799\":2,\"800\":2,\"810\":2,\"812\":4,\"818\":1,\"819\":1,\"820\":2,\"821\":1,\"825\":1,\"826\":4,\"827\":1,\"843\":1,\"844\":1,\"846\":1,\"847\":1,\"848\":1,\"849\":1}}],[\"中设置页面信息\",{\"1\":{\"884\":1}}],[\"中设置页面标题\",{\"1\":{\"883\":1}}],[\"中设立了4个\",{\"1\":{\"746\":1}}],[\"中使用\",{\"1\":{\"870\":1,\"886\":1}}],[\"中使用至少一个空格将字符串中的\",{\"1\":{\"244\":1}}],[\"中很重要的一个概念\",{\"1\":{\"866\":1}}],[\"中自定义它们\",{\"1\":{\"861\":1}}],[\"中常用的逻辑备份工具为\",{\"1\":{\"830\":1}}],[\"中看到都复制了些什么语句\",{\"1\":{\"823\":1}}],[\"中会包含大量的数据\",{\"1\":{\"823\":1}}],[\"中继日志与二进制日志的格式相同\",{\"1\":{\"813\":1}}],[\"中继日志还有一个索引文件\",{\"1\":{\"813\":1}}],[\"中继日志只在主从服务器架构的从服务器上存在\",{\"1\":{\"813\":1}}],[\"中继日志\",{\"0\":{\"813\":1},\"1\":{\"805\":1,\"813\":1}}],[\"中继日志和\",{\"1\":{\"805\":1}}],[\"中只有一条数据\",{\"1\":{\"800\":1}}],[\"中只存储主键值和对应的页号\",{\"1\":{\"646\":1}}],[\"中获取历史快照\",{\"1\":{\"799\":1}}],[\"中行锁升级为表锁\",{\"1\":{\"779\":1}}],[\"中去\",{\"1\":{\"753\":1}}],[\"中规定\",{\"1\":{\"746\":1}}],[\"中止的\",{\"1\":{\"742\":1}}],[\"中则需要循环+计数\",{\"1\":{\"729\":1}}],[\"中维护了一个计数器\",{\"1\":{\"729\":1}}],[\"中驱动表对应的执行计划记录的filtered值`\",{\"1\":{\"709\":1}}],[\"中指定索引列\",{\"1\":{\"687\":1}}],[\"中指定外键约束\",{\"1\":{\"618\":1}}],[\"中排在第一个的列名相同\",{\"1\":{\"615\":1}}],[\"中子查询的使用大大增强了\",{\"1\":{\"568\":1}}],[\"中效率高\",{\"1\":{\"564\":1}}],[\"中图\",{\"1\":{\"541\":1}}],[\"中定义的信息之外\",{\"1\":{\"470\":2}}],[\"中就无需在使用\",{\"1\":{\"464\":1}}],[\"中就可以使用\",{\"1\":{\"451\":1}}],[\"中创建配置文件\",{\"1\":{\"452\":1}}],[\"中提供了\",{\"1\":{\"452\":1}}],[\"中讲解的方法一致\",{\"1\":{\"424\":1}}],[\"中加入\",{\"1\":{\"420\":1}}],[\"中要通过\",{\"1\":{\"404\":2}}],[\"中文文档\",{\"1\":{\"399\":1,\"405\":1,\"475\":1,\"491\":1}}],[\"中节点数目为\",{\"1\":{\"390\":2}}],[\"中作为\",{\"1\":{\"345\":1}}],[\"中出现的顺序排列\",{\"1\":{\"312\":1}}],[\"中唯一元素的个数\",{\"1\":{\"312\":1}}],[\"中间位置\",{\"1\":{\"290\":1}}],[\"中间值\",{\"1\":{\"277\":1}}],[\"中间值>最左边的值\",{\"1\":{\"277\":1}}],[\"中存在这个目标值\",{\"1\":{\"277\":1}}],[\"中已经不包含了\",{\"1\":{\"271\":1}}],[\"中已经判断了\",{\"1\":{\"271\":1}}],[\"中同样能看出\",{\"1\":{\"271\":1}}],[\"中因此返回\",{\"1\":{\"269\":1}}],[\"中并且下标为\",{\"1\":{\"269\":1}}],[\"中最长的回文子串\",{\"1\":{\"260\":1}}],[\"中最大的岛屿面积\",{\"1\":{\"227\":1}}],[\"中最小的\",{\"1\":{\"107\":1}}],[\"中不需要是因为在搜索的过程中\",{\"1\":{\"222\":1}}],[\"中不能有重复\",{\"1\":{\"197\":1}}],[\"中需要使用一个容器来保存节点用来遍历\",{\"1\":{\"222\":1}}],[\"中插入\",{\"1\":{\"200\":1}}],[\"中所有可以使数字和为\",{\"1\":{\"196\":1}}],[\"中所有可能的\",{\"1\":{\"186\":1}}],[\"中可以使数字和为目标数\",{\"1\":{\"194\":1}}],[\"中每个字符出现的次数都相同\",{\"1\":{\"161\":1}}],[\"中每一个值都在\",{\"1\":{\"46\":1}}],[\"中得知\",{\"1\":{\"152\":1,\"153\":1}}],[\"中得到\",{\"1\":{\"147\":2}}],[\"中找到对应的服务\",{\"1\":{\"464\":1}}],[\"中找到节点值等于\",{\"1\":{\"53\":1}}],[\"中找出并返回总和为\",{\"1\":{\"104\":1}}],[\"中组合方式\",{\"1\":{\"103\":2}}],[\"中方法\",{\"1\":{\"99\":3}}],[\"中方案\",{\"1\":{\"81\":1}}],[\"中的第一个\",{\"1\":{\"883\":1}}],[\"中的数据不就成了\",{\"1\":{\"846\":1}}],[\"中的数据进行增加\",{\"1\":{\"642\":1}}],[\"中的事务版本号进行比较\",{\"1\":{\"799\":1}}],[\"中的内容写到文件系统缓存\",{\"1\":{\"753\":1}}],[\"中的日志刷新到\",{\"1\":{\"753\":1}}],[\"中的某属性集不是\",{\"1\":{\"736\":1}}],[\"中的流程是\",{\"1\":{\"634\":1}}],[\"中的子查询\",{\"0\":{\"575\":1}}],[\"中的拦截器\",{\"1\":{\"498\":1}}],[\"中的服务端名称去consul\",{\"1\":{\"464\":1}}],[\"中的前五个元素为\",{\"1\":{\"278\":1}}],[\"中的前两个元素均为\",{\"1\":{\"278\":1}}],[\"中的每个值都\",{\"1\":{\"277\":1}}],[\"中的每个数字在每个组合中只能使用\",{\"1\":{\"196\":1}}],[\"中的任何数字\",{\"1\":{\"200\":1}}],[\"中的\",{\"1\":{\"194\":1,\"269\":1,\"481\":1,\"868\":1}}],[\"中的方案个数\",{\"1\":{\"148\":1}}],[\"中的整数\",{\"1\":{\"140\":1}}],[\"中的所有单词都用一个空格隔开\",{\"1\":{\"246\":1}}],[\"中的所有字符串\",{\"1\":{\"110\":1}}],[\"中的所有元素是不重复的\",{\"1\":{\"269\":1}}],[\"中的所有元素\",{\"1\":{\"104\":1,\"202\":1,\"223\":1}}],[\"中的所有值\",{\"1\":{\"102\":1}}],[\"中的所有\",{\"1\":{\"59\":1}}],[\"中的所有整数\",{\"1\":{\"50\":1,\"208\":1,\"276\":1}}],[\"中的最大值是\",{\"1\":{\"50\":4}}],[\"中的最大值\",{\"1\":{\"50\":1}}],[\"中的位置\",{\"1\":{\"47\":1}}],[\"中序\",{\"1\":{\"54\":1}}],[\"中序其实也可以\",{\"1\":{\"31\":1}}],[\"中序遍历二叉搜索树是升序的\",{\"1\":{\"56\":1}}],[\"中序遍历中根结点在中间\",{\"1\":{\"47\":1}}],[\"中序遍历+后续遍历确定一颗二叉树步骤\",{\"1\":{\"47\":1}}],[\"中序遍历\",{\"0\":{\"7\":1},\"1\":{\"0\":1,\"56\":2,\"74\":1}}],[\"中\",{\"1\":{\"1\":1,\"7\":1,\"46\":1,\"69\":1,\"147\":1,\"187\":1,\"193\":1,\"197\":1,\"199\":1,\"207\":1,\"244\":1,\"267\":1,\"271\":1,\"309\":1,\"327\":1,\"372\":1,\"390\":4,\"420\":1,\"435\":1,\"451\":1,\"464\":1,\"470\":1,\"597\":1,\"600\":1,\"686\":1,\"725\":1,\"753\":2,\"778\":1,\"794\":1,\"813\":1,\"823\":1}}],[\"对业务都有一定的侵入性\",{\"1\":{\"853\":1}}],[\"对数据库对象利用工具进行导出工作\",{\"1\":{\"830\":1}}],[\"对数据进行排序的时候\",{\"1\":{\"689\":1}}],[\"对数据进行分组查询\",{\"1\":{\"689\":1}}],[\"对我们复原操作的实际场景\",{\"1\":{\"805\":1}}],[\"对周围的数据没有影响\",{\"1\":{\"775\":1}}],[\"对表结构进行修改时\",{\"1\":{\"773\":1}}],[\"对另外一条数据设置x锁\",{\"1\":{\"771\":1}}],[\"对其中一条数据设置x锁\",{\"1\":{\"771\":1}}],[\"对其进行校验\",{\"1\":{\"325\":1}}],[\"对当前会话的所有后续的事务有效\",{\"1\":{\"746\":1}}],[\"对外暴露的接口可以非常容易猜测对应的信息\",{\"1\":{\"731\":1}}],[\"对外暴露可以被调用的接口方法清单\",{\"1\":{\"462\":1}}],[\"对优化的影响\",{\"1\":{\"729\":1}}],[\"对他们进行排序\",{\"1\":{\"725\":1}}],[\"对单表的访问方法就是\",{\"1\":{\"704\":1}}],[\"对用于连接的字段创建索引\",{\"1\":{\"689\":1}}],[\"对分组或者排序的字段进行索引\",{\"1\":{\"689\":1}}],[\"对索引的使用效率至关重要\",{\"1\":{\"657\":1}}],[\"对事务完整性没有要求或者以select\",{\"1\":{\"637\":1}}],[\"对物理服务器级别\",{\"1\":{\"631\":1}}],[\"对象中表示的一组数据转换为字符串\",{\"1\":{\"608\":1}}],[\"对磁盘i\",{\"1\":{\"604\":1}}],[\"对微服务a的调用就会占用越来越多的系统资源\",{\"1\":{\"471\":1}}],[\"对方服务宕机或不可用\",{\"1\":{\"420\":1}}],[\"对配置的资源进行流程控制\",{\"1\":{\"416\":1}}],[\"对根节点的状态做检验\",{\"1\":{\"372\":1}}],[\"对元素为负数并且绝对值较大的元素进行取反\",{\"1\":{\"354\":1}}],[\"对每个孩子\",{\"1\":{\"343\":1}}],[\"对每一个单词进行排序\",{\"1\":{\"165\":1}}],[\"对每一颗子树都进行判断是否是平衡二叉树\",{\"1\":{\"37\":1}}],[\"对角线以下\",{\"1\":{\"304\":2}}],[\"对角线以上\",{\"1\":{\"304\":2}}],[\"对角线元素的起点位置为\",{\"1\":{\"304\":4}}],[\"对nums数组进行去重操作\",{\"1\":{\"268\":1}}],[\"对n的每个位置上的数进行求和\",{\"1\":{\"171\":1}}],[\"对航班进行排序\",{\"1\":{\"213\":1}}],[\"对left\",{\"1\":{\"179\":1}}],[\"对\",{\"1\":{\"177\":1,\"179\":2,\"257\":1,\"307\":1,\"364\":1,\"633\":1,\"689\":1,\"752\":1,\"868\":1}}],[\"对i进行去重\",{\"1\":{\"177\":1}}],[\"对start升序\",{\"1\":{\"366\":1}}],[\"对s\",{\"1\":{\"163\":1}}],[\"对word1增加\",{\"1\":{\"152\":1,\"153\":1}}],[\"对这俩个队列分别求出能够偷的最大金额\",{\"1\":{\"115\":1}}],[\"对应表的主键自增id\",{\"1\":{\"733\":1}}],[\"对应分析可以采取的行动\",{\"1\":{\"694\":1}}],[\"对应下标位置为0\",{\"1\":{\"460\":2}}],[\"对应下标位置为1\",{\"1\":{\"460\":2}}],[\"对应全局事务的管辖\",{\"1\":{\"426\":1}}],[\"对应的数据输出\",{\"1\":{\"725\":1}}],[\"对应的索引\",{\"1\":{\"417\":1}}],[\"对应的处理函数必须static修饰\",{\"1\":{\"416\":2}}],[\"对应的是漏桶算法\",{\"1\":{\"411\":1}}],[\"对应的连接符\",{\"1\":{\"403\":1}}],[\"对应的\",{\"1\":{\"137\":1}}],[\"对应的dp\",{\"1\":{\"133\":1}}],[\"对应的交易状态为\",{\"1\":{\"127\":1}}],[\"对应的节点\",{\"1\":{\"67\":1}}],[\"对应leetcode题目\",{\"1\":{\"0\":1}}],[\"对于写操作\",{\"1\":{\"801\":1}}],[\"对于使用\",{\"1\":{\"794\":1}}],[\"对于每个update\",{\"1\":{\"755\":1}}],[\"对于每个delete\",{\"1\":{\"755\":1}}],[\"对于每个insert\",{\"1\":{\"755\":1}}],[\"对于每个节点依然有俩种情况\",{\"1\":{\"117\":1}}],[\"对于非主属性来说\",{\"1\":{\"737\":1}}],[\"对于排序来说\",{\"1\":{\"725\":1}}],[\"对于单表查询来说\",{\"1\":{\"709\":1}}],[\"对于包含派生表的查询\",{\"1\":{\"703\":1}}],[\"对于包含union或者union\",{\"1\":{\"703\":2}}],[\"对于在同一个select关键字中的表来说\",{\"1\":{\"703\":1}}],[\"对于小的数据集\",{\"1\":{\"686\":1}}],[\"对于上面的树来说\",{\"1\":{\"660\":1}}],[\"对于等值查询来说\",{\"1\":{\"658\":1}}],[\"对于联合索引的情况\",{\"1\":{\"658\":1}}],[\"对于mysql数据库目前只有innodb数据引擎支持聚簇索引\",{\"1\":{\"650\":1}}],[\"对于myisam引擎的表是没有区别的\",{\"1\":{\"562\":1}}],[\"对于innodb表\",{\"1\":{\"650\":2}}],[\"对于有依赖关系的子表和父表联合查询时\",{\"1\":{\"642\":1}}],[\"对于有根树\",{\"1\":{\"61\":1,\"63\":1}}],[\"对于大并发的\",{\"1\":{\"618\":1}}],[\"对于外键约束\",{\"1\":{\"618\":1}}],[\"对于我们来说是不可见的\",{\"1\":{\"565\":1}}],[\"对于两个结果集的重复部分\",{\"1\":{\"540\":1}}],[\"对于请求路径为\",{\"1\":{\"502\":1}}],[\"对于俩个链表的相交结点的后面的结点个数是一样的\",{\"1\":{\"391\":1}}],[\"对于输入\",{\"1\":{\"379\":1}}],[\"对于该题无非有三种情况\",{\"1\":{\"358\":1}}],[\"对于该题来说\",{\"1\":{\"344\":1}}],[\"对于该题来说没有终止条件\",{\"1\":{\"217\":1}}],[\"对于最后一位顾客\",{\"1\":{\"357\":1}}],[\"对于接下来的\",{\"1\":{\"357\":1}}],[\"对于求最大子数组和\",{\"1\":{\"348\":1}}],[\"对于去重问题\",{\"1\":{\"218\":1}}],[\"对于去重我们在\",{\"1\":{\"211\":1}}],[\"对于回溯类型的题目\",{\"1\":{\"218\":1}}],[\"对于回溯问题\",{\"1\":{\"211\":1}}],[\"对于回溯问题我遇见了三种\",{\"1\":{\"203\":1}}],[\"对于数独来说\",{\"1\":{\"217\":1}}],[\"对于n皇后问题\",{\"1\":{\"215\":1}}],[\"对于n皇后的约束条件\",{\"1\":{\"215\":1}}],[\"对于\",{\"1\":{\"211\":2,\"548\":1,\"774\":1,\"885\":1}}],[\"对于给定的输入\",{\"1\":{\"194\":1}}],[\"对于组合来说就是一个集合\",{\"1\":{\"183\":1}}],[\"对于以上四种情况依次进行讨论\",{\"1\":{\"152\":1}}],[\"对于这个题有俩种操作\",{\"1\":{\"152\":1}}],[\"对于这道题的遍历顺序是非常讲究的\",{\"1\":{\"103\":1}}],[\"对于这道题来说\",{\"1\":{\"101\":1}}],[\"对于这道题超时\",{\"1\":{\"99\":1}}],[\"对于今天是否持有股票由前一天状态转移而来\",{\"1\":{\"120\":1,\"122\":1}}],[\"对于某一天的股票只有俩种状态\",{\"1\":{\"120\":1}}],[\"对于根节点3\",{\"1\":{\"117\":1}}],[\"对于第i个房屋\",{\"1\":{\"113\":1}}],[\"对于动态规划\",{\"1\":{\"105\":1}}],[\"对于完全背包问题\",{\"1\":{\"93\":1}}],[\"对于01背包问题\",{\"1\":{\"91\":1}}],[\"对于背包问题来说\",{\"1\":{\"91\":1}}],[\"对于背包问题\",{\"1\":{\"90\":1}}],[\"对于整数\",{\"1\":{\"87\":1}}],[\"对于一条完整的记录来说\",{\"1\":{\"672\":1}}],[\"对于一个数如果他不是快乐数\",{\"1\":{\"170\":1}}],[\"对于一个正整数\",{\"1\":{\"169\":1}}],[\"对于一个结点\",{\"1\":{\"54\":1}}],[\"对于一颗平衡二叉树来说\",{\"1\":{\"37\":1}}],[\"对于k层的二叉树来说\",{\"1\":{\"0\":1}}],[\"对比myisam的存储引擎\",{\"1\":{\"636\":1,\"655\":1}}],[\"对比\",{\"0\":{\"589\":1},\"1\":{\"12\":1,\"436\":1}}],[\"一切外键概念必须在应用层解决\",{\"1\":{\"837\":1}}],[\"一切就绪之后\",{\"1\":{\"442\":1}}],[\"一台\",{\"1\":{\"821\":2}}],[\"一台摄像头足以监控所有节点\",{\"1\":{\"371\":1}}],[\"一主一从搭建\",{\"0\":{\"821\":1}}],[\"一是用于\",{\"1\":{\"808\":1}}],[\"一是支持事务\",{\"1\":{\"774\":1}}],[\"一是管理不方便\",{\"1\":{\"462\":1}}],[\"一组逻辑操作单元\",{\"1\":{\"741\":1}}],[\"一组数据进行汇总的函数\",{\"1\":{\"561\":1}}],[\"一些额外的信息\",{\"1\":{\"710\":1}}],[\"一些setting\",{\"1\":{\"441\":1}}],[\"一张表里\",{\"1\":{\"686\":1}}],[\"一张图上的所有结点的话\",{\"1\":{\"12\":1}}],[\"一棵很大的b+树由许多数据页组成\",{\"1\":{\"656\":1}}],[\"一棵高度平衡二叉树定义为\",{\"1\":{\"36\":1}}],[\"一的\",{\"1\":{\"615\":1}}],[\"一种策略是\",{\"1\":{\"786\":1}}],[\"一种类型\",{\"1\":{\"600\":1}}],[\"一种是redirect\",{\"1\":{\"422\":2}}],[\"一种是response返回文字提示信息\",{\"1\":{\"422\":2}}],[\"一种是控制台\",{\"1\":{\"421\":1}}],[\"一种是配置类\",{\"1\":{\"421\":1}}],[\"一种是放第\",{\"1\":{\"91\":1}}],[\"一种是不放第\",{\"1\":{\"91\":1}}],[\"一种是自上而下\",{\"1\":{\"37\":1}}],[\"一种是\",{\"1\":{\"29\":2}}],[\"一起使用才有意义\",{\"1\":{\"597\":1}}],[\"一方面\",{\"1\":{\"749\":1}}],[\"一方\",{\"1\":{\"513\":1,\"598\":1}}],[\"一条记录时需要判断一下插入位置是不是被别的事务加了\",{\"1\":{\"778\":1}}],[\"一条记录对应另一个表中的多条记录\",{\"1\":{\"513\":1}}],[\"一条记录对应另一个表中的一条记录\",{\"1\":{\"513\":1}}],[\"一条大的查询语句里边可以包含若干个select关键字\",{\"1\":{\"703\":1}}],[\"一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分\",{\"1\":{\"677\":1}}],[\"一条链路通过trace\",{\"1\":{\"484\":1}}],[\"一对多建表原则\",{\"1\":{\"513\":1}}],[\"一对多关系\",{\"1\":{\"513\":1}}],[\"一对多关联\",{\"1\":{\"513\":1}}],[\"一对一\",{\"1\":{\"513\":1}}],[\"一对一关联\",{\"1\":{\"513\":1}}],[\"一系列的断言和过滤器组成\",{\"1\":{\"488\":1}}],[\"一秒钟n个\",{\"1\":{\"472\":1}}],[\"一旦设置默认值\",{\"1\":{\"620\":1}}],[\"一旦下游服务c因某些原因变得不可用\",{\"1\":{\"472\":1}}],[\"一旦我们重启应用\",{\"1\":{\"419\":1}}],[\"一旦你支付此费用\",{\"1\":{\"82\":1}}],[\"一款开源的分布式消息系统\",{\"1\":{\"399\":1}}],[\"一\",{\"0\":{\"399\":1,\"440\":1,\"507\":1},\"1\":{\"598\":1}}],[\"一支弓箭可以沿着\",{\"1\":{\"363\":1}}],[\"一开始你手头没有任何零钱\",{\"1\":{\"357\":1}}],[\"一致性读\",{\"1\":{\"790\":1}}],[\"一致性和持久性由事务的\",{\"1\":{\"747\":1}}],[\"一致性是指事务执行前后\",{\"1\":{\"741\":1}}],[\"一致性\",{\"1\":{\"741\":1,\"747\":2}}],[\"一致\",{\"1\":{\"312\":1}}],[\"一直是0\",{\"1\":{\"304\":1}}],[\"一轮可以完成矩阵\",{\"1\":{\"299\":1}}],[\"一经开辟\",{\"1\":{\"279\":1}}],[\"一行放入一个皇后\",{\"1\":{\"215\":2}}],[\"一行一行遍历\",{\"1\":{\"85\":1}}],[\"一次最少把内存中的16kb内容刷新到磁盘中\",{\"1\":{\"666\":1}}],[\"一次购买一杯\",{\"1\":{\"357\":1}}],[\"一次\",{\"1\":{\"196\":1,\"229\":1}}],[\"一次遍历\",{\"1\":{\"120\":1}}],[\"一般的语句修改使用statment格式保存binlog\",{\"1\":{\"823\":1}}],[\"一般应用对数据库而言都是\",{\"1\":{\"818\":1}}],[\"一般不建议启动该参数\",{\"1\":{\"697\":1}}],[\"一般超过\",{\"1\":{\"689\":1}}],[\"一般b+树的高度不会超过4层\",{\"1\":{\"648\":1}}],[\"一般指的是值的范围\",{\"1\":{\"619\":1}}],[\"一般用于枚举数据\",{\"1\":{\"598\":1}}],[\"一般会和\",{\"1\":{\"564\":1}}],[\"一般情况下就是该表的主键\",{\"1\":{\"650\":1}}],[\"一般情况下不用考虑超限问题\",{\"1\":{\"598\":1}}],[\"一般情况下\",{\"1\":{\"446\":1,\"472\":1}}],[\"一般情况\",{\"1\":{\"222\":1}}],[\"一般都是用到啥写啥参数\",{\"1\":{\"185\":1}}],[\"一般来说对于数组使用双指针\",{\"1\":{\"279\":1}}],[\"一般来说搜到叶子节点了\",{\"1\":{\"185\":1}}],[\"一般来说\",{\"1\":{\"67\":1,\"185\":1,\"491\":1,\"835\":1}}],[\"一部分是不用s\",{\"1\":{\"148\":1,\"153\":1}}],[\"一部分是用s\",{\"1\":{\"148\":1,\"153\":1}}],[\"一股\",{\"1\":{\"121\":1}}],[\"一番侦察之后\",{\"1\":{\"116\":1}}],[\"一夜之内能够偷窃到的最高金额\",{\"1\":{\"112\":1}}],[\"一维数组实现\",{\"1\":{\"92\":1}}],[\"一维数组的遍历顺序是非常讲究的\",{\"1\":{\"92\":1}}],[\"一维数组其实就是将每一行的数据都进行拷贝\",{\"1\":{\"92\":1}}],[\"一共有4种类型的记录\",{\"1\":{\"680\":1}}],[\"一共有三层\",{\"1\":{\"452\":1}}],[\"一共有俩种情况\",{\"1\":{\"261\":1}}],[\"一共有俩种方式\",{\"1\":{\"83\":1}}],[\"一共有dp\",{\"1\":{\"103\":1,\"105\":1}}],[\"一共有\",{\"1\":{\"98\":1,\"103\":1,\"105\":1}}],[\"一共可以构建\",{\"1\":{\"89\":1}}],[\"一定的频率刷入到真正的redo\",{\"1\":{\"753\":1}}],[\"一定是紧跟在from后面的\",{\"1\":{\"525\":1}}],[\"一定是先入栈\",{\"1\":{\"325\":1}}],[\"一定是2的倍数\",{\"1\":{\"325\":1}}],[\"一定是从左往右依次排满的\",{\"1\":{\"0\":1}}],[\"一定不要深究其细节\",{\"1\":{\"386\":1}}],[\"一定不是有效的括号\",{\"1\":{\"326\":1}}],[\"一定不是target\",{\"1\":{\"271\":1}}],[\"一定不等于\",{\"1\":{\"271\":1}}],[\"一定要间隔一段时间\",{\"1\":{\"848\":1}}],[\"一定要为其起一个别名\",{\"1\":{\"579\":1}}],[\"一定要指明长度\",{\"1\":{\"689\":1}}],[\"一定要指明查询得表\",{\"1\":{\"533\":1}}],[\"一定要指向\",{\"1\":{\"201\":1}}],[\"一定要符合\",{\"1\":{\"452\":1}}],[\"一定要清楚\",{\"1\":{\"420\":1}}],[\"一定要倒序\",{\"1\":{\"92\":2,\"95\":1}}],[\"一定要学会记录前后俩个指针\",{\"1\":{\"58\":1}}],[\"一样比较前后俩个元素进行去重\",{\"1\":{\"207\":1}}],[\"一样\",{\"1\":{\"39\":1,\"49\":1,\"89\":1,\"115\":1,\"191\":1,\"213\":1,\"452\":1,\"464\":1,\"721\":1}}],[\"一个拥有\",{\"1\":{\"874\":1}}],[\"一个更新操作\",{\"1\":{\"848\":1}}],[\"一个更易于构建云原生应用的动态服务发现\",{\"1\":{\"399\":1,\"400\":1}}],[\"一个主库线程\",{\"1\":{\"820\":1}}],[\"一个主机\",{\"1\":{\"493\":1}}],[\"一个事务中的每一次\",{\"1\":{\"799\":1}}],[\"一个事务在执行过程中只有\",{\"1\":{\"765\":1}}],[\"一个事务在执行过程中每次执行select操作时都会生成一个readview\",{\"1\":{\"765\":1}}],[\"一个事务可能包含很多语句\",{\"1\":{\"749\":1}}],[\"一个事务只能看见已经提交事务所做\",{\"1\":{\"746\":1}}],[\"一个比赛\",{\"1\":{\"737\":1}}],[\"一个索引包含了满足查询结果的数据就叫做覆盖索引\",{\"1\":{\"727\":1}}],[\"一个常见又非常头疼的问题就是\",{\"1\":{\"726\":1}}],[\"一个sql查询的趟数越少越好\",{\"1\":{\"702\":1}}],[\"一个代表最大记录\",{\"1\":{\"680\":1}}],[\"一个页中可以存储多个行记录\",{\"1\":{\"666\":1}}],[\"一个页默认会\",{\"1\":{\"656\":1}}],[\"一个节点只能有两个子节点\",{\"1\":{\"659\":1}}],[\"一个节点也可以是它自己的祖先\",{\"1\":{\"61\":1,\"63\":1}}],[\"一个简单索引的设计方案\",{\"0\":{\"643\":1}}],[\"一个表可以\",{\"1\":{\"686\":1}}],[\"一个表可以有很多列都分别限定了非空\",{\"1\":{\"614\":1}}],[\"一个表没有手动定义主键\",{\"1\":{\"681\":1}}],[\"一个表最多只能有一个自增长列\",{\"1\":{\"617\":1}}],[\"一个表最多只能有一个主键约束\",{\"1\":{\"616\":1}}],[\"一个表\",{\"1\":{\"605\":1}}],[\"一个完整的数据存储过程总共有\",{\"1\":{\"582\":1}}],[\"一个同时插入多行记录的insert语句等同于多个单行插入的insert语句\",{\"1\":{\"542\":1}}],[\"一个数据库中可以有多个表\",{\"1\":{\"511\":1}}],[\"一个文档就相当于一条记录\",{\"1\":{\"510\":1}}],[\"一个必需的\",{\"1\":{\"494\":1}}],[\"一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果\",{\"1\":{\"483\":1}}],[\"一个注解\",{\"1\":{\"462\":1}}],[\"一个8002\",{\"1\":{\"459\":1}}],[\"一个8001\",{\"1\":{\"459\":1}}],[\"一个账户服务\",{\"1\":{\"430\":1}}],[\"一个库存服务\",{\"1\":{\"430\":1}}],[\"一个订单服务\",{\"1\":{\"430\":1}}],[\"一个响应就是一个调用\",{\"1\":{\"412\":1}}],[\"一个请求发送到服务器\",{\"1\":{\"412\":1}}],[\"一个易于使用的高性能微服务分布式事务解决方案\",{\"1\":{\"399\":1}}],[\"一个cur指向当前结点\",{\"1\":{\"381\":1}}],[\"一个作为输出栈\",{\"1\":{\"322\":1}}],[\"一个作为输入栈\",{\"1\":{\"322\":1}}],[\"一个空的队列不会调用\",{\"1\":{\"321\":1}}],[\"一个不重叠的区间数组\",{\"1\":{\"294\":1}}],[\"一个用来执行具体操作\",{\"1\":{\"279\":1}}],[\"一个用来遍历\",{\"1\":{\"279\":1}}],[\"一个岛所有的1都变成了2后\",{\"1\":{\"226\":1}}],[\"一个保存所有的路径\",{\"1\":{\"224\":1}}],[\"一个保存每一条路径\",{\"1\":{\"224\":1}}],[\"一个合理的行程所经历的机场必然是机票数+1\",{\"1\":{\"213\":1}}],[\"一个\",{\"1\":{\"199\":2,\"213\":1,\"229\":1,\"381\":1}}],[\"一个n个数的集合里有多少符合条件的子集\",{\"1\":{\"183\":1,\"218\":1}}],[\"一个字符串按一定规则有几种切割方式\",{\"1\":{\"183\":1,\"218\":1}}],[\"一个字符串的\",{\"1\":{\"138\":1}}],[\"一个可能的最长回文子序列为\",{\"1\":{\"156\":2}}],[\"一个元素\",{\"1\":{\"152\":2,\"153\":2}}],[\"一个是由左上方推导而来\",{\"1\":{\"91\":1}}],[\"一个是由正上方推导而来\",{\"1\":{\"91\":1}}],[\"一个机器人位于一个\",{\"1\":{\"84\":1}}],[\"一个正确的答案是\",{\"1\":{\"67\":1}}],[\"一个二叉树每个节点\",{\"1\":{\"36\":1}}],[\"一个树的左右子树的高度的差值不能大于1\",{\"1\":{\"0\":1}}],[\"2台\",{\"1\":{\"822\":1}}],[\"2字节\",{\"1\":{\"668\":1}}],[\"2位格式的year已经不推荐使用\",{\"1\":{\"602\":1}}],[\"27开始\",{\"1\":{\"602\":1}}],[\"27\",{\"1\":{\"492\":1}}],[\"2s\",{\"1\":{\"478\":1}}],[\"2b8\",{\"1\":{\"429\":1,\"431\":3,\"432\":1,\"442\":1,\"443\":1,\"452\":1}}],[\"2<\",{\"1\":{\"420\":1,\"423\":1,\"441\":2,\"442\":2}}],[\"2表示最小记\",{\"1\":{\"643\":1}}],[\"2表示排队等待\",{\"1\":{\"419\":1}}],[\"2表示链路\",{\"1\":{\"419\":1}}],[\"2个请求数量\",{\"1\":{\"410\":1}}],[\"2个孩子的胃口值分别是1\",{\"1\":{\"343\":1}}],[\"29\",{\"1\":{\"370\":1}}],[\"299\",{\"1\":{\"369\":1,\"370\":1}}],[\"2处发射箭\",{\"1\":{\"363\":1}}],[\"2在3前面\",{\"1\":{\"313\":1}}],[\"2列作为元素的起点\",{\"1\":{\"299\":1}}],[\"2作为行\",{\"1\":{\"299\":2}}],[\"2了\",{\"1\":{\"288\":1}}],[\"2^31\",{\"1\":{\"274\":1}}],[\"2d\",{\"1\":{\"233\":1}}],[\"2a\",{\"1\":{\"173\":1}}],[\"2倍的子序列长度\",{\"1\":{\"150\":1}}],[\"23\",{\"1\":{\"142\":1,\"192\":1,\"200\":2,\"215\":1,\"347\":1,\"557\":1,\"636\":1,\"659\":1}}],[\"231\",{\"1\":{\"17\":2,\"21\":2,\"42\":2,\"55\":2,\"106\":1,\"169\":1,\"172\":2,\"274\":1,\"315\":2,\"343\":1,\"363\":2}}],[\"2nf\",{\"1\":{\"736\":1}}],[\"2n\",{\"1\":{\"99\":1,\"257\":1}}],[\"2时\",{\"1\":{\"91\":1}}],[\"2~n的二叉搜索树数量\",{\"1\":{\"89\":1}}],[\"28<\",{\"1\":{\"402\":1,\"432\":1,\"443\":1}}],[\"28\",{\"1\":{\"84\":2,\"190\":1,\"191\":1}}],[\"26<\",{\"1\":{\"441\":1}}],[\"26\",{\"1\":{\"73\":1,\"74\":1,\"96\":1,\"163\":1,\"368\":1}}],[\"217\",{\"0\":{\"266\":1}}],[\"216\",{\"1\":{\"195\":1}}],[\"21\",{\"1\":{\"73\":1,\"96\":1,\"557\":1,\"696\":1}}],[\"212\",{\"1\":{\"23\":1}}],[\"25默认支持的存储引擎如下\",{\"1\":{\"631\":1}}],[\"256\",{\"1\":{\"428\":2}}],[\"25525511135\",{\"1\":{\"200\":1}}],[\"255\",{\"1\":{\"200\":6,\"201\":8,\"595\":1}}],[\"2500\",{\"1\":{\"132\":1}}],[\"25\",{\"1\":{\"65\":2,\"557\":2}}],[\"257\",{\"1\":{\"45\":1}}],[\"2里\",{\"1\":{\"62\":1}}],[\"22<\",{\"1\":{\"441\":1}}],[\"22\",{\"1\":{\"44\":1,\"169\":1,\"170\":1,\"190\":1,\"191\":1,\"330\":2,\"492\":1,\"557\":1,\"558\":1,\"659\":1}}],[\"245\",{\"1\":{\"200\":1}}],[\"24\",{\"1\":{\"40\":2,\"495\":3}}],[\"2h\",{\"1\":{\"34\":1}}],[\"20开始\",{\"1\":{\"630\":1}}],[\"206\",{\"1\":{\"529\":1}}],[\"20s\",{\"1\":{\"480\":1}}],[\"204\",{\"1\":{\"444\":1}}],[\"203\",{\"1\":{\"444\":1}}],[\"20<\",{\"1\":{\"441\":1}}],[\"20的情况\",{\"1\":{\"358\":1}}],[\"20题\",{\"1\":{\"328\":1}}],[\"209\",{\"0\":{\"284\":1}}],[\"2016\",{\"1\":{\"835\":1}}],[\"2011\",{\"1\":{\"835\":1}}],[\"2014\",{\"1\":{\"558\":1}}],[\"20140422154706\",{\"1\":{\"558\":1}}],[\"2019\",{\"1\":{\"429\":1}}],[\"201\",{\"1\":{\"200\":1,\"444\":1,\"604\":1}}],[\"2008\",{\"1\":{\"835\":1}}],[\"2009\",{\"1\":{\"558\":1}}],[\"2003\",{\"1\":{\"444\":1,\"835\":1}}],[\"2001\",{\"1\":{\"432\":1,\"435\":1,\"441\":1,\"444\":1}}],[\"200\",{\"1\":{\"94\":1,\"104\":1,\"178\":1,\"231\":1,\"233\":1,\"330\":2,\"417\":1,\"419\":1,\"422\":3,\"444\":4,\"680\":1}}],[\"2000010\",{\"1\":{\"726\":1}}],[\"20000\",{\"1\":{\"327\":1}}],[\"2000000\",{\"1\":{\"58\":1,\"726\":4}}],[\"2000\",{\"1\":{\"11\":1,\"13\":1,\"52\":1,\"140\":1,\"361\":1,\"428\":2}}],[\"2024\",{\"1\":{\"469\":1,\"492\":1}}],[\"20240417165601046\",{\"1\":{\"849\":1}}],[\"20240417164418066\",{\"1\":{\"848\":1}}],[\"20240417162515274\",{\"1\":{\"847\":1}}],[\"20240417162206531\",{\"1\":{\"846\":1}}],[\"20240416222902670\",{\"1\":{\"844\":1}}],[\"20240416203555111\",{\"1\":{\"843\":1}}],[\"20240401100217220\",{\"1\":{\"827\":1}}],[\"20240401095908989\",{\"1\":{\"826\":1}}],[\"20240401095701933\",{\"1\":{\"826\":1}}],[\"20240401095618744\",{\"1\":{\"826\":1}}],[\"20240401095449801\",{\"1\":{\"826\":1}}],[\"20240401095229716\",{\"1\":{\"825\":1}}],[\"20240401093954967\",{\"1\":{\"821\":1}}],[\"20240401093401888\",{\"1\":{\"820\":1}}],[\"20240401093239495\",{\"1\":{\"820\":1}}],[\"20240401092406011\",{\"1\":{\"819\":1}}],[\"20240401091741919\",{\"1\":{\"818\":1}}],[\"20240406170813435\",{\"1\":{\"504\":1}}],[\"20240406175812435\",{\"1\":{\"401\":1}}],[\"20240406120715377\",{\"1\":{\"497\":1}}],[\"20240406114040874\",{\"1\":{\"497\":1}}],[\"20240406110126338\",{\"1\":{\"494\":1}}],[\"20240406110445918\",{\"1\":{\"493\":1}}],[\"20240406102807150\",{\"1\":{\"492\":1}}],[\"20240406093526625\",{\"1\":{\"491\":1}}],[\"20240405220811768\",{\"1\":{\"489\":1}}],[\"20240405215124906\",{\"1\":{\"487\":1}}],[\"20240405171318573\",{\"1\":{\"484\":1}}],[\"20240405170221197\",{\"1\":{\"483\":1}}],[\"20240405160342750\",{\"1\":{\"481\":1}}],[\"20240405154506118\",{\"1\":{\"480\":1}}],[\"20240404222812716\",{\"1\":{\"474\":1}}],[\"20240404224526487\",{\"1\":{\"472\":1}}],[\"20240404193126160\",{\"1\":{\"470\":1}}],[\"20240404191738868\",{\"1\":{\"468\":1}}],[\"20240404190854797\",{\"1\":{\"467\":1}}],[\"20240404190229058\",{\"1\":{\"466\":1}}],[\"20240404185845647\",{\"1\":{\"466\":1}}],[\"20240404180225749\",{\"1\":{\"464\":1}}],[\"20240404165630286\",{\"1\":{\"459\":1}}],[\"20240404160450799\",{\"1\":{\"458\":1}}],[\"20240404160411124\",{\"1\":{\"458\":1}}],[\"20240404160254565\",{\"1\":{\"458\":1}}],[\"20240404163255634\",{\"1\":{\"454\":1}}],[\"20240404162958313\",{\"1\":{\"454\":1}}],[\"20240404161459754\",{\"1\":{\"454\":1}}],[\"20240404153112431\",{\"1\":{\"452\":1}}],[\"20240404095624490\",{\"1\":{\"451\":1}}],[\"20240404095040744\",{\"1\":{\"451\":1}}],[\"20240404094642750\",{\"1\":{\"451\":1}}],[\"20240404093343196\",{\"1\":{\"450\":1}}],[\"20240404085317620\",{\"1\":{\"447\":1}}],[\"20240403190958476\",{\"1\":{\"446\":1}}],[\"20240403190803023\",{\"1\":{\"440\":1}}],[\"20240403184340723\",{\"1\":{\"444\":1}}],[\"20240403180158686\",{\"1\":{\"443\":1}}],[\"20240403175504845\",{\"1\":{\"442\":1}}],[\"20240403154635126\",{\"1\":{\"442\":1}}],[\"20240403151300525\",{\"1\":{\"441\":1}}],[\"20240403151239930\",{\"1\":{\"441\":1}}],[\"20240403151215573\",{\"1\":{\"441\":1}}],[\"20240403151142511\",{\"1\":{\"441\":1}}],[\"20240403150916271\",{\"1\":{\"441\":1}}],[\"20240403150037397\",{\"1\":{\"439\":1}}],[\"20240409093736742\",{\"1\":{\"436\":1}}],[\"20240409093644143\",{\"1\":{\"436\":1}}],[\"20240409095139203\",{\"1\":{\"410\":1}}],[\"20240408232842558\",{\"1\":{\"435\":1}}],[\"20240408232346946\",{\"1\":{\"435\":1}}],[\"20240408231538674\",{\"1\":{\"435\":1}}],[\"20240408231312526\",{\"1\":{\"435\":1}}],[\"20240408231109741\",{\"1\":{\"435\":1}}],[\"20240408214052493\",{\"1\":{\"430\":1}}],[\"20240408175204593\",{\"1\":{\"426\":1}}],[\"20240408173040132\",{\"1\":{\"424\":1}}],[\"20240408173757761\",{\"1\":{\"420\":1}}],[\"20240408165157733\",{\"1\":{\"422\":1}}],[\"20240408165033508\",{\"1\":{\"422\":1}}],[\"20240408164942547\",{\"1\":{\"422\":1}}],[\"20240407223223116\",{\"1\":{\"420\":1}}],[\"20240407182939752\",{\"1\":{\"419\":1}}],[\"20240407181056456\",{\"1\":{\"418\":1}}],[\"20240407175308411\",{\"1\":{\"417\":1}}],[\"20240407175012419\",{\"1\":{\"417\":1}}],[\"20240407173759088\",{\"1\":{\"416\":1}}],[\"20240407173708083\",{\"1\":{\"416\":1}}],[\"20240407171011182\",{\"1\":{\"415\":1}}],[\"20240407170816884\",{\"1\":{\"414\":1}}],[\"20240407165310826\",{\"1\":{\"413\":1}}],[\"20240407163859059\",{\"1\":{\"411\":1}}],[\"20240407163753693\",{\"1\":{\"411\":1}}],[\"20240407163626365\",{\"1\":{\"411\":1}}],[\"20240407162712647\",{\"1\":{\"411\":1}}],[\"20240407160215658\",{\"1\":{\"410\":1}}],[\"20240407160023443\",{\"1\":{\"410\":1}}],[\"20240407155927550\",{\"1\":{\"410\":1}}],[\"20240407155401415\",{\"1\":{\"409\":1}}],[\"20240407154325626\",{\"1\":{\"407\":1}}],[\"20240407125401206\",{\"1\":{\"406\":1}}],[\"20240407124007126\",{\"1\":{\"404\":1}}],[\"20240407123501816\",{\"1\":{\"404\":1}}],[\"20240407121621452\",{\"1\":{\"404\":1}}],[\"20240407120907972\",{\"1\":{\"403\":1}}],[\"20240407120504030\",{\"1\":{\"403\":1}}],[\"20240331224337529\",{\"1\":{\"812\":1}}],[\"20240331224233530\",{\"1\":{\"812\":1}}],[\"20240331224057648\",{\"1\":{\"812\":1}}],[\"20240331223700913\",{\"1\":{\"812\":1}}],[\"20240331222834151\",{\"1\":{\"810\":1}}],[\"20240331222759467\",{\"1\":{\"810\":1}}],[\"20240331155312038\",{\"1\":{\"800\":1}}],[\"20240331154809923\",{\"1\":{\"800\":1}}],[\"20240331152746169\",{\"1\":{\"799\":1}}],[\"20240331152555348\",{\"1\":{\"799\":1}}],[\"20240331144352550\",{\"1\":{\"794\":1}}],[\"20240331144303492\",{\"1\":{\"794\":1}}],[\"20240331143804882\",{\"1\":{\"793\":1}}],[\"20240331143413546\",{\"1\":{\"793\":1}}],[\"20240331135828610\",{\"1\":{\"786\":1}}],[\"20240327225404331\",{\"1\":{\"776\":1}}],[\"20240327224623534\",{\"1\":{\"776\":1}}],[\"20240327222401309\",{\"1\":{\"775\":1}}],[\"20240326233627730\",{\"1\":{\"771\":1}}],[\"20240326231544244\",{\"1\":{\"770\":1}}],[\"20240326225709207\",{\"1\":{\"767\":1}}],[\"20240326223411829\",{\"1\":{\"766\":1}}],[\"20240326221907548\",{\"1\":{\"763\":1}}],[\"20240326221608906\",{\"1\":{\"763\":1}}],[\"20240325230912020\",{\"1\":{\"757\":1}}],[\"20240325223116404\",{\"1\":{\"753\":1}}],[\"20240325222800349\",{\"1\":{\"753\":1}}],[\"20240325222116848\",{\"1\":{\"752\":1}}],[\"20240323180805461\",{\"1\":{\"746\":1}}],[\"20240323172453754\",{\"1\":{\"742\":1}}],[\"20240323170524930\",{\"1\":{\"741\":1}}],[\"20240320230855090\",{\"1\":{\"732\":1}}],[\"20240319234219202\",{\"1\":{\"737\":1}}],[\"20240319232051189\",{\"1\":{\"736\":1}}],[\"20240310164918993\",{\"1\":{\"721\":1}}],[\"20240310164838342\",{\"1\":{\"721\":1}}],[\"20240310164656309\",{\"1\":{\"719\":1}}],[\"20240310152010416\",{\"1\":{\"720\":1}}],[\"20240310151935806\",{\"1\":{\"720\":1}}],[\"20240310151827814\",{\"1\":{\"719\":1}}],[\"20240310151442469\",{\"1\":{\"718\":1}}],[\"20240310111121929\",{\"1\":{\"717\":1}}],[\"20240310110623960\",{\"1\":{\"717\":1}}],[\"20240310105838510\",{\"1\":{\"715\":1}}],[\"20240310100857719\",{\"1\":{\"709\":1}}],[\"20240310100628691\",{\"1\":{\"708\":1}}],[\"20240310100526181\",{\"1\":{\"707\":1}}],[\"20240310102153604\",{\"1\":{\"704\":1}}],[\"20240310095915180\",{\"1\":{\"705\":1}}],[\"20240310095627040\",{\"1\":{\"704\":1}}],[\"20240310095527031\",{\"1\":{\"704\":1}}],[\"20240310095346237\",{\"1\":{\"704\":1}}],[\"20240310095108269\",{\"1\":{\"704\":1}}],[\"20240310095023881\",{\"1\":{\"704\":1}}],[\"20240310094837880\",{\"1\":{\"704\":1}}],[\"20240310092957534\",{\"1\":{\"704\":1}}],[\"20240310092716677\",{\"1\":{\"704\":1}}],[\"20240310092129260\",{\"1\":{\"703\":1}}],[\"20240310092030111\",{\"1\":{\"703\":1}}],[\"20240310091919576\",{\"1\":{\"703\":1}}],[\"20240310091731883\",{\"1\":{\"703\":1}}],[\"20240310091643267\",{\"1\":{\"703\":1}}],[\"20240310091400898\",{\"1\":{\"703\":1}}],[\"20240310091215725\",{\"1\":{\"703\":1}}],[\"20240310091146963\",{\"1\":{\"703\":1}}],[\"20240310090854664\",{\"1\":{\"703\":1}}],[\"20240310090400721\",{\"1\":{\"702\":1}}],[\"20240310090328759\",{\"1\":{\"702\":1}}],[\"20240310090245790\",{\"1\":{\"702\":1}}],[\"20240310090133802\",{\"1\":{\"702\":1}}],[\"20240310090045821\",{\"1\":{\"702\":1}}],[\"20240310083958313\",{\"1\":{\"700\":1}}],[\"20240312230102351\",{\"1\":{\"384\":1}}],[\"20240309212058249\",{\"1\":{\"699\":1}}],[\"20240309213148974\",{\"1\":{\"698\":1}}],[\"20240309204534652\",{\"1\":{\"695\":1}}],[\"20240309204229520\",{\"1\":{\"694\":1}}],[\"20240309204157480\",{\"1\":{\"694\":1}}],[\"20240309204147339\",{\"1\":{\"694\":1}}],[\"20240309174802116\",{\"1\":{\"681\":1}}],[\"20240309174017828\",{\"1\":{\"672\":1}}],[\"20240309173013323\",{\"1\":{\"680\":1}}],[\"20240309172929988\",{\"1\":{\"680\":1}}],[\"20240309172436494\",{\"1\":{\"680\":1}}],[\"20240309172420461\",{\"1\":{\"680\":1}}],[\"20240309172255360\",{\"1\":{\"677\":1}}],[\"20240309175046593\",{\"1\":{\"674\":1}}],[\"20240309170452315\",{\"1\":{\"670\":1}}],[\"20240309164857546\",{\"1\":{\"668\":1}}],[\"20240309164803163\",{\"1\":{\"668\":1}}],[\"20240309164615169\",{\"1\":{\"668\":1}}],[\"20240309164149462\",{\"1\":{\"667\":1}}],[\"20240303223348532\",{\"1\":{\"662\":1}}],[\"20240303223129942\",{\"1\":{\"661\":1}}],[\"20240303222538988\",{\"1\":{\"661\":1}}],[\"20240303222227748\",{\"1\":{\"660\":1}}],[\"20240303222055598\",{\"1\":{\"660\":1}}],[\"20240303221843260\",{\"1\":{\"659\":1}}],[\"20240303221323044\",{\"1\":{\"658\":1}}],[\"20240303220848923\",{\"1\":{\"658\":1}}],[\"20240303220727904\",{\"1\":{\"658\":1}}],[\"20240303153135717\",{\"1\":{\"655\":1}}],[\"20240303150535429\",{\"1\":{\"634\":1}}],[\"20240303175258390\",{\"1\":{\"654\":1}}],[\"20240303174517529\",{\"1\":{\"654\":1}}],[\"20240303174134511\",{\"1\":{\"653\":1}}],[\"20240303171428003\",{\"1\":{\"651\":1}}],[\"20240303164233160\",{\"1\":{\"648\":1}}],[\"20240303163724778\",{\"1\":{\"647\":1}}],[\"20240303163423317\",{\"1\":{\"646\":1}}],[\"20240303162601117\",{\"1\":{\"645\":1}}],[\"20240303162213065\",{\"1\":{\"643\":1}}],[\"20240303161921543\",{\"1\":{\"643\":1}}],[\"20240303161708066\",{\"1\":{\"643\":1}}],[\"20240303145118032\",{\"1\":{\"634\":1}}],[\"20240303145041888\",{\"1\":{\"633\":1}}],[\"20240303144634632\",{\"1\":{\"631\":1}}],[\"20240303143605705\",{\"1\":{\"624\":1}}],[\"20240302163657908\",{\"1\":{\"618\":1}}],[\"20240302145741574\",{\"1\":{\"607\":1}}],[\"20240302145246557\",{\"1\":{\"606\":1}}],[\"20240302145016780\",{\"1\":{\"605\":1}}],[\"20240302144050785\",{\"1\":{\"604\":1}}],[\"20240302143727048\",{\"1\":{\"604\":1}}],[\"20240302143552379\",{\"1\":{\"603\":1}}],[\"20240302142903236\",{\"1\":{\"602\":1}}],[\"20240302142649063\",{\"1\":{\"601\":1}}],[\"20240302140543685\",{\"1\":{\"599\":1}}],[\"20240302135427089\",{\"1\":{\"595\":1}}],[\"20240302133735988\",{\"1\":{\"593\":1}}],[\"20240302134320608\",{\"1\":{\"592\":1}}],[\"20240225160621281\",{\"1\":{\"582\":1}}],[\"20240220225120684\",{\"1\":{\"155\":1}}],[\"20240220223909726\",{\"1\":{\"155\":1,\"157\":1}}],[\"20240218215042625\",{\"1\":{\"143\":1}}],[\"20240204223442999\",{\"1\":{\"137\":1}}],[\"20240121205834432\",{\"1\":{\"579\":1}}],[\"20240121204606375\",{\"1\":{\"579\":1}}],[\"20240121204418557\",{\"1\":{\"579\":1}}],[\"20240121200231681\",{\"1\":{\"577\":1}}],[\"20240121195145554\",{\"1\":{\"572\":1}}],[\"20240121192306003\",{\"1\":{\"570\":1}}],[\"20240121192239686\",{\"1\":{\"570\":1}}],[\"20240121190639539\",{\"1\":{\"569\":1}}],[\"20240121104516378\",{\"1\":{\"558\":1}}],[\"20240121104255210\",{\"1\":{\"558\":1}}],[\"20240121103503504\",{\"1\":{\"557\":1}}],[\"20240121102811237\",{\"1\":{\"555\":1}}],[\"20240121102332562\",{\"1\":{\"554\":1}}],[\"20240120182229805\",{\"1\":{\"548\":1}}],[\"20240120182018969\",{\"1\":{\"548\":1}}],[\"20240120180848000\",{\"1\":{\"545\":1}}],[\"20240120165502981\",{\"1\":{\"541\":1}}],[\"20240120165311267\",{\"1\":{\"540\":1}}],[\"20240120165244443\",{\"1\":{\"540\":1}}],[\"20240120164123647\",{\"1\":{\"539\":1}}],[\"20240120164036256\",{\"1\":{\"539\":1}}],[\"20240124224148152\",{\"1\":{\"117\":1}}],[\"20240124225905894\",{\"1\":{\"117\":1}}],[\"20240124225525551\",{\"1\":{\"117\":1}}],[\"20240124225359093\",{\"1\":{\"117\":1}}],[\"20240124225306215\",{\"1\":{\"117\":1}}],[\"20240107185812138\",{\"1\":{\"536\":1}}],[\"20240107185420069\",{\"1\":{\"534\":1}}],[\"20240107182920238\",{\"1\":{\"533\":1}}],[\"20240107182127530\",{\"1\":{\"532\":1}}],[\"20240107183549127\",{\"1\":{\"533\":1}}],[\"20240107163939637\",{\"1\":{\"531\":1}}],[\"20240107163418942\",{\"1\":{\"530\":1}}],[\"20240107161107200\",{\"1\":{\"529\":1}}],[\"20240107160009260\",{\"1\":{\"528\":1}}],[\"20240107155807921\",{\"1\":{\"528\":1}}],[\"20240107155017501\",{\"1\":{\"528\":1}}],[\"20240107153620324\",{\"1\":{\"527\":1}}],[\"20240107151645420\",{\"1\":{\"523\":1}}],[\"20240107150527876\",{\"1\":{\"522\":1}}],[\"20240107150425601\",{\"1\":{\"522\":1}}],[\"20240107145437984\",{\"1\":{\"521\":1}}],[\"20240107134613344\",{\"1\":{\"513\":1}}],[\"20240107134510774\",{\"1\":{\"513\":1}}],[\"20240107134232352\",{\"1\":{\"513\":1}}],[\"20240107134006553\",{\"1\":{\"513\":1}}],[\"20240107133218203\",{\"1\":{\"512\":1}}],[\"20240107131342618\",{\"1\":{\"509\":1}}],[\"20240104232139131\",{\"1\":{\"95\":1}}],[\"20240104213223574\",{\"1\":{\"91\":1}}],[\"20240104212748795\",{\"1\":{\"91\":1}}],[\"20240103221447619\",{\"1\":{\"89\":1}}],[\"20240103221010457\",{\"1\":{\"89\":1}}],[\"202\",{\"1\":{\"444\":1}}],[\"20200101010101\",{\"1\":{\"557\":1}}],[\"2020\",{\"1\":{\"399\":2,\"884\":1}}],[\"2021\",{\"1\":{\"399\":2,\"557\":2}}],[\"2022不知道行不行\",{\"1\":{\"441\":1}}],[\"2022\",{\"1\":{\"399\":3,\"441\":1}}],[\"20230220221634769\",{\"1\":{\"288\":1}}],[\"20230220221128972\",{\"1\":{\"288\":1}}],[\"20230922114839267\",{\"1\":{\"304\":1}}],[\"20230922105341336\",{\"1\":{\"304\":1}}],[\"20230922094206193\",{\"1\":{\"304\":1}}],[\"20230920220039986\",{\"1\":{\"298\":1}}],[\"20230920220015959\",{\"1\":{\"298\":1}}],[\"20230925231243004\",{\"1\":{\"261\":1}}],[\"20230927214123859\",{\"1\":{\"245\":1}}],[\"20230813175651994\",{\"1\":{\"0\":1}}],[\"2023\",{\"1\":{\"190\":1,\"191\":1,\"215\":1,\"441\":1}}],[\"20231008215639908\",{\"1\":{\"377\":1}}],[\"20231007224528548\",{\"1\":{\"313\":1}}],[\"20231007224359553\",{\"1\":{\"313\":1}}],[\"20231007224209714\",{\"1\":{\"313\":1}}],[\"20231007223129927\",{\"1\":{\"313\":1}}],[\"20231007220324257\",{\"1\":{\"276\":1}}],[\"20231010151845350\",{\"1\":{\"386\":1}}],[\"20231019212329144\",{\"1\":{\"322\":1}}],[\"20231017222624936\",{\"1\":{\"256\":1}}],[\"20231030231551687\",{\"1\":{\"8\":1}}],[\"20231030212729924\",{\"1\":{\"0\":1}}],[\"20231213223205258\",{\"1\":{\"346\":1}}],[\"20231211222933758\",{\"1\":{\"213\":1}}],[\"20231207232714523\",{\"1\":{\"211\":1}}],[\"20231207230757432\",{\"1\":{\"211\":1}}],[\"20231207234459580\",{\"1\":{\"211\":1}}],[\"20231206223245857\",{\"1\":{\"209\":1}}],[\"20231206215822477\",{\"1\":{\"207\":1}}],[\"20231205223420271\",{\"1\":{\"205\":1}}],[\"20231205213146498\",{\"1\":{\"203\":1}}],[\"20231204232800781\",{\"1\":{\"201\":1}}],[\"20231204232030986\",{\"1\":{\"199\":1}}],[\"20231221230308320\",{\"1\":{\"366\":1}}],[\"20231221223229285\",{\"1\":{\"364\":1}}],[\"20231221222403573\",{\"1\":{\"364\":1}}],[\"20231221220346622\",{\"1\":{\"364\":1}}],[\"20231228222645533\",{\"1\":{\"85\":1}}],[\"20231227222904092\",{\"1\":{\"83\":1}}],[\"20231128230343416\",{\"1\":{\"190\":1}}],[\"20231122222756717\",{\"1\":{\"72\":1}}],[\"20231121231408805\",{\"1\":{\"68\":1}}],[\"20231121231225377\",{\"1\":{\"68\":1}}],[\"20231114221040622\",{\"1\":{\"49\":1}}],[\"20231113230335449\",{\"1\":{\"47\":1}}],[\"20231106221428126\",{\"1\":{\"33\":1}}],[\"20\",{\"0\":{\"831\":1,\"832\":1},\"1\":{\"11\":2,\"13\":2,\"17\":2,\"25\":1,\"27\":1,\"36\":1,\"40\":1,\"46\":3,\"48\":3,\"65\":2,\"82\":1,\"83\":1,\"91\":2,\"98\":1,\"110\":1,\"186\":1,\"200\":1,\"297\":1,\"357\":4,\"428\":2,\"557\":1,\"604\":2,\"617\":2,\"619\":2,\"687\":2,\"696\":2,\"728\":2,\"776\":1,\"794\":1,\"800\":3}}],[\"2\",{\"0\":{\"5\":1,\"401\":1,\"402\":2,\"403\":1,\"404\":1,\"407\":1,\"412\":1,\"427\":1,\"428\":1,\"429\":2,\"442\":1,\"449\":1,\"450\":2,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"458\":1,\"461\":1,\"462\":1,\"463\":2,\"464\":1,\"465\":1,\"467\":1,\"473\":1,\"474\":1,\"475\":2,\"477\":1,\"479\":1,\"481\":1,\"482\":1,\"486\":1,\"489\":1,\"493\":1,\"498\":1,\"500\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":2,\"517\":1,\"518\":2,\"519\":1,\"520\":1,\"522\":1,\"525\":2,\"526\":1,\"532\":1,\"534\":1,\"542\":1,\"549\":1,\"552\":1,\"555\":1,\"560\":1,\"561\":1,\"563\":1,\"570\":1,\"571\":1,\"573\":1,\"576\":2,\"578\":1,\"579\":1,\"584\":1,\"585\":1,\"586\":2,\"587\":1,\"588\":1,\"589\":1,\"596\":1,\"598\":1,\"599\":1,\"605\":1,\"613\":1,\"614\":1,\"615\":2,\"616\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":1,\"626\":1,\"634\":1,\"637\":1,\"642\":1,\"646\":1,\"651\":1,\"659\":1,\"667\":1,\"668\":1,\"669\":2,\"670\":1,\"671\":1,\"672\":1,\"673\":1,\"674\":1,\"687\":1,\"690\":1,\"695\":1,\"699\":1,\"702\":1,\"716\":1,\"723\":1,\"732\":1,\"745\":1,\"750\":1,\"754\":1,\"756\":1,\"763\":1,\"766\":1,\"767\":1,\"768\":2,\"774\":1,\"779\":1,\"784\":1,\"786\":1,\"791\":1,\"794\":1,\"797\":1,\"806\":1,\"810\":1,\"819\":1,\"820\":1,\"823\":1,\"832\":1},\"1\":{\"11\":1,\"12\":2,\"13\":1,\"15\":2,\"17\":2,\"19\":5,\"21\":2,\"23\":3,\"25\":3,\"27\":3,\"30\":5,\"32\":5,\"34\":2,\"36\":3,\"38\":2,\"39\":1,\"40\":1,\"42\":3,\"43\":1,\"44\":4,\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":11,\"52\":6,\"53\":5,\"55\":2,\"57\":3,\"58\":1,\"59\":4,\"61\":6,\"63\":10,\"65\":5,\"67\":7,\"69\":6,\"71\":1,\"72\":1,\"73\":5,\"74\":1,\"78\":9,\"79\":4,\"80\":9,\"81\":10,\"82\":3,\"83\":6,\"84\":4,\"85\":1,\"86\":5,\"87\":7,\"88\":1,\"89\":3,\"91\":1,\"92\":4,\"94\":2,\"95\":4,\"96\":7,\"97\":7,\"98\":3,\"99\":5,\"100\":3,\"102\":4,\"103\":4,\"104\":7,\"106\":3,\"108\":2,\"110\":1,\"112\":5,\"113\":5,\"114\":7,\"115\":9,\"116\":2,\"117\":2,\"119\":2,\"120\":1,\"121\":3,\"122\":3,\"123\":3,\"124\":10,\"125\":13,\"126\":19,\"127\":3,\"128\":7,\"129\":5,\"130\":1,\"132\":7,\"134\":7,\"136\":5,\"137\":3,\"138\":1,\"140\":12,\"141\":2,\"142\":4,\"143\":2,\"145\":1,\"147\":1,\"148\":2,\"149\":2,\"150\":5,\"151\":1,\"152\":2,\"153\":6,\"154\":1,\"156\":2,\"157\":3,\"161\":1,\"164\":1,\"166\":6,\"169\":2,\"170\":4,\"172\":4,\"173\":4,\"174\":5,\"175\":2,\"176\":7,\"177\":3,\"178\":16,\"179\":3,\"186\":5,\"188\":2,\"189\":8,\"192\":4,\"193\":2,\"194\":16,\"196\":9,\"197\":1,\"198\":1,\"200\":4,\"201\":4,\"202\":6,\"204\":9,\"206\":2,\"207\":2,\"208\":8,\"210\":12,\"212\":2,\"214\":1,\"216\":11,\"222\":1,\"223\":7,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"231\":1,\"233\":10,\"240\":13,\"242\":1,\"244\":1,\"246\":1,\"249\":1,\"250\":1,\"252\":3,\"254\":1,\"255\":1,\"257\":19,\"260\":1,\"262\":1,\"266\":5,\"269\":3,\"271\":2,\"273\":5,\"274\":5,\"275\":2,\"276\":12,\"277\":11,\"278\":17,\"281\":2,\"284\":4,\"287\":2,\"288\":2,\"289\":2,\"290\":7,\"294\":4,\"295\":3,\"296\":1,\"297\":5,\"299\":3,\"300\":3,\"303\":5,\"304\":6,\"305\":1,\"306\":2,\"309\":2,\"312\":10,\"313\":2,\"315\":1,\"321\":4,\"324\":1,\"326\":1,\"330\":6,\"333\":1,\"334\":2,\"336\":5,\"343\":7,\"345\":6,\"346\":1,\"347\":4,\"349\":3,\"351\":6,\"353\":10,\"354\":2,\"355\":10,\"357\":4,\"359\":9,\"360\":4,\"361\":13,\"362\":4,\"363\":11,\"364\":1,\"365\":11,\"366\":3,\"367\":1,\"369\":1,\"370\":3,\"371\":2,\"372\":13,\"376\":3,\"379\":2,\"380\":5,\"383\":4,\"385\":3,\"388\":5,\"390\":13,\"393\":3,\"399\":8,\"401\":1,\"412\":2,\"415\":1,\"416\":3,\"419\":2,\"420\":1,\"422\":1,\"423\":1,\"424\":1,\"429\":2,\"432\":1,\"440\":1,\"441\":4,\"442\":1,\"447\":1,\"452\":1,\"454\":1,\"459\":1,\"460\":5,\"463\":1,\"464\":1,\"468\":1,\"477\":1,\"478\":3,\"480\":1,\"481\":2,\"482\":1,\"485\":1,\"486\":4,\"489\":1,\"495\":1,\"497\":1,\"520\":2,\"527\":1,\"528\":1,\"541\":1,\"548\":1,\"550\":1,\"557\":2,\"559\":2,\"565\":3,\"579\":1,\"587\":1,\"617\":1,\"618\":2,\"634\":1,\"642\":2,\"649\":1,\"658\":1,\"662\":1,\"672\":1,\"680\":3,\"686\":2,\"689\":3,\"690\":1,\"701\":1,\"729\":1,\"746\":1,\"757\":1,\"767\":2,\"771\":2,\"786\":1,\"797\":2,\"799\":1,\"800\":2,\"806\":1,\"807\":1,\"822\":1,\"826\":1,\"835\":1,\"851\":1,\"877\":1}}],[\"2k\",{\"1\":{\"0\":1,\"252\":3,\"253\":2,\"254\":1}}],[\"1b\",{\"1\":{\"749\":1}}],[\"1nf\",{\"1\":{\"736\":1}}],[\"1ast\",{\"1\":{\"731\":1}}],[\"1万条数据\",{\"1\":{\"728\":1}}],[\"1ogs\",{\"1\":{\"698\":1}}],[\"1og2n\",{\"1\":{\"658\":1}}],[\"1版本中\",{\"1\":{\"677\":1}}],[\"1个char\",{\"1\":{\"643\":1}}],[\"1个摄像头\",{\"1\":{\"372\":1}}],[\"1到1之间\",{\"1\":{\"549\":2}}],[\"1看小数点前1位\",{\"1\":{\"548\":1}}],[\"1就是10次只能有一次被记录下来\",{\"1\":{\"486\":1}}],[\"1就是dp\",{\"1\":{\"107\":1}}],[\"1<\",{\"1\":{\"468\":1}}],[\"1+2\",{\"1\":{\"467\":1}}],[\"1+1\",{\"1\":{\"81\":1,\"520\":2}}],[\"1删除\",{\"1\":{\"440\":1}}],[\"1表示只读\",{\"1\":{\"823\":1}}],[\"1表示目录项记录\",{\"1\":{\"643\":1}}],[\"1表示warm\",{\"1\":{\"419\":1}}],[\"1表示关联\",{\"1\":{\"419\":1}}],[\"1表示qps\",{\"1\":{\"419\":1}}],[\"1s\",{\"1\":{\"413\":1,\"480\":1,\"482\":1}}],[\"1s发送10个请求\",{\"1\":{\"411\":1}}],[\"1s超过2个请求时\",{\"1\":{\"410\":1}}],[\"1s以内有超过\",{\"1\":{\"410\":1}}],[\"1指向的元素\",{\"1\":{\"313\":1}}],[\"1呢\",{\"1\":{\"270\":1}}],[\"1开始引入\",{\"1\":{\"568\":1}}],[\"1开始\",{\"1\":{\"241\":1}}],[\"17开始\",{\"1\":{\"595\":1}}],[\"17\",{\"0\":{\"790\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":1,\"797\":1,\"798\":1,\"799\":1,\"800\":1,\"801\":1},\"1\":{\"193\":1,\"195\":1,\"276\":2,\"330\":7,\"345\":2,\"399\":1,\"486\":1}}],[\"1$\",{\"1\":{\"188\":1,\"304\":1,\"334\":1}}],[\"1时\",{\"1\":{\"155\":1}}],[\"1结尾时\",{\"1\":{\"137\":1}}],[\"1结尾的最长公共前缀为\",{\"1\":{\"137\":1}}],[\"1结尾\",{\"1\":{\"137\":2}}],[\"1之后\",{\"1\":{\"725\":1}}],[\"1之前是使用双路排序\",{\"1\":{\"725\":1}}],[\"1之前的元素之间的关系\",{\"1\":{\"133\":1}}],[\"1之间的最长递增子序列\",{\"1\":{\"133\":1}}],[\"1各个位置的最长升序子序列\",{\"1\":{\"133\":1}}],[\"1800\",{\"1\":{\"575\":1}}],[\"1800000\",{\"1\":{\"429\":1}}],[\"18\",{\"0\":{\"805\":1,\"806\":1,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1},\"1\":{\"132\":1,\"294\":2,\"402\":1,\"432\":1,\"441\":1,\"443\":1,\"608\":1}}],[\"1是不行的\",{\"1\":{\"113\":1}}],[\"16777216\",{\"1\":{\"751\":1}}],[\"16m\",{\"1\":{\"751\":1}}],[\"16kb的数据刷新回磁盘\",{\"1\":{\"749\":1}}],[\"16kb大小的存储空间被划分为七个部分\",{\"1\":{\"667\":1}}],[\"16kb\",{\"1\":{\"646\":1,\"666\":1,\"749\":1}}],[\"168\",{\"1\":{\"200\":3,\"495\":10}}],[\"16\",{\"0\":{\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"766\":1,\"767\":1,\"768\":1,\"779\":1,\"784\":1},\"1\":{\"108\":1,\"198\":1,\"281\":3,\"297\":2,\"345\":3,\"363\":2,\"364\":1,\"495\":2}}],[\"1的个数看做背包的容量\",{\"1\":{\"101\":1}}],[\"19th\",{\"1\":{\"872\":1}}],[\"19开始\",{\"1\":{\"602\":1}}],[\"1999\",{\"1\":{\"429\":1}}],[\"1991\",{\"0\":{\"290\":1}}],[\"192\",{\"1\":{\"200\":3,\"495\":9}}],[\"19\",{\"0\":{\"817\":1,\"818\":1,\"819\":1,\"820\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":1,\"825\":1,\"826\":1,\"827\":1},\"1\":{\"88\":1,\"169\":1}}],[\"1~n\",{\"1\":{\"276\":1}}],[\"1~9个数字进行校验是否冲突并填入\",{\"1\":{\"217\":1}}],[\"1~i时的左右子树的二叉搜索树的数量\",{\"1\":{\"89\":1}}],[\"1~\",{\"1\":{\"34\":1}}],[\"134453\",{\"1\":{\"696\":1}}],[\"13<\",{\"1\":{\"442\":1}}],[\"132\",{\"1\":{\"330\":1}}],[\"131\",{\"1\":{\"201\":1}}],[\"135\",{\"1\":{\"200\":1,\"201\":2}}],[\"13\",{\"0\":{\"714\":1,\"723\":1,\"724\":1,\"725\":1,\"726\":1,\"727\":1,\"728\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"733\":1},\"1\":{\"19\":2,\"44\":1,\"108\":2,\"276\":2,\"297\":2,\"330\":2,\"345\":2,\"353\":1,\"454\":2}}],[\"120\",{\"1\":{\"612\":1}}],[\"124\",{\"1\":{\"495\":1}}],[\"123\",{\"1\":{\"493\":1,\"717\":1}}],[\"123456\",{\"1\":{\"429\":1,\"825\":2}}],[\"1234\",{\"1\":{\"369\":2}}],[\"127\",{\"1\":{\"429\":4,\"432\":1,\"460\":6}}],[\"128\",{\"1\":{\"428\":5,\"431\":6}}],[\"121\",{\"1\":{\"122\":1,\"281\":1}}],[\"1228\",{\"1\":{\"809\":1}}],[\"122\",{\"1\":{\"122\":2}}],[\"12\",{\"0\":{\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"701\":1,\"702\":1,\"703\":1,\"704\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1},\"1\":{\"19\":2,\"57\":1,\"106\":1,\"108\":2,\"112\":2,\"169\":2,\"215\":1,\"269\":2,\"297\":2,\"315\":2,\"330\":1,\"363\":2,\"364\":1,\"485\":1,\"486\":1,\"523\":1,\"548\":6,\"557\":2,\"587\":2}}],[\"11000\",{\"1\":{\"569\":1}}],[\"11<\",{\"1\":{\"441\":1}}],[\"11处发射箭\",{\"1\":{\"363\":1}}],[\"111\",{\"1\":{\"200\":1}}],[\"111001\",{\"1\":{\"100\":2}}],[\"115\",{\"1\":{\"153\":1}}],[\"11\",{\"0\":{\"685\":1,\"686\":1,\"687\":1,\"688\":1},\"1\":{\"17\":4,\"19\":2,\"44\":1,\"94\":2,\"95\":1,\"106\":2,\"108\":1,\"174\":1,\"190\":1,\"191\":1,\"200\":1,\"201\":2,\"215\":1,\"227\":1,\"240\":1,\"276\":3,\"281\":1,\"284\":1,\"297\":2,\"330\":3,\"431\":15,\"689\":2}}],[\"10万条数据\",{\"1\":{\"728\":1}}],[\"10此时需要mysql排序前2000010\",{\"1\":{\"726\":1}}],[\"10s\",{\"1\":{\"478\":1,\"481\":1}}],[\"10元\",{\"1\":{\"358\":1}}],[\"10+5\",{\"1\":{\"358\":1}}],[\"1020\",{\"1\":{\"232\":1}}],[\"102\",{\"1\":{\"200\":1,\"527\":1}}],[\"10而跳过\",{\"1\":{\"179\":1}}],[\"10亿\",{\"1\":{\"145\":1}}],[\"101023\",{\"1\":{\"200\":1}}],[\"101\",{\"1\":{\"132\":2,\"200\":1}}],[\"1038\",{\"1\":{\"73\":1}}],[\"108\",{\"1\":{\"65\":4}}],[\"109\",{\"1\":{\"61\":2,\"84\":1,\"134\":2,\"147\":1,\"174\":4,\"178\":4,\"275\":4,\"369\":1}}],[\"1075\",{\"1\":{\"617\":1}}],[\"107\",{\"1\":{\"53\":2}}],[\"1063\",{\"1\":{\"617\":1}}],[\"106一样\",{\"1\":{\"51\":1}}],[\"106\",{\"1\":{\"49\":1,\"72\":1,\"361\":1}}],[\"105\",{\"1\":{\"27\":1,\"51\":1,\"57\":1,\"59\":2,\"61\":1,\"67\":4,\"72\":1,\"119\":1,\"123\":2,\"142\":1,\"176\":2,\"233\":1,\"249\":1,\"275\":1,\"303\":2,\"306\":1,\"333\":1,\"336\":1,\"347\":1,\"349\":1,\"355\":1,\"357\":1,\"363\":1,\"365\":1,\"390\":1,\"393\":2}}],[\"10^4\",{\"1\":{\"19\":1,\"145\":1}}],[\"104\",{\"1\":{\"17\":1,\"21\":1,\"25\":1,\"34\":2,\"36\":2,\"42\":1,\"52\":2,\"55\":1,\"57\":1,\"59\":1,\"65\":1,\"67\":1,\"69\":3,\"71\":3,\"73\":3,\"106\":1,\"108\":1,\"116\":2,\"119\":1,\"121\":2,\"129\":3,\"132\":2,\"134\":1,\"142\":2,\"161\":1,\"164\":1,\"174\":1,\"240\":1,\"244\":1,\"246\":1,\"257\":3,\"273\":5,\"277\":4,\"294\":2,\"303\":2,\"312\":3,\"315\":1,\"324\":1,\"330\":1,\"333\":2,\"343\":2,\"347\":2,\"349\":1,\"351\":1,\"353\":2,\"355\":1,\"359\":2,\"365\":2,\"376\":1,\"390\":1,\"393\":1}}],[\"10\",{\"0\":{\"666\":1,\"667\":1,\"668\":1,\"669\":1,\"670\":1,\"671\":1,\"672\":1,\"673\":1,\"674\":1,\"675\":1,\"676\":1,\"677\":1,\"710\":1},\"1\":{\"17\":1,\"19\":2,\"65\":2,\"71\":3,\"73\":1,\"82\":1,\"83\":1,\"86\":2,\"100\":4,\"102\":2,\"129\":1,\"132\":1,\"140\":1,\"171\":4,\"179\":1,\"189\":1,\"196\":1,\"197\":1,\"200\":4,\"201\":2,\"202\":3,\"204\":3,\"208\":2,\"210\":2,\"275\":2,\"281\":1,\"294\":2,\"297\":2,\"330\":5,\"345\":4,\"357\":9,\"358\":1,\"363\":2,\"364\":1,\"367\":1,\"369\":1,\"406\":1,\"413\":1,\"414\":1,\"429\":1,\"431\":3,\"434\":1,\"440\":2,\"548\":2,\"557\":6,\"600\":1,\"689\":1,\"699\":5,\"710\":2,\"726\":3,\"794\":1,\"831\":1}}],[\"100元\",{\"1\":{\"741\":1}}],[\"10066\",{\"1\":{\"704\":1}}],[\"1005\",{\"1\":{\"618\":1}}],[\"1003\",{\"1\":{\"444\":1}}],[\"1004\",{\"1\":{\"444\":1}}],[\"1002\",{\"1\":{\"444\":1}}],[\"1001\",{\"1\":{\"444\":1}}],[\"100\",{\"1\":{\"15\":3,\"25\":2,\"30\":3,\"32\":2,\"38\":3,\"82\":3,\"84\":1,\"94\":1,\"96\":1,\"100\":2,\"112\":1,\"114\":1,\"125\":1,\"136\":1,\"145\":1,\"164\":1,\"169\":1,\"196\":1,\"206\":2,\"281\":3,\"290\":1,\"321\":1,\"353\":2,\"385\":2,\"388\":1,\"429\":1,\"431\":2,\"467\":1,\"476\":1,\"527\":1,\"680\":1,\"696\":1,\"701\":2,\"749\":1,\"809\":1}}],[\"10005\",{\"1\":{\"704\":1}}],[\"100000001\",{\"1\":{\"732\":1}}],[\"10000\",{\"1\":{\"255\":1,\"269\":1,\"564\":2}}],[\"1000\",{\"1\":{\"11\":2,\"13\":2,\"19\":1,\"23\":2,\"27\":2,\"32\":1,\"40\":3,\"44\":4,\"50\":2,\"82\":1,\"98\":4,\"104\":2,\"110\":1,\"114\":1,\"125\":2,\"127\":1,\"136\":1,\"138\":1,\"147\":1,\"154\":1,\"156\":1,\"166\":2,\"240\":4,\"260\":1,\"290\":2,\"297\":2,\"345\":2,\"351\":1,\"371\":1,\"379\":3,\"419\":2,\"429\":2,\"431\":2,\"835\":1}}],[\"156\",{\"1\":{\"809\":1}}],[\"15s\",{\"1\":{\"467\":1}}],[\"150\",{\"1\":{\"194\":1,\"618\":1}}],[\"15\",{\"0\":{\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"748\":1,\"754\":1},\"1\":{\"11\":2,\"13\":2,\"17\":2,\"25\":1,\"27\":1,\"36\":1,\"40\":2,\"46\":3,\"48\":3,\"73\":1,\"82\":4,\"83\":2,\"91\":2,\"92\":7,\"174\":1,\"177\":1,\"206\":1,\"223\":1,\"240\":1,\"276\":2,\"294\":2,\"297\":2,\"345\":1,\"357\":1,\"492\":1,\"558\":1}}],[\"141\",{\"1\":{\"573\":5}}],[\"14\",{\"0\":{\"737\":1},\"1\":{\"17\":4,\"19\":2,\"172\":2,\"297\":2}}],[\"145\",{\"1\":{\"0\":1}}],[\"144\",{\"1\":{\"0\":1}}],[\"1\",{\"0\":{\"1\":1,\"401\":1,\"404\":1,\"406\":1,\"409\":1,\"426\":1,\"428\":1,\"441\":2,\"442\":1,\"443\":1,\"444\":1,\"445\":1,\"446\":1,\"447\":1,\"449\":1,\"456\":1,\"457\":2,\"458\":1,\"459\":1,\"460\":1,\"462\":1,\"466\":1,\"472\":1,\"474\":1,\"476\":1,\"480\":1,\"484\":1,\"485\":2,\"486\":1,\"488\":1,\"491\":1,\"492\":1,\"499\":1,\"508\":2,\"509\":3,\"510\":2,\"511\":1,\"512\":2,\"513\":1,\"517\":1,\"520\":1,\"521\":1,\"533\":1,\"546\":1,\"547\":2,\"548\":1,\"552\":1,\"553\":1,\"554\":1,\"559\":1,\"561\":1,\"562\":1,\"569\":1,\"571\":1,\"572\":1,\"577\":1,\"583\":1,\"585\":1,\"593\":1,\"594\":2,\"595\":1,\"598\":1,\"604\":1,\"612\":1,\"614\":1,\"624\":1,\"625\":2,\"626\":1,\"631\":1,\"632\":1,\"636\":1,\"641\":1,\"645\":1,\"650\":1,\"654\":1,\"658\":1,\"666\":1,\"668\":1,\"676\":1,\"677\":1,\"685\":1,\"686\":2,\"687\":1,\"688\":1,\"689\":1,\"694\":1,\"698\":1,\"701\":1,\"714\":1,\"715\":1,\"731\":1,\"737\":1,\"741\":1,\"744\":1,\"748\":1,\"749\":1,\"755\":1,\"761\":1,\"762\":2,\"763\":1,\"764\":1,\"765\":1,\"767\":1,\"769\":1,\"780\":1,\"785\":1,\"790\":1,\"793\":1,\"796\":1,\"805\":1,\"809\":1,\"817\":1,\"818\":2,\"819\":1,\"822\":1,\"831\":1},\"1\":{\"0\":1,\"11\":3,\"12\":4,\"13\":3,\"15\":5,\"16\":1,\"17\":4,\"19\":5,\"21\":5,\"23\":4,\"24\":1,\"25\":2,\"27\":1,\"28\":1,\"30\":5,\"32\":4,\"34\":4,\"35\":1,\"36\":3,\"37\":10,\"38\":7,\"39\":1,\"40\":3,\"42\":6,\"43\":2,\"44\":5,\"45\":1,\"46\":5,\"47\":7,\"48\":5,\"49\":7,\"50\":13,\"51\":1,\"52\":5,\"53\":7,\"55\":5,\"56\":2,\"57\":5,\"58\":1,\"59\":3,\"60\":1,\"61\":8,\"62\":1,\"63\":1,\"65\":5,\"67\":1,\"69\":8,\"71\":7,\"72\":2,\"73\":7,\"74\":1,\"78\":14,\"79\":7,\"80\":12,\"81\":11,\"82\":16,\"83\":6,\"84\":3,\"85\":13,\"86\":7,\"87\":9,\"88\":5,\"89\":10,\"91\":15,\"92\":9,\"94\":6,\"95\":2,\"96\":20,\"97\":1,\"98\":34,\"99\":4,\"100\":16,\"101\":4,\"102\":5,\"103\":11,\"104\":17,\"105\":2,\"106\":9,\"107\":7,\"108\":3,\"109\":5,\"110\":4,\"111\":2,\"112\":11,\"113\":11,\"114\":9,\"115\":10,\"116\":6,\"117\":6,\"119\":7,\"120\":23,\"121\":10,\"122\":32,\"123\":12,\"124\":34,\"125\":5,\"126\":40,\"127\":5,\"128\":38,\"129\":7,\"130\":20,\"132\":5,\"133\":5,\"134\":9,\"135\":5,\"136\":6,\"137\":23,\"138\":2,\"139\":22,\"140\":13,\"141\":16,\"142\":10,\"143\":6,\"145\":1,\"146\":22,\"147\":2,\"148\":41,\"149\":2,\"150\":11,\"151\":1,\"152\":53,\"153\":77,\"154\":2,\"155\":11,\"156\":2,\"157\":15,\"161\":2,\"164\":2,\"166\":4,\"169\":7,\"170\":1,\"171\":3,\"172\":4,\"173\":3,\"174\":6,\"175\":2,\"176\":22,\"177\":7,\"178\":8,\"179\":4,\"183\":2,\"186\":10,\"187\":1,\"188\":6,\"189\":11,\"190\":3,\"191\":4,\"192\":2,\"193\":4,\"194\":4,\"195\":2,\"196\":12,\"197\":9,\"198\":2,\"199\":5,\"200\":11,\"201\":10,\"202\":7,\"203\":2,\"204\":6,\"205\":2,\"206\":3,\"207\":6,\"208\":14,\"209\":2,\"210\":17,\"211\":16,\"212\":2,\"213\":17,\"214\":3,\"215\":6,\"216\":16,\"217\":2,\"223\":9,\"224\":4,\"225\":21,\"226\":14,\"227\":32,\"228\":14,\"229\":15,\"230\":19,\"231\":2,\"232\":14,\"233\":16,\"234\":7,\"240\":16,\"241\":2,\"242\":2,\"244\":2,\"245\":1,\"246\":2,\"249\":3,\"251\":1,\"252\":1,\"254\":1,\"255\":2,\"256\":5,\"257\":18,\"260\":2,\"261\":6,\"262\":1,\"266\":7,\"269\":7,\"271\":12,\"273\":11,\"274\":10,\"275\":14,\"276\":23,\"277\":22,\"278\":5,\"281\":5,\"283\":1,\"284\":13,\"286\":1,\"287\":5,\"288\":1,\"289\":2,\"290\":15,\"292\":3,\"293\":1,\"294\":9,\"295\":5,\"296\":8,\"297\":6,\"298\":2,\"299\":62,\"300\":17,\"303\":7,\"304\":17,\"305\":6,\"306\":15,\"308\":1,\"309\":13,\"311\":4,\"312\":11,\"313\":1,\"314\":1,\"315\":5,\"317\":1,\"321\":10,\"324\":2,\"327\":1,\"330\":7,\"333\":20,\"334\":12,\"335\":3,\"336\":10,\"338\":2,\"343\":11,\"344\":2,\"345\":9,\"346\":9,\"347\":10,\"349\":8,\"350\":3,\"351\":10,\"352\":1,\"353\":11,\"354\":4,\"355\":11,\"356\":1,\"357\":2,\"359\":9,\"360\":17,\"361\":17,\"362\":17,\"363\":8,\"364\":10,\"365\":11,\"366\":8,\"367\":2,\"368\":1,\"369\":1,\"370\":2,\"371\":3,\"372\":13,\"376\":5,\"379\":8,\"380\":5,\"383\":7,\"384\":1,\"385\":5,\"388\":10,\"390\":14,\"393\":8,\"399\":9,\"412\":2,\"416\":3,\"417\":1,\"419\":7,\"420\":1,\"421\":1,\"422\":3,\"423\":2,\"428\":1,\"429\":4,\"431\":12,\"432\":5,\"440\":1,\"441\":3,\"442\":3,\"447\":1,\"451\":1,\"452\":1,\"454\":3,\"459\":1,\"460\":9,\"463\":1,\"464\":1,\"467\":1,\"468\":1,\"477\":1,\"482\":1,\"486\":5,\"489\":1,\"495\":11,\"497\":1,\"523\":1,\"528\":9,\"533\":1,\"541\":1,\"548\":7,\"557\":2,\"559\":3,\"562\":2,\"565\":2,\"587\":1,\"606\":2,\"617\":1,\"618\":3,\"634\":1,\"642\":2,\"643\":2,\"658\":2,\"662\":1,\"672\":1,\"680\":2,\"686\":1,\"689\":1,\"690\":1,\"696\":2,\"698\":1,\"701\":3,\"704\":1,\"710\":3,\"729\":5,\"731\":1,\"737\":2,\"745\":1,\"746\":1,\"749\":1,\"757\":1,\"767\":2,\"771\":4,\"786\":1,\"797\":2,\"799\":1,\"800\":6,\"809\":2,\"810\":1,\"822\":1,\"826\":1,\"832\":2,\"836\":1,\"851\":1,\"870\":1,\"877\":1,\"884\":2,\"886\":2}}],[\"拥有\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
